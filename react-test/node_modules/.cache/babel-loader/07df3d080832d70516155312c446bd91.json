{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nimport { getCurrentFiberOwnerNameInDevOrNull } from 'react-reconciler/src/ReactCurrentFiber';\nimport { setValueForProperty } from './DOMPropertyOperations';\nimport { getFiberCurrentPropsFromNode } from './ReactDOMComponentTree';\nimport { getToStringValue, toString } from './ToStringValue';\nimport { checkControlledValueProps } from '../shared/ReactControlledValuePropTypes';\nimport { updateValueIfChanged } from './inputValueTracking';\nimport getActiveElement from './getActiveElement';\nimport assign from 'shared/assign';\nimport { disableInputAttributeSyncing } from 'shared/ReactFeatureFlags';\nimport { checkAttributeStringCoercion } from 'shared/CheckStringCoercion';\nlet didWarnValueDefaultValue = false;\nlet didWarnCheckedDefaultChecked = false;\nlet didWarnControlledToUncontrolled = false;\nlet didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  const usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n/**\r\n * Implements an <input> host component that allows setting these optional\r\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\r\n *\r\n * If `checked` or `value` are not supplied (or null/undefined), user actions\r\n * that affect the checked state or value will trigger updates to the element.\r\n *\r\n * If they are supplied (and not null/undefined), the rendered element will not\r\n * trigger updates to the element. Instead, the props must change in order for\r\n * the rendered element to be updated.\r\n *\r\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\r\n * with an empty value (or `defaultValue`).\r\n *\r\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\r\n */\n\n\nexport function getHostProps(element, props) {\n  const node = element;\n  const checked = props.checked;\n  const hostProps = assign({}, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: undefined,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n  return hostProps;\n}\nexport function initWrapperState(element, props) {\n  if (__DEV__) {\n    checkControlledValueProps('input', props);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      console.error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      console.error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  const node = element;\n  const defaultValue = props.defaultValue == null ? '' : props.defaultValue;\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\n    controlled: isControlled(props)\n  };\n}\nexport function updateChecked(element, props) {\n  const node = element;\n  const checked = props.checked;\n\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked, false);\n  }\n}\nexport function updateWrapper(element, props) {\n  const node = element;\n\n  if (__DEV__) {\n    const controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n      console.error('A component is changing an uncontrolled input to be controlled. ' + 'This is likely caused by the value changing from undefined to ' + 'a defined value, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');\n      didWarnUncontrolledToControlled = true;\n    }\n\n    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n      console.error('A component is changing a controlled input to be uncontrolled. ' + 'This is likely caused by the value changing from a defined to ' + 'undefined, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n  const value = getToStringValue(props.value);\n  const type = props.type;\n\n  if (value != null) {\n    if (type === 'number') {\n      if (value === 0 && node.value === '' || // We explicitly want to coerce to number here if possible.\n      // eslint-disable-next-line\n      node.value != value) {\n        node.value = toString(value);\n      }\n    } else if (node.value !== toString(value)) {\n      node.value = toString(value);\n    }\n  } else if (type === 'submit' || type === 'reset') {\n    // Submit/reset inputs need the attribute removed completely to avoid\n    // blank-text buttons.\n    node.removeAttribute('value');\n    return;\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the value attribute, React only assigns a new value\n    // whenever the defaultValue React prop has changed. When not present,\n    // React does nothing\n    if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  } else {\n    // When syncing the value attribute, the value comes from a cascade of\n    // properties:\n    //  1. The value React property\n    //  2. The defaultValue React property\n    //  3. Otherwise there should be no change\n    if (props.hasOwnProperty('value')) {\n      setDefaultValue(node, props.type, value);\n    } else if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the attribute is directly\n    // controllable from the defaultValue React property. It needs to be\n    // updated as new props come in.\n    if (props.defaultChecked == null) {\n      node.removeAttribute('checked');\n    } else {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, it only changes when it needs\n    // to be removed, such as transitioning from a checkbox into a text input\n    if (props.checked == null && props.defaultChecked != null) {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  }\n}\nexport function postMountWrapper(element, props, isHydrating) {\n  const node = element; // Do not assign value if it is already set. This prevents user text input\n  // from being lost during SSR hydration.\n\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\n    const type = props.type;\n    const isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the\n    // default value provided by the browser. See: #12872\n\n    if (isButton && (props.value === undefined || props.value === null)) {\n      return;\n    }\n\n    const initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input\n    // from being lost during SSR hydration.\n\n    if (!isHydrating) {\n      if (disableInputAttributeSyncing) {\n        const value = getToStringValue(props.value); // When not syncing the value attribute, the value property points\n        // directly to the React prop. Only assign it if it exists.\n\n        if (value != null) {\n          // Always assign on buttons so that it is possible to assign an\n          // empty string to clear button text.\n          //\n          // Otherwise, do not re-assign the value property if is empty. This\n          // potentially avoids a DOM write and prevents Firefox (~60.0.1) from\n          // prematurely marking required inputs as invalid. Equality is compared\n          // to the current value in case the browser provided value is not an\n          // empty string.\n          if (isButton || value !== node.value) {\n            node.value = toString(value);\n          }\n        }\n      } else {\n        // When syncing the value attribute, the value property should use\n        // the wrapperState._initialValue property. This uses:\n        //\n        //   1. The value React property when present\n        //   2. The defaultValue React property when present\n        //   3. An empty string\n        if (initialValue !== node.value) {\n          node.value = initialValue;\n        }\n      }\n    }\n\n    if (disableInputAttributeSyncing) {\n      // When not syncing the value attribute, assign the value attribute\n      // directly from the defaultValue React property (when present)\n      const defaultValue = getToStringValue(props.defaultValue);\n\n      if (defaultValue != null) {\n        node.defaultValue = toString(defaultValue);\n      }\n    } else {\n      // Otherwise, the value attribute is synchronized to the property,\n      // so we assign defaultValue to the same thing as the value property\n      // assignment step above.\n      node.defaultValue = initialValue;\n    }\n  } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n\n\n  const name = node.name;\n\n  if (name !== '') {\n    node.name = '';\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the checked property\n    // never gets assigned. It must be manually set. We don't want\n    // to do this when hydrating so that existing user input isn't\n    // modified\n    if (!isHydrating) {\n      updateChecked(element, props);\n    } // Only assign the checked attribute if it is defined. This saves\n    // a DOM write when controlling the checked attribute isn't needed\n    // (text inputs, submit/reset)\n\n\n    if (props.hasOwnProperty('defaultChecked')) {\n      node.defaultChecked = !node.defaultChecked;\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, both the checked property and\n    // attribute are assigned at the same time using defaultChecked. This uses:\n    //\n    //   1. The checked React property when present\n    //   2. The defaultChecked React property when present\n    //   3. Otherwise, false\n    node.defaultChecked = !node.defaultChecked;\n    node.defaultChecked = !!node._wrapperState.initialChecked;\n  }\n\n  if (name !== '') {\n    node.name = name;\n  }\n}\nexport function restoreControlledState(element, props) {\n  console.log(3333333333);\n  const node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  const name = props.name;\n\n  if (props.type === 'radio' && name != null) {\n    let queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    } // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n\n\n    if (__DEV__) {\n      checkAttributeStringCoercion(name, 'name');\n    }\n\n    const group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (let i = 0; i < group.length; i++) {\n      const otherNode = group[i];\n\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      } // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n\n\n      const otherProps = getFiberCurrentPropsFromNode(otherNode);\n\n      if (!otherProps) {\n        throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.');\n      } // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n\n\n      updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n} // In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\n\n\nexport function setDefaultValue(node, type, value) {\n  if ( // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n  type !== 'number' || getActiveElement(node.ownerDocument) !== node) {\n    if (value == null) {\n      node.defaultValue = toString(node._wrapperState.initialValue);\n    } else if (node.defaultValue !== toString(value)) {\n      node.defaultValue = toString(value);\n    }\n  }\n}","map":{"version":3,"names":["getCurrentFiberOwnerNameInDevOrNull","setValueForProperty","getFiberCurrentPropsFromNode","getToStringValue","toString","checkControlledValueProps","updateValueIfChanged","getActiveElement","assign","disableInputAttributeSyncing","checkAttributeStringCoercion","didWarnValueDefaultValue","didWarnCheckedDefaultChecked","didWarnControlledToUncontrolled","didWarnUncontrolledToControlled","isControlled","props","usesChecked","type","checked","value","getHostProps","element","node","hostProps","defaultChecked","undefined","defaultValue","_wrapperState","initialChecked","initWrapperState","__DEV__","console","error","initialValue","controlled","updateChecked","updateWrapper","removeAttribute","hasOwnProperty","setDefaultValue","postMountWrapper","isHydrating","isButton","name","restoreControlledState","log","updateNamedCousins","rootNode","queryRoot","parentNode","group","querySelectorAll","JSON","stringify","i","length","otherNode","form","otherProps","Error","ownerDocument"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-dom/src/client/ReactDOMInput.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\n// TODO: direct imports like some-package/src/* are bad. Fix me.\r\nimport {getCurrentFiberOwnerNameInDevOrNull} from 'react-reconciler/src/ReactCurrentFiber';\r\n\r\nimport {setValueForProperty} from './DOMPropertyOperations';\r\nimport {getFiberCurrentPropsFromNode} from './ReactDOMComponentTree';\r\nimport {getToStringValue, toString} from './ToStringValue';\r\nimport {checkControlledValueProps} from '../shared/ReactControlledValuePropTypes';\r\nimport {updateValueIfChanged} from './inputValueTracking';\r\nimport getActiveElement from './getActiveElement';\r\nimport assign from 'shared/assign';\r\nimport {disableInputAttributeSyncing} from 'shared/ReactFeatureFlags';\r\nimport {checkAttributeStringCoercion} from 'shared/CheckStringCoercion';\r\n\r\nimport type {ToStringValue} from './ToStringValue';\r\n\r\ntype InputWithWrapperState = HTMLInputElement & {\r\n  _wrapperState: {\r\n    initialValue: ToStringValue,\r\n    initialChecked: ?boolean,\r\n    controlled?: boolean,\r\n    ...\r\n  },\r\n  ...\r\n};\r\n\r\nlet didWarnValueDefaultValue = false;\r\nlet didWarnCheckedDefaultChecked = false;\r\nlet didWarnControlledToUncontrolled = false;\r\nlet didWarnUncontrolledToControlled = false;\r\n\r\nfunction isControlled(props) {\r\n  const usesChecked = props.type === 'checkbox' || props.type === 'radio';\r\n  return usesChecked ? props.checked != null : props.value != null;\r\n}\r\n\r\n/**\r\n * Implements an <input> host component that allows setting these optional\r\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\r\n *\r\n * If `checked` or `value` are not supplied (or null/undefined), user actions\r\n * that affect the checked state or value will trigger updates to the element.\r\n *\r\n * If they are supplied (and not null/undefined), the rendered element will not\r\n * trigger updates to the element. Instead, the props must change in order for\r\n * the rendered element to be updated.\r\n *\r\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\r\n * with an empty value (or `defaultValue`).\r\n *\r\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\r\n */\r\n\r\nexport function getHostProps(element: Element, props: Object) {\r\n  const node = ((element: any): InputWithWrapperState);\r\n  const checked = props.checked;\r\n\r\n  const hostProps = assign({}, props, {\r\n    defaultChecked: undefined,\r\n    defaultValue: undefined,\r\n    value: undefined,\r\n    checked: checked != null ? checked : node._wrapperState.initialChecked,\r\n  });\r\n\r\n  return hostProps;\r\n}\r\n\r\nexport function initWrapperState(element: Element, props: Object) {\r\n  if (__DEV__) {\r\n    checkControlledValueProps('input', props);\r\n\r\n    if (\r\n      props.checked !== undefined &&\r\n      props.defaultChecked !== undefined &&\r\n      !didWarnCheckedDefaultChecked\r\n    ) {\r\n      console.error(\r\n        '%s contains an input of type %s with both checked and defaultChecked props. ' +\r\n          'Input elements must be either controlled or uncontrolled ' +\r\n          '(specify either the checked prop, or the defaultChecked prop, but not ' +\r\n          'both). Decide between using a controlled or uncontrolled input ' +\r\n          'element and remove one of these props. More info: ' +\r\n          'https://reactjs.org/link/controlled-components',\r\n        getCurrentFiberOwnerNameInDevOrNull() || 'A component',\r\n        props.type,\r\n      );\r\n      didWarnCheckedDefaultChecked = true;\r\n    }\r\n    if (\r\n      props.value !== undefined &&\r\n      props.defaultValue !== undefined &&\r\n      !didWarnValueDefaultValue\r\n    ) {\r\n      console.error(\r\n        '%s contains an input of type %s with both value and defaultValue props. ' +\r\n          'Input elements must be either controlled or uncontrolled ' +\r\n          '(specify either the value prop, or the defaultValue prop, but not ' +\r\n          'both). Decide between using a controlled or uncontrolled input ' +\r\n          'element and remove one of these props. More info: ' +\r\n          'https://reactjs.org/link/controlled-components',\r\n        getCurrentFiberOwnerNameInDevOrNull() || 'A component',\r\n        props.type,\r\n      );\r\n      didWarnValueDefaultValue = true;\r\n    }\r\n  }\r\n\r\n  const node = ((element: any): InputWithWrapperState);\r\n  const defaultValue = props.defaultValue == null ? '' : props.defaultValue;\r\n\r\n  node._wrapperState = {\r\n    initialChecked:\r\n      props.checked != null ? props.checked : props.defaultChecked,\r\n    initialValue: getToStringValue(\r\n      props.value != null ? props.value : defaultValue,\r\n    ),\r\n    controlled: isControlled(props),\r\n  };\r\n}\r\n\r\nexport function updateChecked(element: Element, props: Object) {\r\n  const node = ((element: any): InputWithWrapperState);\r\n  const checked = props.checked;\r\n  if (checked != null) {\r\n    setValueForProperty(node, 'checked', checked, false);\r\n  }\r\n}\r\n\r\nexport function updateWrapper(element: Element, props: Object) {\r\n  const node = ((element: any): InputWithWrapperState);\r\n  if (__DEV__) {\r\n    const controlled = isControlled(props);\r\n\r\n    if (\r\n      !node._wrapperState.controlled &&\r\n      controlled &&\r\n      !didWarnUncontrolledToControlled\r\n    ) {\r\n      console.error(\r\n        'A component is changing an uncontrolled input to be controlled. ' +\r\n          'This is likely caused by the value changing from undefined to ' +\r\n          'a defined value, which should not happen. ' +\r\n          'Decide between using a controlled or uncontrolled input ' +\r\n          'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components',\r\n      );\r\n      didWarnUncontrolledToControlled = true;\r\n    }\r\n    if (\r\n      node._wrapperState.controlled &&\r\n      !controlled &&\r\n      !didWarnControlledToUncontrolled\r\n    ) {\r\n      console.error(\r\n        'A component is changing a controlled input to be uncontrolled. ' +\r\n          'This is likely caused by the value changing from a defined to ' +\r\n          'undefined, which should not happen. ' +\r\n          'Decide between using a controlled or uncontrolled input ' +\r\n          'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components',\r\n      );\r\n      didWarnControlledToUncontrolled = true;\r\n    }\r\n  }\r\n\r\n  updateChecked(element, props);\r\n\r\n  const value = getToStringValue(props.value);\r\n  const type = props.type;\r\n\r\n  if (value != null) {\r\n    if (type === 'number') {\r\n      if (\r\n        (value === 0 && node.value === '') ||\r\n        // We explicitly want to coerce to number here if possible.\r\n        // eslint-disable-next-line\r\n        node.value != (value: any)\r\n      ) {\r\n        node.value = toString((value: any));\r\n      }\r\n    } else if (node.value !== toString((value: any))) {\r\n      node.value = toString((value: any));\r\n    }\r\n  } else if (type === 'submit' || type === 'reset') {\r\n    // Submit/reset inputs need the attribute removed completely to avoid\r\n    // blank-text buttons.\r\n    node.removeAttribute('value');\r\n    return;\r\n  }\r\n\r\n  if (disableInputAttributeSyncing) {\r\n    // When not syncing the value attribute, React only assigns a new value\r\n    // whenever the defaultValue React prop has changed. When not present,\r\n    // React does nothing\r\n    if (props.hasOwnProperty('defaultValue')) {\r\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\r\n    }\r\n  } else {\r\n    // When syncing the value attribute, the value comes from a cascade of\r\n    // properties:\r\n    //  1. The value React property\r\n    //  2. The defaultValue React property\r\n    //  3. Otherwise there should be no change\r\n    if (props.hasOwnProperty('value')) {\r\n      setDefaultValue(node, props.type, value);\r\n    } else if (props.hasOwnProperty('defaultValue')) {\r\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\r\n    }\r\n  }\r\n\r\n  if (disableInputAttributeSyncing) {\r\n    // When not syncing the checked attribute, the attribute is directly\r\n    // controllable from the defaultValue React property. It needs to be\r\n    // updated as new props come in.\r\n    if (props.defaultChecked == null) {\r\n      node.removeAttribute('checked');\r\n    } else {\r\n      node.defaultChecked = !!props.defaultChecked;\r\n    }\r\n  } else {\r\n    // When syncing the checked attribute, it only changes when it needs\r\n    // to be removed, such as transitioning from a checkbox into a text input\r\n    if (props.checked == null && props.defaultChecked != null) {\r\n      node.defaultChecked = !!props.defaultChecked;\r\n    }\r\n  }\r\n}\r\n\r\nexport function postMountWrapper(\r\n  element: Element,\r\n  props: Object,\r\n  isHydrating: boolean,\r\n) {\r\n  const node = ((element: any): InputWithWrapperState);\r\n\r\n  // Do not assign value if it is already set. This prevents user text input\r\n  // from being lost during SSR hydration.\r\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\r\n    const type = props.type;\r\n    const isButton = type === 'submit' || type === 'reset';\r\n\r\n    // Avoid setting value attribute on submit/reset inputs as it overrides the\r\n    // default value provided by the browser. See: #12872\r\n    if (isButton && (props.value === undefined || props.value === null)) {\r\n      return;\r\n    }\r\n\r\n    const initialValue = toString(node._wrapperState.initialValue);\r\n\r\n    // Do not assign value if it is already set. This prevents user text input\r\n    // from being lost during SSR hydration.\r\n    if (!isHydrating) {\r\n      if (disableInputAttributeSyncing) {\r\n        const value = getToStringValue(props.value);\r\n\r\n        // When not syncing the value attribute, the value property points\r\n        // directly to the React prop. Only assign it if it exists.\r\n        if (value != null) {\r\n          // Always assign on buttons so that it is possible to assign an\r\n          // empty string to clear button text.\r\n          //\r\n          // Otherwise, do not re-assign the value property if is empty. This\r\n          // potentially avoids a DOM write and prevents Firefox (~60.0.1) from\r\n          // prematurely marking required inputs as invalid. Equality is compared\r\n          // to the current value in case the browser provided value is not an\r\n          // empty string.\r\n          if (isButton || value !== node.value) {\r\n            node.value = toString(value);\r\n          }\r\n        }\r\n      } else {\r\n        // When syncing the value attribute, the value property should use\r\n        // the wrapperState._initialValue property. This uses:\r\n        //\r\n        //   1. The value React property when present\r\n        //   2. The defaultValue React property when present\r\n        //   3. An empty string\r\n        if (initialValue !== node.value) {\r\n          node.value = initialValue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (disableInputAttributeSyncing) {\r\n      // When not syncing the value attribute, assign the value attribute\r\n      // directly from the defaultValue React property (when present)\r\n      const defaultValue = getToStringValue(props.defaultValue);\r\n      if (defaultValue != null) {\r\n        node.defaultValue = toString(defaultValue);\r\n      }\r\n    } else {\r\n      // Otherwise, the value attribute is synchronized to the property,\r\n      // so we assign defaultValue to the same thing as the value property\r\n      // assignment step above.\r\n      node.defaultValue = initialValue;\r\n    }\r\n  }\r\n\r\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\r\n  // this is needed to work around a chrome bug where setting defaultChecked\r\n  // will sometimes influence the value of checked (even after detachment).\r\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\r\n  // We need to temporarily unset name to avoid disrupting radio button groups.\r\n  const name = node.name;\r\n  if (name !== '') {\r\n    node.name = '';\r\n  }\r\n\r\n  if (disableInputAttributeSyncing) {\r\n    // When not syncing the checked attribute, the checked property\r\n    // never gets assigned. It must be manually set. We don't want\r\n    // to do this when hydrating so that existing user input isn't\r\n    // modified\r\n    if (!isHydrating) {\r\n      updateChecked(element, props);\r\n    }\r\n\r\n    // Only assign the checked attribute if it is defined. This saves\r\n    // a DOM write when controlling the checked attribute isn't needed\r\n    // (text inputs, submit/reset)\r\n    if (props.hasOwnProperty('defaultChecked')) {\r\n      node.defaultChecked = !node.defaultChecked;\r\n      node.defaultChecked = !!props.defaultChecked;\r\n    }\r\n  } else {\r\n    // When syncing the checked attribute, both the checked property and\r\n    // attribute are assigned at the same time using defaultChecked. This uses:\r\n    //\r\n    //   1. The checked React property when present\r\n    //   2. The defaultChecked React property when present\r\n    //   3. Otherwise, false\r\n    node.defaultChecked = !node.defaultChecked;\r\n    node.defaultChecked = !!node._wrapperState.initialChecked;\r\n  }\r\n\r\n  if (name !== '') {\r\n    node.name = name;\r\n  }\r\n}\r\n\r\nexport function restoreControlledState(element: Element, props: Object) {\r\n  console.log(3333333333)\r\n  const node = ((element: any): InputWithWrapperState);\r\n  updateWrapper(node, props);\r\n  updateNamedCousins(node, props);\r\n}\r\n\r\nfunction updateNamedCousins(rootNode, props) {\r\n  const name = props.name;\r\n  if (props.type === 'radio' && name != null) {\r\n    let queryRoot: Element = rootNode;\r\n\r\n    while (queryRoot.parentNode) {\r\n      queryRoot = ((queryRoot.parentNode: any): Element);\r\n    }\r\n\r\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\r\n    // but that sometimes behaves strangely in IE8. We could also try using\r\n    // `form.getElementsByName`, but that will only return direct children\r\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\r\n    // the input might not even be in a form. It might not even be in the\r\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\r\n    // miss anything.\r\n    if (__DEV__) {\r\n      checkAttributeStringCoercion(name, 'name');\r\n    }\r\n    const group = queryRoot.querySelectorAll(\r\n      'input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]',\r\n    );\r\n\r\n    for (let i = 0; i < group.length; i++) {\r\n      const otherNode = ((group[i]: any): HTMLInputElement);\r\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\r\n        continue;\r\n      }\r\n      // This will throw if radio buttons rendered by different copies of React\r\n      // and the same name are rendered into the same form (same as #1939).\r\n      // That's probably okay; we don't support it just as we don't support\r\n      // mixing React radio buttons with non-React ones.\r\n      const otherProps = getFiberCurrentPropsFromNode(otherNode);\r\n\r\n      if (!otherProps) {\r\n        throw new Error(\r\n          'ReactDOMInput: Mixing React and non-React radio inputs with the ' +\r\n            'same `name` is not supported.',\r\n        );\r\n      }\r\n\r\n      // We need update the tracked value on the named cousin since the value\r\n      // was changed but the input saw no event or value set\r\n      updateValueIfChanged(otherNode);\r\n\r\n      // If this is a controlled radio button group, forcing the input that\r\n      // was previously checked to update will cause it to be come re-checked\r\n      // as appropriate.\r\n      updateWrapper(otherNode, otherProps);\r\n    }\r\n  }\r\n}\r\n\r\n// In Chrome, assigning defaultValue to certain input types triggers input validation.\r\n// For number inputs, the display value loses trailing decimal points. For email inputs,\r\n// Chrome raises \"The specified value <x> is not a valid email address\".\r\n//\r\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\r\n// when the user is inputting text\r\n//\r\n// https://github.com/facebook/react/issues/7253\r\nexport function setDefaultValue(\r\n  node: InputWithWrapperState,\r\n  type: ?string,\r\n  value: *,\r\n) {\r\n  if (\r\n    // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\r\n    type !== 'number' ||\r\n    getActiveElement(node.ownerDocument) !== node\r\n  ) {\r\n    if (value == null) {\r\n      node.defaultValue = toString(node._wrapperState.initialValue);\r\n    } else if (node.defaultValue !== toString(value)) {\r\n      node.defaultValue = toString(value);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}