{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { registerTwoPhaseEvent } from '../EventRegistry';\nimport { SyntheticEvent } from '../SyntheticEvent';\nimport isTextInputElement from '../isTextInputElement';\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport getEventTarget from '../getEventTarget';\nimport isEventSupported from '../isEventSupported';\nimport { getNodeFromInstance } from '../../client/ReactDOMComponentTree';\nimport { updateValueIfChanged } from '../../client/inputValueTracking';\nimport { setDefaultValue } from '../../client/ReactDOMInput';\nimport { enqueueStateRestore } from '../ReactDOMControlledComponent';\nimport { disableInputAttributeSyncing, enableCustomElementPropertySupport } from 'shared/ReactFeatureFlags';\nimport { batchedUpdates } from '../ReactDOMUpdateBatching';\nimport { processDispatchQueue, accumulateTwoPhaseListeners } from '../DOMPluginEventSystem';\nimport isCustomComponent from '../../shared/isCustomComponent';\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);\n}\n\nfunction createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  const listeners = accumulateTwoPhaseListeners(inst, 'onChange');\n\n  if (listeners.length > 0) {\n    const event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n  }\n}\n/**\r\n * For IE shims\r\n */\n\n\nlet activeElement = null;\nlet activeElementInst = null;\n/**\r\n * SECTION: handle `change` event\r\n */\n\nfunction shouldUseChangeEvent(elem) {\n  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  const dispatchQueue = [];\n  createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n\n  batchedUpdates(runEventInBatch, dispatchQueue);\n}\n\nfunction runEventInBatch(dispatchQueue) {\n  processDispatchQueue(dispatchQueue, 0);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  const targetNode = getNodeFromInstance(targetInst);\n\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\n  if (domEventName === 'change') {\n    return targetInst;\n  }\n}\n/**\r\n * SECTION: handle `input` event\r\n */\n\n\nlet isInputEventSupported = false;\n\nif (canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n/**\r\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\r\n * and override the value property so that we can distinguish user events from\r\n * value changes in JS.\r\n */\n\n\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n/**\r\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\r\n * if any exists.\r\n */\n\n\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n/**\r\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\r\n * the value of the active element has changed.\r\n */\n\n\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n  if (domEventName === 'focusin') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (domEventName === 'focusout') {\n    stopWatchingForValueChange();\n  }\n} // For IE8 and IE9.\n\n\nfunction getTargetInstForInputEventPolyfill(domEventName, targetInst) {\n  if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n/**\r\n * SECTION: handle `click` event\r\n */\n\n\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  const nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\n  if (domEventName === 'click') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n  if (domEventName === 'input' || domEventName === 'change') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node) {\n  const state = node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  if (!disableInputAttributeSyncing) {\n    // If controlled, assign the value attribute to the current value on blur\n    setDefaultValue(node, 'number', node.value);\n  }\n}\n/**\r\n * This plugin creates an `onChange` event that normalizes change events\r\n * across form elements. This event fires at a time when it's possible to\r\n * change the element's value without seeing a flicker.\r\n *\r\n * Supported elements are:\r\n * - input (see `isTextInputElement`)\r\n * - textarea\r\n * - select\r\n */\n\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n  let getTargetInstFunc, handleEventFunc;\n\n  if (shouldUseChangeEvent(targetNode)) {\n    getTargetInstFunc = getTargetInstForChangeEvent;\n  } else if (isTextInputElement(targetNode)) {\n    if (isInputEventSupported) {\n      getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n    } else {\n      getTargetInstFunc = getTargetInstForInputEventPolyfill;\n      handleEventFunc = handleEventsForInputEventPolyfill;\n    }\n  } else if (shouldUseClickEvent(targetNode)) {\n    getTargetInstFunc = getTargetInstForClickEvent;\n  } else if (enableCustomElementPropertySupport && targetInst && isCustomComponent(targetInst.elementType, targetInst.memoizedProps)) {\n    getTargetInstFunc = getTargetInstForChangeEvent;\n  }\n\n  if (getTargetInstFunc) {\n    const inst = getTargetInstFunc(domEventName, targetInst);\n\n    if (inst) {\n      createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);\n      return;\n    }\n  }\n\n  if (handleEventFunc) {\n    handleEventFunc(domEventName, targetNode, targetInst);\n  } // When blurring, set the value attribute for number inputs\n\n\n  if (domEventName === 'focusout') {\n    handleControlledInputBlur(targetNode);\n  }\n}\n\nexport { registerEvents, extractEvents };","map":{"version":3,"names":["registerTwoPhaseEvent","SyntheticEvent","isTextInputElement","canUseDOM","getEventTarget","isEventSupported","getNodeFromInstance","updateValueIfChanged","setDefaultValue","enqueueStateRestore","disableInputAttributeSyncing","enableCustomElementPropertySupport","batchedUpdates","processDispatchQueue","accumulateTwoPhaseListeners","isCustomComponent","registerEvents","createAndAccumulateChangeEvent","dispatchQueue","inst","nativeEvent","target","listeners","length","event","push","activeElement","activeElementInst","shouldUseChangeEvent","elem","nodeName","toLowerCase","type","manualDispatchChangeEvent","runEventInBatch","getInstIfValueChanged","targetInst","targetNode","getTargetInstForChangeEvent","domEventName","isInputEventSupported","document","documentMode","startWatchingForValueChange","attachEvent","handlePropertyChange","stopWatchingForValueChange","detachEvent","propertyName","handleEventsForInputEventPolyfill","getTargetInstForInputEventPolyfill","shouldUseClickEvent","getTargetInstForClickEvent","getTargetInstForInputOrChangeEvent","handleControlledInputBlur","node","state","_wrapperState","controlled","value","extractEvents","nativeEventTarget","eventSystemFlags","targetContainer","window","getTargetInstFunc","handleEventFunc","elementType","memoizedProps"],"sources":["E:/react-test/src/react/packages/react-dom/src/events/plugins/ChangeEventPlugin.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\nimport type {AnyNativeEvent} from '../PluginModuleType';\r\nimport type {DOMEventName} from '../DOMEventNames';\r\nimport type {DispatchQueue} from '../DOMPluginEventSystem';\r\nimport type {EventSystemFlags} from '../EventSystemFlags';\r\n\r\nimport {registerTwoPhaseEvent} from '../EventRegistry';\r\nimport {SyntheticEvent} from '../SyntheticEvent';\r\nimport isTextInputElement from '../isTextInputElement';\r\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\r\n\r\nimport getEventTarget from '../getEventTarget';\r\nimport isEventSupported from '../isEventSupported';\r\nimport {getNodeFromInstance} from '../../client/ReactDOMComponentTree';\r\nimport {updateValueIfChanged} from '../../client/inputValueTracking';\r\nimport {setDefaultValue} from '../../client/ReactDOMInput';\r\nimport {enqueueStateRestore} from '../ReactDOMControlledComponent';\r\n\r\nimport {\r\n  disableInputAttributeSyncing,\r\n  enableCustomElementPropertySupport,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {batchedUpdates} from '../ReactDOMUpdateBatching';\r\nimport {\r\n  processDispatchQueue,\r\n  accumulateTwoPhaseListeners,\r\n} from '../DOMPluginEventSystem';\r\nimport isCustomComponent from '../../shared/isCustomComponent';\r\n\r\nfunction registerEvents() {\r\n  registerTwoPhaseEvent('onChange', [\r\n    'change',\r\n    'click',\r\n    'focusin',\r\n    'focusout',\r\n    'input',\r\n    'keydown',\r\n    'keyup',\r\n    'selectionchange',\r\n  ]);\r\n}\r\n\r\nfunction createAndAccumulateChangeEvent(\r\n  dispatchQueue,\r\n  inst,\r\n  nativeEvent,\r\n  target,\r\n) {\r\n  // Flag this event loop as needing state restore.\r\n  enqueueStateRestore(((target: any): Node));\r\n  const listeners = accumulateTwoPhaseListeners(inst, 'onChange');\r\n  if (listeners.length > 0) {\r\n    const event = new SyntheticEvent(\r\n      'onChange',\r\n      'change',\r\n      null,\r\n      nativeEvent,\r\n      target,\r\n    );\r\n    dispatchQueue.push({event, listeners});\r\n  }\r\n}\r\n/**\r\n * For IE shims\r\n */\r\nlet activeElement = null;\r\nlet activeElementInst = null;\r\n\r\n/**\r\n * SECTION: handle `change` event\r\n */\r\nfunction shouldUseChangeEvent(elem) {\r\n  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();\r\n  return (\r\n    nodeName === 'select' ||\r\n    (nodeName === 'input' && (elem: any).type === 'file')\r\n  );\r\n}\r\n\r\nfunction manualDispatchChangeEvent(nativeEvent) {\r\n  const dispatchQueue = [];\r\n  createAndAccumulateChangeEvent(\r\n    dispatchQueue,\r\n    activeElementInst,\r\n    nativeEvent,\r\n    getEventTarget(nativeEvent),\r\n  );\r\n\r\n  // If change and propertychange bubbled, we'd just bind to it like all the\r\n  // other events and have it go through ReactBrowserEventEmitter. Since it\r\n  // doesn't, we manually listen for the events and so we have to enqueue and\r\n  // process the abstract event manually.\r\n  //\r\n  // Batching is necessary here in order to ensure that all event handlers run\r\n  // before the next rerender (including event handlers attached to ancestor\r\n  // elements instead of directly on the input). Without this, controlled\r\n  // components don't work properly in conjunction with event bubbling because\r\n  // the component is rerendered and the value reverted before all the event\r\n  // handlers can run. See https://github.com/facebook/react/issues/708.\r\n  batchedUpdates(runEventInBatch, dispatchQueue);\r\n}\r\n\r\nfunction runEventInBatch(dispatchQueue) {\r\n  processDispatchQueue(dispatchQueue, 0);\r\n}\r\n\r\nfunction getInstIfValueChanged(targetInst: Object) {\r\n  const targetNode = getNodeFromInstance(targetInst);\r\n  if (updateValueIfChanged(((targetNode: any): HTMLInputElement))) {\r\n    return targetInst;\r\n  }\r\n}\r\n\r\nfunction getTargetInstForChangeEvent(domEventName: DOMEventName, targetInst) {\r\n  if (domEventName === 'change') {\r\n    return targetInst;\r\n  }\r\n}\r\n\r\n/**\r\n * SECTION: handle `input` event\r\n */\r\nlet isInputEventSupported = false;\r\nif (canUseDOM) {\r\n  // IE9 claims to support the input event but fails to trigger it when\r\n  // deleting text, so we ignore its input events.\r\n  isInputEventSupported =\r\n    isEventSupported('input') &&\r\n    (!document.documentMode || document.documentMode > 9);\r\n}\r\n\r\n/**\r\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\r\n * and override the value property so that we can distinguish user events from\r\n * value changes in JS.\r\n */\r\nfunction startWatchingForValueChange(target, targetInst) {\r\n  activeElement = target;\r\n  activeElementInst = targetInst;\r\n  (activeElement: any).attachEvent('onpropertychange', handlePropertyChange);\r\n}\r\n\r\n/**\r\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\r\n * if any exists.\r\n */\r\nfunction stopWatchingForValueChange() {\r\n  if (!activeElement) {\r\n    return;\r\n  }\r\n  (activeElement: any).detachEvent('onpropertychange', handlePropertyChange);\r\n  activeElement = null;\r\n  activeElementInst = null;\r\n}\r\n\r\n/**\r\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\r\n * the value of the active element has changed.\r\n */\r\nfunction handlePropertyChange(nativeEvent) {\r\n  if (nativeEvent.propertyName !== 'value') {\r\n    return;\r\n  }\r\n  if (getInstIfValueChanged(activeElementInst)) {\r\n    manualDispatchChangeEvent(nativeEvent);\r\n  }\r\n}\r\n\r\nfunction handleEventsForInputEventPolyfill(\r\n  domEventName: DOMEventName,\r\n  target,\r\n  targetInst,\r\n) {\r\n  if (domEventName === 'focusin') {\r\n    // In IE9, propertychange fires for most input events but is buggy and\r\n    // doesn't fire when text is deleted, but conveniently, selectionchange\r\n    // appears to fire in all of the remaining cases so we catch those and\r\n    // forward the event if the value has changed\r\n    // In either case, we don't want to call the event handler if the value\r\n    // is changed from JS so we redefine a setter for `.value` that updates\r\n    // our activeElementValue variable, allowing us to ignore those changes\r\n    //\r\n    // stopWatching() should be a noop here but we call it just in case we\r\n    // missed a blur event somehow.\r\n    stopWatchingForValueChange();\r\n    startWatchingForValueChange(target, targetInst);\r\n  } else if (domEventName === 'focusout') {\r\n    stopWatchingForValueChange();\r\n  }\r\n}\r\n\r\n// For IE8 and IE9.\r\nfunction getTargetInstForInputEventPolyfill(\r\n  domEventName: DOMEventName,\r\n  targetInst,\r\n) {\r\n  if (\r\n    domEventName === 'selectionchange' ||\r\n    domEventName === 'keyup' ||\r\n    domEventName === 'keydown'\r\n  ) {\r\n    // On the selectionchange event, the target is just document which isn't\r\n    // helpful for us so just check activeElement instead.\r\n    //\r\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\r\n    // propertychange on the first input event after setting `value` from a\r\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\r\n    // gets it and catching keydown lets us fire an event for the first\r\n    // keystroke if user does a key repeat (it'll be a little delayed: right\r\n    // before the second keystroke). Other input methods (e.g., paste) seem to\r\n    // fire selectionchange normally.\r\n    return getInstIfValueChanged(activeElementInst);\r\n  }\r\n}\r\n\r\n/**\r\n * SECTION: handle `click` event\r\n */\r\nfunction shouldUseClickEvent(elem) {\r\n  // Use the `click` event to detect changes to checkbox and radio inputs.\r\n  // This approach works across all browsers, whereas `change` does not fire\r\n  // until `blur` in IE8.\r\n  const nodeName = elem.nodeName;\r\n  return (\r\n    nodeName &&\r\n    nodeName.toLowerCase() === 'input' &&\r\n    (elem.type === 'checkbox' || elem.type === 'radio')\r\n  );\r\n}\r\n\r\nfunction getTargetInstForClickEvent(domEventName: DOMEventName, targetInst) {\r\n  if (domEventName === 'click') {\r\n    return getInstIfValueChanged(targetInst);\r\n  }\r\n}\r\n\r\nfunction getTargetInstForInputOrChangeEvent(\r\n  domEventName: DOMEventName,\r\n  targetInst,\r\n) {\r\n  if (domEventName === 'input' || domEventName === 'change') {\r\n    return getInstIfValueChanged(targetInst);\r\n  }\r\n}\r\n\r\nfunction handleControlledInputBlur(node: HTMLInputElement) {\r\n  const state = (node: any)._wrapperState;\r\n\r\n  if (!state || !state.controlled || node.type !== 'number') {\r\n    return;\r\n  }\r\n\r\n  if (!disableInputAttributeSyncing) {\r\n    // If controlled, assign the value attribute to the current value on blur\r\n    setDefaultValue((node: any), 'number', (node: any).value);\r\n  }\r\n}\r\n\r\n/**\r\n * This plugin creates an `onChange` event that normalizes change events\r\n * across form elements. This event fires at a time when it's possible to\r\n * change the element's value without seeing a flicker.\r\n *\r\n * Supported elements are:\r\n * - input (see `isTextInputElement`)\r\n * - textarea\r\n * - select\r\n */\r\nfunction extractEvents(\r\n  dispatchQueue: DispatchQueue,\r\n  domEventName: DOMEventName,\r\n  targetInst: null | Fiber,\r\n  nativeEvent: AnyNativeEvent,\r\n  nativeEventTarget: null | EventTarget,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: null | EventTarget,\r\n) {\r\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\r\n\r\n  let getTargetInstFunc, handleEventFunc;\r\n  if (shouldUseChangeEvent(targetNode)) {\r\n    getTargetInstFunc = getTargetInstForChangeEvent;\r\n  } else if (isTextInputElement(((targetNode: any): HTMLElement))) {\r\n    if (isInputEventSupported) {\r\n      getTargetInstFunc = getTargetInstForInputOrChangeEvent;\r\n    } else {\r\n      getTargetInstFunc = getTargetInstForInputEventPolyfill;\r\n      handleEventFunc = handleEventsForInputEventPolyfill;\r\n    }\r\n  } else if (shouldUseClickEvent(targetNode)) {\r\n    getTargetInstFunc = getTargetInstForClickEvent;\r\n  } else if (\r\n    enableCustomElementPropertySupport &&\r\n    targetInst &&\r\n    isCustomComponent(targetInst.elementType, targetInst.memoizedProps)\r\n  ) {\r\n    getTargetInstFunc = getTargetInstForChangeEvent;\r\n  }\r\n\r\n  if (getTargetInstFunc) {\r\n    const inst = getTargetInstFunc(domEventName, targetInst);\r\n    if (inst) {\r\n      createAndAccumulateChangeEvent(\r\n        dispatchQueue,\r\n        inst,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n      );\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (handleEventFunc) {\r\n    handleEventFunc(domEventName, targetNode, targetInst);\r\n  }\r\n\r\n  // When blurring, set the value attribute for number inputs\r\n  if (domEventName === 'focusout') {\r\n    handleControlledInputBlur(((targetNode: any): HTMLInputElement));\r\n  }\r\n}\r\n\r\nexport {registerEvents, extractEvents};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}