{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { getChildHostContext, getRootHostContext } from './ReactFiberHostConfig';\nimport { createCursor, push, pop } from './ReactFiberStack.new';\nconst NO_CONTEXT = {};\nconst contextStackCursor = createCursor(NO_CONTEXT);\nconst contextFiberStackCursor = createCursor(NO_CONTEXT);\nconst rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  if (c === NO_CONTEXT) {\n    throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n\n  return c;\n}\n\nfunction getRootHostContainer() {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n\n  push(contextStackCursor, NO_CONTEXT, fiber);\n  const nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n  pop(contextStackCursor, fiber);\n  push(contextStackCursor, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  const context = requiredContext(contextStackCursor.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  const context = requiredContext(contextStackCursor.current);\n  const nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n  if (context === nextContext) {\n    return;\n  } // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nexport { getHostContext, getRootHostContainer, popHostContainer, popHostContext, pushHostContainer, pushHostContext };","map":{"version":3,"names":["getChildHostContext","getRootHostContext","createCursor","push","pop","NO_CONTEXT","contextStackCursor","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","c","Error","getRootHostContainer","rootInstance","current","pushHostContainer","fiber","nextRootInstance","nextRootContext","popHostContainer","getHostContext","context","pushHostContext","nextContext","type","popHostContext"],"sources":["E:/react-test/src/react/packages/react-reconciler/src/ReactFiberHostContext.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {StackCursor} from './ReactFiberStack.new';\r\nimport type {Container, HostContext} from './ReactFiberHostConfig';\r\n\r\nimport {getChildHostContext, getRootHostContext} from './ReactFiberHostConfig';\r\nimport {createCursor, push, pop} from './ReactFiberStack.new';\r\n\r\ndeclare class NoContextT {}\r\nconst NO_CONTEXT: NoContextT = ({}: any);\r\n\r\nconst contextStackCursor: StackCursor<HostContext | NoContextT> = createCursor(\r\n  NO_CONTEXT,\r\n);\r\nconst contextFiberStackCursor: StackCursor<Fiber | NoContextT> = createCursor(\r\n  NO_CONTEXT,\r\n);\r\nconst rootInstanceStackCursor: StackCursor<\r\n  Container | NoContextT,\r\n> = createCursor(NO_CONTEXT);\r\n\r\nfunction requiredContext<Value>(c: Value | NoContextT): Value {\r\n  if (c === NO_CONTEXT) {\r\n    throw new Error(\r\n      'Expected host context to exist. This error is likely caused by a bug ' +\r\n        'in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  return (c: any);\r\n}\r\n\r\nfunction getRootHostContainer(): Container {\r\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\r\n  return rootInstance;\r\n}\r\n\r\nfunction pushHostContainer(fiber: Fiber, nextRootInstance: Container) {\r\n  // Push current root instance onto the stack;\r\n  // This allows us to reset root when portals are popped.\r\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\r\n  // Track the context and the Fiber that provided it.\r\n  // This enables us to pop only Fibers that provide unique contexts.\r\n  push(contextFiberStackCursor, fiber, fiber);\r\n\r\n  // Finally, we need to push the host context to the stack.\r\n  // However, we can't just call getRootHostContext() and push it because\r\n  // we'd have a different number of entries on the stack depending on\r\n  // whether getRootHostContext() throws somewhere in renderer code or not.\r\n  // So we push an empty value first. This lets us safely unwind on errors.\r\n  push(contextStackCursor, NO_CONTEXT, fiber);\r\n  const nextRootContext = getRootHostContext(nextRootInstance);\r\n  // Now that we know this function doesn't throw, replace it.\r\n  pop(contextStackCursor, fiber);\r\n  push(contextStackCursor, nextRootContext, fiber);\r\n}\r\n\r\nfunction popHostContainer(fiber: Fiber) {\r\n  pop(contextStackCursor, fiber);\r\n  pop(contextFiberStackCursor, fiber);\r\n  pop(rootInstanceStackCursor, fiber);\r\n}\r\n\r\nfunction getHostContext(): HostContext {\r\n  const context = requiredContext(contextStackCursor.current);\r\n  return context;\r\n}\r\n\r\nfunction pushHostContext(fiber: Fiber): void {\r\n  const rootInstance: Container = requiredContext(\r\n    rootInstanceStackCursor.current,\r\n  );\r\n  const context: HostContext = requiredContext(contextStackCursor.current);\r\n  const nextContext = getChildHostContext(context, fiber.type, rootInstance);\r\n\r\n  // Don't push this Fiber's context unless it's unique.\r\n  if (context === nextContext) {\r\n    return;\r\n  }\r\n\r\n  // Track the context and the Fiber that provided it.\r\n  // This enables us to pop only Fibers that provide unique contexts.\r\n  push(contextFiberStackCursor, fiber, fiber);\r\n  push(contextStackCursor, nextContext, fiber);\r\n}\r\n\r\nfunction popHostContext(fiber: Fiber): void {\r\n  // Do not pop unless this Fiber provided the current context.\r\n  // pushHostContext() only pushes Fibers that provide unique contexts.\r\n  if (contextFiberStackCursor.current !== fiber) {\r\n    return;\r\n  }\r\n\r\n  pop(contextStackCursor, fiber);\r\n  pop(contextFiberStackCursor, fiber);\r\n}\r\n\r\nexport {\r\n  getHostContext,\r\n  getRootHostContainer,\r\n  popHostContainer,\r\n  popHostContext,\r\n  pushHostContainer,\r\n  pushHostContext,\r\n};\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA,SAAQA,mBAAR,EAA6BC,kBAA7B,QAAsD,wBAAtD;AACA,SAAQC,YAAR,EAAsBC,IAAtB,EAA4BC,GAA5B,QAAsC,uBAAtC;AAGA,MAAMC,UAAsB,GAAI,EAAhC;AAEA,MAAMC,kBAAyD,GAAGJ,YAAY,CAC5EG,UAD4E,CAA9E;AAGA,MAAME,uBAAwD,GAAGL,YAAY,CAC3EG,UAD2E,CAA7E;AAGA,MAAMG,uBAEL,GAAGN,YAAY,CAACG,UAAD,CAFhB;;AAIA,SAASI,eAAT,CAAgCC,CAAhC,EAA8D;EAC5D,IAAIA,CAAC,KAAKL,UAAV,EAAsB;IACpB,MAAM,IAAIM,KAAJ,CACJ,0EACE,iCAFE,CAAN;EAID;;EAED,OAAQD,CAAR;AACD;;AAED,SAASE,oBAAT,GAA2C;EACzC,MAAMC,YAAY,GAAGJ,eAAe,CAACD,uBAAuB,CAACM,OAAzB,CAApC;EACA,OAAOD,YAAP;AACD;;AAED,SAASE,iBAAT,CAA2BC,KAA3B,EAAyCC,gBAAzC,EAAsE;EACpE;EACA;EACAd,IAAI,CAACK,uBAAD,EAA0BS,gBAA1B,EAA4CD,KAA5C,CAAJ,CAHoE,CAIpE;EACA;;EACAb,IAAI,CAACI,uBAAD,EAA0BS,KAA1B,EAAiCA,KAAjC,CAAJ,CANoE,CAQpE;EACA;EACA;EACA;EACA;;EACAb,IAAI,CAACG,kBAAD,EAAqBD,UAArB,EAAiCW,KAAjC,CAAJ;EACA,MAAME,eAAe,GAAGjB,kBAAkB,CAACgB,gBAAD,CAA1C,CAdoE,CAepE;;EACAb,GAAG,CAACE,kBAAD,EAAqBU,KAArB,CAAH;EACAb,IAAI,CAACG,kBAAD,EAAqBY,eAArB,EAAsCF,KAAtC,CAAJ;AACD;;AAED,SAASG,gBAAT,CAA0BH,KAA1B,EAAwC;EACtCZ,GAAG,CAACE,kBAAD,EAAqBU,KAArB,CAAH;EACAZ,GAAG,CAACG,uBAAD,EAA0BS,KAA1B,CAAH;EACAZ,GAAG,CAACI,uBAAD,EAA0BQ,KAA1B,CAAH;AACD;;AAED,SAASI,cAAT,GAAuC;EACrC,MAAMC,OAAO,GAAGZ,eAAe,CAACH,kBAAkB,CAACQ,OAApB,CAA/B;EACA,OAAOO,OAAP;AACD;;AAED,SAASC,eAAT,CAAyBN,KAAzB,EAA6C;EAC3C,MAAMH,YAAuB,GAAGJ,eAAe,CAC7CD,uBAAuB,CAACM,OADqB,CAA/C;EAGA,MAAMO,OAAoB,GAAGZ,eAAe,CAACH,kBAAkB,CAACQ,OAApB,CAA5C;EACA,MAAMS,WAAW,GAAGvB,mBAAmB,CAACqB,OAAD,EAAUL,KAAK,CAACQ,IAAhB,EAAsBX,YAAtB,CAAvC,CAL2C,CAO3C;;EACA,IAAIQ,OAAO,KAAKE,WAAhB,EAA6B;IAC3B;EACD,CAV0C,CAY3C;EACA;;;EACApB,IAAI,CAACI,uBAAD,EAA0BS,KAA1B,EAAiCA,KAAjC,CAAJ;EACAb,IAAI,CAACG,kBAAD,EAAqBiB,WAArB,EAAkCP,KAAlC,CAAJ;AACD;;AAED,SAASS,cAAT,CAAwBT,KAAxB,EAA4C;EAC1C;EACA;EACA,IAAIT,uBAAuB,CAACO,OAAxB,KAAoCE,KAAxC,EAA+C;IAC7C;EACD;;EAEDZ,GAAG,CAACE,kBAAD,EAAqBU,KAArB,CAAH;EACAZ,GAAG,CAACG,uBAAD,EAA0BS,KAA1B,CAAH;AACD;;AAED,SACEI,cADF,EAEER,oBAFF,EAGEO,gBAHF,EAIEM,cAJF,EAKEV,iBALF,EAMEO,eANF"},"metadata":{},"sourceType":"module"}