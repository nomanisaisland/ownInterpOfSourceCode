{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { warnAboutDeprecatedLifecycles, replayFailedUnitOfWorkWithInvokeGuardedCallback, enableCreateEventHandleAPI, enableProfilerTimer, enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableProfilerNestedUpdateScheduledHook, deferRenderPhaseUpdateToNextBatch, enableDebugTracing, enableSchedulingProfiler, disableSchedulerTimeoutInWorkLoop, enableStrictEffects, skipUnmountedBoundaries, enableUpdaterTracking, enableCache, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport is from 'shared/objectIs';\nimport { // Aliased because `act` will override and push to an internal queue\nscheduleCallback as Scheduler_scheduleCallback, cancelCallback as Scheduler_cancelCallback, shouldYield, requestPaint, now, ImmediatePriority as ImmediateSchedulerPriority, UserBlockingPriority as UserBlockingSchedulerPriority, NormalPriority as NormalSchedulerPriority, IdlePriority as IdleSchedulerPriority } from './Scheduler';\nimport { flushSyncCallbacks, flushSyncCallbacksOnlyInLegacyMode, scheduleSyncCallback, scheduleLegacySyncCallback } from './ReactFiberSyncTaskQueue.old';\nimport { logCommitStarted, logCommitStopped, logLayoutEffectsStarted, logLayoutEffectsStopped, logPassiveEffectsStarted, logPassiveEffectsStopped, logRenderStarted, logRenderStopped } from './DebugTracing';\nimport { resetAfterCommit, scheduleTimeout, cancelTimeout, noTimeout, afterActiveInstanceBlur, getCurrentEventPriority, supportsMicrotasks, errorHydratingContainer, scheduleMicrotask } from './ReactFiberHostConfig';\nimport { createWorkInProgress, assignFiberPropertiesInDEV } from './ReactFiber.old';\nimport { isRootDehydrated } from './ReactFiberShellHydration';\nimport { NoMode, ProfileMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostRoot, IndeterminateComponent, ClassComponent, SuspenseComponent, SuspenseListComponent, FunctionComponent, ForwardRef, MemoComponent, SimpleMemoComponent, Profiler } from './ReactWorkTags';\nimport { LegacyRoot } from './ReactRootTags';\nimport { NoFlags, Placement, Incomplete, StoreConsistency, HostEffectMask, Hydrating, ForceClientRender, BeforeMutationMask, MutationMask, LayoutMask, PassiveMask, MountPassiveDev, MountLayoutDev } from './ReactFiberFlags';\nimport { NoLanes, NoLane, SyncLane, NoTimestamp, claimNextTransitionLane, claimNextRetryLane, includesSomeLane, isSubsetOfLanes, mergeLanes, removeLanes, pickArbitraryLane, includesNonIdleWork, includesOnlyRetries, includesOnlyTransitions, includesBlockingLane, includesExpiredLane, getNextLanes, markStarvedLanesAsExpired, getLanesToRetrySynchronouslyOnError, getMostRecentEventTime, markRootUpdated, markRootSuspended as markRootSuspended_dontCallThisOneDirectly, markRootPinged, markRootEntangled, markRootFinished, getHighestPriorityLane, addFiberToLanesMap, movePendingFibersToMemoized, addTransitionToLanesMap, getTransitionsForLanes } from './ReactFiberLane.old';\nimport { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority, IdleEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority, lowerEventPriority, lanesToEventPriority } from './ReactEventPriorities.old';\nimport { requestCurrentTransition, NoTransition } from './ReactFiberTransition';\nimport { beginWork as originalBeginWork } from './ReactFiberBeginWork.old';\nimport { completeWork } from './ReactFiberCompleteWork.old';\nimport { unwindWork, unwindInterruptedWork } from './ReactFiberUnwindWork.old';\nimport { throwException, createRootErrorUpdate, createClassErrorUpdate } from './ReactFiberThrow.old';\nimport { commitBeforeMutationEffects, commitLayoutEffects, commitMutationEffects, commitPassiveEffectDurations, commitPassiveMountEffects, commitPassiveUnmountEffects, invokeLayoutEffectMountInDEV, invokePassiveEffectMountInDEV, invokeLayoutEffectUnmountInDEV, invokePassiveEffectUnmountInDEV, reportUncaughtErrorInDEV } from './ReactFiberCommitWork.old';\nimport { enqueueUpdate } from './ReactUpdateQueue.old';\nimport { resetContextDependencies } from './ReactFiberNewContext.old';\nimport { resetHooksAfterThrow, ContextOnlyDispatcher, getIsUpdatingOpaqueValueInRenderPhaseInDEV } from './ReactFiberHooks.old';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { push as pushToStack, pop as popFromStack, createCursor } from './ReactFiberStack.old';\nimport { enqueueInterleavedUpdates, hasInterleavedUpdates } from './ReactFiberInterleavedUpdates.old';\nimport { markNestedUpdateScheduled, recordCommitTime, resetNestedUpdateFlag, startProfilerTimer, stopProfilerTimerIfRunningAndRecordDelta, syncNestedUpdateFlag } from './ReactProfilerTimer.old'; // DEV stuff\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\nimport { isRendering as ReactCurrentDebugFiberIsRenderingInDEV, current as ReactCurrentFiberCurrent, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { isDevToolsPresent, markCommitStarted, markCommitStopped, markComponentRenderStopped, markComponentSuspended, markComponentErrored, markLayoutEffectsStarted, markLayoutEffectsStopped, markPassiveEffectsStarted, markPassiveEffectsStopped, markRenderStarted, markRenderYielded, markRenderStopped, onCommitRoot as onCommitRootDevTools, onPostCommitRoot as onPostCommitRootDevTools } from './ReactFiberDevToolsHook.old';\nimport { onCommitRoot as onCommitRootTestSelector } from './ReactTestSelectors';\nimport { releaseCache } from './ReactFiberCacheComponent.old';\nimport { isLegacyActEnvironment, isConcurrentActEnvironment } from './ReactFiberAct.old';\nimport { processTransitionCallbacks } from './ReactFiberTracingMarkerComponent.old';\nconst ceil = Math.ceil;\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  ReactCurrentBatchConfig,\n  ReactCurrentActQueue\n} = ReactSharedInternals;\nexport const NoContext =\n/*             */\n0b000;\nconst BatchedContext =\n/*               */\n0b001;\nconst RenderContext =\n/*                */\n0b010;\nconst CommitContext =\n/*                */\n0b100;\nconst RootInProgress = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\nconst RootDidNotComplete = 6; // Describes where we are in the React execution stack\n\nlet executionContext = NoContext; // The root we're working on\n\nlet workInProgressRoot = null; // The fiber we're working on\n\nlet workInProgress = null; // The lanes we're rendering\n\nlet workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\n\nexport let subtreeRenderLanes = NoLanes;\nconst subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n\nlet workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n\nlet workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\n\nlet workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nlet workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n\nlet workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n\nlet workInProgressRootRenderPhaseUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.\n\nlet workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n\nlet workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\n\nlet workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nlet globalMostRecentFallbackTime = 0;\nconst FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\n\nlet workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\n\nconst RENDER_TIMEOUT_MS = 500;\nlet workInProgressTransitions = null;\nexport function getWorkInProgressTransitions() {\n  return workInProgressTransitions;\n}\nlet currentPendingTransitionCallbacks = null;\nexport function addTransitionStartCallbackToPendingTransition(transition) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: [],\n        transitionComplete: null\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionStart === null) {\n      currentPendingTransitionCallbacks.transitionStart = [];\n    }\n\n    currentPendingTransitionCallbacks.transitionStart.push(transition);\n  }\n}\nexport function addTransitionCompleteCallbackToPendingTransition(transition) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionComplete: []\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionComplete === null) {\n      currentPendingTransitionCallbacks.transitionComplete = [];\n    }\n\n    currentPendingTransitionCallbacks.transitionComplete.push(transition);\n  }\n}\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n}\n\nexport function getRenderTargetTime() {\n  return workInProgressRootRenderTargetTime;\n}\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\n// to track which root is currently committing layout effects.\n\nlet rootCommittingMutationOrLayoutEffects = null;\nlet rootDoesHavePassiveEffects = false;\nlet rootWithPendingPassiveEffects = null;\nlet pendingPassiveEffectsLanes = NoLanes;\nlet pendingPassiveProfilerEffects = [];\nlet pendingPassiveEffectsRemainingLanes = NoLanes;\nlet pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount = 0;\nlet rootWithNestedUpdates = null;\nlet isFlushingPassiveEffects = false;\nlet didScheduleUpdateDuringPassiveEffects = false;\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount = 0;\nlet rootWithPassiveNestedUpdates = null; // If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\n\nlet currentEventTime = NoTimestamp;\nlet currentEventTransitionLane = NoLanes;\nlet isRunningInsertionEffect = false;\nexport function getWorkInProgressRoot() {\n  return workInProgressRoot;\n}\nexport function requestEventTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now();\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = now();\n  return currentEventTime;\n}\nexport function getCurrentTime() {\n  return now();\n}\nexport function requestUpdateLane(fiber) {\n  // Special cases\n  const mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  } else if (!deferRenderPhaseUpdateToNextBatch && (executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  const isTransition = requestCurrentTransition() !== NoTransition;\n\n  if (isTransition) {\n    if (__DEV__ && ReactCurrentBatchConfig.transition !== null) {\n      const transition = ReactCurrentBatchConfig.transition;\n\n      if (!transition._updatedFibers) {\n        transition._updatedFibers = new Set();\n      }\n\n      transition._updatedFibers.add(fiber);\n    } // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n\n\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n\n    return currentEventTransitionLane;\n  } // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  const updateLane = getCurrentUpdatePriority();\n\n  if (updateLane !== NoLane) {\n    return updateLane;\n  } // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  const eventLane = getCurrentEventPriority();\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n  // Special cases\n  const mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  }\n\n  return claimNextRetryLane();\n}\n/**\r\n * @description 在fiber上调度update\r\n * @param {*} fiber \r\n * @param {*} lane \r\n * @param {*} eventTime \r\n * @returns \r\n */\n\n\nexport function scheduleUpdateOnFiber(fiber, lane, eventTime) {\n  // 检查更新是否符合规则\n  checkForNestedUpdates();\n\n  if (__DEV__) {\n    if (isRunningInsertionEffect) {\n      console.error('useInsertionEffect must not schedule updates.');\n    }\n  } // \n\n\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane); // console.log(root)\n\n  if (root === null) {\n    return null;\n  }\n\n  if (__DEV__) {\n    if (isFlushingPassiveEffects) {\n      didScheduleUpdateDuringPassiveEffects = true;\n    }\n  } // Mark that the root has a pending update.\n\n\n  markRootUpdated(root, lane, eventTime);\n\n  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(workInProgressRootRenderPhaseUpdatedLanes, lane);\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      if ((executionContext & CommitContext) !== NoContext && root === rootCommittingMutationOrLayoutEffects) {\n        if (fiber.mode & ProfileMode) {\n          let current = fiber;\n\n          while (current !== null) {\n            if (current.tag === Profiler) {\n              const {\n                id,\n                onNestedUpdateScheduled\n              } = current.memoizedProps;\n\n              if (typeof onNestedUpdateScheduled === 'function') {\n                onNestedUpdateScheduled(id);\n              }\n            }\n\n            current = current.return;\n          }\n        }\n      }\n    }\n\n    if (enableTransitionTracing) {\n      const transition = ReactCurrentBatchConfig.transition;\n\n      if (transition !== null) {\n        if (transition.startTime === -1) {\n          transition.startTime = now();\n        }\n\n        addTransitionToLanesMap(root, transition, lane);\n      }\n    }\n\n    if (root === workInProgressRoot) {\n      // TODO: Consolidate with `isInterleavedUpdate` check\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if (deferRenderPhaseUpdateToNextBatch || (executionContext & RenderContext) === NoContext) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n      }\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n\n    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n\n  return root;\n}\nexport function scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n  // This is a special fork of scheduleUpdateOnFiber that is only used to\n  // schedule the initial hydration of a root that has just been created. Most\n  // of the stuff in scheduleUpdateOnFiber can be skipped.\n  //\n  // The main reason for this separate path, though, is to distinguish the\n  // initial children from subsequent updates. In fully client-rendered roots\n  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n  // updates, but hydration roots are special because the initial render must\n  // match what was rendered on the server.\n  const current = root.current;\n  current.lanes = lane;\n  markRootUpdated(root, lane, eventTime);\n  ensureRootIsScheduled(root, eventTime);\n} // This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\n// 从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber\n\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n  // Update the source fiber's lanes\n  console.log(sourceFiber.lanes);\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  console.log(sourceFiber.lanes);\n  let alternate = sourceFiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n\n  if (__DEV__) {\n    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  } // Walk the parent path to the root and update the child lanes.\n\n\n  let node = sourceFiber;\n  let parent = sourceFiber.return;\n\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    } else {\n      if (__DEV__) {\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        }\n      }\n    }\n\n    node = parent;\n    parent = parent.return;\n  }\n\n  if (node.tag === HostRoot) {\n    const root = node.stateNode;\n    return root;\n  } else {\n    return null;\n  }\n}\n\nexport function isInterleavedUpdate(fiber, lane) {\n  // workInProgressRoot为空的话就代表是mount阶段\n  return (// TODO: Optimize slightly by comparing to root that fiber belongs to.\n    // Requires some refactoring. Not a big deal though since it's rare for\n    // concurrent apps to have more than a single root.\n    (workInProgressRoot !== null || // If the interleaved updates queue hasn't been cleared yet, then\n    // we should treat this as an interleaved update, too. This is also a\n    // defensive coding measure in case a new update comes in between when\n    // rendering has finished and when the interleaved updates are transferred\n    // to the main queue.\n    hasInterleavedUpdates()) && (fiber.mode & ConcurrentMode) !== NoMode && ( // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\n    // then don't treat this as an interleaved update. This pattern is\n    // accompanied by a warning but we haven't fully deprecated it yet. We can\n    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n    deferRenderPhaseUpdateToNextBatch || (executionContext & RenderContext) === NoContext)\n  );\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\n\n/**\r\n * @description 通知Scheduler根据更新的优先级，决定以同步还是异步的方式调度本次更新。\r\n * @param {*} root \r\n * @param {*} currentTime \r\n * @returns \r\n */\n\nfunction ensureRootIsScheduled(root, currentTime) {\n  const existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n\n  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n\n  const nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); //计算nextLanes\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  } // We use the highest priority lane to represent the priority of the callback.\n\n\n  const newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n\n  const existingCallbackPriority = root.callbackPriority;\n\n  if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n  // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n  // on the `act` queue.\n  !(__DEV__ && ReactCurrentActQueue.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n    if (__DEV__) {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n        console.error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // The priority hasn't changed. We can reuse the existing task. Exit.\n\n\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback(existingCallbackNode);\n  } // Schedule a new callback.\n\n\n  let newCallbackNode;\n\n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if (__DEV__ && ReactCurrentActQueue.isBatchingLegacy !== null) {\n        ReactCurrentActQueue.didScheduleLegacyUpdate = true;\n      } // 进入render阶段和commit阶段\n\n\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if (__DEV__ && ReactCurrentActQueue.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(() => {\n          // In Safari, appending an iframe forces microtasks to run.\n          // https://github.com/facebook/react/issues/22459\n          // We don't support running callbacks in the middle of render\n          // or commit so we need to check against that.\n          if (executionContext === NoContext) {\n            // It's only safe to do this conditionally because we always\n            // check for pending work before we exit the task.\n            flushSyncCallbacks();\n          }\n        });\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n\n    newCallbackNode = null;\n  } else {\n    //将lane的优先级转换成schduler的优先级\n    let schedulerPriorityLevel;\n\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    } //以schedulerPriorityLevel的优先级执行performConcurrentWorkOnRoot 也就是concurrent模式的起点\n\n\n    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n// render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。\n// 最终调用workLoopConcurrent实现时间切片\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    resetNestedUpdateFlag();\n  } // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n\n\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  } // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n\n\n  const originalCallbackNode = root.callbackNode;\n  const didFlushPassiveEffects = flushPassiveEffects();\n\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {// Current task was not canceled. Continue.\n    }\n  } // Determine the next lanes to work on, using the fields stored\n  // on the root.\n\n\n  let lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  } // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n\n\n  const shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n  let exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n\n  if (exitStatus !== RootInProgress) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n\n    if (exitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    if (exitStatus === RootDidNotComplete) {\n      // The render unwound without completing the tree. This happens in special\n      // cases where need to exit the current render without producing a\n      // consistent tree or committing.\n      //\n      // This should only happen during a concurrent render, not a discrete or\n      // synchronous update. We should have already checked for this when we\n      // unwound the stack.\n      markRootSuspended(root, lanes);\n    } else {\n      // The render completed.\n      // Check if this render may have yielded to a concurrent event, and if so,\n      // confirm that any newly rendered stores are consistent.\n      // TODO: It's possible that even a concurrent render may never have yielded\n      // to the main thread, if it was fast enough, or if it expired. We could\n      // skip the consistency check in that case, too.\n      const renderWasConcurrent = !includesBlockingLane(root, lanes);\n      const finishedWork = root.current.alternate;\n\n      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n        // A store was mutated in an interleaved event. Render again,\n        // synchronously, to block further mutations.\n        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n\n        if (exitStatus === RootErrored) {\n          const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n          if (errorRetryLanes !== NoLanes) {\n            lanes = errorRetryLanes;\n            exitStatus = recoverFromConcurrentError(root, errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n            // concurrent events.\n          }\n        }\n\n        if (exitStatus === RootFatalErrored) {\n          const fatalError = workInProgressRootFatalError;\n          prepareFreshStack(root, NoLanes);\n          markRootSuspended(root, lanes);\n          ensureRootIsScheduled(root, now());\n          throw fatalError;\n        }\n      } // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n\n\n      root.finishedWork = finishedWork;\n      root.finishedLanes = lanes;\n      finishConcurrentRender(root, exitStatus, lanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, now());\n\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n\n  return null;\n}\n\nfunction recoverFromConcurrentError(root, errorRetryLanes) {\n  // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n  // Before rendering again, save the errors from the previous attempt.\n  const errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n\n  if (isRootDehydrated(root)) {\n    // The shell failed to hydrate. Set a flag to force a client rendering\n    // during the next attempt. To do this, we call prepareFreshStack now\n    // to create the root work-in-progress fiber. This is a bit weird in terms\n    // of factoring, because it relies on renderRootSync not calling\n    // prepareFreshStack again in the call below, which happens because the\n    // root and lanes haven't changed.\n    //\n    // TODO: I think what we should do is set ForceClientRender inside\n    // throwException, like we do for nested Suspense boundaries. The reason\n    // it's here instead is so we can switch to the synchronous work loop, too.\n    // Something to consider for a future refactor.\n    const rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n    rootWorkInProgress.flags |= ForceClientRender;\n\n    if (__DEV__) {\n      errorHydratingContainer(root.containerInfo);\n    }\n  }\n\n  const exitStatus = renderRootSync(root, errorRetryLanes);\n\n  if (exitStatus !== RootErrored) {\n    // Successfully finished rendering on retry\n    // The errors from the failed first attempt have been recovered. Add\n    // them to the collection of recoverable errors. We'll log them in the\n    // commit phase.\n    const errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n    workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n    // from the first attempt, to preserve the causal sequence.\n\n    if (errorsFromSecondAttempt !== null) {\n      queueRecoverableErrors(errorsFromSecondAttempt);\n    }\n  } else {// The UI failed to recover.\n  }\n\n  return exitStatus;\n}\n\nexport function queueRecoverableErrors(errors) {\n  if (workInProgressRootRecoverableErrors === null) {\n    workInProgressRootRecoverableErrors = errors;\n  } else {\n    workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n  }\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootInProgress:\n    case RootFatalErrored:\n      {\n        throw new Error('Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // We should have already attempted to retry this tree. If we reached\n        // this point, it errored again. Commit it.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspended(root, lanes); // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n\n        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()) {\n          // This render only included retries, no updates. Throttle committing\n          // retries so that we don't show too many loading states too quickly.\n          const msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            const nextLanes = getNextLanes(root, NoLanes); //计算nextLanes\n\n            if (nextLanes !== NoLanes) {\n              // There's additional work on this root.\n              break;\n            }\n\n            const suspendedLanes = root.suspendedLanes;\n\n            if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              // FIXME: What if the suspended lanes are Idle? Should not restart.\n              const eventTime = requestEventTime();\n              markRootPinged(root, suspendedLanes, eventTime);\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspended(root, lanes);\n\n        if (includesOnlyTransitions(lanes)) {\n          // This is a transition, so we should exit without committing a\n          // placeholder and without scheduling a timeout. Delay indefinitely\n          // until we receive more data.\n          break;\n        }\n\n        if (!shouldForceFlushFallbacksInDEV()) {\n          // This is not a transition, but we did trigger an avoided state.\n          // Schedule a placeholder to display after a short delay, using the Just\n          // Noticeable Difference.\n          // TODO: Is the JND optimization worth the added complexity? If this is\n          // the only reason we track the event time, then probably not.\n          // Consider removing.\n          const mostRecentEventTime = getMostRecentEventTime(root, lanes);\n          const eventTimeMs = mostRecentEventTime;\n          const timeElapsedMs = now() - eventTimeMs;\n          const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            // Instead of committing the fallback immediately, wait for more data\n            // to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n            break;\n          }\n        } // Commit the placeholder.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unknown root exit status.');\n      }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  let node = finishedWork;\n\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      const updateQueue = node.updateQueue;\n\n      if (updateQueue !== null) {\n        const checks = updateQueue.stores;\n\n        if (checks !== null) {\n          for (let i = 0; i < checks.length; i++) {\n            const check = checks[i];\n            const getSnapshot = check.getSnapshot;\n            const renderedValue = check.value;\n\n            try {\n              if (!is(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n\n    const child = node.child;\n\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n\n    if (node === finishedWork) {\n      return true;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n\n\n  return true;\n}\n\nfunction markRootSuspended(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n// render 阶段\n\n\nfunction performSyncWorkOnRoot(root) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  } // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\n\n\n  flushPassiveEffects();\n  let lanes = getNextLanes(root, NoLanes);\n\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  let exitStatus = renderRootSync(root, lanes);\n\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  if (exitStatus === RootDidNotComplete) {\n    throw new Error('Root did not complete. This is a bug in React.');\n  } // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n\n\n  const finishedWork = root.current.alternate;\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes; // 开启commit 工作流程\n\n  commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions); // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n\n  ensureRootIsScheduled(root, now());\n  return null;\n}\n\nexport function flushRoot(root, lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now());\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function getExecutionContext() {\n  return executionContext;\n}\nexport function deferredUpdates(fn) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\nexport function batchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n\n    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nexport function discreteUpdates(fn, a, b, c, d) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n} // Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n\n// eslint-disable-next-line no-redeclare\nexport function flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n    // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\n    flushPassiveEffects();\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function isAlreadyRendering() {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return __DEV__ && (executionContext & (RenderContext | CommitContext)) !== NoContext;\n}\nexport function flushControlled(fn) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function pushRenderLanes(fiber, lanes) {\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n}\nexport function popRenderLanes(fiber) {\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\n  popFromStack(subtreeRenderLanesCursor, fiber);\n}\n\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n  const timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      const current = interruptedWork.alternate;\n      unwindInterruptedWork(current, interruptedWork, workInProgressRootRenderLanes);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  workInProgressRoot = root;\n  const rootWorkInProgress = createWorkInProgress(root.current, null);\n  workInProgress = rootWorkInProgress;\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  workInProgressRootExitStatus = RootInProgress;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  workInProgressRootConcurrentErrors = null;\n  workInProgressRootRecoverableErrors = null;\n  enqueueInterleavedUpdates();\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n\n  return rootWorkInProgress;\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    let erroredWork = workInProgress;\n\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentDebugFiberInDEV(); // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n\n      ReactCurrentOwner.current = null;\n\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n\n        workInProgress = null;\n        return;\n      }\n\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n      }\n\n      if (enableSchedulingProfiler) {\n        markComponentRenderStopped();\n\n        if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n          const wakeable = thrownValue;\n          markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n        } else {\n          markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n      }\n\n      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n\n      continue;\n    } // Return to the normal work loop.\n\n\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher() {\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nexport function markSkippedUpdateLanes(lane) {\n  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n}\nexport function renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nexport function renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n\n\n  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\nexport function renderDidError(error) {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n\n  if (workInProgressRootConcurrentErrors === null) {\n    workInProgressRootConcurrentErrors = [error];\n  } else {\n    workInProgressRootConcurrentErrors.push(error);\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nexport function renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootInProgress;\n}\n\nfunction renderRootSync(root, lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStopped();\n  } // Set this to null to indicate there's no in-progress render.\n\n\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n  return workInProgressRootExitStatus;\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root, lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  } // Check if the tree has completed.\n\n\n  if (workInProgress !== null) {\n    // Still work remaining.\n    if (enableSchedulingProfiler) {\n      markRenderYielded();\n    }\n\n    return RootInProgress;\n  } else {\n    // Completed the tree.\n    if (enableSchedulingProfiler) {\n      markRenderStopped();\n    } // Set this to null to indicate there's no in-progress render.\n\n\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n\n    return workInProgressRootExitStatus;\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  // shouldYield() 利用这个函数判断是否可以终止任务\n  // workInProgress 是FiberRootNode 下的 current  也是双缓存树的第一颗树\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n/**\r\n * @description performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。\r\n * @description 我们知道Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为两部分：“递”和“归”。\r\n * @description “递”阶段  \r\n * 首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用beginWork方法 (opens new window)。\r\n\r\n该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。\r\n\r\n当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。\r\n * @description “归”阶段\r\n * 在“归”阶段会调用completeWork (opens new window)处理Fiber节点。\r\n\r\n当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。\r\ns\r\n如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。\r\n\r\n“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。\r\n * @param {*} unitOfWork \r\n */\n\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n  let next;\n\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    // console.log(unitOfWork.elementType,\"beginWork\")\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    // 当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。\n    // 如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。\n    // “递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。\n    // console.log(unitOfWork.elementType,\"unitOfWork\")\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n} // effectList 在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为effectList的单向链表中。effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。\n// 形成环状链表的时候会从触发更新的节点向上合并effectList直到rootFiber，这一过程发生在completeUnitOfWork函数中，整个函数的作用就是向上合并effectList\n\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = completedWork.alternate;\n    const returnFiber = completedWork.return; // Check if the work completed or if something threw.\n\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentDebugFiberInDEV(completedWork);\n      let next;\n\n      if (!enableProfilerTimer || (completedWork.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, completedWork, subtreeRenderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n\n      resetCurrentDebugFiberInDEV();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(current, completedWork, subtreeRenderLanes); // Because this fiber did not complete, don't reset its lanes.\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        next.flags &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n\n      if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n\n        let actualDuration = completedWork.actualDuration;\n        let child = completedWork.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      } else {\n        // We've unwound all the way to the root.\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n        return;\n      }\n    }\n\n    const siblingFiber = completedWork.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    } // Otherwise, return to the parent\n\n\n    completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n\n    workInProgress = completedWork;\n  } while (completedWork !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(root, recoverableErrors, transitions) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n} // commit阶段\n// 在commitRootImpl的函数中主要分三个部分：\n// 1. commit阶段前置工作\n// 调用flushPassiveEffects执行完所有effect的任务\n// 初始化相关变量\n// 赋值firstEffect给后面遍历effectList用\n\n\nfunction commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    // 调用flushPassiveEffects执行完所有effect的任务\n    // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  const finishedWork = root.finishedWork;\n  const lanes = root.finishedLanes;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logCommitStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    if (__DEV__) {\n      if (lanes === NoLanes) {\n        console.error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n      }\n    }\n  } // 重置变量 finishedWork指rooFiber\n\n\n  root.finishedWork = null; //重置优先级\n\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n  } // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n  // Scheduler回调函数重置\n\n\n  root.callbackNode = null;\n  root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  markRootFinished(root, remainingLanes); // 重置全局变量\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } else {// This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  } // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n\n\n  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      pendingPassiveEffectsRemainingLanes = remainingLanes; // workInProgressTransitions might be overwritten, so we want\n      // to store it in pendingPassiveTransitions until they get processed\n      // We need to pass this through as an argument to commitRoot\n      // because workInProgressTransitions might have changed between\n      // the previous render and commit if we throttle the commit\n      // with setTimeout\n\n      pendingPassiveTransitions = transitions;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        // 触发useEffect\n        // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\n        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\n        return null;\n      });\n    }\n  } // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n\n\n  const subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n  const rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = null;\n    const previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority); // 将当前上下文标记为CommitContext，作为commit阶段的标志\n\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext; // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    // beforeMutation阶段的主函数\n\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      // Track the root here, rather than in commitLayoutEffects(), because of ref setters.\n      // Updates scheduled during ref detachment should also be flagged.\n      rootCommittingMutationOrLayoutEffects = root;\n    } // The next phase is the mutation phase, where we mutate the host tree.\n\n\n    commitMutationEffects(root, finishedWork, lanes);\n\n    if (enableCreateEventHandleAPI) {\n      if (shouldFireAfterActiveInstanceBlur) {\n        afterActiveInstanceBlur();\n      }\n    }\n\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStarted(lanes);\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStarted(lanes);\n    }\n\n    commitLayoutEffects(finishedWork, root, lanes);\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStopped();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      rootCommittingMutationOrLayoutEffects = null;\n    } // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n\n\n    requestPaint();\n    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n  }\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n    // There were no passive effects, so we can immediately release the cache\n    // pool for this render.\n    releaseRootPooledCache(root, remainingLanes);\n\n    if (__DEV__) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n    }\n  } // Read this again, since an effect might have updated it\n\n\n  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed — that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (__DEV__ && enableStrictEffects) {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root.current, false);\n    }\n  }\n\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  if (__DEV__) {\n    onCommitRootTestSelector();\n  } // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n\n  ensureRootIsScheduled(root, now());\n\n  if (recoverableErrors !== null) {\n    // There were errors during this render, but recovered from them without\n    // needing to surface it to the UI. We log them here.\n    const onRecoverableError = root.onRecoverableError;\n\n    for (let i = 0; i < recoverableErrors.length; i++) {\n      const recoverableError = recoverableErrors[i];\n      onRecoverableError(recoverableError);\n    }\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  } // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n\n\n  if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n    // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\n    flushPassiveEffects();\n  } // Read this again, since a passive effect might have updated it\n\n\n  remainingLanes = root.pendingLanes;\n\n  if (includesSomeLane(remainingLanes, SyncLane)) {\n    if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n      markNestedUpdateScheduled();\n    } // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n\n\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbacks();\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStopped();\n  }\n\n  return null;\n}\n\nfunction releaseRootPooledCache(root, remainingLanes) {\n  if (enableCache) {\n    const pooledCacheLanes = root.pooledCacheLanes &= remainingLanes;\n\n    if (pooledCacheLanes === NoLanes) {\n      // None of the remaining work relies on the cache pool. Clear it so\n      // subsequent requests get a new cache\n      const pooledCache = root.pooledCache;\n\n      if (pooledCache != null) {\n        root.pooledCache = null;\n        releaseCache(pooledCache);\n      }\n    }\n  }\n}\n/**\r\n * 整个useEffect异步调用分为三步：\r\n\r\nbefore mutation阶段在scheduleCallback中调度flushPassiveEffects\r\nlayout阶段之后将effectList赋值给rootWithPendingPassiveEffects\r\nscheduleCallback触发flushPassiveEffects，flushPassiveEffects内部遍历rootWithPendingPassiveEffects\r\n */\n\n/**\r\n * @description effectList中保存了需要执行副作用的Fiber节点。其中副作用包括\r\n\r\n插入DOM节点（Placement）\r\n更新DOM节点（Update）\r\n删除DOM节点（Deletion）\r\n除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。\r\n * @returns \r\n */\n\n\nexport function flushPassiveEffects() {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\n    // flushPassiveEffectsImpl\n    const root = rootWithPendingPassiveEffects; // Cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitRoot\n    // where the remaining lanes are known\n\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = NoLanes;\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    const previousPriority = getCurrentUpdatePriority();\n\n    try {\n      ReactCurrentBatchConfig.transition = null;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n\n  return false;\n}\nexport function enqueuePendingPassiveProfilerEffect(fiber) {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    pendingPassiveProfilerEffects.push(fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        // 触发useEffect\n        // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  } // Cache and clear the transitions flag\n\n\n  const transitions = pendingPassiveTransitions;\n  pendingPassiveTransitions = null;\n  const root = rootWithPendingPassiveEffects;\n  const lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  if (__DEV__) {\n    isFlushingPassiveEffects = true;\n    didScheduleUpdateDuringPassiveEffects = false;\n\n    if (enableDebugTracing) {\n      logPassiveEffectsStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n\n    for (let i = 0; i < profilerEffects.length; i++) {\n      const fiber = profilerEffects[i];\n      commitPassiveEffectDurations(root, fiber);\n    }\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logPassiveEffectsStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStopped();\n  }\n\n  if (__DEV__ && enableStrictEffects) {\n    commitDoubleInvokeEffectsInDEV(root.current, true);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbacks();\n\n  if (enableTransitionTracing) {\n    const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;\n    const prevRootTransitionCallbacks = root.transitionCallbacks;\n\n    if (prevPendingTransitionCallbacks !== null && prevRootTransitionCallbacks !== null) {\n      // TODO(luna) Refactor this code into the Host Config\n      // TODO(luna) The end time here is not necessarily accurate\n      // because passive effects could be called before paint\n      // (synchronously) or after paint (normally). We need\n      // to come up with a way to get the correct end time for both cases.\n      // One solution is in the host config, if the passive effects\n      // have not yet been run, make a call to flush the passive effects\n      // right after paint.\n      const endTime = now();\n      currentPendingTransitionCallbacks = null;\n      scheduleCallback(IdleSchedulerPriority, () => processTransitionCallbacks(prevPendingTransitionCallbacks, endTime, prevRootTransitionCallbacks));\n    }\n  }\n\n  if (__DEV__) {\n    // If additional passive effects were scheduled, increment a counter. If this\n    // exceeds the limit, we'll fire a warning.\n    if (didScheduleUpdateDuringPassiveEffects) {\n      if (root === rootWithPassiveNestedUpdates) {\n        nestedPassiveUpdateCount++;\n      } else {\n        nestedPassiveUpdateCount = 0;\n        rootWithPassiveNestedUpdates = root;\n      }\n    } else {\n      nestedPassiveUpdateCount = 0;\n    }\n\n    isFlushingPassiveEffects = false;\n    didScheduleUpdateDuringPassiveEffects = false;\n  } // TODO: Move to commitPassiveMountEffects\n\n\n  onPostCommitRootDevTools(root);\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nexport function markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n  enqueueUpdate(rootFiber, update, SyncLane);\n  const eventTime = requestEventTime();\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);\n\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n  if (__DEV__) {\n    reportUncaughtErrorInDEV(error);\n    setIsRunningInsertionEffect(false);\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = null;\n\n  if (skipUnmountedBoundaries) {\n    fiber = nearestMountedAncestor;\n  } else {\n    fiber = sourceFiber.return;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n        enqueueUpdate(fiber, update, SyncLane);\n        const eventTime = requestEventTime();\n        const root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);\n\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n\n  if (__DEV__) {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    console.error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error);\n  }\n}\nexport function pingSuspendedRoot(root, wakeable, pingedLanes) {\n  const pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  const eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes, eventTime);\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root.\n      prepareFreshStack(root, NoLanes);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  } // TODO: Special case idle priority?\n\n\n  const eventTime = requestEventTime();\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\n\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber) {\n  const suspenseState = boundaryFiber.memoizedState;\n  let retryLane = NoLane;\n\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nexport function resolveRetryWakeable(boundaryFiber, wakeable) {\n  let retryLane = NoLane; // Default\n\n  let retryCache;\n\n  switch (boundaryFiber.tag) {\n    case SuspenseComponent:\n      retryCache = boundaryFiber.stateNode;\n      const suspenseState = boundaryFiber.memoizedState;\n\n      if (suspenseState !== null) {\n        retryLane = suspenseState.retryLane;\n      }\n\n      break;\n\n    case SuspenseListComponent:\n      retryCache = boundaryFiber.stateNode;\n      break;\n\n    default:\n      throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n      console.error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n  if (__DEV__ && enableStrictEffects) {\n    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n    // Maybe not a big deal since this is DEV only behavior.\n    setCurrentDebugFiberInDEV(fiber);\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n    }\n\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n    }\n\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    let current = firstChild;\n    let subtreeRoot = null;\n\n    while (current !== null) {\n      const primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n\n      if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n        current = current.child;\n      } else {\n        if ((current.flags & fiberFlags) !== NoFlags) {\n          invokeEffectFn(current);\n        }\n\n        if (current.sibling !== null) {\n          current = current.sibling;\n        } else {\n          current = subtreeRoot = current.return;\n        }\n      }\n    }\n  }\n}\n\nlet didWarnStateUpdateForNotYetMountedComponent = null;\n\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    const tag = fiber.tag;\n\n    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    const componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    const previousFiber = ReactCurrentFiberCurrent;\n\n    try {\n      setCurrentDebugFiberInDEV(fiber);\n      console.error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n    } finally {\n      if (previousFiber) {\n        setCurrentDebugFiberInDEV(fiber);\n      } else {\n        resetCurrentDebugFiberInDEV();\n      }\n    }\n  }\n}\n\nlet beginWork;\n\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  const dummyFiber = null;\n  /**\r\n   * @param current 当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate\r\n   * @param workInProgress 当前组件对应的Fiber节点\r\n   * @param lanes 优先级相关\r\n   */\n\n  beginWork = (current, unitOfWork, lanes) => {\n    // mount阶段current上次更新时的节点为null\n    // 组件update时，由于之前已经mount过，所以current !== null。\n    // 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return originalBeginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      } // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n      unwindInterruptedWork(current, unitOfWork, workInProgressRootRenderLanes); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, originalBeginWork, null, current, unitOfWork, lanes);\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n\n        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      } // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\n\n      throw originalError;\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInRenderForAnotherComponent;\n\nif (__DEV__) {\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (ReactCurrentDebugFiberIsRenderingInDEV && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n          {\n            const renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n            const dedupeKey = renderingComponentName;\n\n            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n              const setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n              console.error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n            }\n\n            break;\n          }\n\n        case ClassComponent:\n          {\n            if (!didWarnAboutUpdateInRender) {\n              console.error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n              didWarnAboutUpdateInRender = true;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nexport function restorePendingUpdaters(root, lanes) {\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      const memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(schedulingFiber => {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      }); // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\nconst fakeActCallbackNode = {}; // 用于以某个优先级异步调度一个回调函数。\n\nfunction scheduleCallback(priorityLevel, callback) {\n  if (__DEV__) {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    const actQueue = ReactCurrentActQueue.current;\n\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return Scheduler_scheduleCallback(priorityLevel, callback);\n    }\n  } else {\n    // In production, always call Scheduler. This function will be stripped out.\n    return Scheduler_scheduleCallback(priorityLevel, callback);\n  }\n}\n\nfunction cancelCallback(callbackNode) {\n  if (__DEV__ && callbackNode === fakeActCallbackNode) {\n    return;\n  } // In production, always call Scheduler. This function will be stripped out.\n\n\n  return Scheduler_cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return __DEV__ && ReactCurrentActQueue.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment(fiber)) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n\n      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue.current === null) {\n      const previousFiber = ReactCurrentFiberCurrent;\n\n      try {\n        setCurrentDebugFiberInDEV(fiber);\n        console.error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n      } finally {\n        if (previousFiber) {\n          setCurrentDebugFiberInDEV(fiber);\n        } else {\n          resetCurrentDebugFiberInDEV();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n  if (__DEV__) {\n    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue.current === null) {\n      console.error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');\n    }\n  }\n}\n\nexport function setIsRunningInsertionEffect(isRunning) {\n  if (__DEV__) {\n    isRunningInsertionEffect = isRunning;\n  }\n}","map":{"version":3,"names":["warnAboutDeprecatedLifecycles","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableCreateEventHandleAPI","enableProfilerTimer","enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableProfilerNestedUpdateScheduledHook","deferRenderPhaseUpdateToNextBatch","enableDebugTracing","enableSchedulingProfiler","disableSchedulerTimeoutInWorkLoop","enableStrictEffects","skipUnmountedBoundaries","enableUpdaterTracking","enableCache","enableTransitionTracing","ReactSharedInternals","is","scheduleCallback","Scheduler_scheduleCallback","cancelCallback","Scheduler_cancelCallback","shouldYield","requestPaint","now","ImmediatePriority","ImmediateSchedulerPriority","UserBlockingPriority","UserBlockingSchedulerPriority","NormalPriority","NormalSchedulerPriority","IdlePriority","IdleSchedulerPriority","flushSyncCallbacks","flushSyncCallbacksOnlyInLegacyMode","scheduleSyncCallback","scheduleLegacySyncCallback","logCommitStarted","logCommitStopped","logLayoutEffectsStarted","logLayoutEffectsStopped","logPassiveEffectsStarted","logPassiveEffectsStopped","logRenderStarted","logRenderStopped","resetAfterCommit","scheduleTimeout","cancelTimeout","noTimeout","afterActiveInstanceBlur","getCurrentEventPriority","supportsMicrotasks","errorHydratingContainer","scheduleMicrotask","createWorkInProgress","assignFiberPropertiesInDEV","isRootDehydrated","NoMode","ProfileMode","ConcurrentMode","HostRoot","IndeterminateComponent","ClassComponent","SuspenseComponent","SuspenseListComponent","FunctionComponent","ForwardRef","MemoComponent","SimpleMemoComponent","Profiler","LegacyRoot","NoFlags","Placement","Incomplete","StoreConsistency","HostEffectMask","Hydrating","ForceClientRender","BeforeMutationMask","MutationMask","LayoutMask","PassiveMask","MountPassiveDev","MountLayoutDev","NoLanes","NoLane","SyncLane","NoTimestamp","claimNextTransitionLane","claimNextRetryLane","includesSomeLane","isSubsetOfLanes","mergeLanes","removeLanes","pickArbitraryLane","includesNonIdleWork","includesOnlyRetries","includesOnlyTransitions","includesBlockingLane","includesExpiredLane","getNextLanes","markStarvedLanesAsExpired","getLanesToRetrySynchronouslyOnError","getMostRecentEventTime","markRootUpdated","markRootSuspended","markRootSuspended_dontCallThisOneDirectly","markRootPinged","markRootEntangled","markRootFinished","getHighestPriorityLane","addFiberToLanesMap","movePendingFibersToMemoized","addTransitionToLanesMap","getTransitionsForLanes","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","lowerEventPriority","lanesToEventPriority","requestCurrentTransition","NoTransition","beginWork","originalBeginWork","completeWork","unwindWork","unwindInterruptedWork","throwException","createRootErrorUpdate","createClassErrorUpdate","commitBeforeMutationEffects","commitLayoutEffects","commitMutationEffects","commitPassiveEffectDurations","commitPassiveMountEffects","commitPassiveUnmountEffects","invokeLayoutEffectMountInDEV","invokePassiveEffectMountInDEV","invokeLayoutEffectUnmountInDEV","invokePassiveEffectUnmountInDEV","reportUncaughtErrorInDEV","enqueueUpdate","resetContextDependencies","resetHooksAfterThrow","ContextOnlyDispatcher","getIsUpdatingOpaqueValueInRenderPhaseInDEV","createCapturedValue","push","pushToStack","pop","popFromStack","createCursor","enqueueInterleavedUpdates","hasInterleavedUpdates","markNestedUpdateScheduled","recordCommitTime","resetNestedUpdateFlag","startProfilerTimer","stopProfilerTimerIfRunningAndRecordDelta","syncNestedUpdateFlag","getComponentNameFromFiber","ReactStrictModeWarnings","isRendering","ReactCurrentDebugFiberIsRenderingInDEV","current","ReactCurrentFiberCurrent","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","invokeGuardedCallback","hasCaughtError","clearCaughtError","isDevToolsPresent","markCommitStarted","markCommitStopped","markComponentRenderStopped","markComponentSuspended","markComponentErrored","markLayoutEffectsStarted","markLayoutEffectsStopped","markPassiveEffectsStarted","markPassiveEffectsStopped","markRenderStarted","markRenderYielded","markRenderStopped","onCommitRoot","onCommitRootDevTools","onPostCommitRoot","onPostCommitRootDevTools","onCommitRootTestSelector","releaseCache","isLegacyActEnvironment","isConcurrentActEnvironment","processTransitionCallbacks","ceil","Math","ReactCurrentDispatcher","ReactCurrentOwner","ReactCurrentBatchConfig","ReactCurrentActQueue","NoContext","BatchedContext","RenderContext","CommitContext","RootInProgress","RootFatalErrored","RootErrored","RootSuspended","RootSuspendedWithDelay","RootCompleted","RootDidNotComplete","executionContext","workInProgressRoot","workInProgress","workInProgressRootRenderLanes","subtreeRenderLanes","subtreeRenderLanesCursor","workInProgressRootExitStatus","workInProgressRootFatalError","workInProgressRootIncludedLanes","workInProgressRootSkippedLanes","workInProgressRootInterleavedUpdatedLanes","workInProgressRootRenderPhaseUpdatedLanes","workInProgressRootPingedLanes","workInProgressRootConcurrentErrors","workInProgressRootRecoverableErrors","globalMostRecentFallbackTime","FALLBACK_THROTTLE_MS","workInProgressRootRenderTargetTime","Infinity","RENDER_TIMEOUT_MS","workInProgressTransitions","getWorkInProgressTransitions","currentPendingTransitionCallbacks","addTransitionStartCallbackToPendingTransition","transition","transitionStart","transitionComplete","addTransitionCompleteCallbackToPendingTransition","resetRenderTimer","getRenderTargetTime","hasUncaughtError","firstUncaughtError","legacyErrorBoundariesThatAlreadyFailed","rootCommittingMutationOrLayoutEffects","rootDoesHavePassiveEffects","rootWithPendingPassiveEffects","pendingPassiveEffectsLanes","pendingPassiveProfilerEffects","pendingPassiveEffectsRemainingLanes","pendingPassiveTransitions","NESTED_UPDATE_LIMIT","nestedUpdateCount","rootWithNestedUpdates","isFlushingPassiveEffects","didScheduleUpdateDuringPassiveEffects","NESTED_PASSIVE_UPDATE_LIMIT","nestedPassiveUpdateCount","rootWithPassiveNestedUpdates","currentEventTime","currentEventTransitionLane","isRunningInsertionEffect","getWorkInProgressRoot","requestEventTime","getCurrentTime","requestUpdateLane","fiber","mode","isTransition","__DEV__","_updatedFibers","Set","add","updateLane","eventLane","requestRetryLane","scheduleUpdateOnFiber","lane","eventTime","checkForNestedUpdates","console","error","root","markUpdateLaneFromFiberToRoot","warnAboutRenderPhaseUpdatesInDEV","warnIfUpdatesNotWrappedWithActDEV","tag","id","onNestedUpdateScheduled","memoizedProps","return","startTime","ensureRootIsScheduled","isBatchingLegacy","scheduleInitialHydrationOnRoot","lanes","sourceFiber","log","alternate","flags","warnAboutUpdateOnNotYetMountedFiberInDEV","node","parent","childLanes","stateNode","isInterleavedUpdate","currentTime","existingCallbackNode","callbackNode","nextLanes","callbackPriority","newCallbackPriority","existingCallbackPriority","fakeActCallbackNode","newCallbackNode","didScheduleLegacyUpdate","performSyncWorkOnRoot","bind","schedulerPriorityLevel","performConcurrentWorkOnRoot","didTimeout","Error","originalCallbackNode","didFlushPassiveEffects","flushPassiveEffects","shouldTimeSlice","exitStatus","renderRootConcurrent","renderRootSync","errorRetryLanes","recoverFromConcurrentError","fatalError","prepareFreshStack","renderWasConcurrent","finishedWork","isRenderConsistentWithExternalStores","finishedLanes","finishConcurrentRender","errorsFromFirstAttempt","rootWorkInProgress","containerInfo","errorsFromSecondAttempt","queueRecoverableErrors","errors","apply","commitRoot","shouldForceFlushFallbacksInDEV","msUntilTimeout","suspendedLanes","timeoutHandle","mostRecentEventTime","eventTimeMs","timeElapsedMs","jnd","updateQueue","checks","stores","i","length","check","getSnapshot","renderedValue","value","child","subtreeFlags","sibling","flushRoot","getExecutionContext","deferredUpdates","fn","previousPriority","prevTransition","batchedUpdates","a","prevExecutionContext","discreteUpdates","b","c","d","flushSync","undefined","isAlreadyRendering","flushControlled","pushRenderLanes","popRenderLanes","interruptedWork","discardPendingWarnings","handleError","thrownValue","erroredWork","then","wakeable","completeUnitOfWork","yetAnotherThrownValue","pushDispatcher","prevDispatcher","popDispatcher","markCommitTimeOfFallback","markSkippedUpdateLanes","renderDidSuspend","renderDidSuspendDelayIfPossible","renderDidError","renderHasNotSuspendedYet","memoizedUpdaters","size","restorePendingUpdaters","clear","workLoopSync","performUnitOfWork","workLoopConcurrent","unitOfWork","next","pendingProps","completedWork","returnFiber","actualDuration","deletions","siblingFiber","recoverableErrors","transitions","previousUpdateLanePriority","commitRootImpl","renderPriorityLevel","flushRenderPhaseStrictModeWarningsInDEV","remainingLanes","subtreeHasEffects","rootHasEffect","shouldFireAfterActiveInstanceBlur","rootDidHavePassiveEffects","releaseRootPooledCache","pendingLanes","commitDoubleInvokeEffectsInDEV","onRecoverableError","recoverableError","pooledCacheLanes","pooledCache","renderPriority","priority","flushPassiveEffectsImpl","enqueuePendingPassiveProfilerEffect","profilerEffects","prevPendingTransitionCallbacks","prevRootTransitionCallbacks","transitionCallbacks","endTime","effectDuration","passiveEffectDuration","isAlreadyFailedLegacyErrorBoundary","instance","has","markLegacyErrorBoundaryAsFailed","prepareToThrowUncaughtError","onUncaughtError","captureCommitPhaseErrorOnRoot","rootFiber","errorInfo","update","captureCommitPhaseError","nearestMountedAncestor","setIsRunningInsertionEffect","ctor","type","getDerivedStateFromError","componentDidCatch","pingSuspendedRoot","pingedLanes","pingCache","delete","warnIfSuspenseResolutionNotWrappedWithActDEV","retryTimedOutBoundary","boundaryFiber","retryLane","retryDehydratedSuspenseBoundary","suspenseState","memoizedState","resolveRetryWakeable","retryCache","timeElapsed","flushLegacyContextWarning","flushPendingUnsafeLifecycleWarnings","hasPassiveEffects","invokeEffectsInDev","firstChild","fiberFlags","invokeEffectFn","subtreeRoot","primarySubtreeFlag","didWarnStateUpdateForNotYetMountedComponent","componentName","previousFiber","dummyFiber","originalWorkInProgressCopy","originalError","replayError","_suppressLogging","didWarnAboutUpdateInRender","didWarnAboutUpdateInRenderForAnotherComponent","renderingComponentName","dedupeKey","setStateComponentName","forEach","schedulingFiber","priorityLevel","callback","actQueue","isRunning"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberWorkLoop.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { Wakeable } from 'shared/ReactTypes';\r\nimport type { Fiber, FiberRoot } from './ReactInternalTypes';\r\nimport type { Lanes, Lane } from './ReactFiberLane.old';\r\nimport type { SuspenseState } from './ReactFiberSuspenseComponent.old';\r\nimport type { StackCursor } from './ReactFiberStack.old';\r\nimport type { Flags } from './ReactFiberFlags';\r\nimport type { FunctionComponentUpdateQueue } from './ReactFiberHooks.old';\r\nimport type { EventPriority } from './ReactEventPriorities.old';\r\nimport type {\r\n  PendingTransitionCallbacks,\r\n  TransitionObject,\r\n  Transition,\r\n} from './ReactFiberTracingMarkerComponent.old';\r\n\r\nimport {\r\n  warnAboutDeprecatedLifecycles,\r\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\r\n  enableCreateEventHandleAPI,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableProfilerNestedUpdatePhase,\r\n  enableProfilerNestedUpdateScheduledHook,\r\n  deferRenderPhaseUpdateToNextBatch,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  disableSchedulerTimeoutInWorkLoop,\r\n  enableStrictEffects,\r\n  skipUnmountedBoundaries,\r\n  enableUpdaterTracking,\r\n  enableCache,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport is from 'shared/objectIs';\r\n\r\nimport {\r\n  // Aliased because `act` will override and push to an internal queue\r\n  scheduleCallback as Scheduler_scheduleCallback,\r\n  cancelCallback as Scheduler_cancelCallback,\r\n  shouldYield,\r\n  requestPaint,\r\n  now,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  IdlePriority as IdleSchedulerPriority,\r\n} from './Scheduler';\r\nimport {\r\n  flushSyncCallbacks,\r\n  flushSyncCallbacksOnlyInLegacyMode,\r\n  scheduleSyncCallback,\r\n  scheduleLegacySyncCallback,\r\n} from './ReactFiberSyncTaskQueue.old';\r\nimport {\r\n  logCommitStarted,\r\n  logCommitStopped,\r\n  logLayoutEffectsStarted,\r\n  logLayoutEffectsStopped,\r\n  logPassiveEffectsStarted,\r\n  logPassiveEffectsStopped,\r\n  logRenderStarted,\r\n  logRenderStopped,\r\n} from './DebugTracing';\r\n\r\nimport {\r\n  resetAfterCommit,\r\n  scheduleTimeout,\r\n  cancelTimeout,\r\n  noTimeout,\r\n  afterActiveInstanceBlur,\r\n  getCurrentEventPriority,\r\n  supportsMicrotasks,\r\n  errorHydratingContainer,\r\n  scheduleMicrotask,\r\n} from './ReactFiberHostConfig';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  assignFiberPropertiesInDEV,\r\n} from './ReactFiber.old';\r\nimport { isRootDehydrated } from './ReactFiberShellHydration';\r\nimport { NoMode, ProfileMode, ConcurrentMode } from './ReactTypeOfMode';\r\nimport {\r\n  HostRoot,\r\n  IndeterminateComponent,\r\n  ClassComponent,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  Profiler,\r\n} from './ReactWorkTags';\r\nimport { LegacyRoot } from './ReactRootTags';\r\nimport {\r\n  NoFlags,\r\n  Placement,\r\n  Incomplete,\r\n  StoreConsistency,\r\n  HostEffectMask,\r\n  Hydrating,\r\n  ForceClientRender,\r\n  BeforeMutationMask,\r\n  MutationMask,\r\n  LayoutMask,\r\n  PassiveMask,\r\n  MountPassiveDev,\r\n  MountLayoutDev,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  NoLanes,\r\n  NoLane,\r\n  SyncLane,\r\n  NoTimestamp,\r\n  claimNextTransitionLane,\r\n  claimNextRetryLane,\r\n  includesSomeLane,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  removeLanes,\r\n  pickArbitraryLane,\r\n  includesNonIdleWork,\r\n  includesOnlyRetries,\r\n  includesOnlyTransitions,\r\n  includesBlockingLane,\r\n  includesExpiredLane,\r\n  getNextLanes,\r\n  markStarvedLanesAsExpired,\r\n  getLanesToRetrySynchronouslyOnError,\r\n  getMostRecentEventTime,\r\n  markRootUpdated,\r\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\r\n  markRootPinged,\r\n  markRootEntangled,\r\n  markRootFinished,\r\n  getHighestPriorityLane,\r\n  addFiberToLanesMap,\r\n  movePendingFibersToMemoized,\r\n  addTransitionToLanesMap,\r\n  getTransitionsForLanes,\r\n} from './ReactFiberLane.old';\r\nimport {\r\n  DiscreteEventPriority,\r\n  ContinuousEventPriority,\r\n  DefaultEventPriority,\r\n  IdleEventPriority,\r\n  getCurrentUpdatePriority,\r\n  setCurrentUpdatePriority,\r\n  lowerEventPriority,\r\n  lanesToEventPriority,\r\n} from './ReactEventPriorities.old';\r\nimport { requestCurrentTransition, NoTransition } from './ReactFiberTransition';\r\nimport { beginWork as originalBeginWork } from './ReactFiberBeginWork.old';\r\nimport { completeWork } from './ReactFiberCompleteWork.old';\r\nimport { unwindWork, unwindInterruptedWork } from './ReactFiberUnwindWork.old';\r\nimport {\r\n  throwException,\r\n  createRootErrorUpdate,\r\n  createClassErrorUpdate,\r\n} from './ReactFiberThrow.old';\r\nimport {\r\n  commitBeforeMutationEffects,\r\n  commitLayoutEffects,\r\n  commitMutationEffects,\r\n  commitPassiveEffectDurations,\r\n  commitPassiveMountEffects,\r\n  commitPassiveUnmountEffects,\r\n  invokeLayoutEffectMountInDEV,\r\n  invokePassiveEffectMountInDEV,\r\n  invokeLayoutEffectUnmountInDEV,\r\n  invokePassiveEffectUnmountInDEV,\r\n  reportUncaughtErrorInDEV,\r\n} from './ReactFiberCommitWork.old';\r\nimport { enqueueUpdate } from './ReactUpdateQueue.old';\r\nimport { resetContextDependencies } from './ReactFiberNewContext.old';\r\nimport {\r\n  resetHooksAfterThrow,\r\n  ContextOnlyDispatcher,\r\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\r\n} from './ReactFiberHooks.old';\r\nimport { createCapturedValue } from './ReactCapturedValue';\r\nimport {\r\n  push as pushToStack,\r\n  pop as popFromStack,\r\n  createCursor,\r\n} from './ReactFiberStack.old';\r\nimport {\r\n  enqueueInterleavedUpdates,\r\n  hasInterleavedUpdates,\r\n} from './ReactFiberInterleavedUpdates.old';\r\n\r\nimport {\r\n  markNestedUpdateScheduled,\r\n  recordCommitTime,\r\n  resetNestedUpdateFlag,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n  syncNestedUpdateFlag,\r\n} from './ReactProfilerTimer.old';\r\n\r\n// DEV stuff\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport {\r\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  invokeGuardedCallback,\r\n  hasCaughtError,\r\n  clearCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {\r\n  isDevToolsPresent,\r\n  markCommitStarted,\r\n  markCommitStopped,\r\n  markComponentRenderStopped,\r\n  markComponentSuspended,\r\n  markComponentErrored,\r\n  markLayoutEffectsStarted,\r\n  markLayoutEffectsStopped,\r\n  markPassiveEffectsStarted,\r\n  markPassiveEffectsStopped,\r\n  markRenderStarted,\r\n  markRenderYielded,\r\n  markRenderStopped,\r\n  onCommitRoot as onCommitRootDevTools,\r\n  onPostCommitRoot as onPostCommitRootDevTools,\r\n} from './ReactFiberDevToolsHook.old';\r\nimport { onCommitRoot as onCommitRootTestSelector } from './ReactTestSelectors';\r\nimport { releaseCache } from './ReactFiberCacheComponent.old';\r\nimport {\r\n  isLegacyActEnvironment,\r\n  isConcurrentActEnvironment,\r\n} from './ReactFiberAct.old';\r\nimport { processTransitionCallbacks } from './ReactFiberTracingMarkerComponent.old';\r\n\r\nconst ceil = Math.ceil;\r\n\r\nconst {\r\n  ReactCurrentDispatcher,\r\n  ReactCurrentOwner,\r\n  ReactCurrentBatchConfig,\r\n  ReactCurrentActQueue,\r\n} = ReactSharedInternals;\r\n\r\ntype ExecutionContext = number;\r\n\r\nexport const NoContext = /*             */ 0b000;\r\nconst BatchedContext = /*               */ 0b001;\r\nconst RenderContext = /*                */ 0b010;\r\nconst CommitContext = /*                */ 0b100;\r\n\r\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5 | 6;\r\nconst RootInProgress = 0;\r\nconst RootFatalErrored = 1;\r\nconst RootErrored = 2;\r\nconst RootSuspended = 3;\r\nconst RootSuspendedWithDelay = 4;\r\nconst RootCompleted = 5;\r\nconst RootDidNotComplete = 6;\r\n\r\n// Describes where we are in the React execution stack\r\nlet executionContext: ExecutionContext = NoContext;\r\n// The root we're working on\r\nlet workInProgressRoot: FiberRoot | null = null;\r\n// The fiber we're working on\r\nlet workInProgress: Fiber | null = null;\r\n// The lanes we're rendering\r\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\r\n\r\n// Stack that allows components to change the render lanes for its subtree\r\n// This is a superset of the lanes we started working on at the root. The only\r\n// case where it's different from `workInProgressRootRenderLanes` is when we\r\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n// Offscreen component.\r\n//\r\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\r\nexport let subtreeRenderLanes: Lanes = NoLanes;\r\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\r\n\r\n// Whether to root completed, errored, suspended, etc.\r\nlet workInProgressRootExitStatus: RootExitStatus = RootInProgress;\r\n// A fatal error, if one is thrown\r\nlet workInProgressRootFatalError: mixed = null;\r\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n// slightly different than `renderLanes` because `renderLanes` can change as you\r\n// enter and exit an Offscreen tree. This value is the combination of all render\r\n// lanes for the entire render phase.\r\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\r\n// The work left over by components that were visited during this render. Only\r\n// includes unprocessed updates, not work in bailed out children.\r\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\r\n// Lanes that were updated (in an interleaved event) during this render.\r\nlet workInProgressRootInterleavedUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were updated during the render phase (*not* an interleaved event).\r\nlet workInProgressRootRenderPhaseUpdatedLanes: Lanes = NoLanes;\r\n// Lanes that were pinged (in an interleaved event) during this render.\r\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\r\n// Errors that are thrown during the render phase.\r\nlet workInProgressRootConcurrentErrors: Array<mixed> | null = null;\r\n// These are errors that we recovered from without surfacing them to the UI.\r\n// We will log them once the tree commits.\r\nlet workInProgressRootRecoverableErrors: Array<mixed> | null = null;\r\n\r\n// The most recent time we committed a fallback. This lets us ensure a train\r\n// model where we don't commit new loading states in too quick succession.\r\nlet globalMostRecentFallbackTime: number = 0;\r\nconst FALLBACK_THROTTLE_MS: number = 500;\r\n\r\n// The absolute time for when we should start giving up on rendering\r\n// more and prefer CPU suspense heuristics instead.\r\nlet workInProgressRootRenderTargetTime: number = Infinity;\r\n// How long a render is supposed to take before we start following CPU\r\n// suspense heuristics and opt out of rendering more content.\r\nconst RENDER_TIMEOUT_MS = 500;\r\n\r\nlet workInProgressTransitions: Array<Transition> | null = null;\r\nexport function getWorkInProgressTransitions () {\r\n  return workInProgressTransitions;\r\n}\r\n\r\nlet currentPendingTransitionCallbacks: PendingTransitionCallbacks | null = null;\r\n\r\nexport function addTransitionStartCallbackToPendingTransition (\r\n  transition: TransitionObject,\r\n) {\r\n  if (enableTransitionTracing) {\r\n    if (currentPendingTransitionCallbacks === null) {\r\n      currentPendingTransitionCallbacks = {\r\n        transitionStart: [],\r\n        transitionComplete: null,\r\n      };\r\n    }\r\n\r\n    if (currentPendingTransitionCallbacks.transitionStart === null) {\r\n      currentPendingTransitionCallbacks.transitionStart = [];\r\n    }\r\n\r\n    currentPendingTransitionCallbacks.transitionStart.push(transition);\r\n  }\r\n}\r\n\r\nexport function addTransitionCompleteCallbackToPendingTransition (\r\n  transition: TransitionObject,\r\n) {\r\n  if (enableTransitionTracing) {\r\n    if (currentPendingTransitionCallbacks === null) {\r\n      currentPendingTransitionCallbacks = {\r\n        transitionStart: null,\r\n        transitionComplete: [],\r\n      };\r\n    }\r\n\r\n    if (currentPendingTransitionCallbacks.transitionComplete === null) {\r\n      currentPendingTransitionCallbacks.transitionComplete = [];\r\n    }\r\n\r\n    currentPendingTransitionCallbacks.transitionComplete.push(transition);\r\n  }\r\n}\r\n\r\nfunction resetRenderTimer () {\r\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n}\r\n\r\nexport function getRenderTargetTime (): number {\r\n  return workInProgressRootRenderTargetTime;\r\n}\r\n\r\nlet hasUncaughtError = false;\r\nlet firstUncaughtError = null;\r\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\r\n\r\n// Only used when enableProfilerNestedUpdateScheduledHook is true;\r\n// to track which root is currently committing layout effects.\r\nlet rootCommittingMutationOrLayoutEffects: FiberRoot | null = null;\r\n\r\nlet rootDoesHavePassiveEffects: boolean = false;\r\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\r\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\r\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\r\nlet pendingPassiveEffectsRemainingLanes: Lanes = NoLanes;\r\nlet pendingPassiveTransitions: Array<Transition> | null = null;\r\n\r\n// Use these to prevent an infinite loop of nested updates\r\nconst NESTED_UPDATE_LIMIT = 50;\r\nlet nestedUpdateCount: number = 0;\r\nlet rootWithNestedUpdates: FiberRoot | null = null;\r\nlet isFlushingPassiveEffects = false;\r\nlet didScheduleUpdateDuringPassiveEffects = false;\r\n\r\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\nlet nestedPassiveUpdateCount: number = 0;\r\nlet rootWithPassiveNestedUpdates: FiberRoot | null = null;\r\n\r\n// If two updates are scheduled within the same event, we should treat their\r\n// event times as simultaneous, even if the actual clock time has advanced\r\n// between the first and second call.\r\nlet currentEventTime: number = NoTimestamp;\r\nlet currentEventTransitionLane: Lanes = NoLanes;\r\n\r\nlet isRunningInsertionEffect = false;\r\n\r\nexport function getWorkInProgressRoot (): FiberRoot | null {\r\n  return workInProgressRoot;\r\n}\r\n\r\nexport function requestEventTime () {\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    // We're inside React, so it's fine to read the actual time.\r\n    return now();\r\n  }\r\n  // We're not inside React, so we may be in the middle of a browser event.\r\n  if (currentEventTime !== NoTimestamp) {\r\n    // Use the same start time for all updates until we enter React again.\r\n    return currentEventTime;\r\n  }\r\n  // This is the first update since React yielded. Compute a new start time.\r\n  currentEventTime = now();\r\n  return currentEventTime;\r\n}\r\n\r\nexport function getCurrentTime () {\r\n  return now();\r\n}\r\n\r\nexport function requestUpdateLane (fiber: Fiber): Lane {\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & ConcurrentMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  } else if (\r\n    !deferRenderPhaseUpdateToNextBatch &&\r\n    (executionContext & RenderContext) !== NoContext &&\r\n    workInProgressRootRenderLanes !== NoLanes\r\n  ) {\r\n    // This is a render phase update. These are not officially supported. The\r\n    // old behavior is to give this the same \"thread\" (lanes) as\r\n    // whatever is currently rendering. So if you call `setState` on a component\r\n    // that happens later in the same render, it will flush. Ideally, we want to\r\n    // remove the special case and treat them as if they came from an\r\n    // interleaved event. Regardless, this pattern is not officially supported.\r\n    // This behavior is only a fallback. The flag only exists until we can roll\r\n    // out the setState warning, since existing code might accidentally rely on\r\n    // the current behavior.\r\n    return pickArbitraryLane(workInProgressRootRenderLanes);\r\n  }\r\n  const isTransition = requestCurrentTransition() !== NoTransition;\r\n  if (isTransition) {\r\n    if (__DEV__ && ReactCurrentBatchConfig.transition !== null) {\r\n      const transition = ReactCurrentBatchConfig.transition;\r\n      if (!transition._updatedFibers) {\r\n        transition._updatedFibers = new Set();\r\n      }\r\n\r\n      transition._updatedFibers.add(fiber);\r\n    }\r\n    // The algorithm for assigning an update to a lane should be stable for all\r\n    // updates at the same priority within the same event. To do this, the\r\n    // inputs to the algorithm must be the same.\r\n    //\r\n    // The trick we use is to cache the first of each of these inputs within an\r\n    // event. Then reset the cached values once we can be sure the event is\r\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\r\n    if (currentEventTransitionLane === NoLane) {\r\n      // All transitions within the same event are assigned the same lane.\r\n      currentEventTransitionLane = claimNextTransitionLane();\r\n    }\r\n    return currentEventTransitionLane;\r\n  }\r\n\r\n  // Updates originating inside certain React methods, like flushSync, have\r\n  // their priority set by tracking it with a context variable.\r\n  //\r\n  // The opaque type returned by the host config is internally a lane, so we can\r\n  // use that directly.\r\n  // TODO: Move this type conversion to the event priority module.\r\n  const updateLane: Lane = (getCurrentUpdatePriority(): any);\r\n  if (updateLane !== NoLane) {\r\n    return updateLane;\r\n  }\r\n\r\n  // This update originated outside React. Ask the host environment for an\r\n  // appropriate priority, based on the type of event.\r\n  //\r\n  // The opaque type returned by the host config is internally a lane, so we can\r\n  // use that directly.\r\n  // TODO: Move this type conversion to the event priority module.\r\n\r\n  const eventLane: Lane = (getCurrentEventPriority(): any);\r\n  return eventLane;\r\n}\r\n\r\nfunction requestRetryLane (fiber: Fiber) {\r\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n  // from its placeholder state to its primary/resolved state.\r\n\r\n  // Special cases\r\n  const mode = fiber.mode;\r\n  if ((mode & ConcurrentMode) === NoMode) {\r\n    return (SyncLane: Lane);\r\n  }\r\n\r\n  return claimNextRetryLane();\r\n}\r\n\r\n/**\r\n * @description 在fiber上调度update\r\n * @param {*} fiber \r\n * @param {*} lane \r\n * @param {*} eventTime \r\n * @returns \r\n */\r\nexport function scheduleUpdateOnFiber (\r\n  fiber: Fiber,\r\n  lane: Lane,\r\n  eventTime: number,\r\n): FiberRoot | null {\r\n  // 检查更新是否符合规则\r\n  checkForNestedUpdates();\r\n  if (__DEV__) {\r\n    if (isRunningInsertionEffect) {\r\n      console.error('useInsertionEffect must not schedule updates.');\r\n    }\r\n  }\r\n\r\n  // \r\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n  // console.log(root)\r\n  if (root === null) {\r\n    return null;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (isFlushingPassiveEffects) {\r\n      didScheduleUpdateDuringPassiveEffects = true;\r\n    }\r\n  }\r\n\r\n  // Mark that the root has a pending update.\r\n  markRootUpdated(root, lane, eventTime);\r\n\r\n  if (\r\n    (executionContext & RenderContext) !== NoLanes &&\r\n    root === workInProgressRoot\r\n  ) {\r\n    // This update was dispatched during the render phase. This is a mistake\r\n    // if the update originates from user space (with the exception of local\r\n    // hook updates, which are handled differently and don't reach this\r\n    // function), but there are some internal React features that use this as\r\n    // an implementation detail, like selective hydration.\r\n    warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n\r\n    // Track lanes that were updated during the render phase\r\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\r\n      workInProgressRootRenderPhaseUpdatedLanes,\r\n      lane,\r\n    );\r\n  } else {\r\n    // This is a normal update, scheduled from outside the render phase. For\r\n    // example, during an input event.\r\n    if (enableUpdaterTracking) {\r\n      if (isDevToolsPresent) {\r\n        addFiberToLanesMap(root, fiber, lane);\r\n      }\r\n    }\r\n\r\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\r\n\r\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\r\n      if (\r\n        (executionContext & CommitContext) !== NoContext &&\r\n        root === rootCommittingMutationOrLayoutEffects\r\n      ) {\r\n        if (fiber.mode & ProfileMode) {\r\n          let current = fiber;\r\n          while (current !== null) {\r\n            if (current.tag === Profiler) {\r\n              const { id, onNestedUpdateScheduled } = current.memoizedProps;\r\n              if (typeof onNestedUpdateScheduled === 'function') {\r\n                onNestedUpdateScheduled(id);\r\n              }\r\n            }\r\n            current = current.return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (enableTransitionTracing) {\r\n      const transition = ReactCurrentBatchConfig.transition;\r\n      if (transition !== null) {\r\n        if (transition.startTime === -1) {\r\n          transition.startTime = now();\r\n        }\r\n\r\n        addTransitionToLanesMap(root, transition, lane);\r\n      }\r\n    }\r\n\r\n    if (root === workInProgressRoot) {\r\n      // TODO: Consolidate with `isInterleavedUpdate` check\r\n\r\n      // Received an update to a tree that's in the middle of rendering. Mark\r\n      // that there was an interleaved update work on this root. Unless the\r\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n      // phase update. In that case, we don't treat render phase updates as if\r\n      // they were interleaved, for backwards compat reasons.\r\n      if (\r\n        deferRenderPhaseUpdateToNextBatch ||\r\n        (executionContext & RenderContext) === NoContext\r\n      ) {\r\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(\r\n          workInProgressRootInterleavedUpdatedLanes,\r\n          lane,\r\n        );\r\n      }\r\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n        // The root already suspended with a delay, which means this render\r\n        // definitely won't finish. Since we have a new update, let's mark it as\r\n        // suspended now, right before marking the incoming update. This has the\r\n        // effect of interrupting the current render and switching to the update.\r\n        // TODO: Make sure this doesn't override pings that happen while we've\r\n        // already started rendering.\r\n        markRootSuspended(root, workInProgressRootRenderLanes);\r\n      }\r\n    }\r\n\r\n    ensureRootIsScheduled(root, eventTime);\r\n    if (\r\n      lane === SyncLane &&\r\n      executionContext === NoContext &&\r\n      (fiber.mode & ConcurrentMode) === NoMode &&\r\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\r\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\r\n    ) {\r\n      // Flush the synchronous work now, unless we're already working or inside\r\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n      // without immediately flushing it. We only do this for user-initiated\r\n      // updates, to preserve historical behavior of legacy mode.\r\n      resetRenderTimer();\r\n      flushSyncCallbacksOnlyInLegacyMode();\r\n    }\r\n  }\r\n  return root;\r\n}\r\n\r\nexport function scheduleInitialHydrationOnRoot (\r\n  root: FiberRoot,\r\n  lane: Lane,\r\n  eventTime: number,\r\n) {\r\n  // This is a special fork of scheduleUpdateOnFiber that is only used to\r\n  // schedule the initial hydration of a root that has just been created. Most\r\n  // of the stuff in scheduleUpdateOnFiber can be skipped.\r\n  //\r\n  // The main reason for this separate path, though, is to distinguish the\r\n  // initial children from subsequent updates. In fully client-rendered roots\r\n  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\r\n  // updates, but hydration roots are special because the initial render must\r\n  // match what was rendered on the server.\r\n  const current = root.current;\r\n  current.lanes = lane;\r\n  markRootUpdated(root, lane, eventTime);\r\n  ensureRootIsScheduled(root, eventTime);\r\n}\r\n\r\n// This is split into a separate function so we can mark a fiber with pending\r\n// work without treating it as a typical update that originates from an event;\r\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n// on a fiber.\r\n\r\n// 从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber\r\nfunction markUpdateLaneFromFiberToRoot (\r\n  sourceFiber: Fiber,\r\n  lane: Lane,\r\n): FiberRoot | null {\r\n  // Update the source fiber's lanes\r\n  console.log(sourceFiber.lanes)\r\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n  console.log(sourceFiber.lanes)\r\n\r\n  let alternate = sourceFiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      alternate === null &&\r\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\r\n    ) {\r\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n    }\r\n  }\r\n  // Walk the parent path to the root and update the child lanes.\r\n  let node = sourceFiber;\r\n  let parent = sourceFiber.return;\r\n  while (parent !== null) {\r\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n    alternate = parent.alternate;\r\n    if (alternate !== null) {\r\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n    } else {\r\n      if (__DEV__) {\r\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n        }\r\n      }\r\n    }\r\n    node = parent;\r\n    parent = parent.return;\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    const root: FiberRoot = node.stateNode;\r\n    return root;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function isInterleavedUpdate (fiber: Fiber, lane: Lane) {\r\n  // workInProgressRoot为空的话就代表是mount阶段\r\n  return (\r\n    // TODO: Optimize slightly by comparing to root that fiber belongs to.\r\n    // Requires some refactoring. Not a big deal though since it's rare for\r\n    // concurrent apps to have more than a single root.\r\n    (workInProgressRoot !== null ||\r\n      // If the interleaved updates queue hasn't been cleared yet, then\r\n      // we should treat this as an interleaved update, too. This is also a\r\n      // defensive coding measure in case a new update comes in between when\r\n      // rendering has finished and when the interleaved updates are transferred\r\n      // to the main queue.\r\n      hasInterleavedUpdates()) &&\r\n    (fiber.mode & ConcurrentMode) !== NoMode &&\r\n    // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\r\n    // then don't treat this as an interleaved update. This pattern is\r\n    // accompanied by a warning but we haven't fully deprecated it yet. We can\r\n    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\r\n    (deferRenderPhaseUpdateToNextBatch ||\r\n      (executionContext & RenderContext) === NoContext)\r\n  );\r\n}\r\n\r\n// Use this function to schedule a task for a root. There's only one task per\r\n// root; if a task was already scheduled, we'll check to make sure the priority\r\n// of the existing task is the same as the priority of the next level that the\r\n// root has work on. This function is called on every update, and right before\r\n// exiting a task.\r\n/**\r\n * @description 通知Scheduler根据更新的优先级，决定以同步还是异步的方式调度本次更新。\r\n * @param {*} root \r\n * @param {*} currentTime \r\n * @returns \r\n */\r\nfunction ensureRootIsScheduled (root: FiberRoot, currentTime: number) {\r\n  const existingCallbackNode = root.callbackNode;\r\n\r\n  // Check if any lanes are being starved by other work. If so, mark them as\r\n  // expired so we know to work on those next.\r\n  markStarvedLanesAsExpired(root, currentTime);\r\n\r\n  // Determine the next lanes to work on, and their priority.\r\n  const nextLanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  ); //计算nextLanes\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // Special case: There's nothing to work on.\r\n    if (existingCallbackNode !== null) {\r\n      cancelCallback(existingCallbackNode);\r\n    }\r\n    root.callbackNode = null;\r\n    root.callbackPriority = NoLane;\r\n    return;\r\n  }\r\n\r\n  // We use the highest priority lane to represent the priority of the callback.\r\n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\r\n\r\n  // Check if there's an existing task. We may be able to reuse it.\r\n  const existingCallbackPriority = root.callbackPriority;\r\n  if (\r\n    existingCallbackPriority === newCallbackPriority &&\r\n    // Special case related to `act`. If the currently scheduled task is a\r\n    // Scheduler task, rather than an `act` task, cancel it and re-scheduled\r\n    // on the `act` queue.\r\n    !(\r\n      __DEV__ &&\r\n      ReactCurrentActQueue.current !== null &&\r\n      existingCallbackNode !== fakeActCallbackNode\r\n    )\r\n  ) {\r\n    if (__DEV__) {\r\n      // If we're going to re-use an existing task, it needs to exist.\r\n      // Assume that discrete update microtasks are non-cancellable and null.\r\n      // TODO: Temporary until we confirm this warning is not fired.\r\n      if (\r\n        existingCallbackNode == null &&\r\n        existingCallbackPriority !== SyncLane\r\n      ) {\r\n        console.error(\r\n          'Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.',\r\n        );\r\n      }\r\n    }\r\n    // The priority hasn't changed. We can reuse the existing task. Exit.\r\n    return;\r\n  }\r\n\r\n  if (existingCallbackNode != null) {\r\n    // Cancel the existing callback. We'll schedule a new one below.\r\n    cancelCallback(existingCallbackNode);\r\n  }\r\n\r\n  // Schedule a new callback.\r\n  let newCallbackNode;\r\n  if (newCallbackPriority === SyncLane) {\r\n    // Special case: Sync React callbacks are scheduled on a special\r\n    // internal queue\r\n    if (root.tag === LegacyRoot) {\r\n      if (__DEV__ && ReactCurrentActQueue.isBatchingLegacy !== null) {\r\n        ReactCurrentActQueue.didScheduleLegacyUpdate = true;\r\n      }\r\n      // 进入render阶段和commit阶段\r\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\r\n    } else {\r\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\r\n    }\r\n    if (supportsMicrotasks) {\r\n      // Flush the queue in a microtask.\r\n      if (__DEV__ && ReactCurrentActQueue.current !== null) {\r\n        // Inside `act`, use our internal `act` queue so that these get flushed\r\n        // at the end of the current scope even when using the sync version\r\n        // of `act`.\r\n        ReactCurrentActQueue.current.push(flushSyncCallbacks);\r\n      } else {\r\n        scheduleMicrotask(() => {\r\n          // In Safari, appending an iframe forces microtasks to run.\r\n          // https://github.com/facebook/react/issues/22459\r\n          // We don't support running callbacks in the middle of render\r\n          // or commit so we need to check against that.\r\n          if (executionContext === NoContext) {\r\n            // It's only safe to do this conditionally because we always\r\n            // check for pending work before we exit the task.\r\n            flushSyncCallbacks();\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      // Flush the queue in an Immediate task.\r\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\r\n    }\r\n    newCallbackNode = null;\r\n  } else {\r\n    //将lane的优先级转换成schduler的优先级\r\n    let schedulerPriorityLevel;\r\n    switch (lanesToEventPriority(nextLanes)) {\r\n      case DiscreteEventPriority:\r\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\r\n        break;\r\n      case ContinuousEventPriority:\r\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\r\n        break;\r\n      case DefaultEventPriority:\r\n        schedulerPriorityLevel = NormalSchedulerPriority;\r\n        break;\r\n      case IdleEventPriority:\r\n        schedulerPriorityLevel = IdleSchedulerPriority;\r\n        break;\r\n      default:\r\n        schedulerPriorityLevel = NormalSchedulerPriority;\r\n        break;\r\n    }\r\n    //以schedulerPriorityLevel的优先级执行performConcurrentWorkOnRoot 也就是concurrent模式的起点\r\n    newCallbackNode = scheduleCallback(\r\n      schedulerPriorityLevel,\r\n      performConcurrentWorkOnRoot.bind(null, root),\r\n    );\r\n  }\r\n\r\n  root.callbackPriority = newCallbackPriority;\r\n  root.callbackNode = newCallbackNode;\r\n}\r\n\r\n// This is the entry point for every concurrent task, i.e. anything that\r\n// goes through Scheduler.\r\n// render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。\r\n// 最终调用workLoopConcurrent实现时间切片\r\nfunction performConcurrentWorkOnRoot (root, didTimeout) {\r\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\r\n    resetNestedUpdateFlag();\r\n  }\r\n\r\n  // Since we know we're in a React event, we can clear the current\r\n  // event time. The next update will compute a new event time.\r\n  currentEventTime = NoTimestamp;\r\n  currentEventTransitionLane = NoLanes;\r\n\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    throw new Error('Should not already be working.');\r\n  }\r\n\r\n  // Flush any pending passive effects before deciding which lanes to work on,\r\n  // in case they schedule additional work.\r\n  const originalCallbackNode = root.callbackNode;\r\n  const didFlushPassiveEffects = flushPassiveEffects();\r\n  if (didFlushPassiveEffects) {\r\n    // Something in the passive effect phase may have canceled the current task.\r\n    // Check if the task node for this root was changed.\r\n    if (root.callbackNode !== originalCallbackNode) {\r\n      // The current task was canceled. Exit. We don't need to call\r\n      // `ensureRootIsScheduled` because the check above implies either that\r\n      // there's a new task, or that there's no remaining work on this root.\r\n      return null;\r\n    } else {\r\n      // Current task was not canceled. Continue.\r\n    }\r\n  }\r\n\r\n  // Determine the next lanes to work on, using the fields stored\r\n  // on the root.\r\n  let lanes = getNextLanes(\r\n    root,\r\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\r\n  );\r\n  if (lanes === NoLanes) {\r\n    // Defensive coding. This is never expected to happen.\r\n    return null;\r\n  }\r\n\r\n  // We disable time-slicing in some cases: if the work has been CPU-bound\r\n  // for too long (\"expired\" work, to prevent starvation), or we're in\r\n  // sync-updates-by-default mode.\r\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\r\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\r\n  // we can remove this, since we track expiration ourselves.\r\n  const shouldTimeSlice =\r\n    !includesBlockingLane(root, lanes) &&\r\n    !includesExpiredLane(root, lanes) &&\r\n    (disableSchedulerTimeoutInWorkLoop || !didTimeout);\r\n  let exitStatus = shouldTimeSlice\r\n    ? renderRootConcurrent(root, lanes)\r\n    : renderRootSync(root, lanes);\r\n  if (exitStatus !== RootInProgress) {\r\n    if (exitStatus === RootErrored) {\r\n      // If something threw an error, try rendering one more time. We'll\r\n      // render synchronously to block concurrent data mutations, and we'll\r\n      // includes all pending updates are included. If it still fails after\r\n      // the second attempt, we'll give up and commit the resulting tree.\r\n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\r\n      if (errorRetryLanes !== NoLanes) {\r\n        lanes = errorRetryLanes;\r\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\r\n      }\r\n    }\r\n    if (exitStatus === RootFatalErrored) {\r\n      const fatalError = workInProgressRootFatalError;\r\n      prepareFreshStack(root, NoLanes);\r\n      markRootSuspended(root, lanes);\r\n      ensureRootIsScheduled(root, now());\r\n      throw fatalError;\r\n    }\r\n\r\n    if (exitStatus === RootDidNotComplete) {\r\n      // The render unwound without completing the tree. This happens in special\r\n      // cases where need to exit the current render without producing a\r\n      // consistent tree or committing.\r\n      //\r\n      // This should only happen during a concurrent render, not a discrete or\r\n      // synchronous update. We should have already checked for this when we\r\n      // unwound the stack.\r\n      markRootSuspended(root, lanes);\r\n    } else {\r\n      // The render completed.\r\n\r\n      // Check if this render may have yielded to a concurrent event, and if so,\r\n      // confirm that any newly rendered stores are consistent.\r\n      // TODO: It's possible that even a concurrent render may never have yielded\r\n      // to the main thread, if it was fast enough, or if it expired. We could\r\n      // skip the consistency check in that case, too.\r\n      const renderWasConcurrent = !includesBlockingLane(root, lanes);\r\n      const finishedWork: Fiber = (root.current.alternate: any);\r\n      if (\r\n        renderWasConcurrent &&\r\n        !isRenderConsistentWithExternalStores(finishedWork)\r\n      ) {\r\n        // A store was mutated in an interleaved event. Render again,\r\n        // synchronously, to block further mutations.\r\n        exitStatus = renderRootSync(root, lanes);\r\n\r\n        // We need to check again if something threw\r\n        if (exitStatus === RootErrored) {\r\n          const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\r\n          if (errorRetryLanes !== NoLanes) {\r\n            lanes = errorRetryLanes;\r\n            exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\r\n            // We assume the tree is now consistent because we didn't yield to any\r\n            // concurrent events.\r\n          }\r\n        }\r\n        if (exitStatus === RootFatalErrored) {\r\n          const fatalError = workInProgressRootFatalError;\r\n          prepareFreshStack(root, NoLanes);\r\n          markRootSuspended(root, lanes);\r\n          ensureRootIsScheduled(root, now());\r\n          throw fatalError;\r\n        }\r\n      }\r\n\r\n      // We now have a consistent tree. The next step is either to commit it,\r\n      // or, if something suspended, wait to commit it after a timeout.\r\n      root.finishedWork = finishedWork;\r\n      root.finishedLanes = lanes;\r\n      finishConcurrentRender(root, exitStatus, lanes);\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, now());\r\n  if (root.callbackNode === originalCallbackNode) {\r\n    // The task node scheduled for this root is the same one that's\r\n    // currently executed. Need to return a continuation.\r\n    return performConcurrentWorkOnRoot.bind(null, root);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction recoverFromConcurrentError (root, errorRetryLanes) {\r\n  // If an error occurred during hydration, discard server response and fall\r\n  // back to client side render.\r\n\r\n  // Before rendering again, save the errors from the previous attempt.\r\n  const errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\r\n\r\n  if (isRootDehydrated(root)) {\r\n    // The shell failed to hydrate. Set a flag to force a client rendering\r\n    // during the next attempt. To do this, we call prepareFreshStack now\r\n    // to create the root work-in-progress fiber. This is a bit weird in terms\r\n    // of factoring, because it relies on renderRootSync not calling\r\n    // prepareFreshStack again in the call below, which happens because the\r\n    // root and lanes haven't changed.\r\n    //\r\n    // TODO: I think what we should do is set ForceClientRender inside\r\n    // throwException, like we do for nested Suspense boundaries. The reason\r\n    // it's here instead is so we can switch to the synchronous work loop, too.\r\n    // Something to consider for a future refactor.\r\n    const rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\r\n    rootWorkInProgress.flags |= ForceClientRender;\r\n    if (__DEV__) {\r\n      errorHydratingContainer(root.containerInfo);\r\n    }\r\n  }\r\n\r\n  const exitStatus = renderRootSync(root, errorRetryLanes);\r\n  if (exitStatus !== RootErrored) {\r\n    // Successfully finished rendering on retry\r\n\r\n    // The errors from the failed first attempt have been recovered. Add\r\n    // them to the collection of recoverable errors. We'll log them in the\r\n    // commit phase.\r\n    const errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\r\n    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;\r\n    // The errors from the second attempt should be queued after the errors\r\n    // from the first attempt, to preserve the causal sequence.\r\n    if (errorsFromSecondAttempt !== null) {\r\n      queueRecoverableErrors(errorsFromSecondAttempt);\r\n    }\r\n  } else {\r\n    // The UI failed to recover.\r\n  }\r\n  return exitStatus;\r\n}\r\n\r\nexport function queueRecoverableErrors (errors: Array<mixed>) {\r\n  if (workInProgressRootRecoverableErrors === null) {\r\n    workInProgressRootRecoverableErrors = errors;\r\n  } else {\r\n    workInProgressRootRecoverableErrors.push.apply(\r\n      workInProgressRootRecoverableErrors,\r\n      errors,\r\n    );\r\n  }\r\n}\r\n\r\nfunction finishConcurrentRender (root, exitStatus, lanes) {\r\n  switch (exitStatus) {\r\n    case RootInProgress:\r\n    case RootFatalErrored: {\r\n      throw new Error('Root did not complete. This is a bug in React.');\r\n    }\r\n    // Flow knows about invariant, so it complains if I add a break\r\n    // statement, but eslint doesn't know about invariant, so it complains\r\n    // if I do. eslint-disable-next-line no-fallthrough\r\n    case RootErrored: {\r\n      // We should have already attempted to retry this tree. If we reached\r\n      // this point, it errored again. Commit it.\r\n      commitRoot(\r\n        root,\r\n        workInProgressRootRecoverableErrors,\r\n        workInProgressTransitions,\r\n      );\r\n      break;\r\n    }\r\n    case RootSuspended: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      // We have an acceptable loading state. We need to figure out if we\r\n      // should immediately commit it or wait a bit.\r\n\r\n      if (\r\n        includesOnlyRetries(lanes) &&\r\n        // do not delay if we're inside an act() scope\r\n        !shouldForceFlushFallbacksInDEV()\r\n      ) {\r\n        // This render only included retries, no updates. Throttle committing\r\n        // retries so that we don't show too many loading states too quickly.\r\n        const msUntilTimeout =\r\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          const nextLanes = getNextLanes(root, NoLanes);  //计算nextLanes\r\n          if (nextLanes !== NoLanes) {\r\n            // There's additional work on this root.\r\n            break;\r\n          }\r\n          const suspendedLanes = root.suspendedLanes;\r\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n            // We should prefer to render the fallback of at the last\r\n            // suspended level. Ping the last suspended level to try\r\n            // rendering it again.\r\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n            const eventTime = requestEventTime();\r\n            markRootPinged(root, suspendedLanes, eventTime);\r\n            break;\r\n          }\r\n\r\n          // The render is suspended, it hasn't timed out, and there's no\r\n          // lower priority work to do. Instead of committing the fallback\r\n          // immediately, wait for more data to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(\r\n              null,\r\n              root,\r\n              workInProgressRootRecoverableErrors,\r\n              workInProgressTransitions,\r\n            ),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n      // The work expired. Commit immediately.\r\n      commitRoot(\r\n        root,\r\n        workInProgressRootRecoverableErrors,\r\n        workInProgressTransitions,\r\n      );\r\n      break;\r\n    }\r\n    case RootSuspendedWithDelay: {\r\n      markRootSuspended(root, lanes);\r\n\r\n      if (includesOnlyTransitions(lanes)) {\r\n        // This is a transition, so we should exit without committing a\r\n        // placeholder and without scheduling a timeout. Delay indefinitely\r\n        // until we receive more data.\r\n        break;\r\n      }\r\n\r\n      if (!shouldForceFlushFallbacksInDEV()) {\r\n        // This is not a transition, but we did trigger an avoided state.\r\n        // Schedule a placeholder to display after a short delay, using the Just\r\n        // Noticeable Difference.\r\n        // TODO: Is the JND optimization worth the added complexity? If this is\r\n        // the only reason we track the event time, then probably not.\r\n        // Consider removing.\r\n\r\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n        const eventTimeMs = mostRecentEventTime;\r\n        const timeElapsedMs = now() - eventTimeMs;\r\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\r\n\r\n        // Don't bother with a very short suspense time.\r\n        if (msUntilTimeout > 10) {\r\n          // Instead of committing the fallback immediately, wait for more data\r\n          // to arrive.\r\n          root.timeoutHandle = scheduleTimeout(\r\n            commitRoot.bind(\r\n              null,\r\n              root,\r\n              workInProgressRootRecoverableErrors,\r\n              workInProgressTransitions,\r\n            ),\r\n            msUntilTimeout,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Commit the placeholder.\r\n      commitRoot(\r\n        root,\r\n        workInProgressRootRecoverableErrors,\r\n        workInProgressTransitions,\r\n      );\r\n      break;\r\n    }\r\n    case RootCompleted: {\r\n      // The work completed. Ready to commit.\r\n      commitRoot(\r\n        root,\r\n        workInProgressRootRecoverableErrors,\r\n        workInProgressTransitions,\r\n      );\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unknown root exit status.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction isRenderConsistentWithExternalStores (finishedWork: Fiber): boolean {\r\n  // Search the rendered tree for external store reads, and check whether the\r\n  // stores were mutated in a concurrent event. Intentionally using an iterative\r\n  // loop instead of recursion so we can exit early.\r\n  let node: Fiber = finishedWork;\r\n  while (true) {\r\n    if (node.flags & StoreConsistency) {\r\n      const updateQueue: FunctionComponentUpdateQueue | null = (node.updateQueue: any);\r\n      if (updateQueue !== null) {\r\n        const checks = updateQueue.stores;\r\n        if (checks !== null) {\r\n          for (let i = 0; i < checks.length; i++) {\r\n            const check = checks[i];\r\n            const getSnapshot = check.getSnapshot;\r\n            const renderedValue = check.value;\r\n            try {\r\n              if (!is(getSnapshot(), renderedValue)) {\r\n                // Found an inconsistent store.\r\n                return false;\r\n              }\r\n            } catch (error) {\r\n              // If `getSnapshot` throws, return `false`. This will schedule\r\n              // a re-render, and the error will be rethrown during render.\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    const child = node.child;\r\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\r\n      child.return = node;\r\n      node = child;\r\n      continue;\r\n    }\r\n    if (node === finishedWork) {\r\n      return true;\r\n    }\r\n    while (node.sibling === null) {\r\n      if (node.return === null || node.return === finishedWork) {\r\n        return true;\r\n      }\r\n      node = node.return;\r\n    }\r\n    node.sibling.return = node.return;\r\n    node = node.sibling;\r\n  }\r\n  // Flow doesn't know this is unreachable, but eslint does\r\n  // eslint-disable-next-line no-unreachable\r\n  return true;\r\n}\r\n\r\nfunction markRootSuspended (root, suspendedLanes) {\r\n  // When suspending, we should always exclude lanes that were pinged or (more\r\n  // rarely, since we try to avoid it) updated during the render phase.\r\n  // TODO: Lol maybe there's a better way to factor this besides this\r\n  // obnoxiously named function :)\r\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n  suspendedLanes = removeLanes(\r\n    suspendedLanes,\r\n    workInProgressRootInterleavedUpdatedLanes,\r\n  );\r\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\r\n}\r\n\r\n// This is the entry point for synchronous tasks that don't go\r\n// through Scheduler\r\n\r\n// render 阶段\r\nfunction performSyncWorkOnRoot (root) {\r\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\r\n    syncNestedUpdateFlag();\r\n  }\r\n\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    throw new Error('Should not already be working.');\r\n  }\r\n  // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\r\n  flushPassiveEffects();\r\n\r\n  let lanes = getNextLanes(root, NoLanes);\r\n  if (!includesSomeLane(lanes, SyncLane)) {\r\n    // There's no remaining sync work left.\r\n    ensureRootIsScheduled(root, now());\r\n    return null;\r\n  }\r\n\r\n  let exitStatus = renderRootSync(root, lanes);\r\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n    // If something threw an error, try rendering one more time. We'll render\r\n    // synchronously to block concurrent data mutations, and we'll includes\r\n    // all pending updates are included. If it still fails after the second\r\n    // attempt, we'll give up and commit the resulting tree.\r\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\r\n    if (errorRetryLanes !== NoLanes) {\r\n      lanes = errorRetryLanes;\r\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\r\n    }\r\n  }\r\n\r\n  if (exitStatus === RootFatalErrored) {\r\n    const fatalError = workInProgressRootFatalError;\r\n    prepareFreshStack(root, NoLanes);\r\n    markRootSuspended(root, lanes);\r\n    ensureRootIsScheduled(root, now());\r\n    throw fatalError;\r\n  }\r\n\r\n  if (exitStatus === RootDidNotComplete) {\r\n    throw new Error('Root did not complete. This is a bug in React.');\r\n  }\r\n\r\n  // We now have a consistent tree. Because this is a sync render, we\r\n  // will commit it even if something suspended.\r\n  const finishedWork: Fiber = (root.current.alternate: any);\r\n  root.finishedWork = finishedWork;\r\n  root.finishedLanes = lanes;\r\n\r\n  // 开启commit 工作流程\r\n  commitRoot(\r\n    root,\r\n    workInProgressRootRecoverableErrors,\r\n    workInProgressTransitions,\r\n  );\r\n\r\n  // Before exiting, make sure there's a callback scheduled for the next\r\n  // pending level.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  return null;\r\n}\r\n\r\nexport function flushRoot (root: FiberRoot, lanes: Lanes) {\r\n  if (lanes !== NoLanes) {\r\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\r\n    ensureRootIsScheduled(root, now());\r\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n      resetRenderTimer();\r\n      flushSyncCallbacks();\r\n    }\r\n  }\r\n}\r\n\r\nexport function getExecutionContext (): ExecutionContext {\r\n  return executionContext;\r\n}\r\n\r\nexport function deferredUpdates<A> (fn: () => A): A {\r\n  const previousPriority = getCurrentUpdatePriority();\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n\r\n  try {\r\n    ReactCurrentBatchConfig.transition = null;\r\n    setCurrentUpdatePriority(DefaultEventPriority);\r\n    return fn();\r\n  } finally {\r\n    setCurrentUpdatePriority(previousPriority);\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n  }\r\n}\r\n\r\nexport function batchedUpdates<A, R> (fn: A => R, a: A): R {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  try {\r\n    return fn(a);\r\n  } finally {\r\n    executionContext = prevExecutionContext;\r\n    // If there were legacy sync updates, flush them at the end of the outer\r\n    // most batchedUpdates-like method.\r\n    if (\r\n      executionContext === NoContext &&\r\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\r\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\r\n    ) {\r\n      resetRenderTimer();\r\n      flushSyncCallbacksOnlyInLegacyMode();\r\n    }\r\n  }\r\n}\r\n\r\nexport function discreteUpdates<A, B, C, D, R> (\r\n  fn: (A, B, C, D) => R,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n): R {\r\n  const previousPriority = getCurrentUpdatePriority();\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n  try {\r\n    ReactCurrentBatchConfig.transition = null;\r\n    setCurrentUpdatePriority(DiscreteEventPriority);\r\n    return fn(a, b, c, d);\r\n  } finally {\r\n    setCurrentUpdatePriority(previousPriority);\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n    if (executionContext === NoContext) {\r\n      resetRenderTimer();\r\n    }\r\n  }\r\n}\r\n\r\n// Overload the definition to the two valid signatures.\r\n// Warning, this opts-out of checking the function body.\r\ndeclare function flushSync<R> (fn: () => R): R;\r\n// eslint-disable-next-line no-redeclare\r\ndeclare function flushSync (): void;\r\n// eslint-disable-next-line no-redeclare\r\nexport function flushSync (fn) {\r\n  // In legacy mode, we flush pending passive effects at the beginning of the\r\n  // next event, not at the end of the previous one.\r\n  if (\r\n    rootWithPendingPassiveEffects !== null &&\r\n    rootWithPendingPassiveEffects.tag === LegacyRoot &&\r\n    (executionContext & (RenderContext | CommitContext)) === NoContext\r\n  ) {\r\n    // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\r\n    flushPassiveEffects();\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n  const previousPriority = getCurrentUpdatePriority();\r\n\r\n  try {\r\n    ReactCurrentBatchConfig.transition = null;\r\n    setCurrentUpdatePriority(DiscreteEventPriority);\r\n    if (fn) {\r\n      return fn();\r\n    } else {\r\n      return undefined;\r\n    }\r\n  } finally {\r\n    setCurrentUpdatePriority(previousPriority);\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n\r\n    executionContext = prevExecutionContext;\r\n    // Flush the immediate callbacks that were scheduled during this batch.\r\n    // Note that this will happen even if batchedUpdates is higher up\r\n    // the stack.\r\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n      flushSyncCallbacks();\r\n    }\r\n  }\r\n}\r\n\r\nexport function isAlreadyRendering () {\r\n  // Used by the renderer to print a warning if certain APIs are called from\r\n  // the wrong context.\r\n  return (\r\n    __DEV__ &&\r\n    (executionContext & (RenderContext | CommitContext)) !== NoContext\r\n  );\r\n}\r\n\r\nexport function flushControlled (fn: () => mixed): void {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= BatchedContext;\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n  const previousPriority = getCurrentUpdatePriority();\r\n  try {\r\n    ReactCurrentBatchConfig.transition = null;\r\n    setCurrentUpdatePriority(DiscreteEventPriority);\r\n    fn();\r\n  } finally {\r\n    setCurrentUpdatePriority(previousPriority);\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n\r\n    executionContext = prevExecutionContext;\r\n    if (executionContext === NoContext) {\r\n      // Flush the immediate callbacks that were scheduled during this batch\r\n      resetRenderTimer();\r\n      flushSyncCallbacks();\r\n    }\r\n  }\r\n}\r\n\r\nexport function pushRenderLanes (fiber: Fiber, lanes: Lanes) {\r\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n  workInProgressRootIncludedLanes = mergeLanes(\r\n    workInProgressRootIncludedLanes,\r\n    lanes,\r\n  );\r\n}\r\n\r\nexport function popRenderLanes (fiber: Fiber) {\r\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n  popFromStack(subtreeRenderLanesCursor, fiber);\r\n}\r\n\r\nfunction prepareFreshStack (root: FiberRoot, lanes: Lanes): Fiber {\r\n  root.finishedWork = null;\r\n  root.finishedLanes = NoLanes;\r\n\r\n  const timeoutHandle = root.timeoutHandle;\r\n  if (timeoutHandle !== noTimeout) {\r\n    // The root previous suspended and scheduled a timeout to commit a fallback\r\n    // state. Now that we have additional work, cancel the timeout.\r\n    root.timeoutHandle = noTimeout;\r\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n    cancelTimeout(timeoutHandle);\r\n  }\r\n\r\n  if (workInProgress !== null) {\r\n    let interruptedWork = workInProgress.return;\r\n    while (interruptedWork !== null) {\r\n      const current = interruptedWork.alternate;\r\n      unwindInterruptedWork(\r\n        current,\r\n        interruptedWork,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      interruptedWork = interruptedWork.return;\r\n    }\r\n  }\r\n  workInProgressRoot = root;\r\n  const rootWorkInProgress = createWorkInProgress(root.current, null);\r\n  workInProgress = rootWorkInProgress;\r\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n  workInProgressRootExitStatus = RootInProgress;\r\n  workInProgressRootFatalError = null;\r\n  workInProgressRootSkippedLanes = NoLanes;\r\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\r\n  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;\r\n  workInProgressRootPingedLanes = NoLanes;\r\n  workInProgressRootConcurrentErrors = null;\r\n  workInProgressRootRecoverableErrors = null;\r\n\r\n  enqueueInterleavedUpdates();\r\n\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.discardPendingWarnings();\r\n  }\r\n\r\n  return rootWorkInProgress;\r\n}\r\n\r\nfunction handleError (root, thrownValue): void {\r\n  do {\r\n    let erroredWork = workInProgress;\r\n    try {\r\n      // Reset module-level state that was set during the render phase.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      resetCurrentDebugFiberInDEV();\r\n      // TODO: I found and added this missing line while investigating a\r\n      // separate issue. Write a regression test using string refs.\r\n      ReactCurrentOwner.current = null;\r\n\r\n      if (erroredWork === null || erroredWork.return === null) {\r\n        // Expected to be working on a non-root fiber. This is a fatal error\r\n        // because there's no ancestor that can handle it; the root is\r\n        // supposed to capture all errors that weren't caught by an error\r\n        // boundary.\r\n        workInProgressRootExitStatus = RootFatalErrored;\r\n        workInProgressRootFatalError = thrownValue;\r\n        // Set `workInProgress` to null. This represents advancing to the next\r\n        // sibling, or the parent if there are no siblings. But since the root\r\n        // has no siblings nor a parent, we set it to null. Usually this is\r\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n        // intentionally not calling those, we need set it here.\r\n        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n\r\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n        // Record the time spent rendering before an error was thrown. This\r\n        // avoids inaccurate Profiler durations in the case of a\r\n        // suspended render.\r\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n      }\r\n\r\n      if (enableSchedulingProfiler) {\r\n        markComponentRenderStopped();\r\n\r\n        if (\r\n          thrownValue !== null &&\r\n          typeof thrownValue === 'object' &&\r\n          typeof thrownValue.then === 'function'\r\n        ) {\r\n          const wakeable: Wakeable = (thrownValue: any);\r\n          markComponentSuspended(\r\n            erroredWork,\r\n            wakeable,\r\n            workInProgressRootRenderLanes,\r\n          );\r\n        } else {\r\n          markComponentErrored(\r\n            erroredWork,\r\n            thrownValue,\r\n            workInProgressRootRenderLanes,\r\n          );\r\n        }\r\n      }\r\n\r\n      throwException(\r\n        root,\r\n        erroredWork.return,\r\n        erroredWork,\r\n        thrownValue,\r\n        workInProgressRootRenderLanes,\r\n      );\r\n      completeUnitOfWork(erroredWork);\r\n    } catch (yetAnotherThrownValue) {\r\n      // Something in the return path also threw.\r\n      thrownValue = yetAnotherThrownValue;\r\n      if (workInProgress === erroredWork && erroredWork !== null) {\r\n        // If this boundary has already errored, then we had trouble processing\r\n        // the error. Bubble it to the next boundary.\r\n        erroredWork = erroredWork.return;\r\n        workInProgress = erroredWork;\r\n      } else {\r\n        erroredWork = workInProgress;\r\n      }\r\n      continue;\r\n    }\r\n    // Return to the normal work loop.\r\n    return;\r\n  } while (true);\r\n}\r\n\r\nfunction pushDispatcher () {\r\n  const prevDispatcher = ReactCurrentDispatcher.current;\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n  if (prevDispatcher === null) {\r\n    // The React isomorphic package does not include a default dispatcher.\r\n    // Instead the first renderer will lazily attach one, in order to give\r\n    // nicer error messages.\r\n    return ContextOnlyDispatcher;\r\n  } else {\r\n    return prevDispatcher;\r\n  }\r\n}\r\n\r\nfunction popDispatcher (prevDispatcher) {\r\n  ReactCurrentDispatcher.current = prevDispatcher;\r\n}\r\n\r\nexport function markCommitTimeOfFallback () {\r\n  globalMostRecentFallbackTime = now();\r\n}\r\n\r\nexport function markSkippedUpdateLanes (lane: Lane | Lanes): void {\r\n  workInProgressRootSkippedLanes = mergeLanes(\r\n    lane,\r\n    workInProgressRootSkippedLanes,\r\n  );\r\n}\r\n\r\nexport function renderDidSuspend (): void {\r\n  if (workInProgressRootExitStatus === RootInProgress) {\r\n    workInProgressRootExitStatus = RootSuspended;\r\n  }\r\n}\r\n\r\nexport function renderDidSuspendDelayIfPossible (): void {\r\n  if (\r\n    workInProgressRootExitStatus === RootInProgress ||\r\n    workInProgressRootExitStatus === RootSuspended ||\r\n    workInProgressRootExitStatus === RootErrored\r\n  ) {\r\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n  }\r\n\r\n  // Check if there are updates that we skipped tree that might have unblocked\r\n  // this render.\r\n  if (\r\n    workInProgressRoot !== null &&\r\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\r\n      includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))\r\n  ) {\r\n    // Mark the current render as suspended so that we switch to working on\r\n    // the updates that were skipped. Usually we only suspend at the end of\r\n    // the render phase.\r\n    // TODO: We should probably always mark the root as suspended immediately\r\n    // (inside this function), since by suspending at the end of the render\r\n    // phase introduces a potential mistake where we suspend lanes that were\r\n    // pinged or updated while we were rendering.\r\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\r\n  }\r\n}\r\n\r\nexport function renderDidError (error: mixed) {\r\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\r\n    workInProgressRootExitStatus = RootErrored;\r\n  }\r\n  if (workInProgressRootConcurrentErrors === null) {\r\n    workInProgressRootConcurrentErrors = [error];\r\n  } else {\r\n    workInProgressRootConcurrentErrors.push(error);\r\n  }\r\n}\r\n\r\n// Called during render to determine if anything has suspended.\r\n// Returns false if we're not sure.\r\nexport function renderHasNotSuspendedYet (): boolean {\r\n  // If something errored or completed, we can't really be sure,\r\n  // so those are false.\r\n  return workInProgressRootExitStatus === RootInProgress;\r\n}\r\n\r\nfunction renderRootSync (root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    if (enableUpdaterTracking) {\r\n      if (isDevToolsPresent) {\r\n        const memoizedUpdaters = root.memoizedUpdaters;\r\n        if (memoizedUpdaters.size > 0) {\r\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\r\n          memoizedUpdaters.clear();\r\n        }\r\n\r\n        // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\r\n        // If we bailout on this work, we'll move them back (like above).\r\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\r\n        // That way we can keep the current update and future updates separate.\r\n        movePendingFibersToMemoized(root, lanes);\r\n      }\r\n    }\r\n\r\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\r\n    prepareFreshStack(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopSync();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n\r\n  executionContext = prevExecutionContext;\r\n  popDispatcher(prevDispatcher);\r\n\r\n  if (workInProgress !== null) {\r\n    // This is a sync render, so we should have finished the whole tree.\r\n    throw new Error(\r\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\r\n      'bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStopped();\r\n  }\r\n\r\n  // Set this to null to indicate there's no in-progress render.\r\n  workInProgressRoot = null;\r\n  workInProgressRootRenderLanes = NoLanes;\r\n\r\n  return workInProgressRootExitStatus;\r\n}\r\n\r\n// The work loop is an extremely hot path. Tell Closure not to inline it.\r\n/** @noinline */\r\nfunction workLoopSync () {\r\n  // Already timed out, so perform work without checking if we need to yield.\r\n  while (workInProgress !== null) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\nfunction renderRootConcurrent (root: FiberRoot, lanes: Lanes) {\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= RenderContext;\r\n  const prevDispatcher = pushDispatcher();\r\n\r\n  // If the root or lanes have changed, throw out the existing stack\r\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n    if (enableUpdaterTracking) {\r\n      if (isDevToolsPresent) {\r\n        const memoizedUpdaters = root.memoizedUpdaters;\r\n        if (memoizedUpdaters.size > 0) {\r\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\r\n          memoizedUpdaters.clear();\r\n        }\r\n\r\n        // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\r\n        // If we bailout on this work, we'll move them back (like above).\r\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\r\n        // That way we can keep the current update and future updates separate.\r\n        movePendingFibersToMemoized(root, lanes);\r\n      }\r\n    }\r\n\r\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\r\n    resetRenderTimer();\r\n    prepareFreshStack(root, lanes);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderStarted(lanes);\r\n  }\r\n\r\n  do {\r\n    try {\r\n      workLoopConcurrent();\r\n      break;\r\n    } catch (thrownValue) {\r\n      handleError(root, thrownValue);\r\n    }\r\n  } while (true);\r\n  resetContextDependencies();\r\n\r\n  popDispatcher(prevDispatcher);\r\n  executionContext = prevExecutionContext;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logRenderStopped();\r\n    }\r\n  }\r\n\r\n  // Check if the tree has completed.\r\n  if (workInProgress !== null) {\r\n    // Still work remaining.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderYielded();\r\n    }\r\n    return RootInProgress;\r\n  } else {\r\n    // Completed the tree.\r\n    if (enableSchedulingProfiler) {\r\n      markRenderStopped();\r\n    }\r\n\r\n    // Set this to null to indicate there's no in-progress render.\r\n    workInProgressRoot = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n\r\n    // Return the final exit status.\r\n    return workInProgressRootExitStatus;\r\n  }\r\n}\r\n\r\n/** @noinline */\r\nfunction workLoopConcurrent () {\r\n  // Perform work until Scheduler asks us to yield\r\n  // shouldYield() 利用这个函数判断是否可以终止任务\r\n  // workInProgress 是FiberRootNode 下的 current  也是双缓存树的第一颗树\r\n  while (workInProgress !== null && !shouldYield()) {\r\n    performUnitOfWork(workInProgress);\r\n  }\r\n}\r\n\r\n/**\r\n * @description performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。\r\n * @description 我们知道Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为两部分：“递”和“归”。\r\n * @description “递”阶段  \r\n * 首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用beginWork方法 (opens new window)。\r\n\r\n该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。\r\n\r\n当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。\r\n * @description “归”阶段\r\n * 在“归”阶段会调用completeWork (opens new window)处理Fiber节点。\r\n\r\n当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。\r\ns\r\n如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。\r\n\r\n“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。\r\n * @param {*} unitOfWork \r\n */\r\nfunction performUnitOfWork (unitOfWork: Fiber): void {\r\n  // The current, flushed, state of this fiber is the alternate. Ideally\r\n  // nothing should rely on this, but relying on it here means that we don't\r\n  // need an additional field on the work in progress.\r\n  const current = unitOfWork.alternate;\r\n  setCurrentDebugFiberInDEV(unitOfWork);\r\n  let next;\r\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\r\n    // console.log(unitOfWork.elementType,\"beginWork\")\r\n    startProfilerTimer(unitOfWork);\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n  } else {\r\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\r\n  }\r\n\r\n  resetCurrentDebugFiberInDEV();\r\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n  if (next === null) {\r\n    // If this doesn't spawn new work, complete the current work.\r\n    // 当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。\r\n    // 如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。\r\n    // “递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。\r\n    // console.log(unitOfWork.elementType,\"unitOfWork\")\r\n    completeUnitOfWork(unitOfWork);\r\n  } else {\r\n    workInProgress = next;\r\n  }\r\n\r\n  ReactCurrentOwner.current = null;\r\n}\r\n\r\n\r\n// effectList 在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为effectList的单向链表中。effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。\r\n// 形成环状链表的时候会从触发更新的节点向上合并effectList直到rootFiber，这一过程发生在completeUnitOfWork函数中，整个函数的作用就是向上合并effectList\r\nfunction completeUnitOfWork (unitOfWork: Fiber): void {\r\n  // Attempt to complete the current unit of work, then move to the next\r\n  // sibling. If there are no more siblings, return to the parent fiber.\r\n  let completedWork = unitOfWork;\r\n  do {\r\n    // The current, flushed, state of this fiber is the alternate. Ideally\r\n    // nothing should rely on this, but relying on it here means that we don't\r\n    // need an additional field on the work in progress.\r\n    const current = completedWork.alternate;\r\n    const returnFiber = completedWork.return;\r\n\r\n    // Check if the work completed or if something threw.\r\n    if ((completedWork.flags & Incomplete) === NoFlags) {\r\n      setCurrentDebugFiberInDEV(completedWork);\r\n      let next;\r\n      if (\r\n        !enableProfilerTimer ||\r\n        (completedWork.mode & ProfileMode) === NoMode\r\n      ) {\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n      } else {\r\n        startProfilerTimer(completedWork);\r\n        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n        // Update render duration assuming we didn't error.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n\r\n      if (next !== null) {\r\n        // Completing this fiber spawned new work. Work on that next.\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n    } else {\r\n      // This fiber did not complete because something threw. Pop values off\r\n      // the stack without entering the complete phase. If this is a boundary,\r\n      // capture values if possible.\r\n      const next = unwindWork(current, completedWork, subtreeRenderLanes);\r\n\r\n      // Because this fiber did not complete, don't reset its lanes.\r\n\r\n      if (next !== null) {\r\n        // If completing this work spawned new work, do that next. We'll come\r\n        // back here again.\r\n        // Since we're restarting, remove anything that is not a host effect\r\n        // from the effect tag.\r\n        next.flags &= HostEffectMask;\r\n        workInProgress = next;\r\n        return;\r\n      }\r\n\r\n      if (\r\n        enableProfilerTimer &&\r\n        (completedWork.mode & ProfileMode) !== NoMode\r\n      ) {\r\n        // Record the render duration for the fiber that errored.\r\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n\r\n        // Include the time spent working on failed children before continuing.\r\n        let actualDuration = completedWork.actualDuration;\r\n        let child = completedWork.child;\r\n        while (child !== null) {\r\n          actualDuration += child.actualDuration;\r\n          child = child.sibling;\r\n        }\r\n        completedWork.actualDuration = actualDuration;\r\n      }\r\n\r\n      if (returnFiber !== null) {\r\n        // Mark the parent fiber as incomplete and clear its subtree flags.\r\n        returnFiber.flags |= Incomplete;\r\n        returnFiber.subtreeFlags = NoFlags;\r\n        returnFiber.deletions = null;\r\n      } else {\r\n        // We've unwound all the way to the root.\r\n        workInProgressRootExitStatus = RootDidNotComplete;\r\n        workInProgress = null;\r\n        return;\r\n      }\r\n    }\r\n\r\n    const siblingFiber = completedWork.sibling;\r\n    if (siblingFiber !== null) {\r\n      // If there is more work to do in this returnFiber, do that next.\r\n      workInProgress = siblingFiber;\r\n      return;\r\n    }\r\n    // Otherwise, return to the parent\r\n    completedWork = returnFiber;\r\n    // Update the next thing we're working on in case something throws.\r\n    workInProgress = completedWork;\r\n  } while (completedWork !== null);\r\n\r\n  // We've reached the root.\r\n  if (workInProgressRootExitStatus === RootInProgress) {\r\n    workInProgressRootExitStatus = RootCompleted;\r\n  }\r\n}\r\n\r\nfunction commitRoot (\r\n  root: FiberRoot,\r\n  recoverableErrors: null | Array<mixed>,\r\n  transitions: Array<Transition> | null,\r\n) {\r\n  // TODO: This no longer makes any sense. We already wrap the mutation and\r\n  // layout phases. Should be able to remove.\r\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n\r\n  try {\r\n    ReactCurrentBatchConfig.transition = null;\r\n    setCurrentUpdatePriority(DiscreteEventPriority);\r\n    commitRootImpl(\r\n      root,\r\n      recoverableErrors,\r\n      transitions,\r\n      previousUpdateLanePriority,\r\n    );\r\n  } finally {\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n    setCurrentUpdatePriority(previousUpdateLanePriority);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// commit阶段\r\n// 在commitRootImpl的函数中主要分三个部分：\r\n// 1. commit阶段前置工作\r\n// 调用flushPassiveEffects执行完所有effect的任务\r\n// 初始化相关变量\r\n// 赋值firstEffect给后面遍历effectList用\r\nfunction commitRootImpl (\r\n  root: FiberRoot,\r\n  recoverableErrors: null | Array<mixed>,\r\n  transitions: Array<Transition> | null,\r\n  renderPriorityLevel: EventPriority,\r\n) {\r\n  do {\r\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n    // means `flushPassiveEffects` will sometimes result in additional\r\n    // passive effects. So we need to keep flushing in a loop until there are\r\n    // no more pending effects.\r\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n    // flush synchronous work at the end, to avoid factoring hazards like this.\r\n    // 调用flushPassiveEffects执行完所有effect的任务\r\n\r\n    // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\r\n    flushPassiveEffects();\r\n  } while (rootWithPendingPassiveEffects !== null);\r\n  flushRenderPhaseStrictModeWarningsInDEV();\r\n\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    throw new Error('Should not already be working.');\r\n  }\r\n\r\n  const finishedWork = root.finishedWork;\r\n  const lanes = root.finishedLanes;\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStarted(lanes);\r\n  }\r\n\r\n  if (finishedWork === null) {\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logCommitStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markCommitStopped();\r\n    }\r\n\r\n    return null;\r\n  } else {\r\n    if (__DEV__) {\r\n      if (lanes === NoLanes) {\r\n        console.error(\r\n          'root.finishedLanes should not be empty during a commit. This is a ' +\r\n          'bug in React.',\r\n        );\r\n      }\r\n    }\r\n  }\r\n  // 重置变量 finishedWork指rooFiber\r\n  root.finishedWork = null;\r\n  //重置优先级\r\n  root.finishedLanes = NoLanes;\r\n\r\n  if (finishedWork === root.current) {\r\n    throw new Error(\r\n      'Cannot commit the same tree as before. This error is likely caused by ' +\r\n      'a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  // commitRoot never returns a continuation; it always finishes synchronously.\r\n  // So we can clear these now to allow a new callback to be scheduled.\r\n  // Scheduler回调函数重置\r\n  root.callbackNode = null;\r\n  root.callbackPriority = NoLane;\r\n\r\n  // Update the first and last pending times on this root. The new first\r\n  // pending time is whatever is left on the root fiber.\r\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n  markRootFinished(root, remainingLanes);\r\n\r\n  // 重置全局变量\r\n  if (root === workInProgressRoot) {\r\n    // We can reset these now that they are finished.\r\n    workInProgressRoot = null;\r\n    workInProgress = null;\r\n    workInProgressRootRenderLanes = NoLanes;\r\n  } else {\r\n    // This indicates that the last root we worked on is not the same one that\r\n    // we're committing now. This most commonly happens when a suspended root\r\n    // times out.\r\n  }\r\n\r\n  // If there are pending passive effects, schedule a callback to process them.\r\n  // Do this as early as possible, so it is queued before anything else that\r\n  // might get scheduled in the commit phase. (See #16714.)\r\n  // TODO: Delete all other places that schedule the passive effect callback\r\n  // They're redundant.\r\n  if (\r\n    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||\r\n    (finishedWork.flags & PassiveMask) !== NoFlags\r\n  ) {\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      pendingPassiveEffectsRemainingLanes = remainingLanes;\r\n      // workInProgressTransitions might be overwritten, so we want\r\n      // to store it in pendingPassiveTransitions until they get processed\r\n      // We need to pass this through as an argument to commitRoot\r\n      // because workInProgressTransitions might have changed between\r\n      // the previous render and commit if we throttle the commit\r\n      // with setTimeout\r\n      pendingPassiveTransitions = transitions;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        // 触发useEffect\r\n        // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\r\n        flushPassiveEffects();\r\n        // This render triggered passive effects: release the root cache pool\r\n        // *after* passive effects fire to avoid freeing a cache pool that may\r\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n\r\n  // Check if there are any effects in the whole tree.\r\n  // TODO: This is left over from the effect list implementation, where we had\r\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\r\n  // only other reason this optimization exists is because it affects profiling.\r\n  // Reconsider whether this is necessary.\r\n  const subtreeHasEffects =\r\n    (finishedWork.subtreeFlags &\r\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\r\n    NoFlags;\r\n  const rootHasEffect =\r\n    (finishedWork.flags &\r\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\r\n    NoFlags;\r\n\r\n  if (subtreeHasEffects || rootHasEffect) {\r\n    const prevTransition = ReactCurrentBatchConfig.transition;\r\n    ReactCurrentBatchConfig.transition = null;\r\n    const previousPriority = getCurrentUpdatePriority();\r\n    setCurrentUpdatePriority(DiscreteEventPriority);\r\n    // 将当前上下文标记为CommitContext，作为commit阶段的标志\r\n    const prevExecutionContext = executionContext;\r\n    executionContext |= CommitContext;\r\n\r\n    // Reset this to null before calling lifecycles\r\n    ReactCurrentOwner.current = null;\r\n\r\n    // The commit phase is broken into several sub-phases. We do a separate pass\r\n    // of the effect list for each phase: all mutation effects come before all\r\n    // layout effects, and so on.\r\n\r\n    // The first phase a \"before mutation\" phase. We use this phase to read the\r\n    // state of the host tree right before we mutate it. This is where\r\n    // getSnapshotBeforeUpdate is called.\r\n\r\n\r\n    // beforeMutation阶段的主函数\r\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(\r\n      root,\r\n      finishedWork,\r\n    );\r\n\r\n    if (enableProfilerTimer) {\r\n      // Mark the current commit time to be shared by all Profilers in this\r\n      // batch. This enables them to be grouped later.\r\n      recordCommitTime();\r\n    }\r\n\r\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\r\n      // Track the root here, rather than in commitLayoutEffects(), because of ref setters.\r\n      // Updates scheduled during ref detachment should also be flagged.\r\n      rootCommittingMutationOrLayoutEffects = root;\r\n    }\r\n\r\n    // The next phase is the mutation phase, where we mutate the host tree.\r\n    commitMutationEffects(root, finishedWork, lanes);\r\n\r\n    if (enableCreateEventHandleAPI) {\r\n      if (shouldFireAfterActiveInstanceBlur) {\r\n        afterActiveInstanceBlur();\r\n      }\r\n    }\r\n    resetAfterCommit(root.containerInfo);\r\n\r\n    // The work-in-progress tree is now the current tree. This must come after\r\n    // the mutation phase, so that the previous tree is still current during\r\n    // componentWillUnmount, but before the layout phase, so that the finished\r\n    // work is current during componentDidMount/Update.\r\n    root.current = finishedWork;\r\n\r\n    // The next phase is the layout phase, where we call effects that read\r\n    // the host tree after it's been mutated. The idiomatic use case for this is\r\n    // layout, but class component lifecycles also fire here for legacy reasons.\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logLayoutEffectsStarted(lanes);\r\n      }\r\n    }\r\n    if (enableSchedulingProfiler) {\r\n      markLayoutEffectsStarted(lanes);\r\n    }\r\n    commitLayoutEffects(finishedWork, root, lanes);\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        logLayoutEffectsStopped();\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markLayoutEffectsStopped();\r\n    }\r\n\r\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\r\n      rootCommittingMutationOrLayoutEffects = null;\r\n    }\r\n\r\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n    // opportunity to paint.\r\n    requestPaint();\r\n\r\n    executionContext = prevExecutionContext;\r\n\r\n    // Reset the priority to the previous non-sync value.\r\n    setCurrentUpdatePriority(previousPriority);\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n  } else {\r\n    // No effects.\r\n    root.current = finishedWork;\r\n    // Measure these anyway so the flamegraph explicitly shows that there were\r\n    // no effects.\r\n    // TODO: Maybe there's a better way to report this.\r\n    if (enableProfilerTimer) {\r\n      recordCommitTime();\r\n    }\r\n  }\r\n\r\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n\r\n  if (rootDoesHavePassiveEffects) {\r\n    // This commit has passive effects. Stash a reference to them. But don't\r\n    // schedule a callback until after flushing layout work.\r\n    rootDoesHavePassiveEffects = false;\r\n    rootWithPendingPassiveEffects = root;\r\n    pendingPassiveEffectsLanes = lanes;\r\n  } else {\r\n    // There were no passive effects, so we can immediately release the cache\r\n    // pool for this render.\r\n    releaseRootPooledCache(root, remainingLanes);\r\n    if (__DEV__) {\r\n      nestedPassiveUpdateCount = 0;\r\n      rootWithPassiveNestedUpdates = null;\r\n    }\r\n  }\r\n\r\n  // Read this again, since an effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n\r\n  // Check if there's remaining work on this root\r\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\r\n  // is to detect whether something might have called setState inside\r\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\r\n  // inside `componentDidCatch` is itself flawed — that's why we recommend\r\n  // `getDerivedStateFromError` instead. However, it could be improved by\r\n  // checking if remainingLanes includes Sync work, instead of whether there's\r\n  // any work remaining at all (which would also include stuff like Suspense\r\n  // retries or transitions). It's been like this for a while, though, so fixing\r\n  // it probably isn't that urgent.\r\n  if (remainingLanes === NoLanes) {\r\n    // If there's no remaining work, we can clear the set of already failed\r\n    // error boundaries.\r\n    legacyErrorBoundariesThatAlreadyFailed = null;\r\n  }\r\n\r\n  if (__DEV__ && enableStrictEffects) {\r\n    if (!rootDidHavePassiveEffects) {\r\n      commitDoubleInvokeEffectsInDEV(root.current, false);\r\n    }\r\n  }\r\n\r\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\r\n\r\n  if (enableUpdaterTracking) {\r\n    if (isDevToolsPresent) {\r\n      root.memoizedUpdaters.clear();\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    onCommitRootTestSelector();\r\n  }\r\n\r\n  // Always call this before exiting `commitRoot`, to ensure that any\r\n  // additional work on this root is scheduled.\r\n  ensureRootIsScheduled(root, now());\r\n\r\n  if (recoverableErrors !== null) {\r\n    // There were errors during this render, but recovered from them without\r\n    // needing to surface it to the UI. We log them here.\r\n    const onRecoverableError = root.onRecoverableError;\r\n    for (let i = 0; i < recoverableErrors.length; i++) {\r\n      const recoverableError = recoverableErrors[i];\r\n      onRecoverableError(recoverableError);\r\n    }\r\n  }\r\n\r\n  if (hasUncaughtError) {\r\n    hasUncaughtError = false;\r\n    const error = firstUncaughtError;\r\n    firstUncaughtError = null;\r\n    throw error;\r\n  }\r\n\r\n  // If the passive effects are the result of a discrete render, flush them\r\n  // synchronously at the end of the current task so that the result is\r\n  // immediately observable. Otherwise, we assume that they are not\r\n  // order-dependent and do not need to be observed by external systems, so we\r\n  // can wait until after paint.\r\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\r\n  // currently schedule the callback in multiple places, will wait until those\r\n  // are consolidated.\r\n  if (\r\n    includesSomeLane(pendingPassiveEffectsLanes, SyncLane) &&\r\n    root.tag !== LegacyRoot\r\n  ) {\r\n    // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\r\n    flushPassiveEffects();\r\n  }\r\n\r\n  // Read this again, since a passive effect might have updated it\r\n  remainingLanes = root.pendingLanes;\r\n  if (includesSomeLane(remainingLanes, (SyncLane: Lane))) {\r\n    if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\r\n      markNestedUpdateScheduled();\r\n    }\r\n\r\n    // Count the number of times the root synchronously re-renders without\r\n    // finishing. If there are too many, it indicates an infinite update loop.\r\n    if (root === rootWithNestedUpdates) {\r\n      nestedUpdateCount++;\r\n    } else {\r\n      nestedUpdateCount = 0;\r\n      rootWithNestedUpdates = root;\r\n    }\r\n  } else {\r\n    nestedUpdateCount = 0;\r\n  }\r\n\r\n  // If layout work was scheduled, flush it now.\r\n  flushSyncCallbacks();\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logCommitStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markCommitStopped();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction releaseRootPooledCache (root: FiberRoot, remainingLanes: Lanes) {\r\n  if (enableCache) {\r\n    const pooledCacheLanes = (root.pooledCacheLanes &= remainingLanes);\r\n    if (pooledCacheLanes === NoLanes) {\r\n      // None of the remaining work relies on the cache pool. Clear it so\r\n      // subsequent requests get a new cache\r\n      const pooledCache = root.pooledCache;\r\n      if (pooledCache != null) {\r\n        root.pooledCache = null;\r\n        releaseCache(pooledCache);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * 整个useEffect异步调用分为三步：\r\n\r\nbefore mutation阶段在scheduleCallback中调度flushPassiveEffects\r\nlayout阶段之后将effectList赋值给rootWithPendingPassiveEffects\r\nscheduleCallback触发flushPassiveEffects，flushPassiveEffects内部遍历rootWithPendingPassiveEffects\r\n */\r\n\r\n\r\n/**\r\n * @description effectList中保存了需要执行副作用的Fiber节点。其中副作用包括\r\n\r\n插入DOM节点（Placement）\r\n更新DOM节点（Update）\r\n删除DOM节点（Deletion）\r\n除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。\r\n * @returns \r\n */\r\nexport function flushPassiveEffects (): boolean {\r\n  // Returns whether passive effects were flushed.\r\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\r\n  // probably just combine the two functions. I believe they were only separate\r\n  // in the first place because we used to wrap it with\r\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\r\n  // priority within React itself, so we can mutate the variable directly.\r\n  if (rootWithPendingPassiveEffects !== null) {\r\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\r\n    // flushPassiveEffectsImpl\r\n    const root = rootWithPendingPassiveEffects;\r\n    // Cache and clear the remaining lanes flag; it must be reset since this\r\n    // method can be called from various places, not always from commitRoot\r\n    // where the remaining lanes are known\r\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\r\n    pendingPassiveEffectsRemainingLanes = NoLanes;\r\n\r\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\r\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\r\n    const prevTransition = ReactCurrentBatchConfig.transition;\r\n    const previousPriority = getCurrentUpdatePriority();\r\n\r\n    try {\r\n      ReactCurrentBatchConfig.transition = null;\r\n      setCurrentUpdatePriority(priority);\r\n      return flushPassiveEffectsImpl();\r\n    } finally {\r\n      setCurrentUpdatePriority(previousPriority);\r\n      ReactCurrentBatchConfig.transition = prevTransition;\r\n\r\n      // Once passive effects have run for the tree - giving components a\r\n      // chance to retain cache instances they use - release the pooled\r\n      // cache at the root (if there is one)\r\n      releaseRootPooledCache(root, remainingLanes);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function enqueuePendingPassiveProfilerEffect (fiber: Fiber): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    pendingPassiveProfilerEffects.push(fiber);\r\n    if (!rootDoesHavePassiveEffects) {\r\n      rootDoesHavePassiveEffects = true;\r\n      scheduleCallback(NormalSchedulerPriority, () => {\r\n        // 触发useEffect\r\n        // 在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。\r\n        flushPassiveEffects();\r\n        return null;\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushPassiveEffectsImpl () {\r\n  if (rootWithPendingPassiveEffects === null) {\r\n    return false;\r\n  }\r\n\r\n  // Cache and clear the transitions flag\r\n  const transitions = pendingPassiveTransitions;\r\n  pendingPassiveTransitions = null;\r\n\r\n  const root = rootWithPendingPassiveEffects;\r\n  const lanes = pendingPassiveEffectsLanes;\r\n  rootWithPendingPassiveEffects = null;\r\n  // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\r\n  // Figure out why and fix it. It's not causing any known issues (probably\r\n  // because it's only used for profiling), but it's a refactor hazard.\r\n  pendingPassiveEffectsLanes = NoLanes;\r\n\r\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n    throw new Error('Cannot flush passive effects while already rendering.');\r\n  }\r\n\r\n  if (__DEV__) {\r\n    isFlushingPassiveEffects = true;\r\n    didScheduleUpdateDuringPassiveEffects = false;\r\n\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStarted(lanes);\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStarted(lanes);\r\n  }\r\n\r\n  const prevExecutionContext = executionContext;\r\n  executionContext |= CommitContext;\r\n\r\n  commitPassiveUnmountEffects(root.current);\r\n  commitPassiveMountEffects(root, root.current, lanes, transitions);\r\n\r\n  // TODO: Move to commitPassiveMountEffects\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const profilerEffects = pendingPassiveProfilerEffects;\r\n    pendingPassiveProfilerEffects = [];\r\n    for (let i = 0; i < profilerEffects.length; i++) {\r\n      const fiber = ((profilerEffects[i]: any): Fiber);\r\n      commitPassiveEffectDurations(root, fiber);\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      logPassiveEffectsStopped();\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markPassiveEffectsStopped();\r\n  }\r\n\r\n  if (__DEV__ && enableStrictEffects) {\r\n    commitDoubleInvokeEffectsInDEV(root.current, true);\r\n  }\r\n\r\n  executionContext = prevExecutionContext;\r\n\r\n  flushSyncCallbacks();\r\n\r\n  if (enableTransitionTracing) {\r\n    const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;\r\n    const prevRootTransitionCallbacks = root.transitionCallbacks;\r\n    if (\r\n      prevPendingTransitionCallbacks !== null &&\r\n      prevRootTransitionCallbacks !== null\r\n    ) {\r\n      // TODO(luna) Refactor this code into the Host Config\r\n      // TODO(luna) The end time here is not necessarily accurate\r\n      // because passive effects could be called before paint\r\n      // (synchronously) or after paint (normally). We need\r\n      // to come up with a way to get the correct end time for both cases.\r\n      // One solution is in the host config, if the passive effects\r\n      // have not yet been run, make a call to flush the passive effects\r\n      // right after paint.\r\n      const endTime = now();\r\n      currentPendingTransitionCallbacks = null;\r\n\r\n      scheduleCallback(IdleSchedulerPriority, () =>\r\n        processTransitionCallbacks(\r\n          prevPendingTransitionCallbacks,\r\n          endTime,\r\n          prevRootTransitionCallbacks,\r\n        ),\r\n      );\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    // If additional passive effects were scheduled, increment a counter. If this\r\n    // exceeds the limit, we'll fire a warning.\r\n    if (didScheduleUpdateDuringPassiveEffects) {\r\n      if (root === rootWithPassiveNestedUpdates) {\r\n        nestedPassiveUpdateCount++;\r\n      } else {\r\n        nestedPassiveUpdateCount = 0;\r\n        rootWithPassiveNestedUpdates = root;\r\n      }\r\n    } else {\r\n      nestedPassiveUpdateCount = 0;\r\n    }\r\n    isFlushingPassiveEffects = false;\r\n    didScheduleUpdateDuringPassiveEffects = false;\r\n  }\r\n\r\n  // TODO: Move to commitPassiveMountEffects\r\n  onPostCommitRootDevTools(root);\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    const stateNode = root.current.stateNode;\r\n    stateNode.effectDuration = 0;\r\n    stateNode.passiveEffectDuration = 0;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isAlreadyFailedLegacyErrorBoundary (instance: mixed): boolean {\r\n  return (\r\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\r\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\r\n  );\r\n}\r\n\r\nexport function markLegacyErrorBoundaryAsFailed (instance: mixed) {\r\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n  } else {\r\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n  }\r\n}\r\n\r\nfunction prepareToThrowUncaughtError (error: mixed) {\r\n  if (!hasUncaughtError) {\r\n    hasUncaughtError = true;\r\n    firstUncaughtError = error;\r\n  }\r\n}\r\nexport const onUncaughtError = prepareToThrowUncaughtError;\r\n\r\nfunction captureCommitPhaseErrorOnRoot (\r\n  rootFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  error: mixed,\r\n) {\r\n  const errorInfo = createCapturedValue(error, sourceFiber);\r\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\r\n  enqueueUpdate(rootFiber, update, (SyncLane: Lane));\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\r\n  if (root !== null) {\r\n    markRootUpdated(root, SyncLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n  }\r\n}\r\n\r\nexport function captureCommitPhaseError (\r\n  sourceFiber: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n  error: mixed,\r\n) {\r\n  if (__DEV__) {\r\n    reportUncaughtErrorInDEV(error);\r\n    setIsRunningInsertionEffect(false);\r\n  }\r\n  if (sourceFiber.tag === HostRoot) {\r\n    // Error was thrown at the root. There is no parent, so the root\r\n    // itself should capture it.\r\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n    return;\r\n  }\r\n\r\n  let fiber = null;\r\n  if (skipUnmountedBoundaries) {\r\n    fiber = nearestMountedAncestor;\r\n  } else {\r\n    fiber = sourceFiber.return;\r\n  }\r\n\r\n  while (fiber !== null) {\r\n    if (fiber.tag === HostRoot) {\r\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n      return;\r\n    } else if (fiber.tag === ClassComponent) {\r\n      const ctor = fiber.type;\r\n      const instance = fiber.stateNode;\r\n      if (\r\n        typeof ctor.getDerivedStateFromError === 'function' ||\r\n        (typeof instance.componentDidCatch === 'function' &&\r\n          !isAlreadyFailedLegacyErrorBoundary(instance))\r\n      ) {\r\n        const errorInfo = createCapturedValue(error, sourceFiber);\r\n        const update = createClassErrorUpdate(\r\n          fiber,\r\n          errorInfo,\r\n          (SyncLane: Lane),\r\n        );\r\n        enqueueUpdate(fiber, update, (SyncLane: Lane));\r\n        const eventTime = requestEventTime();\r\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\r\n        if (root !== null) {\r\n          markRootUpdated(root, SyncLane, eventTime);\r\n          ensureRootIsScheduled(root, eventTime);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    fiber = fiber.return;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\r\n    // will fire for errors that are thrown by destroy functions inside deleted\r\n    // trees. What it should instead do is propagate the error to the parent of\r\n    // the deleted tree. In the meantime, do not add this warning to the\r\n    // allowlist; this is only for our internal use.\r\n    console.error(\r\n      'Internal React error: Attempted to capture a commit phase error ' +\r\n      'inside a detached tree. This indicates a bug in React. Likely ' +\r\n      'causes include deleting the same fiber more than once, committing an ' +\r\n      'already-finished tree, or an inconsistent return pointer.\\n\\n' +\r\n      'Error message:\\n\\n%s',\r\n      error,\r\n    );\r\n  }\r\n}\r\n\r\nexport function pingSuspendedRoot (\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  pingedLanes: Lanes,\r\n) {\r\n  const pingCache = root.pingCache;\r\n  if (pingCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    pingCache.delete(wakeable);\r\n  }\r\n\r\n  const eventTime = requestEventTime();\r\n  markRootPinged(root, pingedLanes, eventTime);\r\n\r\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\r\n\r\n  if (\r\n    workInProgressRoot === root &&\r\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\r\n  ) {\r\n    // Received a ping at the same priority level at which we're currently\r\n    // rendering. We might want to restart this render. This should mirror\r\n    // the logic of whether or not a root suspends once it completes.\r\n\r\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n    // we should probably never restart.\r\n\r\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n    // so we can always restart.\r\n    if (\r\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\r\n      (workInProgressRootExitStatus === RootSuspended &&\r\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\r\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\r\n    ) {\r\n      // Restart from the root.\r\n      prepareFreshStack(root, NoLanes);\r\n    } else {\r\n      // Even though we can't restart right now, we might get an\r\n      // opportunity later. So we mark this render as having a ping.\r\n      workInProgressRootPingedLanes = mergeLanes(\r\n        workInProgressRootPingedLanes,\r\n        pingedLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  ensureRootIsScheduled(root, eventTime);\r\n}\r\n\r\nfunction retryTimedOutBoundary (boundaryFiber: Fiber, retryLane: Lane) {\r\n  // The boundary fiber (a Suspense component or SuspenseList component)\r\n  // previously was rendered in its fallback state. One of the promises that\r\n  // suspended it has resolved, which means at least part of the tree was\r\n  // likely unblocked. Try rendering again, at a new lanes.\r\n  if (retryLane === NoLane) {\r\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\r\n    // unnecessary entanglement?\r\n    retryLane = requestRetryLane(boundaryFiber);\r\n  }\r\n  // TODO: Special case idle priority?\r\n  const eventTime = requestEventTime();\r\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n  if (root !== null) {\r\n    markRootUpdated(root, retryLane, eventTime);\r\n    ensureRootIsScheduled(root, eventTime);\r\n  }\r\n}\r\n\r\nexport function retryDehydratedSuspenseBoundary (boundaryFiber: Fiber) {\r\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n  let retryLane = NoLane;\r\n  if (suspenseState !== null) {\r\n    retryLane = suspenseState.retryLane;\r\n  }\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\nexport function resolveRetryWakeable (boundaryFiber: Fiber, wakeable: Wakeable) {\r\n  let retryLane = NoLane; // Default\r\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\r\n  switch (boundaryFiber.tag) {\r\n    case SuspenseComponent:\r\n      retryCache = boundaryFiber.stateNode;\r\n      const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\r\n      if (suspenseState !== null) {\r\n        retryLane = suspenseState.retryLane;\r\n      }\r\n      break;\r\n    case SuspenseListComponent:\r\n      retryCache = boundaryFiber.stateNode;\r\n      break;\r\n    default:\r\n      throw new Error(\r\n        'Pinged unknown suspense boundary type. ' +\r\n        'This is probably a bug in React.',\r\n      );\r\n  }\r\n\r\n  if (retryCache !== null) {\r\n    // The wakeable resolved, so we no longer need to memoize, because it will\r\n    // never be thrown again.\r\n    retryCache.delete(wakeable);\r\n  }\r\n\r\n  retryTimedOutBoundary(boundaryFiber, retryLane);\r\n}\r\n\r\n// Computes the next Just Noticeable Difference (JND) boundary.\r\n// The theory is that a person can't tell the difference between small differences in time.\r\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n// difference in the experience. However, waiting for longer might mean that we can avoid\r\n// showing an intermediate loading state. The longer we have already waited, the harder it\r\n// is to tell small differences in time. Therefore, the longer we've already waited,\r\n// the longer we can wait additionally. At some point we have to give up though.\r\n// We pick a train model where the next boundary commits at a consistent schedule.\r\n// These particular numbers are vague estimates. We expect to adjust them based on research.\r\nfunction jnd (timeElapsed: number) {\r\n  return timeElapsed < 120\r\n    ? 120\r\n    : timeElapsed < 480\r\n      ? 480\r\n      : timeElapsed < 1080\r\n        ? 1080\r\n        : timeElapsed < 1920\r\n          ? 1920\r\n          : timeElapsed < 3000\r\n            ? 3000\r\n            : timeElapsed < 4320\r\n              ? 4320\r\n              : ceil(timeElapsed / 1960) * 1960;\r\n}\r\n\r\nfunction checkForNestedUpdates () {\r\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n    nestedUpdateCount = 0;\r\n    rootWithNestedUpdates = null;\r\n\r\n    throw new Error(\r\n      'Maximum update depth exceeded. This can happen when a component ' +\r\n      'repeatedly calls setState inside componentWillUpdate or ' +\r\n      'componentDidUpdate. React limits the number of nested updates to ' +\r\n      'prevent infinite loops.',\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n      nestedPassiveUpdateCount = 0;\r\n      rootWithPassiveNestedUpdates = null;\r\n\r\n      console.error(\r\n        'Maximum update depth exceeded. This can happen when a component ' +\r\n        \"calls setState inside useEffect, but useEffect either doesn't \" +\r\n        'have a dependency array, or one of the dependencies changes on ' +\r\n        'every render.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushRenderPhaseStrictModeWarningsInDEV () {\r\n  if (__DEV__) {\r\n    ReactStrictModeWarnings.flushLegacyContextWarning();\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitDoubleInvokeEffectsInDEV (\r\n  fiber: Fiber,\r\n  hasPassiveEffects: boolean,\r\n) {\r\n  if (__DEV__ && enableStrictEffects) {\r\n    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\r\n    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\r\n    // Maybe not a big deal since this is DEV only behavior.\r\n\r\n    setCurrentDebugFiberInDEV(fiber);\r\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\r\n    if (hasPassiveEffects) {\r\n      invokeEffectsInDev(\r\n        fiber,\r\n        MountPassiveDev,\r\n        invokePassiveEffectUnmountInDEV,\r\n      );\r\n    }\r\n\r\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\r\n    if (hasPassiveEffects) {\r\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\r\n    }\r\n    resetCurrentDebugFiberInDEV();\r\n  }\r\n}\r\n\r\nfunction invokeEffectsInDev (\r\n  firstChild: Fiber,\r\n  fiberFlags: Flags,\r\n  invokeEffectFn: (fiber: Fiber) => void,\r\n): void {\r\n  if (__DEV__ && enableStrictEffects) {\r\n    // We don't need to re-check StrictEffectsMode here.\r\n    // This function is only called if that check has already passed.\r\n\r\n    let current = firstChild;\r\n    let subtreeRoot = null;\r\n    while (current !== null) {\r\n      const primarySubtreeFlag = current.subtreeFlags & fiberFlags;\r\n      if (\r\n        current !== subtreeRoot &&\r\n        current.child !== null &&\r\n        primarySubtreeFlag !== NoFlags\r\n      ) {\r\n        current = current.child;\r\n      } else {\r\n        if ((current.flags & fiberFlags) !== NoFlags) {\r\n          invokeEffectFn(current);\r\n        }\r\n\r\n        if (current.sibling !== null) {\r\n          current = current.sibling;\r\n        } else {\r\n          current = subtreeRoot = current.return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\r\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV (fiber) {\r\n  if (__DEV__) {\r\n    if ((executionContext & RenderContext) !== NoContext) {\r\n      // We let the other warning about render phase updates deal with this one.\r\n      return;\r\n    }\r\n\r\n    if (!(fiber.mode & ConcurrentMode)) {\r\n      return;\r\n    }\r\n\r\n    const tag = fiber.tag;\r\n    if (\r\n      tag !== IndeterminateComponent &&\r\n      tag !== HostRoot &&\r\n      tag !== ClassComponent &&\r\n      tag !== FunctionComponent &&\r\n      tag !== ForwardRef &&\r\n      tag !== MemoComponent &&\r\n      tag !== SimpleMemoComponent\r\n    ) {\r\n      // Only warn for user-defined components, not internal ones like Suspense.\r\n      return;\r\n    }\r\n\r\n    // We show the whole stack but dedupe on the top component's name because\r\n    // the problematic code almost always lies inside that component.\r\n    const componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\r\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n        return;\r\n      }\r\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n    } else {\r\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n    }\r\n\r\n    const previousFiber = ReactCurrentFiberCurrent;\r\n    try {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      console.error(\r\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\r\n        'This indicates that you have a side-effect in your render function that ' +\r\n        'asynchronously later calls tries to update the component. Move this work to ' +\r\n        'useEffect instead.',\r\n      );\r\n    } finally {\r\n      if (previousFiber) {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n      } else {\r\n        resetCurrentDebugFiberInDEV();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlet beginWork;\r\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\r\n  const dummyFiber = null;\r\n  /**\r\n   * @param current 当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate\r\n   * @param workInProgress 当前组件对应的Fiber节点\r\n   * @param lanes 优先级相关\r\n   */\r\n  beginWork = (current, unitOfWork, lanes) => {\r\n    // mount阶段current上次更新时的节点为null\r\n    // 组件update时，由于之前已经mount过，所以current !== null。\r\n\r\n    // 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。\r\n\r\n    // If a component throws an error, we replay it again in a synchronously\r\n    // dispatched event, so that the debugger will treat it as an uncaught\r\n    // error See ReactErrorUtils for more information.\r\n\r\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n    // fiber. If beginWork throws, we'll use this to reset the state.\r\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\r\n      dummyFiber,\r\n      unitOfWork,\r\n    );\r\n    try {\r\n      return originalBeginWork(current, unitOfWork, lanes);\r\n    } catch (originalError) {\r\n      if (\r\n        originalError !== null &&\r\n        typeof originalError === 'object' &&\r\n        typeof originalError.then === 'function'\r\n      ) {\r\n        // Don't replay promises. Treat everything else like an error.\r\n        throw originalError;\r\n      }\r\n\r\n      // Keep this code in sync with handleError; any changes here must have\r\n      // corresponding changes there.\r\n      resetContextDependencies();\r\n      resetHooksAfterThrow();\r\n      // Don't reset current debug fiber, since we're about to work on the\r\n      // same fiber again.\r\n\r\n      // Unwind the failed stack frame\r\n      unwindInterruptedWork(current, unitOfWork, workInProgressRootRenderLanes);\r\n\r\n      // Restore the original properties of the fiber.\r\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n\r\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\r\n        // Reset the profiler timer.\r\n        startProfilerTimer(unitOfWork);\r\n      }\r\n\r\n      // Run beginWork again.\r\n      invokeGuardedCallback(\r\n        null,\r\n        originalBeginWork,\r\n        null,\r\n        current,\r\n        unitOfWork,\r\n        lanes,\r\n      );\r\n\r\n      if (hasCaughtError()) {\r\n        const replayError = clearCaughtError();\r\n        if (\r\n          typeof replayError === 'object' &&\r\n          replayError !== null &&\r\n          replayError._suppressLogging &&\r\n          typeof originalError === 'object' &&\r\n          originalError !== null &&\r\n          !originalError._suppressLogging\r\n        ) {\r\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\r\n          originalError._suppressLogging = true;\r\n        }\r\n      }\r\n      // We always throw the original error in case the second render pass is not idempotent.\r\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\r\n      throw originalError;\r\n    }\r\n  };\r\n} else {\r\n  beginWork = originalBeginWork;\r\n}\r\n\r\nlet didWarnAboutUpdateInRender = false;\r\nlet didWarnAboutUpdateInRenderForAnotherComponent;\r\nif (__DEV__) {\r\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n}\r\n\r\nfunction warnAboutRenderPhaseUpdatesInDEV (fiber) {\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentDebugFiberIsRenderingInDEV &&\r\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\r\n    ) {\r\n      switch (fiber.tag) {\r\n        case FunctionComponent:\r\n        case ForwardRef:\r\n        case SimpleMemoComponent: {\r\n          const renderingComponentName =\r\n            (workInProgress && getComponentNameFromFiber(workInProgress)) ||\r\n            'Unknown';\r\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n          const dedupeKey = renderingComponentName;\r\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n            const setStateComponentName =\r\n              getComponentNameFromFiber(fiber) || 'Unknown';\r\n            console.error(\r\n              'Cannot update a component (`%s`) while rendering a ' +\r\n              'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\r\n              'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\r\n              setStateComponentName,\r\n              renderingComponentName,\r\n              renderingComponentName,\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ClassComponent: {\r\n          if (!didWarnAboutUpdateInRender) {\r\n            console.error(\r\n              'Cannot update during an existing state transition (such as ' +\r\n              'within `render`). Render methods should be a pure ' +\r\n              'function of props and state.',\r\n            );\r\n            didWarnAboutUpdateInRender = true;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function restorePendingUpdaters (root: FiberRoot, lanes: Lanes): void {\r\n  if (enableUpdaterTracking) {\r\n    if (isDevToolsPresent) {\r\n      const memoizedUpdaters = root.memoizedUpdaters;\r\n      memoizedUpdaters.forEach(schedulingFiber => {\r\n        addFiberToLanesMap(root, schedulingFiber, lanes);\r\n      });\r\n\r\n      // This function intentionally does not clear memoized updaters.\r\n      // Those may still be relevant to the current commit\r\n      // and a future one (e.g. Suspense).\r\n    }\r\n  }\r\n}\r\n\r\nconst fakeActCallbackNode = {};\r\n// 用于以某个优先级异步调度一个回调函数。\r\nfunction scheduleCallback (priorityLevel, callback) {\r\n  if (__DEV__) {\r\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\r\n    // the `act` queue instead.\r\n    const actQueue = ReactCurrentActQueue.current;\r\n    if (actQueue !== null) {\r\n      actQueue.push(callback);\r\n      return fakeActCallbackNode;\r\n    } else {\r\n      return Scheduler_scheduleCallback(priorityLevel, callback);\r\n    }\r\n  } else {\r\n    // In production, always call Scheduler. This function will be stripped out.\r\n    return Scheduler_scheduleCallback(priorityLevel, callback);\r\n  }\r\n}\r\n\r\nfunction cancelCallback (callbackNode) {\r\n  if (__DEV__ && callbackNode === fakeActCallbackNode) {\r\n    return;\r\n  }\r\n  // In production, always call Scheduler. This function will be stripped out.\r\n  return Scheduler_cancelCallback(callbackNode);\r\n}\r\n\r\nfunction shouldForceFlushFallbacksInDEV () {\r\n  // Never force flush in production. This function should get stripped out.\r\n  return __DEV__ && ReactCurrentActQueue.current !== null;\r\n}\r\n\r\nfunction warnIfUpdatesNotWrappedWithActDEV (fiber: Fiber): void {\r\n  if (__DEV__) {\r\n    if (fiber.mode & ConcurrentMode) {\r\n      if (!isConcurrentActEnvironment()) {\r\n        // Not in an act environment. No need to warn.\r\n        return;\r\n      }\r\n    } else {\r\n      // Legacy mode has additional cases where we suppress a warning.\r\n      if (!isLegacyActEnvironment(fiber)) {\r\n        // Not in an act environment. No need to warn.\r\n        return;\r\n      }\r\n      if (executionContext !== NoContext) {\r\n        // Legacy mode doesn't warn if the update is batched, i.e.\r\n        // batchedUpdates or flushSync.\r\n        return;\r\n      }\r\n      if (\r\n        fiber.tag !== FunctionComponent &&\r\n        fiber.tag !== ForwardRef &&\r\n        fiber.tag !== SimpleMemoComponent\r\n      ) {\r\n        // For backwards compatibility with pre-hooks code, legacy mode only\r\n        // warns for updates that originate from a hook.\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (ReactCurrentActQueue.current === null) {\r\n      const previousFiber = ReactCurrentFiberCurrent;\r\n      try {\r\n        setCurrentDebugFiberInDEV(fiber);\r\n        console.error(\r\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\r\n          'When testing, code that causes React state updates should be ' +\r\n          'wrapped into act(...):\\n\\n' +\r\n          'act(() => {\\n' +\r\n          '  /* fire events that update state */\\n' +\r\n          '});\\n' +\r\n          '/* assert on the output */\\n\\n' +\r\n          \"This ensures that you're testing the behavior the user would see \" +\r\n          'in the browser.' +\r\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n          getComponentNameFromFiber(fiber),\r\n        );\r\n      } finally {\r\n        if (previousFiber) {\r\n          setCurrentDebugFiberInDEV(fiber);\r\n        } else {\r\n          resetCurrentDebugFiberInDEV();\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV (root: FiberRoot): void {\r\n  if (__DEV__) {\r\n    if (\r\n      root.tag !== LegacyRoot &&\r\n      isConcurrentActEnvironment() &&\r\n      ReactCurrentActQueue.current === null\r\n    ) {\r\n      console.error(\r\n        'A suspended resource finished loading inside a test, but the event ' +\r\n        'was not wrapped in act(...).\\n\\n' +\r\n        'When testing, code that resolves suspended data should be wrapped ' +\r\n        'into act(...):\\n\\n' +\r\n        'act(() => {\\n' +\r\n        '  /* finish loading suspended data */\\n' +\r\n        '});\\n' +\r\n        '/* assert on the output */\\n\\n' +\r\n        \"This ensures that you're testing the behavior the user would see \" +\r\n        'in the browser.' +\r\n        ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function setIsRunningInsertionEffect (isRunning: boolean): void {\r\n  if (__DEV__) {\r\n    isRunningInsertionEffect = isRunning;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}