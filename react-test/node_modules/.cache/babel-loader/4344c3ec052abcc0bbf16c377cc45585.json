{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableSuspenseAvoidThisFallback, enableLegacyHidden } from 'shared/ReactFeatureFlags';\nimport { resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions } from './ReactMutableSource.old';\nimport { now } from './Scheduler';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, ContextProvider, ContextConsumer, ForwardRef, Fragment, Mode, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent, TracingMarkerComponent } from './ReactWorkTags';\nimport { NoMode, ConcurrentMode, ProfileMode } from './ReactTypeOfMode';\nimport { Ref, RefStatic, Placement, Update, Visibility, NoFlags, DidCapture, Snapshot, ChildDeletion, StaticMask, MutationMask, Passive, Incomplete, ShouldCapture, ForceClientRender } from './ReactFiberFlags';\nimport { createInstance, createTextInstance, appendInitialChild, finalizeInitialChildren, prepareUpdate, supportsMutation, supportsPersistence, cloneInstance, cloneHiddenInstance, cloneHiddenTextInstance, createContainerChildSet, appendChildToContainerChildSet, finalizeContainerChildren, preparePortalMount, prepareScopeUpdate } from './ReactFiberHostConfig';\nimport { getRootHostContainer, popHostContext, getHostContext, popHostContainer } from './ReactFiberHostContext.old';\nimport { suspenseStackCursor, InvisibleParentSuspenseContext, hasSuspenseContext, popSuspenseContext, pushSuspenseContext, setShallowSuspenseContext, ForceSuspenseFallback, setDefaultShallowSuspenseContext } from './ReactFiberSuspenseContext.old';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent.old';\nimport { isContextProvider as isLegacyContextProvider, popContext as popLegacyContext, popTopLevelContextObject as popTopLevelLegacyContextObject } from './ReactFiberContext.old';\nimport { popProvider } from './ReactFiberNewContext.old';\nimport { prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, warnIfUnhydratedTailNodes, popHydrationState, resetHydrationState, getIsHydrating, hasUnhydratedTailNodes, upgradeHydrationErrorsToRecoverable } from './ReactFiberHydrationContext.old';\nimport { enableSuspenseCallback, enableScopeAPI, enableProfilerTimer, enableCache, enableSuspenseLayoutEffectSemantics, enablePersistentOffscreenHostContainer, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { renderDidSuspend, renderDidSuspendDelayIfPossible, renderHasNotSuspendedYet, popRenderLanes, getRenderTargetTime, subtreeRenderLanes, getWorkInProgressTransitions } from './ReactFiberWorkLoop.old';\nimport { OffscreenLane, SomeRetryLane, NoLanes, includesSomeLane, mergeLanes } from './ReactFiberLane.old';\nimport { resetChildFibers } from './ReactChildFiber.old';\nimport { createScopeInstance } from './ReactFiberScope.old';\nimport { transferActualDuration } from './ReactProfilerTimer.old';\nimport { popCacheProvider } from './ReactFiberCacheComponent.old';\nimport { popTreeContext } from './ReactFiberTreeContext.old';\nimport { popRootTransition, popTransition } from './ReactFiberTransition.old';\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef(workInProgress) {\n  workInProgress.flags |= Ref;\n\n  if (enableSuspenseLayoutEffectSemantics) {\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction hadNoMutationsEffects(current, completedWork) {\n  const didBailout = current !== null && current.child === completedWork.child;\n\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n\n\n  let child = completedWork.child;\n\n  while (child !== null) {\n    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n      return false;\n    }\n\n    child = child.sibling;\n  }\n\n  return true;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\n\nif (supportsMutation) {\n  // Mutation mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // update时执行该方法\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    // 保存原先状态\n    const oldProps = current.memoizedProps;\n\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    } // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n\n\n    const instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n\n    const updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n    // 被处理完的props被赋值给workInProgress.updateQueue，并最终会在commit阶段被渲染在页面上。\n    // 其中updatePayload为数组形式，他的偶数索引的值为变化的prop key，奇数索引的值为变化的prop value。\n\n    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        if (enablePersistentOffscreenHostContainer) {\n          appendAllChildren(parent, node, false, false);\n        } else {\n          appendAllChildren(parent, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n  const appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        if (enablePersistentOffscreenHostContainer) {\n          appendAllChildrenToContainer(containerChildSet, node, false, false);\n        } else {\n          appendAllChildrenToContainer(containerChildSet, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {\n    const portalOrRoot = workInProgress.stateNode;\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged) {// No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      const newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // mount时执行这个方法\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    const recyclableInstance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    const newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    workInProgress.stateNode = newInstance;\n\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {// Noop\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {// Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n\n  switch (renderState.tailMode) {\n    case 'hidden':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          renderState.tail = null;\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n\n    case 'collapsed':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          if (!hasRenderedATailFallback && renderState.tail !== null) {\n            // We suspended during the head. We want to show at least one\n            // row at the tail. So we'll keep on and cut off the rest.\n            renderState.tail.sibling = null;\n          } else {\n            renderState.tail = null;\n          }\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n  }\n}\n\nfunction bubbleProperties(completedWork) {\n  const didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n  let newChildLanes = NoLanes;\n  let subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let actualDuration = completedWork.actualDuration;\n      let treeBaseDuration = completedWork.selfBaseDuration;\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n\n        actualDuration += child.actualDuration;\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        child.return = completedWork;\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let treeBaseDuration = completedWork.selfBaseDuration;\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask;\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        child.return = completedWork;\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\n\nexport function completeSuspendedOffscreenHostContainer(current, workInProgress) {\n  // This is a fork of the complete phase for HostComponent. We use it when\n  // a suspense tree is in its fallback state, because in that case the primary\n  // tree that includes the offscreen boundary is skipped over without a\n  // regular complete phase.\n  //\n  // We can optimize this path further by inlining the update logic for\n  // offscreen instances specifically, i.e. skipping the `prepareUpdate` call.\n  const rootContainerInstance = getRootHostContainer();\n  const type = workInProgress.type;\n  const newProps = workInProgress.memoizedProps;\n\n  if (current !== null) {\n    updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n  } else {\n    const currentHostContext = getHostContext();\n    const instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n    appendAllChildren(instance, workInProgress, false, false);\n    workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n    // (eg DOM renderer supports auto-focus for certain elements).\n    // Make sure such renderers get scheduled for later work.\n\n    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    if (workInProgress.ref !== null) {\n      // If there is a ref on a host node we need to schedule a callback\n      markRef(workInProgress);\n    }\n  }\n\n  bubbleProperties(workInProgress);\n} // completeWork主要工作是处理fiber的props、创建dom、创建effectList\n\nfunction completeWork(current, workInProgress, renderLanes) {\n  const newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n\n  popTreeContext(workInProgress); //根据workInProgress.tag进入不同逻辑，这里我们关注HostComponent，HostComponent，其他类型之后在讲\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostRoot:\n      {\n        const fiberRoot = workInProgress.stateNode;\n\n        if (enableTransitionTracing) {\n          const transitions = getWorkInProgressTransitions(); // We set the Passive flag here because if there are new transitions,\n          // we will need to schedule callbacks and process the transitions,\n          // which we do in the passive phase\n\n          if (transitions !== null) {\n            workInProgress.flags |= Passive;\n          }\n        }\n\n        if (enableCache) {\n          let previousCache = null;\n\n          if (current !== null) {\n            previousCache = current.memoizedState.cache;\n          }\n\n          const cache = workInProgress.memoizedState.cache;\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n\n          popCacheProvider(workInProgress, cache);\n        }\n\n        popRootTransition(workInProgress, fiberRoot, renderLanes);\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        resetMutableSourceWorkInProgressVersions();\n\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // If we hydrated, then we'll need to schedule an update for\n            // the commit side-effects on the root.\n            markUpdate(workInProgress);\n          } else {\n            if (current !== null) {\n              const prevState = current.memoizedState;\n\n              if ( // Check if this is a client root\n              !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n              (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                // Schedule an effect to clear this container at the start of the\n                // next commit. This handles the case of React rendering into a\n                // container with previous children. It's also safe to do for\n                // updates too, because current.child would only be null if the\n                // previous render was null (so the container would already\n                // be empty).\n                workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                // recoverable errors during first hydration attempt. If so, add\n                // them to a queue so we can log them in the commit phase.\n\n                upgradeHydrationErrorsToRecoverable();\n              }\n            }\n          }\n        }\n\n        updateHostContainer(current, workInProgress);\n        bubbleProperties(workInProgress);\n\n        if (enableTransitionTracing) {\n          if ((workInProgress.subtreeFlags & Visibility) !== NoFlags) {\n            // If any of our suspense children toggle visibility, this means that\n            // the pending boundaries array needs to be updated, which we only\n            // do in the passive phase.\n            workInProgress.flags |= Passive;\n          }\n        }\n\n        return null;\n      }\n\n    case HostComponent:\n      {\n        // 原生节点的处理逻辑\n        popHostContext(workInProgress);\n        const rootContainerInstance = getRootHostContainer();\n        const type = workInProgress.type; // update时\n\n        if (current !== null && workInProgress.stateNode != null) {\n          // 处理props（包括onClick、style、children ...），并将处理好的props赋值给updatePayload,最后会保存在workInProgress.updateQueue上\n          // 当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：\n          // onClick、onChange等回调函数的注册\n          // 处理style prop\n          // 处理DANGEROUSLY_SET_INNER_HTML prop\n          // 处理children prop\n          // 主要逻辑\n          updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          // mount时\n          if (!newProps) {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n\n            bubbleProperties(workInProgress);\n            return null;\n          }\n\n          const currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on whether we want to add them top->down or\n          // bottom->up. Top->down is faster in IE11.\n\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node need to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            // 创建fiber对应的dom节点\n            const instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress); // 将后代dom节点插入刚创建的dom里\n\n            appendAllChildren(instance, workInProgress, false, false); // dom节点赋值给fiber.stateNode\n\n            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            // 处理props和updateHostComponent类似\n\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostText:\n      {\n        const newText = newProps;\n\n        if (current && workInProgress.stateNode != null) {\n          const oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n          }\n\n          const rootContainerInstance = getRootHostContainer();\n          const currentHostContext = getHostContext();\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        const nextState = workInProgress.memoizedState;\n\n        if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n          warnIfUnhydratedTailNodes(workInProgress);\n          resetHydrationState();\n          workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n          return workInProgress;\n        }\n\n        if (nextState !== null && nextState.dehydrated !== null) {\n          // We might be inside a hydration state the first time we're picking up this\n          // Suspense boundary, and also after we've reentered it for further hydration.\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (current === null) {\n            if (!wasHydrated) {\n              throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n            }\n\n            prepareToHydrateHostSuspenseInstance(workInProgress);\n            bubbleProperties(workInProgress);\n\n            if (enableProfilerTimer) {\n              if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                const isTimedOutSuspense = nextState !== null;\n\n                if (isTimedOutSuspense) {\n                  // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                  const primaryChildFragment = workInProgress.child;\n\n                  if (primaryChildFragment !== null) {\n                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                  }\n                }\n              }\n            }\n\n            return null;\n          } else {\n            // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n            // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n            resetHydrationState();\n\n            if ((workInProgress.flags & DidCapture) === NoFlags) {\n              // This boundary did not suspend so it's now hydrated and unsuspended.\n              workInProgress.memoizedState = null;\n            } // If nothing suspended, we need to schedule an effect to mark this boundary\n            // as having hydrated so events know that they're free to be invoked.\n            // It's also a signal to replay events and the suspense callback.\n            // If something suspended, schedule an effect to attach retry listeners.\n            // So we might as well always mark this.\n\n\n            workInProgress.flags |= Update;\n            bubbleProperties(workInProgress);\n\n            if (enableProfilerTimer) {\n              if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                const isTimedOutSuspense = nextState !== null;\n\n                if (isTimedOutSuspense) {\n                  // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                  const primaryChildFragment = workInProgress.child;\n\n                  if (primaryChildFragment !== null) {\n                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                  }\n                }\n              }\n            }\n\n            return null;\n          }\n        } // Successfully completed this tree. If this was a forced client render,\n        // there may have been recoverable errors during first hydration\n        // attempt. If so, add them to a queue so we can log them in the\n        // commit phase.\n\n\n        upgradeHydrationErrorsToRecoverable();\n\n        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n          // Something suspended. Re-render with the fallback children.\n          workInProgress.lanes = renderLanes; // Do not reset the effect list.\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          } // Don't bubble properties in this case.\n\n\n          return workInProgress;\n        }\n\n        const nextDidTimeout = nextState !== null;\n        let prevDidTimeout = false;\n\n        if (current === null) {\n          popHydrationState(workInProgress);\n        } else {\n          const prevState = current.memoizedState;\n          prevDidTimeout = prevState !== null;\n        }\n\n        if (enableCache && nextDidTimeout) {\n          const offscreenFiber = workInProgress.child;\n          let previousCache = null;\n\n          if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {\n            previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n          }\n\n          let cache = null;\n\n          if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {\n            cache = offscreenFiber.memoizedState.cachePool.pool;\n          }\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            offscreenFiber.flags |= Passive;\n          }\n        } // If the suspended state of the boundary changes, we need to schedule\n        // a passive effect, which is when we process the transitions\n\n\n        if (nextDidTimeout !== prevDidTimeout) {\n          if (enableTransitionTracing) {\n            const offscreenFiber = workInProgress.child;\n            offscreenFiber.flags |= Passive;\n          } // If the suspended state of the boundary changes, we need to schedule\n          // an effect to toggle the subtree's visibility. When we switch from\n          // fallback -> primary, the inner Offscreen fiber schedules this effect\n          // as part of its normal complete phase. But when we switch from\n          // primary -> fallback, the inner Offscreen fiber does not have a complete\n          // phase. So we need to schedule its effect here.\n          //\n          // We also use this flag to connect/disconnect the effects, but the same\n          // logic applies: when re-connecting, the Offscreen fiber's complete\n          // phase will handle scheduling the effect. It's only when the fallback\n          // is active that we have to do anything special.\n\n\n          if (nextDidTimeout) {\n            const offscreenFiber = workInProgress.child;\n            offscreenFiber.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n            // in the concurrent tree already suspended during this render.\n            // This is a known bug.\n\n            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n              // TODO: Move this back to throwException because this is too late\n              // if this is a large tree which is common for initial loads. We\n              // don't know if we should restart a render or not until we get\n              // this marker, and this is too late.\n              // If this render already had a ping or lower pri updates,\n              // and this is the first time we know we're going to suspend we\n              // should be able to immediately restart from within throwException.\n              const hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n\n              if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                // If this was in an invisible tree or a new render, then showing\n                // this boundary is ok.\n                renderDidSuspend();\n              } else {\n                // Otherwise, we're going to have to hide content so we should\n                // suspend for longer if possible.\n                renderDidSuspendDelayIfPossible();\n              }\n            }\n          }\n        }\n\n        const wakeables = workInProgress.updateQueue;\n\n        if (wakeables !== null) {\n          // Schedule an effect to attach a retry listener to the promise.\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        if (enableSuspenseCallback && workInProgress.updateQueue !== null && workInProgress.memoizedProps.suspenseCallback != null) {\n          // Always notify the callback\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        bubbleProperties(workInProgress);\n\n        if (enableProfilerTimer) {\n          if ((workInProgress.mode & ProfileMode) !== NoMode) {\n            if (nextDidTimeout) {\n              // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n              const primaryChildFragment = workInProgress.child;\n\n              if (primaryChildFragment !== null) {\n                // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ContextProvider:\n      // Pop provider fiber\n      const context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n\n    case IncompleteClassComponent:\n      {\n        // Same as class component case. I put it down here so that the tags are\n        // sequential to ensure this switch is compiled to a jump table.\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress);\n        const renderState = workInProgress.memoizedState;\n\n        if (renderState === null) {\n          // We're running in the default, \"independent\" mode.\n          // We don't do anything in this mode.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        let didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n        const renderedTail = renderState.rendering;\n\n        if (renderedTail === null) {\n          // We just rendered the head.\n          if (!didSuspendAlready) {\n            // This is the first pass. We need to figure out if anything is still\n            // suspended in the rendered set.\n            // If new content unsuspended, but there's still some content that\n            // didn't. Then we need to do a second pass that forces everything\n            // to keep showing their fallbacks.\n            // We might be suspended if something in this render pass suspended, or\n            // something in the previous committed pass suspended. Otherwise,\n            // there's no chance so we can skip the expensive call to\n            // findFirstSuspended.\n            const cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n\n            if (!cannotBeSuspended) {\n              let row = workInProgress.child;\n\n              while (row !== null) {\n                const suspended = findFirstSuspended(row);\n\n                if (suspended !== null) {\n                  didSuspendAlready = true;\n                  workInProgress.flags |= DidCapture;\n                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                  // part of the second pass. In that case nothing will subscribe to\n                  // its thenables. Instead, we'll transfer its thenables to the\n                  // SuspenseList so that it can retry if they resolve.\n                  // There might be multiple of these in the list but since we're\n                  // going to wait for all of them anyway, it doesn't really matter\n                  // which ones gets to ping. In theory we could get clever and keep\n                  // track of how many dependencies remain but it gets tricky because\n                  // in the meantime, we can add/remove/change items and dependencies.\n                  // We might bail out of the loop before finding any but that\n                  // doesn't matter since that means that the other boundaries that\n                  // we did find already has their listeners attached.\n\n                  const newThenables = suspended.updateQueue;\n\n                  if (newThenables !== null) {\n                    workInProgress.updateQueue = newThenables;\n                    workInProgress.flags |= Update;\n                  } // Rerender the whole list, but this time, we'll force fallbacks\n                  // to stay in place.\n                  // Reset the effect flags before doing the second pass since that's now invalid.\n                  // Reset the child fibers to their original state.\n\n\n                  workInProgress.subtreeFlags = NoFlags;\n                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                  // rerender the children.\n\n                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n\n                  return workInProgress.child;\n                }\n\n                row = row.sibling;\n              }\n            }\n\n            if (renderState.tail !== null && now() > getRenderTargetTime()) {\n              // We have already passed our CPU deadline but we still have rows\n              // left in the tail. We'll just give up further attempts to render\n              // the main content and only render fallbacks.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          } else {\n            cutOffTailIfNeeded(renderState, false);\n          } // Next we're going to render the tail.\n\n        } else {\n          // Append the rendered row to the child list.\n          if (!didSuspendAlready) {\n            const suspended = findFirstSuspended(renderedTail);\n\n            if (suspended !== null) {\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n              // get lost if this row ends up dropped during a second pass.\n\n              const newThenables = suspended.updateQueue;\n\n              if (newThenables !== null) {\n                workInProgress.updateQueue = newThenables;\n                workInProgress.flags |= Update;\n              }\n\n              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n              ) {\n                // We're done.\n                bubbleProperties(workInProgress);\n                return null;\n              }\n            } else if ( // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n              // We have now passed our CPU deadline and we'll just give up further\n              // attempts to render the main content and only render fallbacks.\n              // The assumption is that this is usually faster.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          }\n\n          if (renderState.isBackwards) {\n            // The effect list of the backwards tail will have been added\n            // to the end. This breaks the guarantee that life-cycles fire in\n            // sibling order but that isn't a strong guarantee promised by React.\n            // Especially since these might also just pop in during future commits.\n            // Append to the beginning of the list.\n            renderedTail.sibling = workInProgress.child;\n            workInProgress.child = renderedTail;\n          } else {\n            const previousSibling = renderState.last;\n\n            if (previousSibling !== null) {\n              previousSibling.sibling = renderedTail;\n            } else {\n              workInProgress.child = renderedTail;\n            }\n\n            renderState.last = renderedTail;\n          }\n        }\n\n        if (renderState.tail !== null) {\n          // We still have tail rows to render.\n          // Pop a row.\n          const next = renderState.tail;\n          renderState.rendering = next;\n          renderState.tail = next.sibling;\n          renderState.renderingStartTime = now();\n          next.sibling = null; // Restore the context.\n          // TODO: We can probably just avoid popping it instead and only\n          // setting it the first time we go from not suspended to suspended.\n\n          let suspenseContext = suspenseStackCursor.current;\n\n          if (didSuspendAlready) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          } else {\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n\n          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n          // Don't bubble properties in this case.\n\n          return next;\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          if (current === null) {\n            const scopeInstance = createScopeInstance();\n            workInProgress.stateNode = scopeInstance;\n            prepareScopeUpdate(scopeInstance, workInProgress);\n\n            if (workInProgress.ref !== null) {\n              markRef(workInProgress);\n              markUpdate(workInProgress);\n            }\n          } else {\n            if (workInProgress.ref !== null) {\n              markUpdate(workInProgress);\n            }\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          }\n\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        popRenderLanes(workInProgress);\n        const nextState = workInProgress.memoizedState;\n        const nextIsHidden = nextState !== null;\n\n        if (current !== null) {\n          const prevState = current.memoizedState;\n          const prevIsHidden = prevState !== null;\n\n          if (prevIsHidden !== nextIsHidden && ( // LegacyHidden doesn't do any hiding — it only pre-renders.\n          !enableLegacyHidden || workInProgress.tag !== LegacyHiddenComponent)) {\n            workInProgress.flags |= Visibility;\n          }\n        }\n\n        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n          bubbleProperties(workInProgress);\n        } else {\n          // Don't bubble properties for hidden children unless we're rendering\n          // at offscreen priority.\n          if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n            bubbleProperties(workInProgress);\n\n            if (supportsMutation) {\n              // Check if there was an insertion or update in the hidden subtree.\n              // If so, we need to hide those nodes in the commit phase, so\n              // schedule a visibility effect.\n              if ((!enableLegacyHidden || workInProgress.tag !== LegacyHiddenComponent) && workInProgress.subtreeFlags & (Placement | Update)) {\n                workInProgress.flags |= Visibility;\n              }\n            }\n          }\n        }\n\n        if (enableCache) {\n          let previousCache = null;\n\n          if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n            previousCache = current.memoizedState.cachePool.pool;\n          }\n\n          let cache = null;\n\n          if (workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null) {\n            cache = workInProgress.memoizedState.cachePool.pool;\n          }\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n        }\n\n        popTransition(workInProgress, current);\n        return null;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (current !== null) {\n            previousCache = current.memoizedState.cache;\n          }\n\n          const cache = workInProgress.memoizedState.cache;\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n\n          popCacheProvider(workInProgress, cache);\n          bubbleProperties(workInProgress);\n        }\n\n        return null;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          // Bubble subtree flags before so we can set the flag property\n          bubbleProperties(workInProgress);\n        }\n\n        return null;\n      }\n  }\n\n  throw new Error(`Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` + 'React. Please file an issue.');\n}\n\nexport { completeWork };","map":{"version":3,"names":["enableSuspenseAvoidThisFallback","enableLegacyHidden","resetWorkInProgressVersions","resetMutableSourceWorkInProgressVersions","now","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","ContextProvider","ContextConsumer","ForwardRef","Fragment","Mode","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","TracingMarkerComponent","NoMode","ConcurrentMode","ProfileMode","Ref","RefStatic","Placement","Update","Visibility","NoFlags","DidCapture","Snapshot","ChildDeletion","StaticMask","MutationMask","Passive","Incomplete","ShouldCapture","ForceClientRender","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","supportsMutation","supportsPersistence","cloneInstance","cloneHiddenInstance","cloneHiddenTextInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","preparePortalMount","prepareScopeUpdate","getRootHostContainer","popHostContext","getHostContext","popHostContainer","suspenseStackCursor","InvisibleParentSuspenseContext","hasSuspenseContext","popSuspenseContext","pushSuspenseContext","setShallowSuspenseContext","ForceSuspenseFallback","setDefaultShallowSuspenseContext","findFirstSuspended","isContextProvider","isLegacyContextProvider","popContext","popLegacyContext","popTopLevelContextObject","popTopLevelLegacyContextObject","popProvider","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","prepareToHydrateHostSuspenseInstance","warnIfUnhydratedTailNodes","popHydrationState","resetHydrationState","getIsHydrating","hasUnhydratedTailNodes","upgradeHydrationErrorsToRecoverable","enableSuspenseCallback","enableScopeAPI","enableProfilerTimer","enableCache","enableSuspenseLayoutEffectSemantics","enablePersistentOffscreenHostContainer","enableTransitionTracing","renderDidSuspend","renderDidSuspendDelayIfPossible","renderHasNotSuspendedYet","popRenderLanes","getRenderTargetTime","subtreeRenderLanes","getWorkInProgressTransitions","OffscreenLane","SomeRetryLane","NoLanes","includesSomeLane","mergeLanes","resetChildFibers","createScopeInstance","transferActualDuration","popCacheProvider","popTreeContext","popRootTransition","popTransition","markUpdate","workInProgress","flags","markRef","hadNoMutationsEffects","current","completedWork","didBailout","child","subtreeFlags","sibling","appendAllChildren","updateHostContainer","updateHostComponent","updateHostText","parent","needsVisibilityToggle","isHidden","node","tag","stateNode","return","type","newProps","rootContainerInstance","oldProps","memoizedProps","instance","currentHostContext","updatePayload","updateQueue","oldText","newText","branches","props","text","memoizedState","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","containerInfo","newChildSet","pendingChildren","currentInstance","recyclableInstance","newInstance","cutOffTailIfNeeded","renderState","hasRenderedATailFallback","tailMode","tailNode","tail","lastTailNode","alternate","bubbleProperties","newChildLanes","mode","actualDuration","treeBaseDuration","selfBaseDuration","lanes","childLanes","completeSuspendedOffscreenHostContainer","ref","completeWork","renderLanes","pendingProps","Component","fiberRoot","transitions","previousCache","cache","pendingContext","context","wasHydrated","prevState","isDehydrated","Error","nextState","dehydrated","isTimedOutSuspense","primaryChildFragment","nextDidTimeout","prevDidTimeout","offscreenFiber","cachePool","pool","hasInvisibleChildContext","unstable_avoidThisFallback","wakeables","suspenseCallback","_context","didSuspendAlready","renderedTail","rendering","cannotBeSuspended","row","suspended","newThenables","renderingStartTime","isBackwards","previousSibling","last","next","suspenseContext","scopeInstance","nextIsHidden","prevIsHidden"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberCompleteWork.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { Fiber } from './ReactInternalTypes';\r\nimport type { RootState } from './ReactFiberRoot.old';\r\nimport type { Lanes, Lane } from './ReactFiberLane.old';\r\nimport type {\r\n  ReactScopeInstance,\r\n  ReactContext,\r\n  Wakeable,\r\n} from 'shared/ReactTypes';\r\nimport type { FiberRoot } from './ReactInternalTypes';\r\nimport type {\r\n  Instance,\r\n  Type,\r\n  Props,\r\n  Container,\r\n  ChildSet,\r\n} from './ReactFiberHostConfig';\r\nimport type {\r\n  SuspenseState,\r\n  SuspenseListRenderState,\r\n} from './ReactFiberSuspenseComponent.old';\r\nimport type { SuspenseContext } from './ReactFiberSuspenseContext.old';\r\nimport type { OffscreenState } from './ReactFiberOffscreenComponent';\r\nimport type { Cache } from './ReactFiberCacheComponent.old';\r\nimport {\r\n  enableSuspenseAvoidThisFallback,\r\n  enableLegacyHidden,\r\n} from 'shared/ReactFeatureFlags';\r\n\r\nimport { resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions } from './ReactMutableSource.old';\r\n\r\nimport { now } from './Scheduler';\r\n\r\nimport {\r\n  IndeterminateComponent,\r\n  FunctionComponent,\r\n  ClassComponent,\r\n  HostRoot,\r\n  HostComponent,\r\n  HostText,\r\n  HostPortal,\r\n  ContextProvider,\r\n  ContextConsumer,\r\n  ForwardRef,\r\n  Fragment,\r\n  Mode,\r\n  Profiler,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  LazyComponent,\r\n  IncompleteClassComponent,\r\n  ScopeComponent,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  CacheComponent,\r\n  TracingMarkerComponent,\r\n} from './ReactWorkTags';\r\nimport { NoMode, ConcurrentMode, ProfileMode } from './ReactTypeOfMode';\r\nimport {\r\n  Ref,\r\n  RefStatic,\r\n  Placement,\r\n  Update,\r\n  Visibility,\r\n  NoFlags,\r\n  DidCapture,\r\n  Snapshot,\r\n  ChildDeletion,\r\n  StaticMask,\r\n  MutationMask,\r\n  Passive,\r\n  Incomplete,\r\n  ShouldCapture,\r\n  ForceClientRender,\r\n} from './ReactFiberFlags';\r\n\r\nimport {\r\n  createInstance,\r\n  createTextInstance,\r\n  appendInitialChild,\r\n  finalizeInitialChildren,\r\n  prepareUpdate,\r\n  supportsMutation,\r\n  supportsPersistence,\r\n  cloneInstance,\r\n  cloneHiddenInstance,\r\n  cloneHiddenTextInstance,\r\n  createContainerChildSet,\r\n  appendChildToContainerChildSet,\r\n  finalizeContainerChildren,\r\n  preparePortalMount,\r\n  prepareScopeUpdate,\r\n} from './ReactFiberHostConfig';\r\nimport {\r\n  getRootHostContainer,\r\n  popHostContext,\r\n  getHostContext,\r\n  popHostContainer,\r\n} from './ReactFiberHostContext.old';\r\nimport {\r\n  suspenseStackCursor,\r\n  InvisibleParentSuspenseContext,\r\n  hasSuspenseContext,\r\n  popSuspenseContext,\r\n  pushSuspenseContext,\r\n  setShallowSuspenseContext,\r\n  ForceSuspenseFallback,\r\n  setDefaultShallowSuspenseContext,\r\n} from './ReactFiberSuspenseContext.old';\r\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent.old';\r\nimport {\r\n  isContextProvider as isLegacyContextProvider,\r\n  popContext as popLegacyContext,\r\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\r\n} from './ReactFiberContext.old';\r\nimport { popProvider } from './ReactFiberNewContext.old';\r\nimport {\r\n  prepareToHydrateHostInstance,\r\n  prepareToHydrateHostTextInstance,\r\n  prepareToHydrateHostSuspenseInstance,\r\n  warnIfUnhydratedTailNodes,\r\n  popHydrationState,\r\n  resetHydrationState,\r\n  getIsHydrating,\r\n  hasUnhydratedTailNodes,\r\n  upgradeHydrationErrorsToRecoverable,\r\n} from './ReactFiberHydrationContext.old';\r\nimport {\r\n  enableSuspenseCallback,\r\n  enableScopeAPI,\r\n  enableProfilerTimer,\r\n  enableCache,\r\n  enableSuspenseLayoutEffectSemantics,\r\n  enablePersistentOffscreenHostContainer,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {\r\n  renderDidSuspend,\r\n  renderDidSuspendDelayIfPossible,\r\n  renderHasNotSuspendedYet,\r\n  popRenderLanes,\r\n  getRenderTargetTime,\r\n  subtreeRenderLanes,\r\n  getWorkInProgressTransitions,\r\n} from './ReactFiberWorkLoop.old';\r\nimport {\r\n  OffscreenLane,\r\n  SomeRetryLane,\r\n  NoLanes,\r\n  includesSomeLane,\r\n  mergeLanes,\r\n} from './ReactFiberLane.old';\r\nimport { resetChildFibers } from './ReactChildFiber.old';\r\nimport { createScopeInstance } from './ReactFiberScope.old';\r\nimport { transferActualDuration } from './ReactProfilerTimer.old';\r\nimport { popCacheProvider } from './ReactFiberCacheComponent.old';\r\nimport { popTreeContext } from './ReactFiberTreeContext.old';\r\nimport { popRootTransition, popTransition } from './ReactFiberTransition.old';\r\n\r\nfunction markUpdate (workInProgress: Fiber) {\r\n  // Tag the fiber with an update effect. This turns a Placement into\r\n  // a PlacementAndUpdate.\r\n  workInProgress.flags |= Update;\r\n}\r\n\r\nfunction markRef (workInProgress: Fiber) {\r\n  workInProgress.flags |= Ref;\r\n  if (enableSuspenseLayoutEffectSemantics) {\r\n    workInProgress.flags |= RefStatic;\r\n  }\r\n}\r\n\r\nfunction hadNoMutationsEffects (current: null | Fiber, completedWork: Fiber) {\r\n  const didBailout = current !== null && current.child === completedWork.child;\r\n  if (didBailout) {\r\n    return true;\r\n  }\r\n\r\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\r\n    return false;\r\n  }\r\n\r\n  // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\r\n  // then we only have to check the `completedWork.subtreeFlags`.\r\n  let child = completedWork.child;\r\n  while (child !== null) {\r\n    if (\r\n      (child.flags & MutationMask) !== NoFlags ||\r\n      (child.subtreeFlags & MutationMask) !== NoFlags\r\n    ) {\r\n      return false;\r\n    }\r\n    child = child.sibling;\r\n  }\r\n  return true;\r\n}\r\n\r\nlet appendAllChildren;\r\nlet updateHostContainer;\r\nlet updateHostComponent;\r\nlet updateHostText;\r\nif (supportsMutation) {\r\n  // Mutation mode\r\n\r\n  appendAllChildren = function (\r\n    parent: Instance,\r\n    workInProgress: Fiber,\r\n    needsVisibilityToggle: boolean,\r\n    isHidden: boolean,\r\n  ) {\r\n    // We only have the top Fiber that was created but we need recurse down its\r\n    // children to find all the terminal nodes.\r\n    let node = workInProgress.child;\r\n    while (node !== null) {\r\n      if (node.tag === HostComponent || node.tag === HostText) {\r\n        appendInitialChild(parent, node.stateNode);\r\n      } else if (node.tag === HostPortal) {\r\n        // If we have a portal child, then we don't want to traverse\r\n        // down its children. Instead, we'll get insertions from each child in\r\n        // the portal directly.\r\n      } else if (node.child !== null) {\r\n        node.child.return = node;\r\n        node = node.child;\r\n        continue;\r\n      }\r\n      if (node === workInProgress) {\r\n        return;\r\n      }\r\n      while (node.sibling === null) {\r\n        if (node.return === null || node.return === workInProgress) {\r\n          return;\r\n        }\r\n        node = node.return;\r\n      }\r\n      node.sibling.return = node.return;\r\n      node = node.sibling;\r\n    }\r\n  };\r\n\r\n  updateHostContainer = function (current: null | Fiber, workInProgress: Fiber) {\r\n    // Noop\r\n  };\r\n  updateHostComponent = function (\r\n    current: Fiber,\r\n    workInProgress: Fiber,\r\n    type: Type,\r\n    newProps: Props,\r\n    rootContainerInstance: Container,\r\n  ) {\r\n    // update时执行该方法\r\n    // If we have an alternate, that means this is an update and we need to\r\n    // schedule a side-effect to do the updates.\r\n    // 保存原先状态\r\n    const oldProps = current.memoizedProps;\r\n    if (oldProps === newProps) {\r\n      // In mutation mode, this is sufficient for a bailout because\r\n      // we won't touch this node even if children changed.\r\n      return;\r\n    }\r\n\r\n    // If we get updated because one of our children updated, we don't\r\n    // have newProps so we'll have to reuse them.\r\n    // TODO: Split the update API as separate for the props vs. children.\r\n    // Even better would be if children weren't special cased at all tho.\r\n    const instance: Instance = workInProgress.stateNode;\r\n    const currentHostContext = getHostContext();\r\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\r\n    // component is hitting the resume path. Figure out why. Possibly\r\n    // related to `hidden`.\r\n    const updatePayload = prepareUpdate(\r\n      instance,\r\n      type,\r\n      oldProps,\r\n      newProps,\r\n      rootContainerInstance,\r\n      currentHostContext,\r\n    );\r\n    // TODO: Type this specific to this type of component.\r\n\r\n\r\n    // 被处理完的props被赋值给workInProgress.updateQueue，并最终会在commit阶段被渲染在页面上。\r\n    // 其中updatePayload为数组形式，他的偶数索引的值为变化的prop key，奇数索引的值为变化的prop value。\r\n    workInProgress.updateQueue = (updatePayload: any);\r\n    // If the update payload indicates that there is a change or if there\r\n    // is a new ref we mark this as an update. All the work is done in commitWork.\r\n    if (updatePayload) {\r\n      markUpdate(workInProgress);\r\n    }\r\n  };\r\n  updateHostText = function (\r\n    current: Fiber,\r\n    workInProgress: Fiber,\r\n    oldText: string,\r\n    newText: string,\r\n  ) {\r\n    // If the text differs, mark it as an update. All the work in done in commitWork.\r\n    if (oldText !== newText) {\r\n      markUpdate(workInProgress);\r\n    }\r\n  };\r\n} else if (supportsPersistence) {\r\n  // Persistent host tree mode\r\n\r\n  appendAllChildren = function (\r\n    parent: Instance,\r\n    workInProgress: Fiber,\r\n    needsVisibilityToggle: boolean,\r\n    isHidden: boolean,\r\n  ) {\r\n    // We only have the top Fiber that was created but we need recurse down its\r\n    // children to find all the terminal nodes.\r\n    let node = workInProgress.child;\r\n    while (node !== null) {\r\n      // eslint-disable-next-line no-labels\r\n      branches: if (node.tag === HostComponent) {\r\n        let instance = node.stateNode;\r\n        if (needsVisibilityToggle && isHidden) {\r\n          // This child is inside a timed out tree. Hide it.\r\n          const props = node.memoizedProps;\r\n          const type = node.type;\r\n          instance = cloneHiddenInstance(instance, type, props, node);\r\n        }\r\n        appendInitialChild(parent, instance);\r\n      } else if (node.tag === HostText) {\r\n        let instance = node.stateNode;\r\n        if (needsVisibilityToggle && isHidden) {\r\n          // This child is inside a timed out tree. Hide it.\r\n          const text = node.memoizedProps;\r\n          instance = cloneHiddenTextInstance(instance, text, node);\r\n        }\r\n        appendInitialChild(parent, instance);\r\n      } else if (node.tag === HostPortal) {\r\n        // If we have a portal child, then we don't want to traverse\r\n        // down its children. Instead, we'll get insertions from each child in\r\n        // the portal directly.\r\n      } else if (\r\n        node.tag === OffscreenComponent &&\r\n        node.memoizedState !== null\r\n      ) {\r\n        // The children in this boundary are hidden. Toggle their visibility\r\n        // before appending.\r\n        const child = node.child;\r\n        if (child !== null) {\r\n          child.return = node;\r\n        }\r\n        if (enablePersistentOffscreenHostContainer) {\r\n          appendAllChildren(parent, node, false, false);\r\n        } else {\r\n          appendAllChildren(parent, node, true, true);\r\n        }\r\n      } else if (node.child !== null) {\r\n        node.child.return = node;\r\n        node = node.child;\r\n        continue;\r\n      }\r\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\r\n      node = (node: Fiber);\r\n      if (node === workInProgress) {\r\n        return;\r\n      }\r\n      while (node.sibling === null) {\r\n        if (node.return === null || node.return === workInProgress) {\r\n          return;\r\n        }\r\n        node = node.return;\r\n      }\r\n      node.sibling.return = node.return;\r\n      node = node.sibling;\r\n    }\r\n  };\r\n\r\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\r\n  const appendAllChildrenToContainer = function (\r\n    containerChildSet: ChildSet,\r\n    workInProgress: Fiber,\r\n    needsVisibilityToggle: boolean,\r\n    isHidden: boolean,\r\n  ) {\r\n    // We only have the top Fiber that was created but we need recurse down its\r\n    // children to find all the terminal nodes.\r\n    let node = workInProgress.child;\r\n    while (node !== null) {\r\n      // eslint-disable-next-line no-labels\r\n      branches: if (node.tag === HostComponent) {\r\n        let instance = node.stateNode;\r\n        if (needsVisibilityToggle && isHidden) {\r\n          // This child is inside a timed out tree. Hide it.\r\n          const props = node.memoizedProps;\r\n          const type = node.type;\r\n          instance = cloneHiddenInstance(instance, type, props, node);\r\n        }\r\n        appendChildToContainerChildSet(containerChildSet, instance);\r\n      } else if (node.tag === HostText) {\r\n        let instance = node.stateNode;\r\n        if (needsVisibilityToggle && isHidden) {\r\n          // This child is inside a timed out tree. Hide it.\r\n          const text = node.memoizedProps;\r\n          instance = cloneHiddenTextInstance(instance, text, node);\r\n        }\r\n        appendChildToContainerChildSet(containerChildSet, instance);\r\n      } else if (node.tag === HostPortal) {\r\n        // If we have a portal child, then we don't want to traverse\r\n        // down its children. Instead, we'll get insertions from each child in\r\n        // the portal directly.\r\n      } else if (\r\n        node.tag === OffscreenComponent &&\r\n        node.memoizedState !== null\r\n      ) {\r\n        // The children in this boundary are hidden. Toggle their visibility\r\n        // before appending.\r\n        const child = node.child;\r\n        if (child !== null) {\r\n          child.return = node;\r\n        }\r\n        if (enablePersistentOffscreenHostContainer) {\r\n          appendAllChildrenToContainer(containerChildSet, node, false, false);\r\n        } else {\r\n          appendAllChildrenToContainer(containerChildSet, node, true, true);\r\n        }\r\n      } else if (node.child !== null) {\r\n        node.child.return = node;\r\n        node = node.child;\r\n        continue;\r\n      }\r\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\r\n      node = (node: Fiber);\r\n      if (node === workInProgress) {\r\n        return;\r\n      }\r\n      while (node.sibling === null) {\r\n        if (node.return === null || node.return === workInProgress) {\r\n          return;\r\n        }\r\n        node = node.return;\r\n      }\r\n      node.sibling.return = node.return;\r\n      node = node.sibling;\r\n    }\r\n  };\r\n  updateHostContainer = function (current: null | Fiber, workInProgress: Fiber) {\r\n    const portalOrRoot: {\r\n      containerInfo: Container,\r\n      pendingChildren: ChildSet,\r\n      ...\r\n  } = workInProgress.stateNode;\r\n  const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\r\n  if (childrenUnchanged) {\r\n    // No changes, just reuse the existing instance.\r\n  } else {\r\n    const container = portalOrRoot.containerInfo;\r\n    const newChildSet = createContainerChildSet(container);\r\n    // If children might have changed, we have to add them all to the set.\r\n    appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\r\n    portalOrRoot.pendingChildren = newChildSet;\r\n    // Schedule an update on the container to swap out the container.\r\n    markUpdate(workInProgress);\r\n    finalizeContainerChildren(container, newChildSet);\r\n  }\r\n};\r\nupdateHostComponent = function (\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  type: Type,\r\n  newProps: Props,\r\n  rootContainerInstance: Container,\r\n) {\r\n  // mount时执行这个方法\r\n  const currentInstance = current.stateNode;\r\n  const oldProps = current.memoizedProps;\r\n  // If there are no effects associated with this node, then none of our children had any updates.\r\n  // This guarantees that we can reuse all of them.\r\n  const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\r\n  if (childrenUnchanged && oldProps === newProps) {\r\n    // No changes, just reuse the existing instance.\r\n    // Note that this might release a previous clone.\r\n    workInProgress.stateNode = currentInstance;\r\n    return;\r\n  }\r\n  const recyclableInstance: Instance = workInProgress.stateNode;\r\n  const currentHostContext = getHostContext();\r\n  let updatePayload = null;\r\n  if (oldProps !== newProps) {\r\n    updatePayload = prepareUpdate(\r\n      recyclableInstance,\r\n      type,\r\n      oldProps,\r\n      newProps,\r\n      rootContainerInstance,\r\n      currentHostContext,\r\n    );\r\n  }\r\n  if (childrenUnchanged && updatePayload === null) {\r\n    // No changes, just reuse the existing instance.\r\n    // Note that this might release a previous clone.\r\n    workInProgress.stateNode = currentInstance;\r\n    return;\r\n  }\r\n  const newInstance = cloneInstance(\r\n    currentInstance,\r\n    updatePayload,\r\n    type,\r\n    oldProps,\r\n    newProps,\r\n    workInProgress,\r\n    childrenUnchanged,\r\n    recyclableInstance,\r\n  );\r\n  if (\r\n    finalizeInitialChildren(\r\n      newInstance,\r\n      type,\r\n      newProps,\r\n      rootContainerInstance,\r\n      currentHostContext,\r\n    )\r\n  ) {\r\n    markUpdate(workInProgress);\r\n  }\r\n  workInProgress.stateNode = newInstance;\r\n  if (childrenUnchanged) {\r\n    // If there are no other effects in this tree, we need to flag this node as having one.\r\n    // Even though we're not going to use it for anything.\r\n    // Otherwise parents won't know that there are new children to propagate upwards.\r\n    markUpdate(workInProgress);\r\n  } else {\r\n    // If children might have changed, we have to add them all to the set.\r\n    appendAllChildren(newInstance, workInProgress, false, false);\r\n  }\r\n};\r\nupdateHostText = function (\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  oldText: string,\r\n  newText: string,\r\n) {\r\n  if (oldText !== newText) {\r\n    // If the text content differs, we'll create a new text instance for it.\r\n    const rootContainerInstance = getRootHostContainer();\r\n    const currentHostContext = getHostContext();\r\n    workInProgress.stateNode = createTextInstance(\r\n      newText,\r\n      rootContainerInstance,\r\n      currentHostContext,\r\n      workInProgress,\r\n    );\r\n    // We'll have to mark it as having an effect, even though we won't use the effect for anything.\r\n    // This lets the parents know that at least one of their children has changed.\r\n    markUpdate(workInProgress);\r\n  } else {\r\n    workInProgress.stateNode = current.stateNode;\r\n  }\r\n};\r\n} else {\r\n  // No host operations\r\n  updateHostContainer = function (current: null | Fiber, workInProgress: Fiber) {\r\n    // Noop\r\n  };\r\n  updateHostComponent = function (\r\n    current: Fiber,\r\n    workInProgress: Fiber,\r\n    type: Type,\r\n    newProps: Props,\r\n    rootContainerInstance: Container,\r\n  ) {\r\n    // Noop\r\n  };\r\n  updateHostText = function (\r\n    current: Fiber,\r\n    workInProgress: Fiber,\r\n    oldText: string,\r\n    newText: string,\r\n  ) {\r\n    // Noop\r\n  };\r\n}\r\n\r\nfunction cutOffTailIfNeeded (\r\n  renderState: SuspenseListRenderState,\r\n  hasRenderedATailFallback: boolean,\r\n) {\r\n  if (getIsHydrating()) {\r\n    // If we're hydrating, we should consume as many items as we can\r\n    // so we don't leave any behind.\r\n    return;\r\n  }\r\n  switch (renderState.tailMode) {\r\n    case 'hidden': {\r\n      // Any insertions at the end of the tail list after this point\r\n      // should be invisible. If there are already mounted boundaries\r\n      // anything before them are not considered for collapsing.\r\n      // Therefore we need to go through the whole tail to find if\r\n      // there are any.\r\n      let tailNode = renderState.tail;\r\n      let lastTailNode = null;\r\n      while (tailNode !== null) {\r\n        if (tailNode.alternate !== null) {\r\n          lastTailNode = tailNode;\r\n        }\r\n        tailNode = tailNode.sibling;\r\n      }\r\n      // Next we're simply going to delete all insertions after the\r\n      // last rendered item.\r\n      if (lastTailNode === null) {\r\n        // All remaining items in the tail are insertions.\r\n        renderState.tail = null;\r\n      } else {\r\n        // Detach the insertion after the last node that was already\r\n        // inserted.\r\n        lastTailNode.sibling = null;\r\n      }\r\n      break;\r\n    }\r\n    case 'collapsed': {\r\n      // Any insertions at the end of the tail list after this point\r\n      // should be invisible. If there are already mounted boundaries\r\n      // anything before them are not considered for collapsing.\r\n      // Therefore we need to go through the whole tail to find if\r\n      // there are any.\r\n      let tailNode = renderState.tail;\r\n      let lastTailNode = null;\r\n      while (tailNode !== null) {\r\n        if (tailNode.alternate !== null) {\r\n          lastTailNode = tailNode;\r\n        }\r\n        tailNode = tailNode.sibling;\r\n      }\r\n      // Next we're simply going to delete all insertions after the\r\n      // last rendered item.\r\n      if (lastTailNode === null) {\r\n        // All remaining items in the tail are insertions.\r\n        if (!hasRenderedATailFallback && renderState.tail !== null) {\r\n          // We suspended during the head. We want to show at least one\r\n          // row at the tail. So we'll keep on and cut off the rest.\r\n          renderState.tail.sibling = null;\r\n        } else {\r\n          renderState.tail = null;\r\n        }\r\n      } else {\r\n        // Detach the insertion after the last node that was already\r\n        // inserted.\r\n        lastTailNode.sibling = null;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nfunction bubbleProperties (completedWork: Fiber) {\r\n  const didBailout =\r\n    completedWork.alternate !== null &&\r\n    completedWork.alternate.child === completedWork.child;\r\n\r\n  let newChildLanes = NoLanes;\r\n  let subtreeFlags = NoFlags;\r\n\r\n  if (!didBailout) {\r\n    // Bubble up the earliest expiration time.\r\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n      // In profiling mode, resetChildExpirationTime is also used to reset\r\n      // profiler durations.\r\n      let actualDuration = completedWork.actualDuration;\r\n      let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n      let child = completedWork.child;\r\n      while (child !== null) {\r\n        newChildLanes = mergeLanes(\r\n          newChildLanes,\r\n          mergeLanes(child.lanes, child.childLanes),\r\n        );\r\n\r\n        subtreeFlags |= child.subtreeFlags;\r\n        subtreeFlags |= child.flags;\r\n\r\n        // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n        // When work is done, it should bubble to the parent's actualDuration. If\r\n        // the fiber has not been cloned though, (meaning no work was done), then\r\n        // this value will reflect the amount of time spent working on a previous\r\n        // render. In that case it should not bubble. We determine whether it was\r\n        // cloned by comparing the child pointer.\r\n        actualDuration += child.actualDuration;\r\n\r\n        treeBaseDuration += child.treeBaseDuration;\r\n        child = child.sibling;\r\n      }\r\n\r\n      completedWork.actualDuration = actualDuration;\r\n      completedWork.treeBaseDuration = treeBaseDuration;\r\n    } else {\r\n      let child = completedWork.child;\r\n      while (child !== null) {\r\n        newChildLanes = mergeLanes(\r\n          newChildLanes,\r\n          mergeLanes(child.lanes, child.childLanes),\r\n        );\r\n\r\n        subtreeFlags |= child.subtreeFlags;\r\n        subtreeFlags |= child.flags;\r\n\r\n        // Update the return pointer so the tree is consistent. This is a code\r\n        // smell because it assumes the commit phase is never concurrent with\r\n        // the render phase. Will address during refactor to alternate model.\r\n        child.return = completedWork;\r\n\r\n        child = child.sibling;\r\n      }\r\n    }\r\n\r\n    completedWork.subtreeFlags |= subtreeFlags;\r\n  } else {\r\n    // Bubble up the earliest expiration time.\r\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\r\n      // In profiling mode, resetChildExpirationTime is also used to reset\r\n      // profiler durations.\r\n      let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\r\n\r\n      let child = completedWork.child;\r\n      while (child !== null) {\r\n        newChildLanes = mergeLanes(\r\n          newChildLanes,\r\n          mergeLanes(child.lanes, child.childLanes),\r\n        );\r\n\r\n        // \"Static\" flags share the lifetime of the fiber/hook they belong to,\r\n        // so we should bubble those up even during a bailout. All the other\r\n        // flags have a lifetime only of a single render + commit, so we should\r\n        // ignore them.\r\n        subtreeFlags |= child.subtreeFlags & StaticMask;\r\n        subtreeFlags |= child.flags & StaticMask;\r\n\r\n        treeBaseDuration += child.treeBaseDuration;\r\n        child = child.sibling;\r\n      }\r\n\r\n      completedWork.treeBaseDuration = treeBaseDuration;\r\n    } else {\r\n      let child = completedWork.child;\r\n      while (child !== null) {\r\n        newChildLanes = mergeLanes(\r\n          newChildLanes,\r\n          mergeLanes(child.lanes, child.childLanes),\r\n        );\r\n\r\n        // \"Static\" flags share the lifetime of the fiber/hook they belong to,\r\n        // so we should bubble those up even during a bailout. All the other\r\n        // flags have a lifetime only of a single render + commit, so we should\r\n        // ignore them.\r\n        subtreeFlags |= child.subtreeFlags & StaticMask;\r\n        subtreeFlags |= child.flags & StaticMask;\r\n\r\n        // Update the return pointer so the tree is consistent. This is a code\r\n        // smell because it assumes the commit phase is never concurrent with\r\n        // the render phase. Will address during refactor to alternate model.\r\n        child.return = completedWork;\r\n\r\n        child = child.sibling;\r\n      }\r\n    }\r\n\r\n    completedWork.subtreeFlags |= subtreeFlags;\r\n  }\r\n\r\n  completedWork.childLanes = newChildLanes;\r\n\r\n  return didBailout;\r\n}\r\n\r\nexport function completeSuspendedOffscreenHostContainer (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n) {\r\n  // This is a fork of the complete phase for HostComponent. We use it when\r\n  // a suspense tree is in its fallback state, because in that case the primary\r\n  // tree that includes the offscreen boundary is skipped over without a\r\n  // regular complete phase.\r\n  //\r\n  // We can optimize this path further by inlining the update logic for\r\n  // offscreen instances specifically, i.e. skipping the `prepareUpdate` call.\r\n  const rootContainerInstance = getRootHostContainer();\r\n  const type = workInProgress.type;\r\n  const newProps = workInProgress.memoizedProps;\r\n  if (current !== null) {\r\n    updateHostComponent(\r\n      current,\r\n      workInProgress,\r\n      type,\r\n      newProps,\r\n      rootContainerInstance,\r\n    );\r\n  } else {\r\n    const currentHostContext = getHostContext();\r\n    const instance = createInstance(\r\n      type,\r\n      newProps,\r\n      rootContainerInstance,\r\n      currentHostContext,\r\n      workInProgress,\r\n    );\r\n\r\n    appendAllChildren(instance, workInProgress, false, false);\r\n\r\n    workInProgress.stateNode = instance;\r\n\r\n    // Certain renderers require commit-time effects for initial mount.\r\n    // (eg DOM renderer supports auto-focus for certain elements).\r\n    // Make sure such renderers get scheduled for later work.\r\n    if (\r\n      finalizeInitialChildren(\r\n        instance,\r\n        type,\r\n        newProps,\r\n        rootContainerInstance,\r\n        currentHostContext,\r\n      )\r\n    ) {\r\n      markUpdate(workInProgress);\r\n    }\r\n\r\n    if (workInProgress.ref !== null) {\r\n      // If there is a ref on a host node we need to schedule a callback\r\n      markRef(workInProgress);\r\n    }\r\n  }\r\n  bubbleProperties(workInProgress);\r\n}\r\n\r\n// completeWork主要工作是处理fiber的props、创建dom、创建effectList\r\nfunction completeWork (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n): Fiber | null {\r\n  const newProps = workInProgress.pendingProps;\r\n  // Note: This intentionally doesn't check if we're hydrating because comparing\r\n  // to the current tree provider fiber is just as fast and less error-prone.\r\n  // Ideally we would have a special version of the work loop only\r\n  // for hydration.\r\n  popTreeContext(workInProgress);\r\n  //根据workInProgress.tag进入不同逻辑，这里我们关注HostComponent，HostComponent，其他类型之后在讲\r\n  switch (workInProgress.tag) {\r\n    case IndeterminateComponent:\r\n    case LazyComponent:\r\n    case SimpleMemoComponent:\r\n    case FunctionComponent:\r\n    case ForwardRef:\r\n    case Fragment:\r\n    case Mode:\r\n    case Profiler:\r\n    case ContextConsumer:\r\n    case MemoComponent:\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    case ClassComponent: {\r\n      const Component = workInProgress.type;\r\n      if (isLegacyContextProvider(Component)) {\r\n        popLegacyContext(workInProgress);\r\n      }\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    }\r\n    case HostRoot: {\r\n      const fiberRoot = (workInProgress.stateNode: FiberRoot);\r\n\r\n      if (enableTransitionTracing) {\r\n        const transitions = getWorkInProgressTransitions();\r\n        // We set the Passive flag here because if there are new transitions,\r\n        // we will need to schedule callbacks and process the transitions,\r\n        // which we do in the passive phase\r\n        if (transitions !== null) {\r\n          workInProgress.flags |= Passive;\r\n        }\r\n      }\r\n\r\n      if (enableCache) {\r\n        let previousCache: Cache | null = null;\r\n        if (current !== null) {\r\n          previousCache = current.memoizedState.cache;\r\n        }\r\n        const cache: Cache = workInProgress.memoizedState.cache;\r\n        if (cache !== previousCache) {\r\n          // Run passive effects to retain/release the cache.\r\n          workInProgress.flags |= Passive;\r\n        }\r\n        popCacheProvider(workInProgress, cache);\r\n      }\r\n      popRootTransition(workInProgress, fiberRoot, renderLanes);\r\n      popHostContainer(workInProgress);\r\n      popTopLevelLegacyContextObject(workInProgress);\r\n      resetMutableSourceWorkInProgressVersions();\r\n      if (fiberRoot.pendingContext) {\r\n        fiberRoot.context = fiberRoot.pendingContext;\r\n        fiberRoot.pendingContext = null;\r\n      }\r\n      if (current === null || current.child === null) {\r\n        // If we hydrated, pop so that we can delete any remaining children\r\n        // that weren't hydrated.\r\n        const wasHydrated = popHydrationState(workInProgress);\r\n        if (wasHydrated) {\r\n          // If we hydrated, then we'll need to schedule an update for\r\n          // the commit side-effects on the root.\r\n          markUpdate(workInProgress);\r\n        } else {\r\n          if (current !== null) {\r\n            const prevState: RootState = current.memoizedState;\r\n            if (\r\n              // Check if this is a client root\r\n              !prevState.isDehydrated ||\r\n              // Check if we reverted to client rendering (e.g. due to an error)\r\n              (workInProgress.flags & ForceClientRender) !== NoFlags\r\n            ) {\r\n              // Schedule an effect to clear this container at the start of the\r\n              // next commit. This handles the case of React rendering into a\r\n              // container with previous children. It's also safe to do for\r\n              // updates too, because current.child would only be null if the\r\n              // previous render was null (so the container would already\r\n              // be empty).\r\n              workInProgress.flags |= Snapshot;\r\n\r\n              // If this was a forced client render, there may have been\r\n              // recoverable errors during first hydration attempt. If so, add\r\n              // them to a queue so we can log them in the commit phase.\r\n              upgradeHydrationErrorsToRecoverable();\r\n            }\r\n          }\r\n        }\r\n      }\r\n      updateHostContainer(current, workInProgress);\r\n      bubbleProperties(workInProgress);\r\n      if (enableTransitionTracing) {\r\n        if ((workInProgress.subtreeFlags & Visibility) !== NoFlags) {\r\n          // If any of our suspense children toggle visibility, this means that\r\n          // the pending boundaries array needs to be updated, which we only\r\n          // do in the passive phase.\r\n          workInProgress.flags |= Passive;\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n    case HostComponent: {\r\n      // 原生节点的处理逻辑\r\n      popHostContext(workInProgress);\r\n      const rootContainerInstance = getRootHostContainer();\r\n      const type = workInProgress.type;\r\n      // update时\r\n      if (current !== null && workInProgress.stateNode != null) {\r\n        // 处理props（包括onClick、style、children ...），并将处理好的props赋值给updatePayload,最后会保存在workInProgress.updateQueue上\r\n\r\n        // 当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：\r\n        // onClick、onChange等回调函数的注册\r\n        // 处理style prop\r\n        // 处理DANGEROUSLY_SET_INNER_HTML prop\r\n        // 处理children prop\r\n\r\n\r\n        // 主要逻辑\r\n        updateHostComponent(\r\n          current,\r\n          workInProgress,\r\n          type,\r\n          newProps,\r\n          rootContainerInstance,\r\n        );\r\n\r\n        if (current.ref !== workInProgress.ref) {\r\n          markRef(workInProgress);\r\n        }\r\n      } else {\r\n        // mount时\r\n        if (!newProps) {\r\n          if (workInProgress.stateNode === null) {\r\n            throw new Error(\r\n              'We must have new props for new mounts. This error is likely ' +\r\n              'caused by a bug in React. Please file an issue.',\r\n            );\r\n          }\r\n\r\n          // This can happen when we abort work.\r\n          bubbleProperties(workInProgress);\r\n          return null;\r\n        }\r\n\r\n        const currentHostContext = getHostContext();\r\n        // TODO: Move createInstance to beginWork and keep it on a context\r\n        // \"stack\" as the parent. Then append children as we go in beginWork\r\n        // or completeWork depending on whether we want to add them top->down or\r\n        // bottom->up. Top->down is faster in IE11.\r\n        const wasHydrated = popHydrationState(workInProgress);\r\n        if (wasHydrated) {\r\n          // TODO: Move this and createInstance step into the beginPhase\r\n          // to consolidate.\r\n          if (\r\n            prepareToHydrateHostInstance(\r\n              workInProgress,\r\n              rootContainerInstance,\r\n              currentHostContext,\r\n            )\r\n          ) {\r\n            // If changes to the hydrated node need to be applied at the\r\n            // commit-phase we mark this as such.\r\n            markUpdate(workInProgress);\r\n          }\r\n        } else {\r\n          // 创建fiber对应的dom节点\r\n          const instance = createInstance(\r\n            type,\r\n            newProps,\r\n            rootContainerInstance,\r\n            currentHostContext,\r\n            workInProgress,\r\n          );\r\n          // 将后代dom节点插入刚创建的dom里\r\n          appendAllChildren(instance, workInProgress, false, false);\r\n          // dom节点赋值给fiber.stateNode\r\n          workInProgress.stateNode = instance;\r\n\r\n          // Certain renderers require commit-time effects for initial mount.\r\n          // (eg DOM renderer supports auto-focus for certain elements).\r\n          // Make sure such renderers get scheduled for later work.\r\n\r\n          // 处理props和updateHostComponent类似\r\n          if (\r\n            finalizeInitialChildren(\r\n              instance,\r\n              type,\r\n              newProps,\r\n              rootContainerInstance,\r\n              currentHostContext,\r\n            )\r\n          ) {\r\n            markUpdate(workInProgress);\r\n          }\r\n        }\r\n\r\n        if (workInProgress.ref !== null) {\r\n          // If there is a ref on a host node we need to schedule a callback\r\n          markRef(workInProgress);\r\n        }\r\n      }\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    }\r\n    case HostText: {\r\n      const newText = newProps;\r\n      if (current && workInProgress.stateNode != null) {\r\n        const oldText = current.memoizedProps;\r\n        // If we have an alternate, that means this is an update and we need\r\n        // to schedule a side-effect to do the updates.\r\n        updateHostText(current, workInProgress, oldText, newText);\r\n      } else {\r\n        if (typeof newText !== 'string') {\r\n          if (workInProgress.stateNode === null) {\r\n            throw new Error(\r\n              'We must have new props for new mounts. This error is likely ' +\r\n              'caused by a bug in React. Please file an issue.',\r\n            );\r\n          }\r\n          // This can happen when we abort work.\r\n        }\r\n        const rootContainerInstance = getRootHostContainer();\r\n        const currentHostContext = getHostContext();\r\n        const wasHydrated = popHydrationState(workInProgress);\r\n        if (wasHydrated) {\r\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\r\n            markUpdate(workInProgress);\r\n          }\r\n        } else {\r\n          workInProgress.stateNode = createTextInstance(\r\n            newText,\r\n            rootContainerInstance,\r\n            currentHostContext,\r\n            workInProgress,\r\n          );\r\n        }\r\n      }\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    }\r\n    case SuspenseComponent: {\r\n      popSuspenseContext(workInProgress);\r\n      const nextState: null | SuspenseState = workInProgress.memoizedState;\r\n\r\n      if (\r\n        hasUnhydratedTailNodes() &&\r\n        (workInProgress.mode & ConcurrentMode) !== NoMode &&\r\n        (workInProgress.flags & DidCapture) === NoFlags\r\n      ) {\r\n        warnIfUnhydratedTailNodes(workInProgress);\r\n        resetHydrationState();\r\n        workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\r\n        return workInProgress;\r\n      }\r\n      if (nextState !== null && nextState.dehydrated !== null) {\r\n        // We might be inside a hydration state the first time we're picking up this\r\n        // Suspense boundary, and also after we've reentered it for further hydration.\r\n        const wasHydrated = popHydrationState(workInProgress);\r\n        if (current === null) {\r\n          if (!wasHydrated) {\r\n            throw new Error(\r\n              'A dehydrated suspense component was completed without a hydrated node. ' +\r\n              'This is probably a bug in React.',\r\n            );\r\n          }\r\n          prepareToHydrateHostSuspenseInstance(workInProgress);\r\n          bubbleProperties(workInProgress);\r\n          if (enableProfilerTimer) {\r\n            if ((workInProgress.mode & ProfileMode) !== NoMode) {\r\n              const isTimedOutSuspense = nextState !== null;\r\n              if (isTimedOutSuspense) {\r\n                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n                const primaryChildFragment = workInProgress.child;\r\n                if (primaryChildFragment !== null) {\r\n                  // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\r\n                  workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        } else {\r\n          // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\r\n          // state since we're now exiting out of it. popHydrationState doesn't do that for us.\r\n          resetHydrationState();\r\n          if ((workInProgress.flags & DidCapture) === NoFlags) {\r\n            // This boundary did not suspend so it's now hydrated and unsuspended.\r\n            workInProgress.memoizedState = null;\r\n          }\r\n          // If nothing suspended, we need to schedule an effect to mark this boundary\r\n          // as having hydrated so events know that they're free to be invoked.\r\n          // It's also a signal to replay events and the suspense callback.\r\n          // If something suspended, schedule an effect to attach retry listeners.\r\n          // So we might as well always mark this.\r\n          workInProgress.flags |= Update;\r\n          bubbleProperties(workInProgress);\r\n          if (enableProfilerTimer) {\r\n            if ((workInProgress.mode & ProfileMode) !== NoMode) {\r\n              const isTimedOutSuspense = nextState !== null;\r\n              if (isTimedOutSuspense) {\r\n                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n                const primaryChildFragment = workInProgress.child;\r\n                if (primaryChildFragment !== null) {\r\n                  // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\r\n                  workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n\r\n      // Successfully completed this tree. If this was a forced client render,\r\n      // there may have been recoverable errors during first hydration\r\n      // attempt. If so, add them to a queue so we can log them in the\r\n      // commit phase.\r\n      upgradeHydrationErrorsToRecoverable();\r\n\r\n      if ((workInProgress.flags & DidCapture) !== NoFlags) {\r\n        // Something suspended. Re-render with the fallback children.\r\n        workInProgress.lanes = renderLanes;\r\n        // Do not reset the effect list.\r\n        if (\r\n          enableProfilerTimer &&\r\n          (workInProgress.mode & ProfileMode) !== NoMode\r\n        ) {\r\n          transferActualDuration(workInProgress);\r\n        }\r\n        // Don't bubble properties in this case.\r\n        return workInProgress;\r\n      }\r\n\r\n      const nextDidTimeout = nextState !== null;\r\n      let prevDidTimeout = false;\r\n      if (current === null) {\r\n        popHydrationState(workInProgress);\r\n      } else {\r\n        const prevState: null | SuspenseState = current.memoizedState;\r\n        prevDidTimeout = prevState !== null;\r\n      }\r\n\r\n      if (enableCache && nextDidTimeout) {\r\n        const offscreenFiber: Fiber = (workInProgress.child: any);\r\n        let previousCache: Cache | null = null;\r\n        if (\r\n          offscreenFiber.alternate !== null &&\r\n          offscreenFiber.alternate.memoizedState !== null &&\r\n          offscreenFiber.alternate.memoizedState.cachePool !== null\r\n        ) {\r\n          previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\r\n        }\r\n        let cache: Cache | null = null;\r\n        if (\r\n          offscreenFiber.memoizedState !== null &&\r\n          offscreenFiber.memoizedState.cachePool !== null\r\n        ) {\r\n          cache = offscreenFiber.memoizedState.cachePool.pool;\r\n        }\r\n        if (cache !== previousCache) {\r\n          // Run passive effects to retain/release the cache.\r\n          offscreenFiber.flags |= Passive;\r\n        }\r\n      }\r\n\r\n      // If the suspended state of the boundary changes, we need to schedule\r\n      // a passive effect, which is when we process the transitions\r\n      if (nextDidTimeout !== prevDidTimeout) {\r\n        if (enableTransitionTracing) {\r\n          const offscreenFiber: Fiber = (workInProgress.child: any);\r\n          offscreenFiber.flags |= Passive;\r\n        }\r\n\r\n        // If the suspended state of the boundary changes, we need to schedule\r\n        // an effect to toggle the subtree's visibility. When we switch from\r\n        // fallback -> primary, the inner Offscreen fiber schedules this effect\r\n        // as part of its normal complete phase. But when we switch from\r\n        // primary -> fallback, the inner Offscreen fiber does not have a complete\r\n        // phase. So we need to schedule its effect here.\r\n        //\r\n        // We also use this flag to connect/disconnect the effects, but the same\r\n        // logic applies: when re-connecting, the Offscreen fiber's complete\r\n        // phase will handle scheduling the effect. It's only when the fallback\r\n        // is active that we have to do anything special.\r\n        if (nextDidTimeout) {\r\n          const offscreenFiber: Fiber = (workInProgress.child: any);\r\n          offscreenFiber.flags |= Visibility;\r\n\r\n          // TODO: This will still suspend a synchronous tree if anything\r\n          // in the concurrent tree already suspended during this render.\r\n          // This is a known bug.\r\n          if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\r\n            // TODO: Move this back to throwException because this is too late\r\n            // if this is a large tree which is common for initial loads. We\r\n            // don't know if we should restart a render or not until we get\r\n            // this marker, and this is too late.\r\n            // If this render already had a ping or lower pri updates,\r\n            // and this is the first time we know we're going to suspend we\r\n            // should be able to immediately restart from within throwException.\r\n            const hasInvisibleChildContext =\r\n              current === null &&\r\n              (workInProgress.memoizedProps.unstable_avoidThisFallback !==\r\n                true ||\r\n                !enableSuspenseAvoidThisFallback);\r\n            if (\r\n              hasInvisibleChildContext ||\r\n              hasSuspenseContext(\r\n                suspenseStackCursor.current,\r\n                (InvisibleParentSuspenseContext: SuspenseContext),\r\n              )\r\n            ) {\r\n              // If this was in an invisible tree or a new render, then showing\r\n              // this boundary is ok.\r\n              renderDidSuspend();\r\n            } else {\r\n              // Otherwise, we're going to have to hide content so we should\r\n              // suspend for longer if possible.\r\n              renderDidSuspendDelayIfPossible();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const wakeables: Set<Wakeable> | null = (workInProgress.updateQueue: any);\r\n      if (wakeables !== null) {\r\n        // Schedule an effect to attach a retry listener to the promise.\r\n        // TODO: Move to passive phase\r\n        workInProgress.flags |= Update;\r\n      }\r\n\r\n      if (\r\n        enableSuspenseCallback &&\r\n        workInProgress.updateQueue !== null &&\r\n        workInProgress.memoizedProps.suspenseCallback != null\r\n      ) {\r\n        // Always notify the callback\r\n        // TODO: Move to passive phase\r\n        workInProgress.flags |= Update;\r\n      }\r\n      bubbleProperties(workInProgress);\r\n      if (enableProfilerTimer) {\r\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\r\n          if (nextDidTimeout) {\r\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n            const primaryChildFragment = workInProgress.child;\r\n            if (primaryChildFragment !== null) {\r\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\r\n              workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n    case HostPortal:\r\n      popHostContainer(workInProgress);\r\n      updateHostContainer(current, workInProgress);\r\n      if (current === null) {\r\n        preparePortalMount(workInProgress.stateNode.containerInfo);\r\n      }\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    case ContextProvider:\r\n      // Pop provider fiber\r\n      const context: ReactContext<any> = workInProgress.type._context;\r\n      popProvider(context, workInProgress);\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    case IncompleteClassComponent: {\r\n      // Same as class component case. I put it down here so that the tags are\r\n      // sequential to ensure this switch is compiled to a jump table.\r\n      const Component = workInProgress.type;\r\n      if (isLegacyContextProvider(Component)) {\r\n        popLegacyContext(workInProgress);\r\n      }\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    }\r\n    case SuspenseListComponent: {\r\n      popSuspenseContext(workInProgress);\r\n\r\n      const renderState: null | SuspenseListRenderState =\r\n        workInProgress.memoizedState;\r\n\r\n      if (renderState === null) {\r\n        // We're running in the default, \"independent\" mode.\r\n        // We don't do anything in this mode.\r\n        bubbleProperties(workInProgress);\r\n        return null;\r\n      }\r\n\r\n      let didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\r\n\r\n      const renderedTail = renderState.rendering;\r\n      if (renderedTail === null) {\r\n        // We just rendered the head.\r\n        if (!didSuspendAlready) {\r\n          // This is the first pass. We need to figure out if anything is still\r\n          // suspended in the rendered set.\r\n\r\n          // If new content unsuspended, but there's still some content that\r\n          // didn't. Then we need to do a second pass that forces everything\r\n          // to keep showing their fallbacks.\r\n\r\n          // We might be suspended if something in this render pass suspended, or\r\n          // something in the previous committed pass suspended. Otherwise,\r\n          // there's no chance so we can skip the expensive call to\r\n          // findFirstSuspended.\r\n          const cannotBeSuspended =\r\n            renderHasNotSuspendedYet() &&\r\n            (current === null || (current.flags & DidCapture) === NoFlags);\r\n          if (!cannotBeSuspended) {\r\n            let row = workInProgress.child;\r\n            while (row !== null) {\r\n              const suspended = findFirstSuspended(row);\r\n              if (suspended !== null) {\r\n                didSuspendAlready = true;\r\n                workInProgress.flags |= DidCapture;\r\n                cutOffTailIfNeeded(renderState, false);\r\n\r\n                // If this is a newly suspended tree, it might not get committed as\r\n                // part of the second pass. In that case nothing will subscribe to\r\n                // its thenables. Instead, we'll transfer its thenables to the\r\n                // SuspenseList so that it can retry if they resolve.\r\n                // There might be multiple of these in the list but since we're\r\n                // going to wait for all of them anyway, it doesn't really matter\r\n                // which ones gets to ping. In theory we could get clever and keep\r\n                // track of how many dependencies remain but it gets tricky because\r\n                // in the meantime, we can add/remove/change items and dependencies.\r\n                // We might bail out of the loop before finding any but that\r\n                // doesn't matter since that means that the other boundaries that\r\n                // we did find already has their listeners attached.\r\n                const newThenables = suspended.updateQueue;\r\n                if (newThenables !== null) {\r\n                  workInProgress.updateQueue = newThenables;\r\n                  workInProgress.flags |= Update;\r\n                }\r\n\r\n                // Rerender the whole list, but this time, we'll force fallbacks\r\n                // to stay in place.\r\n                // Reset the effect flags before doing the second pass since that's now invalid.\r\n                // Reset the child fibers to their original state.\r\n                workInProgress.subtreeFlags = NoFlags;\r\n                resetChildFibers(workInProgress, renderLanes);\r\n\r\n                // Set up the Suspense Context to force suspense and immediately\r\n                // rerender the children.\r\n                pushSuspenseContext(\r\n                  workInProgress,\r\n                  setShallowSuspenseContext(\r\n                    suspenseStackCursor.current,\r\n                    ForceSuspenseFallback,\r\n                  ),\r\n                );\r\n                // Don't bubble properties in this case.\r\n                return workInProgress.child;\r\n              }\r\n              row = row.sibling;\r\n            }\r\n          }\r\n\r\n          if (renderState.tail !== null && now() > getRenderTargetTime()) {\r\n            // We have already passed our CPU deadline but we still have rows\r\n            // left in the tail. We'll just give up further attempts to render\r\n            // the main content and only render fallbacks.\r\n            workInProgress.flags |= DidCapture;\r\n            didSuspendAlready = true;\r\n\r\n            cutOffTailIfNeeded(renderState, false);\r\n\r\n            // Since nothing actually suspended, there will nothing to ping this\r\n            // to get it started back up to attempt the next item. While in terms\r\n            // of priority this work has the same priority as this current render,\r\n            // it's not part of the same transition once the transition has\r\n            // committed. If it's sync, we still want to yield so that it can be\r\n            // painted. Conceptually, this is really the same as pinging.\r\n            // We can use any RetryLane even if it's the one currently rendering\r\n            // since we're leaving it behind on this node.\r\n            workInProgress.lanes = SomeRetryLane;\r\n          }\r\n        } else {\r\n          cutOffTailIfNeeded(renderState, false);\r\n        }\r\n        // Next we're going to render the tail.\r\n      } else {\r\n        // Append the rendered row to the child list.\r\n        if (!didSuspendAlready) {\r\n          const suspended = findFirstSuspended(renderedTail);\r\n          if (suspended !== null) {\r\n            workInProgress.flags |= DidCapture;\r\n            didSuspendAlready = true;\r\n\r\n            // Ensure we transfer the update queue to the parent so that it doesn't\r\n            // get lost if this row ends up dropped during a second pass.\r\n            const newThenables = suspended.updateQueue;\r\n            if (newThenables !== null) {\r\n              workInProgress.updateQueue = newThenables;\r\n              workInProgress.flags |= Update;\r\n            }\r\n\r\n            cutOffTailIfNeeded(renderState, true);\r\n            // This might have been modified.\r\n            if (\r\n              renderState.tail === null &&\r\n              renderState.tailMode === 'hidden' &&\r\n              !renderedTail.alternate &&\r\n              !getIsHydrating() // We don't cut it if we're hydrating.\r\n            ) {\r\n              // We're done.\r\n              bubbleProperties(workInProgress);\r\n              return null;\r\n            }\r\n          } else if (\r\n            // The time it took to render last row is greater than the remaining\r\n            // time we have to render. So rendering one more row would likely\r\n            // exceed it.\r\n            now() * 2 - renderState.renderingStartTime >\r\n            getRenderTargetTime() &&\r\n            renderLanes !== OffscreenLane\r\n          ) {\r\n            // We have now passed our CPU deadline and we'll just give up further\r\n            // attempts to render the main content and only render fallbacks.\r\n            // The assumption is that this is usually faster.\r\n            workInProgress.flags |= DidCapture;\r\n            didSuspendAlready = true;\r\n\r\n            cutOffTailIfNeeded(renderState, false);\r\n\r\n            // Since nothing actually suspended, there will nothing to ping this\r\n            // to get it started back up to attempt the next item. While in terms\r\n            // of priority this work has the same priority as this current render,\r\n            // it's not part of the same transition once the transition has\r\n            // committed. If it's sync, we still want to yield so that it can be\r\n            // painted. Conceptually, this is really the same as pinging.\r\n            // We can use any RetryLane even if it's the one currently rendering\r\n            // since we're leaving it behind on this node.\r\n            workInProgress.lanes = SomeRetryLane;\r\n          }\r\n        }\r\n        if (renderState.isBackwards) {\r\n          // The effect list of the backwards tail will have been added\r\n          // to the end. This breaks the guarantee that life-cycles fire in\r\n          // sibling order but that isn't a strong guarantee promised by React.\r\n          // Especially since these might also just pop in during future commits.\r\n          // Append to the beginning of the list.\r\n          renderedTail.sibling = workInProgress.child;\r\n          workInProgress.child = renderedTail;\r\n        } else {\r\n          const previousSibling = renderState.last;\r\n          if (previousSibling !== null) {\r\n            previousSibling.sibling = renderedTail;\r\n          } else {\r\n            workInProgress.child = renderedTail;\r\n          }\r\n          renderState.last = renderedTail;\r\n        }\r\n      }\r\n\r\n      if (renderState.tail !== null) {\r\n        // We still have tail rows to render.\r\n        // Pop a row.\r\n        const next = renderState.tail;\r\n        renderState.rendering = next;\r\n        renderState.tail = next.sibling;\r\n        renderState.renderingStartTime = now();\r\n        next.sibling = null;\r\n\r\n        // Restore the context.\r\n        // TODO: We can probably just avoid popping it instead and only\r\n        // setting it the first time we go from not suspended to suspended.\r\n        let suspenseContext = suspenseStackCursor.current;\r\n        if (didSuspendAlready) {\r\n          suspenseContext = setShallowSuspenseContext(\r\n            suspenseContext,\r\n            ForceSuspenseFallback,\r\n          );\r\n        } else {\r\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n        }\r\n        pushSuspenseContext(workInProgress, suspenseContext);\r\n        // Do a pass over the next row.\r\n        // Don't bubble properties in this case.\r\n        return next;\r\n      }\r\n      bubbleProperties(workInProgress);\r\n      return null;\r\n    }\r\n    case ScopeComponent: {\r\n      if (enableScopeAPI) {\r\n        if (current === null) {\r\n          const scopeInstance: ReactScopeInstance = createScopeInstance();\r\n          workInProgress.stateNode = scopeInstance;\r\n          prepareScopeUpdate(scopeInstance, workInProgress);\r\n          if (workInProgress.ref !== null) {\r\n            markRef(workInProgress);\r\n            markUpdate(workInProgress);\r\n          }\r\n        } else {\r\n          if (workInProgress.ref !== null) {\r\n            markUpdate(workInProgress);\r\n          }\r\n          if (current.ref !== workInProgress.ref) {\r\n            markRef(workInProgress);\r\n          }\r\n        }\r\n        bubbleProperties(workInProgress);\r\n        return null;\r\n      }\r\n      break;\r\n    }\r\n    case OffscreenComponent:\r\n    case LegacyHiddenComponent: {\r\n      popRenderLanes(workInProgress);\r\n      const nextState: OffscreenState | null = workInProgress.memoizedState;\r\n      const nextIsHidden = nextState !== null;\r\n\r\n      if (current !== null) {\r\n        const prevState: OffscreenState | null = current.memoizedState;\r\n        const prevIsHidden = prevState !== null;\r\n        if (\r\n          prevIsHidden !== nextIsHidden &&\r\n          // LegacyHidden doesn't do any hiding — it only pre-renders.\r\n          (!enableLegacyHidden || workInProgress.tag !== LegacyHiddenComponent)\r\n        ) {\r\n          workInProgress.flags |= Visibility;\r\n        }\r\n      }\r\n\r\n      if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\r\n        bubbleProperties(workInProgress);\r\n      } else {\r\n        // Don't bubble properties for hidden children unless we're rendering\r\n        // at offscreen priority.\r\n        if (includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane))) {\r\n          bubbleProperties(workInProgress);\r\n          if (supportsMutation) {\r\n            // Check if there was an insertion or update in the hidden subtree.\r\n            // If so, we need to hide those nodes in the commit phase, so\r\n            // schedule a visibility effect.\r\n            if (\r\n              (!enableLegacyHidden ||\r\n                workInProgress.tag !== LegacyHiddenComponent) &&\r\n              workInProgress.subtreeFlags & (Placement | Update)\r\n            ) {\r\n              workInProgress.flags |= Visibility;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (enableCache) {\r\n        let previousCache: Cache | null = null;\r\n        if (\r\n          current !== null &&\r\n          current.memoizedState !== null &&\r\n          current.memoizedState.cachePool !== null\r\n        ) {\r\n          previousCache = current.memoizedState.cachePool.pool;\r\n        }\r\n        let cache: Cache | null = null;\r\n        if (\r\n          workInProgress.memoizedState !== null &&\r\n          workInProgress.memoizedState.cachePool !== null\r\n        ) {\r\n          cache = workInProgress.memoizedState.cachePool.pool;\r\n        }\r\n        if (cache !== previousCache) {\r\n          // Run passive effects to retain/release the cache.\r\n          workInProgress.flags |= Passive;\r\n        }\r\n      }\r\n\r\n      popTransition(workInProgress, current);\r\n\r\n      return null;\r\n    }\r\n    case CacheComponent: {\r\n      if (enableCache) {\r\n        let previousCache: Cache | null = null;\r\n        if (current !== null) {\r\n          previousCache = current.memoizedState.cache;\r\n        }\r\n        const cache: Cache = workInProgress.memoizedState.cache;\r\n        if (cache !== previousCache) {\r\n          // Run passive effects to retain/release the cache.\r\n          workInProgress.flags |= Passive;\r\n        }\r\n        popCacheProvider(workInProgress, cache);\r\n        bubbleProperties(workInProgress);\r\n      }\r\n      return null;\r\n    }\r\n    case TracingMarkerComponent: {\r\n      if (enableTransitionTracing) {\r\n        // Bubble subtree flags before so we can set the flag property\r\n        bubbleProperties(workInProgress);\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n\r\n  throw new Error(\r\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\r\n    'React. Please file an issue.',\r\n  );\r\n}\r\n\r\nexport { completeWork };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}