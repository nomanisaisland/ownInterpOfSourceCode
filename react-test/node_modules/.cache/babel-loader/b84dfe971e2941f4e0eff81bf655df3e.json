{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\nimport getNodeForCharacterOffset from './getNodeForCharacterOffset';\nimport { TEXT_NODE } from '../shared/HTMLNodeType';\n/**\r\n * @param {DOMElement} outerNode\r\n * @return {?object}\r\n */\n\nexport function getOffsets(outerNode) {\n  const {\n    ownerDocument\n  } = outerNode;\n  const win = ownerDocument && ownerDocument.defaultView || window;\n  const selection = win.getSelection && win.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset\n  } = selection; // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n}\n/**\r\n * Returns {start, end} where `start` is the character/codepoint index of\r\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\r\n * `end` is the index of (focusNode, focusOffset).\r\n *\r\n * Returns null if you pass in garbage input but we should probably just crash.\r\n *\r\n * Exported only for testing.\r\n */\n\nexport function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n  let length = 0;\n  let start = -1;\n  let end = -1;\n  let indexWithinAnchor = 0;\n  let indexWithinFocus = 0;\n  let node = outerNode;\n  let parentNode = null;\n\n  outer: while (true) {\n    let next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n\n      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      } // Moving from `node` to its first child `next`.\n\n\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n\n      node = parentNode;\n      parentNode = node.parentNode;\n    } // Moving from `node` to its next sibling `next`.\n\n\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n/**\r\n * In modern non-IE browsers, we can support both forward and backward\r\n * selections.\r\n *\r\n * Note: IE10+ supports the Selection object, but it does not support\r\n * the `extend` method, which means that even in modern IE, it's not possible\r\n * to programmatically create a backward selection. Thus, for all IE\r\n * versions, we use the old IE API to create our selections.\r\n *\r\n * @param {DOMElement|DOMTextNode} node\r\n * @param {object} offsets\r\n */\n\nexport function setOffsets(node, offsets) {\n  const doc = node.ownerDocument || document;\n  const win = doc && doc.defaultView || window; // Edge fails with \"Object expected\" in some scenarios.\n  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n  // fails when pasting 100+ items)\n\n  if (!win.getSelection) {\n    return;\n  }\n\n  const selection = win.getSelection();\n  const length = node.textContent.length;\n  let start = Math.min(offsets.start, length);\n  let end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n\n  if (!selection.extend && start > end) {\n    const temp = end;\n    end = start;\n    start = temp;\n  }\n\n  const startMarker = getNodeForCharacterOffset(node, start);\n  const endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n\n    const range = doc.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}","map":{"version":3,"names":["getNodeForCharacterOffset","TEXT_NODE","getOffsets","outerNode","ownerDocument","win","defaultView","window","selection","getSelection","rangeCount","anchorNode","anchorOffset","focusNode","focusOffset","nodeType","e","getModernOffsetsFromPoints","length","start","end","indexWithinAnchor","indexWithinFocus","node","parentNode","outer","next","nodeValue","firstChild","nextSibling","setOffsets","offsets","doc","document","textContent","Math","min","undefined","extend","temp","startMarker","endMarker","offset","range","createRange","setStart","removeAllRanges","addRange","setEnd"],"sources":["E:/debug-anything/react-test/src/react/packages/react-dom/src/client/ReactDOMSelection.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nimport getNodeForCharacterOffset from './getNodeForCharacterOffset';\r\nimport {TEXT_NODE} from '../shared/HTMLNodeType';\r\n\r\n/**\r\n * @param {DOMElement} outerNode\r\n * @return {?object}\r\n */\r\nexport function getOffsets(outerNode) {\r\n  const {ownerDocument} = outerNode;\r\n  const win = (ownerDocument && ownerDocument.defaultView) || window;\r\n  const selection = win.getSelection && win.getSelection();\r\n\r\n  if (!selection || selection.rangeCount === 0) {\r\n    return null;\r\n  }\r\n\r\n  const {anchorNode, anchorOffset, focusNode, focusOffset} = selection;\r\n\r\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\r\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\r\n  // expose properties, triggering a \"Permission denied error\" if any of its\r\n  // properties are accessed. The only seemingly possible way to avoid erroring\r\n  // is to access a property that typically works for non-anonymous divs and\r\n  // catch any error that may otherwise arise. See\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\r\n  try {\r\n    /* eslint-disable no-unused-expressions */\r\n    anchorNode.nodeType;\r\n    focusNode.nodeType;\r\n    /* eslint-enable no-unused-expressions */\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n\r\n  return getModernOffsetsFromPoints(\r\n    outerNode,\r\n    anchorNode,\r\n    anchorOffset,\r\n    focusNode,\r\n    focusOffset,\r\n  );\r\n}\r\n\r\n/**\r\n * Returns {start, end} where `start` is the character/codepoint index of\r\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\r\n * `end` is the index of (focusNode, focusOffset).\r\n *\r\n * Returns null if you pass in garbage input but we should probably just crash.\r\n *\r\n * Exported only for testing.\r\n */\r\nexport function getModernOffsetsFromPoints(\r\n  outerNode,\r\n  anchorNode,\r\n  anchorOffset,\r\n  focusNode,\r\n  focusOffset,\r\n) {\r\n  let length = 0;\r\n  let start = -1;\r\n  let end = -1;\r\n  let indexWithinAnchor = 0;\r\n  let indexWithinFocus = 0;\r\n  let node = outerNode;\r\n  let parentNode = null;\r\n\r\n  outer: while (true) {\r\n    let next = null;\r\n\r\n    while (true) {\r\n      if (\r\n        node === anchorNode &&\r\n        (anchorOffset === 0 || node.nodeType === TEXT_NODE)\r\n      ) {\r\n        start = length + anchorOffset;\r\n      }\r\n      if (\r\n        node === focusNode &&\r\n        (focusOffset === 0 || node.nodeType === TEXT_NODE)\r\n      ) {\r\n        end = length + focusOffset;\r\n      }\r\n\r\n      if (node.nodeType === TEXT_NODE) {\r\n        length += node.nodeValue.length;\r\n      }\r\n\r\n      if ((next = node.firstChild) === null) {\r\n        break;\r\n      }\r\n      // Moving from `node` to its first child `next`.\r\n      parentNode = node;\r\n      node = next;\r\n    }\r\n\r\n    while (true) {\r\n      if (node === outerNode) {\r\n        // If `outerNode` has children, this is always the second time visiting\r\n        // it. If it has no children, this is still the first loop, and the only\r\n        // valid selection is anchorNode and focusNode both equal to this node\r\n        // and both offsets 0, in which case we will have handled above.\r\n        break outer;\r\n      }\r\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\r\n        start = length;\r\n      }\r\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\r\n        end = length;\r\n      }\r\n      if ((next = node.nextSibling) !== null) {\r\n        break;\r\n      }\r\n      node = parentNode;\r\n      parentNode = node.parentNode;\r\n    }\r\n\r\n    // Moving from `node` to its next sibling `next`.\r\n    node = next;\r\n  }\r\n\r\n  if (start === -1 || end === -1) {\r\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\r\n    // actually inside the passed-in node.)\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    start: start,\r\n    end: end,\r\n  };\r\n}\r\n\r\n/**\r\n * In modern non-IE browsers, we can support both forward and backward\r\n * selections.\r\n *\r\n * Note: IE10+ supports the Selection object, but it does not support\r\n * the `extend` method, which means that even in modern IE, it's not possible\r\n * to programmatically create a backward selection. Thus, for all IE\r\n * versions, we use the old IE API to create our selections.\r\n *\r\n * @param {DOMElement|DOMTextNode} node\r\n * @param {object} offsets\r\n */\r\nexport function setOffsets(node, offsets) {\r\n  const doc = node.ownerDocument || document;\r\n  const win = (doc && doc.defaultView) || window;\r\n\r\n  // Edge fails with \"Object expected\" in some scenarios.\r\n  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,\r\n  // fails when pasting 100+ items)\r\n  if (!win.getSelection) {\r\n    return;\r\n  }\r\n\r\n  const selection = win.getSelection();\r\n  const length = node.textContent.length;\r\n  let start = Math.min(offsets.start, length);\r\n  let end = offsets.end === undefined ? start : Math.min(offsets.end, length);\r\n\r\n  // IE 11 uses modern selection, but doesn't support the extend method.\r\n  // Flip backward selections, so we can set with a single range.\r\n  if (!selection.extend && start > end) {\r\n    const temp = end;\r\n    end = start;\r\n    start = temp;\r\n  }\r\n\r\n  const startMarker = getNodeForCharacterOffset(node, start);\r\n  const endMarker = getNodeForCharacterOffset(node, end);\r\n\r\n  if (startMarker && endMarker) {\r\n    if (\r\n      selection.rangeCount === 1 &&\r\n      selection.anchorNode === startMarker.node &&\r\n      selection.anchorOffset === startMarker.offset &&\r\n      selection.focusNode === endMarker.node &&\r\n      selection.focusOffset === endMarker.offset\r\n    ) {\r\n      return;\r\n    }\r\n    const range = doc.createRange();\r\n    range.setStart(startMarker.node, startMarker.offset);\r\n    selection.removeAllRanges();\r\n\r\n    if (start > end) {\r\n      selection.addRange(range);\r\n      selection.extend(endMarker.node, endMarker.offset);\r\n    } else {\r\n      range.setEnd(endMarker.node, endMarker.offset);\r\n      selection.addRange(range);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}