{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableProfiling } from './SchedulerFeatureFlags';\nlet runIdCounter = 0;\nlet mainThreadIdCounter = 0; // Bytes per element is 4\n\nconst INITIAL_EVENT_LOG_SIZE = 131072;\nconst MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes\n\nlet eventLogSize = 0;\nlet eventLogBuffer = null;\nlet eventLog = null;\nlet eventLogIndex = 0;\nconst TaskStartEvent = 1;\nconst TaskCompleteEvent = 2;\nconst TaskErrorEvent = 3;\nconst TaskCancelEvent = 4;\nconst TaskRunEvent = 5;\nconst TaskYieldEvent = 6;\nconst SchedulerSuspendEvent = 7;\nconst SchedulerResumeEvent = 8;\n\nfunction logEvent(entries) {\n  if (eventLog !== null) {\n    const offset = eventLogIndex;\n    eventLogIndex += entries.length;\n\n    if (eventLogIndex + 1 > eventLogSize) {\n      eventLogSize *= 2;\n\n      if (eventLogSize > MAX_EVENT_LOG_SIZE) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error'](\"Scheduler Profiling: Event log exceeded maximum size. Don't \" + 'forget to call `stopLoggingProfilingEvents()`.');\n        stopLoggingProfilingEvents();\n        return;\n      }\n\n      const newEventLog = new Int32Array(eventLogSize * 4);\n      newEventLog.set(eventLog);\n      eventLogBuffer = newEventLog.buffer;\n      eventLog = newEventLog;\n    }\n\n    eventLog.set(entries, offset);\n  }\n}\n\nexport function startLoggingProfilingEvents() {\n  eventLogSize = INITIAL_EVENT_LOG_SIZE;\n  eventLogBuffer = new ArrayBuffer(eventLogSize * 4);\n  eventLog = new Int32Array(eventLogBuffer);\n  eventLogIndex = 0;\n}\nexport function stopLoggingProfilingEvents() {\n  const buffer = eventLogBuffer;\n  eventLogSize = 0;\n  eventLogBuffer = null;\n  eventLog = null;\n  eventLogIndex = 0;\n  return buffer;\n}\nexport function markTaskStart(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      // performance.now returns a float, representing milliseconds. When the\n      // event is logged, it's coerced to an int. Convert to microseconds to\n      // maintain extra degrees of precision.\n      logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);\n    }\n  }\n}\nexport function markTaskCompleted(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskCompleteEvent, ms * 1000, task.id]);\n    }\n  }\n}\nexport function markTaskCanceled(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskCancelEvent, ms * 1000, task.id]);\n    }\n  }\n}\nexport function markTaskErrored(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskErrorEvent, ms * 1000, task.id]);\n    }\n  }\n}\nexport function markTaskRun(task, ms) {\n  if (enableProfiling) {\n    runIdCounter++;\n\n    if (eventLog !== null) {\n      logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\nexport function markTaskYield(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\nexport function markSchedulerSuspended(ms) {\n  if (enableProfiling) {\n    mainThreadIdCounter++;\n\n    if (eventLog !== null) {\n      logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}\nexport function markSchedulerUnsuspended(ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}","map":{"version":3,"names":["enableProfiling","runIdCounter","mainThreadIdCounter","INITIAL_EVENT_LOG_SIZE","MAX_EVENT_LOG_SIZE","eventLogSize","eventLogBuffer","eventLog","eventLogIndex","TaskStartEvent","TaskCompleteEvent","TaskErrorEvent","TaskCancelEvent","TaskRunEvent","TaskYieldEvent","SchedulerSuspendEvent","SchedulerResumeEvent","logEvent","entries","offset","length","console","stopLoggingProfilingEvents","newEventLog","Int32Array","set","buffer","startLoggingProfilingEvents","ArrayBuffer","markTaskStart","task","ms","id","priorityLevel","markTaskCompleted","markTaskCanceled","markTaskErrored","markTaskRun","markTaskYield","markSchedulerSuspended","markSchedulerUnsuspended"],"sources":["E:/debug-anything/react-test/src/react/packages/scheduler/src/SchedulerProfiling.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {PriorityLevel} from './SchedulerPriorities';\r\nimport {enableProfiling} from './SchedulerFeatureFlags';\r\n\r\nlet runIdCounter: number = 0;\r\nlet mainThreadIdCounter: number = 0;\r\n\r\n// Bytes per element is 4\r\nconst INITIAL_EVENT_LOG_SIZE = 131072;\r\nconst MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes\r\n\r\nlet eventLogSize = 0;\r\nlet eventLogBuffer = null;\r\nlet eventLog = null;\r\nlet eventLogIndex = 0;\r\n\r\nconst TaskStartEvent = 1;\r\nconst TaskCompleteEvent = 2;\r\nconst TaskErrorEvent = 3;\r\nconst TaskCancelEvent = 4;\r\nconst TaskRunEvent = 5;\r\nconst TaskYieldEvent = 6;\r\nconst SchedulerSuspendEvent = 7;\r\nconst SchedulerResumeEvent = 8;\r\n\r\nfunction logEvent(entries) {\r\n  if (eventLog !== null) {\r\n    const offset = eventLogIndex;\r\n    eventLogIndex += entries.length;\r\n    if (eventLogIndex + 1 > eventLogSize) {\r\n      eventLogSize *= 2;\r\n      if (eventLogSize > MAX_EVENT_LOG_SIZE) {\r\n        // Using console['error'] to evade Babel and ESLint\r\n        console['error'](\r\n          \"Scheduler Profiling: Event log exceeded maximum size. Don't \" +\r\n            'forget to call `stopLoggingProfilingEvents()`.',\r\n        );\r\n        stopLoggingProfilingEvents();\r\n        return;\r\n      }\r\n      const newEventLog = new Int32Array(eventLogSize * 4);\r\n      newEventLog.set(eventLog);\r\n      eventLogBuffer = newEventLog.buffer;\r\n      eventLog = newEventLog;\r\n    }\r\n    eventLog.set(entries, offset);\r\n  }\r\n}\r\n\r\nexport function startLoggingProfilingEvents(): void {\r\n  eventLogSize = INITIAL_EVENT_LOG_SIZE;\r\n  eventLogBuffer = new ArrayBuffer(eventLogSize * 4);\r\n  eventLog = new Int32Array(eventLogBuffer);\r\n  eventLogIndex = 0;\r\n}\r\n\r\nexport function stopLoggingProfilingEvents(): ArrayBuffer | null {\r\n  const buffer = eventLogBuffer;\r\n  eventLogSize = 0;\r\n  eventLogBuffer = null;\r\n  eventLog = null;\r\n  eventLogIndex = 0;\r\n  return buffer;\r\n}\r\n\r\nexport function markTaskStart(\r\n  task: {\r\n    id: number,\r\n    priorityLevel: PriorityLevel,\r\n    ...\r\n  },\r\n  ms: number,\r\n) {\r\n  if (enableProfiling) {\r\n    if (eventLog !== null) {\r\n      // performance.now returns a float, representing milliseconds. When the\r\n      // event is logged, it's coerced to an int. Convert to microseconds to\r\n      // maintain extra degrees of precision.\r\n      logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function markTaskCompleted(\r\n  task: {\r\n    id: number,\r\n    priorityLevel: PriorityLevel,\r\n    ...\r\n  },\r\n  ms: number,\r\n) {\r\n  if (enableProfiling) {\r\n    if (eventLog !== null) {\r\n      logEvent([TaskCompleteEvent, ms * 1000, task.id]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function markTaskCanceled(\r\n  task: {\r\n    id: number,\r\n    priorityLevel: PriorityLevel,\r\n    ...\r\n  },\r\n  ms: number,\r\n) {\r\n  if (enableProfiling) {\r\n    if (eventLog !== null) {\r\n      logEvent([TaskCancelEvent, ms * 1000, task.id]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function markTaskErrored(\r\n  task: {\r\n    id: number,\r\n    priorityLevel: PriorityLevel,\r\n    ...\r\n  },\r\n  ms: number,\r\n) {\r\n  if (enableProfiling) {\r\n    if (eventLog !== null) {\r\n      logEvent([TaskErrorEvent, ms * 1000, task.id]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function markTaskRun(\r\n  task: {\r\n    id: number,\r\n    priorityLevel: PriorityLevel,\r\n    ...\r\n  },\r\n  ms: number,\r\n) {\r\n  if (enableProfiling) {\r\n    runIdCounter++;\r\n\r\n    if (eventLog !== null) {\r\n      logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function markTaskYield(task: {id: number, ...}, ms: number) {\r\n  if (enableProfiling) {\r\n    if (eventLog !== null) {\r\n      logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function markSchedulerSuspended(ms: number) {\r\n  if (enableProfiling) {\r\n    mainThreadIdCounter++;\r\n\r\n    if (eventLog !== null) {\r\n      logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function markSchedulerUnsuspended(ms: number) {\r\n  if (enableProfiling) {\r\n    if (eventLog !== null) {\r\n      logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}