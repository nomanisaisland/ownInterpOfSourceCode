{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\n\n/* eslint-disable no-var */\n\n/* eslint-disable react-internal/prod-error-codes */\nimport { enableSchedulerDebugging, enableProfiling } from '../SchedulerFeatureFlags';\nimport { push, pop, peek } from '../SchedulerMinHeap'; // TODO: Use symbols?\n\nimport { ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority } from '../SchedulerPriorities';\nimport { markTaskRun, markTaskYield, markTaskCompleted, markTaskCanceled, markTaskErrored, markSchedulerSuspended, markSchedulerUnsuspended, markTaskStart, stopLoggingProfilingEvents, startLoggingProfilingEvents } from '../SchedulerProfiling'; // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\n\nvar maxSigned31BitInt = 1073741823; // Times out immediately\n\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\nvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\nvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\nvar taskQueue = [];\nvar timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\nvar taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n\nvar isSchedulerPaused = false;\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\nvar isPerformingWork = false;\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false;\nlet currentMockTime = 0;\nlet scheduledCallback = null;\nlet scheduledTimeout = null;\nlet timeoutTime = -1;\nlet yieldedValues = null;\nlet expectedNumberOfYields = -1;\nlet didStop = false;\nlet isFlushing = false;\nlet needsPaint = false;\nlet shouldYieldForPaint = false;\nvar disableYieldValue = false;\n\nfunction setDisableYieldValue(newValue) {\n  disableYieldValue = newValue;\n}\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  let timer = peek(timerQueue);\n\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n\n      if (enableProfiling) {\n        markTaskStart(timer, currentTime);\n        timer.isQueued = true;\n      }\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      const firstTimer = peek(timerQueue);\n\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  if (enableProfiling) {\n    markSchedulerUnsuspended(initialTime);\n  } // We'll need a host callback the next time work is scheduled.\n\n\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  const previousPriorityLevel = currentPriorityLevel;\n\n  try {\n    if (enableProfiling) {\n      try {\n        return workLoop(hasTimeRemaining, initialTime);\n      } catch (error) {\n        if (currentTask !== null) {\n          const currentTime = getCurrentTime();\n          markTaskErrored(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n\n        throw error;\n      }\n    } else {\n      // No catch in prod code path.\n      return workLoop(hasTimeRemaining, initialTime);\n    }\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n\n    if (enableProfiling) {\n      const currentTime = getCurrentTime();\n      markSchedulerSuspended(currentTime);\n    }\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue);\n\n  while (currentTask !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n\n    const callback = currentTask.callback;\n\n    if (typeof callback === 'function') {\n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n      if (enableProfiling) {\n        markTaskRun(currentTask, currentTime);\n      }\n\n      const continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = getCurrentTime();\n\n      if (typeof continuationCallback === 'function') {\n        currentTask.callback = continuationCallback;\n\n        if (enableProfiling) {\n          markTaskYield(currentTask, currentTime);\n        }\n      } else {\n        if (enableProfiling) {\n          markTaskCompleted(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n\n      advanceTimers(currentTime);\n    } else {\n      pop(taskQueue);\n    }\n\n    currentTask = peek(taskQueue);\n  } // Return whether there's additional work\n\n\n  if (currentTask !== null) {\n    return true;\n  } else {\n    const firstTimer = peek(timerQueue);\n\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n\n    return false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = getCurrentTime();\n  var startTime;\n\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  var timeout;\n\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n\n    case UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n\n    case IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n\n    case LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n\n    case NormalPriority:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\n  var expirationTime = startTime + timeout;\n  var newTask = {\n    id: taskIdCounter++,\n    callback,\n    priorityLevel,\n    startTime,\n    expirationTime,\n    sortIndex: -1\n  };\n\n  if (enableProfiling) {\n    newTask.isQueued = false;\n  }\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      } // Schedule a timeout.\n\n\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n\n    if (enableProfiling) {\n      markTaskStart(newTask, currentTime);\n      newTask.isQueued = true;\n    } // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return peek(taskQueue);\n}\n\nfunction unstable_cancelCallback(task) {\n  if (enableProfiling) {\n    if (task.isQueued) {\n      const currentTime = getCurrentTime();\n      markTaskCanceled(task, currentTime);\n      task.isQueued = false;\n    }\n  } // Null out the callback to indicate the task has been canceled. (Can't\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n\n\n  task.callback = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction requestHostCallback(callback) {\n  scheduledCallback = callback;\n}\n\nfunction requestHostTimeout(callback, ms) {\n  scheduledTimeout = callback;\n  timeoutTime = currentMockTime + ms;\n}\n\nfunction cancelHostTimeout() {\n  scheduledTimeout = null;\n  timeoutTime = -1;\n}\n\nfunction shouldYieldToHost() {\n  if (expectedNumberOfYields === 0 && yieldedValues === null || expectedNumberOfYields !== -1 && yieldedValues !== null && yieldedValues.length >= expectedNumberOfYields || shouldYieldForPaint && needsPaint) {\n    // We yielded at least as many values as expected. Stop flushing.\n    didStop = true;\n    return true;\n  }\n\n  return false;\n}\n\nfunction getCurrentTime() {\n  return currentMockTime;\n}\n\nfunction forceFrameRate() {// No-op\n}\n\nfunction reset() {\n  if (isFlushing) {\n    throw new Error('Cannot reset while already flushing work.');\n  }\n\n  currentMockTime = 0;\n  scheduledCallback = null;\n  scheduledTimeout = null;\n  timeoutTime = -1;\n  yieldedValues = null;\n  expectedNumberOfYields = -1;\n  didStop = false;\n  isFlushing = false;\n  needsPaint = false;\n} // Should only be used via an assertion helper that inspects the yielded values.\n\n\nfunction unstable_flushNumberOfYields(count) {\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n\n  if (scheduledCallback !== null) {\n    const cb = scheduledCallback;\n    expectedNumberOfYields = count;\n    isFlushing = true;\n\n    try {\n      let hasMoreWork = true;\n\n      do {\n        hasMoreWork = cb(true, currentMockTime);\n      } while (hasMoreWork && !didStop);\n\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n    } finally {\n      expectedNumberOfYields = -1;\n      didStop = false;\n      isFlushing = false;\n    }\n  }\n}\n\nfunction unstable_flushUntilNextPaint() {\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n\n  if (scheduledCallback !== null) {\n    const cb = scheduledCallback;\n    shouldYieldForPaint = true;\n    needsPaint = false;\n    isFlushing = true;\n\n    try {\n      let hasMoreWork = true;\n\n      do {\n        hasMoreWork = cb(true, currentMockTime);\n      } while (hasMoreWork && !didStop);\n\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n    } finally {\n      shouldYieldForPaint = false;\n      didStop = false;\n      isFlushing = false;\n    }\n  }\n}\n\nfunction unstable_flushExpired() {\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n\n  if (scheduledCallback !== null) {\n    isFlushing = true;\n\n    try {\n      const hasMoreWork = scheduledCallback(false, currentMockTime);\n\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n    } finally {\n      isFlushing = false;\n    }\n  }\n}\n\nfunction unstable_flushAllWithoutAsserting() {\n  // Returns false if no work was flushed.\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n\n  if (scheduledCallback !== null) {\n    const cb = scheduledCallback;\n    isFlushing = true;\n\n    try {\n      let hasMoreWork = true;\n\n      do {\n        hasMoreWork = cb(true, currentMockTime);\n      } while (hasMoreWork);\n\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n\n      return true;\n    } finally {\n      isFlushing = false;\n    }\n  } else {\n    return false;\n  }\n}\n\nfunction unstable_clearYields() {\n  if (yieldedValues === null) {\n    return [];\n  }\n\n  const values = yieldedValues;\n  yieldedValues = null;\n  return values;\n}\n\nfunction unstable_flushAll() {\n  if (yieldedValues !== null) {\n    throw new Error('Log is not empty. Assert on the log of yielded values before ' + 'flushing additional work.');\n  }\n\n  unstable_flushAllWithoutAsserting();\n\n  if (yieldedValues !== null) {\n    throw new Error('While flushing work, something yielded a value. Use an ' + 'assertion helper to assert on the log of yielded values, e.g. ' + 'expect(Scheduler).toFlushAndYield([...])');\n  }\n}\n\nfunction unstable_yieldValue(value) {\n  // eslint-disable-next-line react-internal/no-production-logging\n  if (console.log.name === 'disabledLog' || disableYieldValue) {\n    // If console.log has been patched, we assume we're in render\n    // replaying and we ignore any values yielding in the second pass.\n    return;\n  }\n\n  if (yieldedValues === null) {\n    yieldedValues = [value];\n  } else {\n    yieldedValues.push(value);\n  }\n}\n\nfunction unstable_advanceTime(ms) {\n  // eslint-disable-next-line react-internal/no-production-logging\n  if (console.log.name === 'disabledLog' || disableYieldValue) {\n    // If console.log has been patched, we assume we're in render\n    // replaying and we ignore any time advancing in the second pass.\n    return;\n  }\n\n  currentMockTime += ms;\n\n  if (scheduledTimeout !== null && timeoutTime <= currentMockTime) {\n    scheduledTimeout(currentMockTime);\n    timeoutTime = -1;\n    scheduledTimeout = null;\n  }\n}\n\nfunction requestPaint() {\n  needsPaint = true;\n}\n\nexport { ImmediatePriority as unstable_ImmediatePriority, UserBlockingPriority as unstable_UserBlockingPriority, NormalPriority as unstable_NormalPriority, IdlePriority as unstable_IdlePriority, LowPriority as unstable_LowPriority, unstable_runWithPriority, unstable_next, unstable_scheduleCallback, unstable_cancelCallback, unstable_wrapCallback, unstable_getCurrentPriorityLevel, shouldYieldToHost as unstable_shouldYield, requestPaint as unstable_requestPaint, unstable_continueExecution, unstable_pauseExecution, unstable_getFirstCallbackNode, getCurrentTime as unstable_now, forceFrameRate as unstable_forceFrameRate, unstable_flushAllWithoutAsserting, unstable_flushNumberOfYields, unstable_flushExpired, unstable_clearYields, unstable_flushUntilNextPaint, unstable_flushAll, unstable_yieldValue, unstable_advanceTime, reset, setDisableYieldValue as unstable_setDisableYieldValue };\nexport const unstable_Profiling = enableProfiling ? {\n  startLoggingProfilingEvents,\n  stopLoggingProfilingEvents\n} : null;","map":{"version":3,"names":["enableSchedulerDebugging","enableProfiling","push","pop","peek","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","markTaskRun","markTaskYield","markTaskCompleted","markTaskCanceled","markTaskErrored","markSchedulerSuspended","markSchedulerUnsuspended","markTaskStart","stopLoggingProfilingEvents","startLoggingProfilingEvents","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY_TIMEOUT","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY_TIMEOUT","taskQueue","timerQueue","taskIdCounter","isSchedulerPaused","currentTask","currentPriorityLevel","isPerformingWork","isHostCallbackScheduled","isHostTimeoutScheduled","currentMockTime","scheduledCallback","scheduledTimeout","timeoutTime","yieldedValues","expectedNumberOfYields","didStop","isFlushing","needsPaint","shouldYieldForPaint","disableYieldValue","setDisableYieldValue","newValue","advanceTimers","currentTime","timer","callback","startTime","sortIndex","expirationTime","isQueued","handleTimeout","requestHostCallback","flushWork","firstTimer","requestHostTimeout","hasTimeRemaining","initialTime","cancelHostTimeout","previousPriorityLevel","workLoop","error","getCurrentTime","shouldYieldToHost","priorityLevel","didUserCallbackTimeout","continuationCallback","unstable_runWithPriority","eventHandler","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","options","delay","timeout","newTask","id","unstable_pauseExecution","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","task","unstable_getCurrentPriorityLevel","ms","length","forceFrameRate","reset","Error","unstable_flushNumberOfYields","count","cb","hasMoreWork","unstable_flushUntilNextPaint","unstable_flushExpired","unstable_flushAllWithoutAsserting","unstable_clearYields","values","unstable_flushAll","unstable_yieldValue","value","console","log","name","unstable_advanceTime","requestPaint","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority","unstable_shouldYield","unstable_requestPaint","unstable_now","unstable_forceFrameRate","unstable_setDisableYieldValue","unstable_Profiling"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/scheduler/src/forks/SchedulerMock.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/* eslint-disable no-var */\r\n/* eslint-disable react-internal/prod-error-codes */\r\n\r\nimport {\r\n  enableSchedulerDebugging,\r\n  enableProfiling,\r\n} from '../SchedulerFeatureFlags';\r\nimport {push, pop, peek} from '../SchedulerMinHeap';\r\n\r\n// TODO: Use symbols?\r\nimport {\r\n  ImmediatePriority,\r\n  UserBlockingPriority,\r\n  NormalPriority,\r\n  LowPriority,\r\n  IdlePriority,\r\n} from '../SchedulerPriorities';\r\nimport {\r\n  markTaskRun,\r\n  markTaskYield,\r\n  markTaskCompleted,\r\n  markTaskCanceled,\r\n  markTaskErrored,\r\n  markSchedulerSuspended,\r\n  markSchedulerUnsuspended,\r\n  markTaskStart,\r\n  stopLoggingProfilingEvents,\r\n  startLoggingProfilingEvents,\r\n} from '../SchedulerProfiling';\r\n\r\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n// Math.pow(2, 30) - 1\r\n// 0b111111111111111111111111111111\r\nvar maxSigned31BitInt = 1073741823;\r\n\r\n// Times out immediately\r\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n// Eventually times out\r\nvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\r\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\r\nvar LOW_PRIORITY_TIMEOUT = 10000;\r\n// Never times out\r\nvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\r\n\r\n// Tasks are stored on a min heap\r\nvar taskQueue = [];\r\nvar timerQueue = [];\r\n\r\n// Incrementing id counter. Used to maintain insertion order.\r\nvar taskIdCounter = 1;\r\n\r\n// Pausing the scheduler is useful for debugging.\r\nvar isSchedulerPaused = false;\r\n\r\nvar currentTask = null;\r\nvar currentPriorityLevel = NormalPriority;\r\n\r\n// This is set while performing work, to prevent re-entrance.\r\nvar isPerformingWork = false;\r\n\r\nvar isHostCallbackScheduled = false;\r\nvar isHostTimeoutScheduled = false;\r\n\r\nlet currentMockTime: number = 0;\r\nlet scheduledCallback: ((boolean, number) => void) | null = null;\r\nlet scheduledTimeout: (number => void) | null = null;\r\nlet timeoutTime: number = -1;\r\nlet yieldedValues: Array<mixed> | null = null;\r\nlet expectedNumberOfYields: number = -1;\r\nlet didStop: boolean = false;\r\nlet isFlushing: boolean = false;\r\nlet needsPaint: boolean = false;\r\nlet shouldYieldForPaint: boolean = false;\r\n\r\nvar disableYieldValue = false;\r\n\r\nfunction setDisableYieldValue(newValue) {\r\n  disableYieldValue = newValue;\r\n}\r\n\r\nfunction advanceTimers(currentTime) {\r\n  // Check for tasks that are no longer delayed and add them to the queue.\r\n  let timer = peek(timerQueue);\r\n  while (timer !== null) {\r\n    if (timer.callback === null) {\r\n      // Timer was cancelled.\r\n      pop(timerQueue);\r\n    } else if (timer.startTime <= currentTime) {\r\n      // Timer fired. Transfer to the task queue.\r\n      pop(timerQueue);\r\n      timer.sortIndex = timer.expirationTime;\r\n      push(taskQueue, timer);\r\n      if (enableProfiling) {\r\n        markTaskStart(timer, currentTime);\r\n        timer.isQueued = true;\r\n      }\r\n    } else {\r\n      // Remaining timers are pending.\r\n      return;\r\n    }\r\n    timer = peek(timerQueue);\r\n  }\r\n}\r\n\r\nfunction handleTimeout(currentTime) {\r\n  isHostTimeoutScheduled = false;\r\n  advanceTimers(currentTime);\r\n\r\n  if (!isHostCallbackScheduled) {\r\n    if (peek(taskQueue) !== null) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    } else {\r\n      const firstTimer = peek(timerQueue);\r\n      if (firstTimer !== null) {\r\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWork(hasTimeRemaining, initialTime) {\r\n  if (enableProfiling) {\r\n    markSchedulerUnsuspended(initialTime);\r\n  }\r\n\r\n  // We'll need a host callback the next time work is scheduled.\r\n  isHostCallbackScheduled = false;\r\n  if (isHostTimeoutScheduled) {\r\n    // We scheduled a timeout but it's no longer needed. Cancel it.\r\n    isHostTimeoutScheduled = false;\r\n    cancelHostTimeout();\r\n  }\r\n\r\n  isPerformingWork = true;\r\n  const previousPriorityLevel = currentPriorityLevel;\r\n  try {\r\n    if (enableProfiling) {\r\n      try {\r\n        return workLoop(hasTimeRemaining, initialTime);\r\n      } catch (error) {\r\n        if (currentTask !== null) {\r\n          const currentTime = getCurrentTime();\r\n          markTaskErrored(currentTask, currentTime);\r\n          currentTask.isQueued = false;\r\n        }\r\n        throw error;\r\n      }\r\n    } else {\r\n      // No catch in prod code path.\r\n      return workLoop(hasTimeRemaining, initialTime);\r\n    }\r\n  } finally {\r\n    currentTask = null;\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    isPerformingWork = false;\r\n    if (enableProfiling) {\r\n      const currentTime = getCurrentTime();\r\n      markSchedulerSuspended(currentTime);\r\n    }\r\n  }\r\n}\r\n\r\nfunction workLoop(hasTimeRemaining, initialTime) {\r\n  let currentTime = initialTime;\r\n  advanceTimers(currentTime);\r\n  currentTask = peek(taskQueue);\r\n  while (\r\n    currentTask !== null &&\r\n    !(enableSchedulerDebugging && isSchedulerPaused)\r\n  ) {\r\n    if (\r\n      currentTask.expirationTime > currentTime &&\r\n      (!hasTimeRemaining || shouldYieldToHost())\r\n    ) {\r\n      // This currentTask hasn't expired, and we've reached the deadline.\r\n      break;\r\n    }\r\n    const callback = currentTask.callback;\r\n    if (typeof callback === 'function') {\r\n      currentTask.callback = null;\r\n      currentPriorityLevel = currentTask.priorityLevel;\r\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\r\n      if (enableProfiling) {\r\n        markTaskRun(currentTask, currentTime);\r\n      }\r\n      const continuationCallback = callback(didUserCallbackTimeout);\r\n      currentTime = getCurrentTime();\r\n      if (typeof continuationCallback === 'function') {\r\n        currentTask.callback = continuationCallback;\r\n        if (enableProfiling) {\r\n          markTaskYield(currentTask, currentTime);\r\n        }\r\n      } else {\r\n        if (enableProfiling) {\r\n          markTaskCompleted(currentTask, currentTime);\r\n          currentTask.isQueued = false;\r\n        }\r\n        if (currentTask === peek(taskQueue)) {\r\n          pop(taskQueue);\r\n        }\r\n      }\r\n      advanceTimers(currentTime);\r\n    } else {\r\n      pop(taskQueue);\r\n    }\r\n    currentTask = peek(taskQueue);\r\n  }\r\n  // Return whether there's additional work\r\n  if (currentTask !== null) {\r\n    return true;\r\n  } else {\r\n    const firstTimer = peek(timerQueue);\r\n    if (firstTimer !== null) {\r\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n    case LowPriority:\r\n    case IdlePriority:\r\n      break;\r\n    default:\r\n      priorityLevel = NormalPriority;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_next(eventHandler) {\r\n  var priorityLevel;\r\n  switch (currentPriorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n      // Shift down to normal priority\r\n      priorityLevel = NormalPriority;\r\n      break;\r\n    default:\r\n      // Anything lower than normal priority should remain at the current level.\r\n      priorityLevel = currentPriorityLevel;\r\n      break;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_wrapCallback(callback) {\r\n  var parentPriorityLevel = currentPriorityLevel;\r\n  return function() {\r\n    // This is a fork of runWithPriority, inlined for performance.\r\n    var previousPriorityLevel = currentPriorityLevel;\r\n    currentPriorityLevel = parentPriorityLevel;\r\n\r\n    try {\r\n      return callback.apply(this, arguments);\r\n    } finally {\r\n      currentPriorityLevel = previousPriorityLevel;\r\n    }\r\n  };\r\n}\r\n\r\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\r\n  var currentTime = getCurrentTime();\r\n\r\n  var startTime;\r\n  if (typeof options === 'object' && options !== null) {\r\n    var delay = options.delay;\r\n    if (typeof delay === 'number' && delay > 0) {\r\n      startTime = currentTime + delay;\r\n    } else {\r\n      startTime = currentTime;\r\n    }\r\n  } else {\r\n    startTime = currentTime;\r\n  }\r\n\r\n  var timeout;\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\r\n      break;\r\n    case UserBlockingPriority:\r\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\r\n      break;\r\n    case IdlePriority:\r\n      timeout = IDLE_PRIORITY_TIMEOUT;\r\n      break;\r\n    case LowPriority:\r\n      timeout = LOW_PRIORITY_TIMEOUT;\r\n      break;\r\n    case NormalPriority:\r\n    default:\r\n      timeout = NORMAL_PRIORITY_TIMEOUT;\r\n      break;\r\n  }\r\n\r\n  var expirationTime = startTime + timeout;\r\n\r\n  var newTask = {\r\n    id: taskIdCounter++,\r\n    callback,\r\n    priorityLevel,\r\n    startTime,\r\n    expirationTime,\r\n    sortIndex: -1,\r\n  };\r\n  if (enableProfiling) {\r\n    newTask.isQueued = false;\r\n  }\r\n\r\n  if (startTime > currentTime) {\r\n    // This is a delayed task.\r\n    newTask.sortIndex = startTime;\r\n    push(timerQueue, newTask);\r\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\r\n      // All tasks are delayed, and this is the task with the earliest delay.\r\n      if (isHostTimeoutScheduled) {\r\n        // Cancel an existing timeout.\r\n        cancelHostTimeout();\r\n      } else {\r\n        isHostTimeoutScheduled = true;\r\n      }\r\n      // Schedule a timeout.\r\n      requestHostTimeout(handleTimeout, startTime - currentTime);\r\n    }\r\n  } else {\r\n    newTask.sortIndex = expirationTime;\r\n    push(taskQueue, newTask);\r\n    if (enableProfiling) {\r\n      markTaskStart(newTask, currentTime);\r\n      newTask.isQueued = true;\r\n    }\r\n    // Schedule a host callback, if needed. If we're already performing work,\r\n    // wait until the next time we yield.\r\n    if (!isHostCallbackScheduled && !isPerformingWork) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    }\r\n  }\r\n\r\n  return newTask;\r\n}\r\n\r\nfunction unstable_pauseExecution() {\r\n  isSchedulerPaused = true;\r\n}\r\n\r\nfunction unstable_continueExecution() {\r\n  isSchedulerPaused = false;\r\n  if (!isHostCallbackScheduled && !isPerformingWork) {\r\n    isHostCallbackScheduled = true;\r\n    requestHostCallback(flushWork);\r\n  }\r\n}\r\n\r\nfunction unstable_getFirstCallbackNode() {\r\n  return peek(taskQueue);\r\n}\r\n\r\nfunction unstable_cancelCallback(task) {\r\n  if (enableProfiling) {\r\n    if (task.isQueued) {\r\n      const currentTime = getCurrentTime();\r\n      markTaskCanceled(task, currentTime);\r\n      task.isQueued = false;\r\n    }\r\n  }\r\n\r\n  // Null out the callback to indicate the task has been canceled. (Can't\r\n  // remove from the queue because you can't remove arbitrary nodes from an\r\n  // array based heap, only the first one.)\r\n  task.callback = null;\r\n}\r\n\r\nfunction unstable_getCurrentPriorityLevel() {\r\n  return currentPriorityLevel;\r\n}\r\n\r\nfunction requestHostCallback(callback: boolean => void) {\r\n  scheduledCallback = callback;\r\n}\r\n\r\nfunction requestHostTimeout(callback: number => void, ms: number) {\r\n  scheduledTimeout = callback;\r\n  timeoutTime = currentMockTime + ms;\r\n}\r\n\r\nfunction cancelHostTimeout(): void {\r\n  scheduledTimeout = null;\r\n  timeoutTime = -1;\r\n}\r\n\r\nfunction shouldYieldToHost(): boolean {\r\n  if (\r\n    (expectedNumberOfYields === 0 && yieldedValues === null) ||\r\n    (expectedNumberOfYields !== -1 &&\r\n      yieldedValues !== null &&\r\n      yieldedValues.length >= expectedNumberOfYields) ||\r\n    (shouldYieldForPaint && needsPaint)\r\n  ) {\r\n    // We yielded at least as many values as expected. Stop flushing.\r\n    didStop = true;\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction getCurrentTime(): number {\r\n  return currentMockTime;\r\n}\r\n\r\nfunction forceFrameRate() {\r\n  // No-op\r\n}\r\n\r\nfunction reset() {\r\n  if (isFlushing) {\r\n    throw new Error('Cannot reset while already flushing work.');\r\n  }\r\n  currentMockTime = 0;\r\n  scheduledCallback = null;\r\n  scheduledTimeout = null;\r\n  timeoutTime = -1;\r\n  yieldedValues = null;\r\n  expectedNumberOfYields = -1;\r\n  didStop = false;\r\n  isFlushing = false;\r\n  needsPaint = false;\r\n}\r\n\r\n// Should only be used via an assertion helper that inspects the yielded values.\r\nfunction unstable_flushNumberOfYields(count: number): void {\r\n  if (isFlushing) {\r\n    throw new Error('Already flushing work.');\r\n  }\r\n  if (scheduledCallback !== null) {\r\n    const cb = scheduledCallback;\r\n    expectedNumberOfYields = count;\r\n    isFlushing = true;\r\n    try {\r\n      let hasMoreWork = true;\r\n      do {\r\n        hasMoreWork = cb(true, currentMockTime);\r\n      } while (hasMoreWork && !didStop);\r\n      if (!hasMoreWork) {\r\n        scheduledCallback = null;\r\n      }\r\n    } finally {\r\n      expectedNumberOfYields = -1;\r\n      didStop = false;\r\n      isFlushing = false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction unstable_flushUntilNextPaint(): void {\r\n  if (isFlushing) {\r\n    throw new Error('Already flushing work.');\r\n  }\r\n  if (scheduledCallback !== null) {\r\n    const cb = scheduledCallback;\r\n    shouldYieldForPaint = true;\r\n    needsPaint = false;\r\n    isFlushing = true;\r\n    try {\r\n      let hasMoreWork = true;\r\n      do {\r\n        hasMoreWork = cb(true, currentMockTime);\r\n      } while (hasMoreWork && !didStop);\r\n      if (!hasMoreWork) {\r\n        scheduledCallback = null;\r\n      }\r\n    } finally {\r\n      shouldYieldForPaint = false;\r\n      didStop = false;\r\n      isFlushing = false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction unstable_flushExpired() {\r\n  if (isFlushing) {\r\n    throw new Error('Already flushing work.');\r\n  }\r\n  if (scheduledCallback !== null) {\r\n    isFlushing = true;\r\n    try {\r\n      const hasMoreWork = scheduledCallback(false, currentMockTime);\r\n      if (!hasMoreWork) {\r\n        scheduledCallback = null;\r\n      }\r\n    } finally {\r\n      isFlushing = false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction unstable_flushAllWithoutAsserting(): boolean {\r\n  // Returns false if no work was flushed.\r\n  if (isFlushing) {\r\n    throw new Error('Already flushing work.');\r\n  }\r\n  if (scheduledCallback !== null) {\r\n    const cb = scheduledCallback;\r\n    isFlushing = true;\r\n    try {\r\n      let hasMoreWork = true;\r\n      do {\r\n        hasMoreWork = cb(true, currentMockTime);\r\n      } while (hasMoreWork);\r\n      if (!hasMoreWork) {\r\n        scheduledCallback = null;\r\n      }\r\n      return true;\r\n    } finally {\r\n      isFlushing = false;\r\n    }\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction unstable_clearYields(): Array<mixed> {\r\n  if (yieldedValues === null) {\r\n    return [];\r\n  }\r\n  const values = yieldedValues;\r\n  yieldedValues = null;\r\n  return values;\r\n}\r\n\r\nfunction unstable_flushAll(): void {\r\n  if (yieldedValues !== null) {\r\n    throw new Error(\r\n      'Log is not empty. Assert on the log of yielded values before ' +\r\n        'flushing additional work.',\r\n    );\r\n  }\r\n  unstable_flushAllWithoutAsserting();\r\n  if (yieldedValues !== null) {\r\n    throw new Error(\r\n      'While flushing work, something yielded a value. Use an ' +\r\n        'assertion helper to assert on the log of yielded values, e.g. ' +\r\n        'expect(Scheduler).toFlushAndYield([...])',\r\n    );\r\n  }\r\n}\r\n\r\nfunction unstable_yieldValue(value: mixed): void {\r\n  // eslint-disable-next-line react-internal/no-production-logging\r\n  if (console.log.name === 'disabledLog' || disableYieldValue) {\r\n    // If console.log has been patched, we assume we're in render\r\n    // replaying and we ignore any values yielding in the second pass.\r\n    return;\r\n  }\r\n  if (yieldedValues === null) {\r\n    yieldedValues = [value];\r\n  } else {\r\n    yieldedValues.push(value);\r\n  }\r\n}\r\n\r\nfunction unstable_advanceTime(ms: number) {\r\n  // eslint-disable-next-line react-internal/no-production-logging\r\n  if (console.log.name === 'disabledLog' || disableYieldValue) {\r\n    // If console.log has been patched, we assume we're in render\r\n    // replaying and we ignore any time advancing in the second pass.\r\n    return;\r\n  }\r\n  currentMockTime += ms;\r\n  if (scheduledTimeout !== null && timeoutTime <= currentMockTime) {\r\n    scheduledTimeout(currentMockTime);\r\n    timeoutTime = -1;\r\n    scheduledTimeout = null;\r\n  }\r\n}\r\n\r\nfunction requestPaint() {\r\n  needsPaint = true;\r\n}\r\n\r\nexport {\r\n  ImmediatePriority as unstable_ImmediatePriority,\r\n  UserBlockingPriority as unstable_UserBlockingPriority,\r\n  NormalPriority as unstable_NormalPriority,\r\n  IdlePriority as unstable_IdlePriority,\r\n  LowPriority as unstable_LowPriority,\r\n  unstable_runWithPriority,\r\n  unstable_next,\r\n  unstable_scheduleCallback,\r\n  unstable_cancelCallback,\r\n  unstable_wrapCallback,\r\n  unstable_getCurrentPriorityLevel,\r\n  shouldYieldToHost as unstable_shouldYield,\r\n  requestPaint as unstable_requestPaint,\r\n  unstable_continueExecution,\r\n  unstable_pauseExecution,\r\n  unstable_getFirstCallbackNode,\r\n  getCurrentTime as unstable_now,\r\n  forceFrameRate as unstable_forceFrameRate,\r\n  unstable_flushAllWithoutAsserting,\r\n  unstable_flushNumberOfYields,\r\n  unstable_flushExpired,\r\n  unstable_clearYields,\r\n  unstable_flushUntilNextPaint,\r\n  unstable_flushAll,\r\n  unstable_yieldValue,\r\n  unstable_advanceTime,\r\n  reset,\r\n  setDisableYieldValue as unstable_setDisableYieldValue,\r\n};\r\n\r\nexport const unstable_Profiling = enableProfiling\r\n  ? {\r\n      startLoggingProfilingEvents,\r\n      stopLoggingProfilingEvents,\r\n    }\r\n  : null;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}