{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableProfilerTimer } from 'shared/ReactFeatureFlags';\nimport { HostRoot, Profiler } from './ReactWorkTags'; // Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\n\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_now: now\n} = Scheduler;\nlet commitTime = 0;\nlet layoutEffectStartTime = -1;\nlet profilerStartTime = -1;\nlet passiveEffectStartTime = -1;\n/**\r\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\r\n *\r\n * The overall sequence is:\r\n *   1. render\r\n *   2. commit (and call `onRender`, `onCommit`)\r\n *   3. check for nested updates\r\n *   4. flush passive effects (and call `onPostCommit`)\r\n *\r\n * Nested updates are identified in step 3 above,\r\n * but step 4 still applies to the work that was just committed.\r\n * We use two flags to track nested updates then:\r\n * one tracks whether the upcoming update is a nested update,\r\n * and the other tracks whether the current update was a nested update.\r\n * The first value gets synced to the second at the start of the render phase.\r\n */\n\nlet currentUpdateIsNested = false;\nlet nestedUpdateScheduled = false;\n\nfunction isCurrentUpdateNested() {\n  return currentUpdateIsNested;\n}\n\nfunction markNestedUpdateScheduled() {\n  if (enableProfilerNestedUpdatePhase) {\n    nestedUpdateScheduled = true;\n  }\n}\n\nfunction resetNestedUpdateFlag() {\n  if (enableProfilerNestedUpdatePhase) {\n    currentUpdateIsNested = false;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction syncNestedUpdateFlag() {\n  if (enableProfilerNestedUpdatePhase) {\n    currentUpdateIsNested = nestedUpdateScheduled;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  commitTime = now();\n}\n\nfunction startProfilerTimer(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = now();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    const elapsedTime = now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n\n    profilerStartTime = -1;\n  }\n}\n\nfunction recordLayoutEffectDuration(fiber) {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  if (layoutEffectStartTime >= 0) {\n    const elapsedTime = now() - layoutEffectStartTime;\n    layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    let parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          const root = parentFiber.stateNode;\n          root.effectDuration += elapsedTime;\n          return;\n\n        case Profiler:\n          const parentStateNode = parentFiber.stateNode;\n          parentStateNode.effectDuration += elapsedTime;\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction recordPassiveEffectDuration(fiber) {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  if (passiveEffectStartTime >= 0) {\n    const elapsedTime = now() - passiveEffectStartTime;\n    passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    let parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          const root = parentFiber.stateNode;\n\n          if (root !== null) {\n            root.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n\n        case Profiler:\n          const parentStateNode = parentFiber.stateNode;\n\n          if (parentStateNode !== null) {\n            // Detached fibers have their state node cleared out.\n            // In this case, the return pointer is also cleared out,\n            // so we won't be able to report the time spent in this Profiler's subtree.\n            parentStateNode.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction startLayoutEffectTimer() {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  layoutEffectStartTime = now();\n}\n\nfunction startPassiveEffectTimer() {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  passiveEffectStartTime = now();\n}\n\nfunction transferActualDuration(fiber) {\n  // Transfer time spent rendering these children so we don't lose it\n  // after we rerender. This is used as a helper in special cases\n  // where we should count the work of multiple passes.\n  let child = fiber.child;\n\n  while (child) {\n    fiber.actualDuration += child.actualDuration;\n    child = child.sibling;\n  }\n}\n\nexport { getCommitTime, isCurrentUpdateNested, markNestedUpdateScheduled, recordCommitTime, recordLayoutEffectDuration, recordPassiveEffectDuration, resetNestedUpdateFlag, startLayoutEffectTimer, startPassiveEffectTimer, startProfilerTimer, stopProfilerTimerIfRunning, stopProfilerTimerIfRunningAndRecordDelta, syncNestedUpdateFlag, transferActualDuration };","map":{"version":3,"names":["enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableProfilerTimer","HostRoot","Profiler","Scheduler","unstable_now","now","commitTime","layoutEffectStartTime","profilerStartTime","passiveEffectStartTime","currentUpdateIsNested","nestedUpdateScheduled","isCurrentUpdateNested","markNestedUpdateScheduled","resetNestedUpdateFlag","syncNestedUpdateFlag","getCommitTime","recordCommitTime","startProfilerTimer","fiber","actualStartTime","stopProfilerTimerIfRunning","stopProfilerTimerIfRunningAndRecordDelta","overrideBaseTime","elapsedTime","actualDuration","selfBaseDuration","recordLayoutEffectDuration","parentFiber","return","tag","root","stateNode","effectDuration","parentStateNode","recordPassiveEffectDuration","passiveEffectDuration","startLayoutEffectTimer","startPassiveEffectTimer","transferActualDuration","child","sibling"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactProfilerTimer.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from './ReactInternalTypes';\r\n\r\nimport {\r\n  enableProfilerCommitHooks,\r\n  enableProfilerNestedUpdatePhase,\r\n  enableProfilerTimer,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {HostRoot, Profiler} from './ReactWorkTags';\r\n\r\n// Intentionally not named imports because Rollup would use dynamic dispatch for\r\n// CommonJS interop named imports.\r\nimport * as Scheduler from 'scheduler';\r\n\r\nconst {unstable_now: now} = Scheduler;\r\n\r\nexport type ProfilerTimer = {\r\n  getCommitTime(): number,\r\n  isCurrentUpdateNested(): boolean,\r\n  markNestedUpdateScheduled(): void,\r\n  recordCommitTime(): void,\r\n  startProfilerTimer(fiber: Fiber): void,\r\n  stopProfilerTimerIfRunning(fiber: Fiber): void,\r\n  stopProfilerTimerIfRunningAndRecordDelta(fiber: Fiber): void,\r\n  syncNestedUpdateFlag(): void,\r\n  ...\r\n};\r\n\r\nlet commitTime: number = 0;\r\nlet layoutEffectStartTime: number = -1;\r\nlet profilerStartTime: number = -1;\r\nlet passiveEffectStartTime: number = -1;\r\n\r\n/**\r\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\r\n *\r\n * The overall sequence is:\r\n *   1. render\r\n *   2. commit (and call `onRender`, `onCommit`)\r\n *   3. check for nested updates\r\n *   4. flush passive effects (and call `onPostCommit`)\r\n *\r\n * Nested updates are identified in step 3 above,\r\n * but step 4 still applies to the work that was just committed.\r\n * We use two flags to track nested updates then:\r\n * one tracks whether the upcoming update is a nested update,\r\n * and the other tracks whether the current update was a nested update.\r\n * The first value gets synced to the second at the start of the render phase.\r\n */\r\nlet currentUpdateIsNested: boolean = false;\r\nlet nestedUpdateScheduled: boolean = false;\r\n\r\nfunction isCurrentUpdateNested(): boolean {\r\n  return currentUpdateIsNested;\r\n}\r\n\r\nfunction markNestedUpdateScheduled(): void {\r\n  if (enableProfilerNestedUpdatePhase) {\r\n    nestedUpdateScheduled = true;\r\n  }\r\n}\r\n\r\nfunction resetNestedUpdateFlag(): void {\r\n  if (enableProfilerNestedUpdatePhase) {\r\n    currentUpdateIsNested = false;\r\n    nestedUpdateScheduled = false;\r\n  }\r\n}\r\n\r\nfunction syncNestedUpdateFlag(): void {\r\n  if (enableProfilerNestedUpdatePhase) {\r\n    currentUpdateIsNested = nestedUpdateScheduled;\r\n    nestedUpdateScheduled = false;\r\n  }\r\n}\r\n\r\nfunction getCommitTime(): number {\r\n  return commitTime;\r\n}\r\n\r\nfunction recordCommitTime(): void {\r\n  if (!enableProfilerTimer) {\r\n    return;\r\n  }\r\n  commitTime = now();\r\n}\r\n\r\nfunction startProfilerTimer(fiber: Fiber): void {\r\n  if (!enableProfilerTimer) {\r\n    return;\r\n  }\r\n\r\n  profilerStartTime = now();\r\n\r\n  if (((fiber.actualStartTime: any): number) < 0) {\r\n    fiber.actualStartTime = now();\r\n  }\r\n}\r\n\r\nfunction stopProfilerTimerIfRunning(fiber: Fiber): void {\r\n  if (!enableProfilerTimer) {\r\n    return;\r\n  }\r\n  profilerStartTime = -1;\r\n}\r\n\r\nfunction stopProfilerTimerIfRunningAndRecordDelta(\r\n  fiber: Fiber,\r\n  overrideBaseTime: boolean,\r\n): void {\r\n  if (!enableProfilerTimer) {\r\n    return;\r\n  }\r\n\r\n  if (profilerStartTime >= 0) {\r\n    const elapsedTime = now() - profilerStartTime;\r\n    fiber.actualDuration += elapsedTime;\r\n    if (overrideBaseTime) {\r\n      fiber.selfBaseDuration = elapsedTime;\r\n    }\r\n    profilerStartTime = -1;\r\n  }\r\n}\r\n\r\nfunction recordLayoutEffectDuration(fiber: Fiber): void {\r\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\r\n    return;\r\n  }\r\n\r\n  if (layoutEffectStartTime >= 0) {\r\n    const elapsedTime = now() - layoutEffectStartTime;\r\n\r\n    layoutEffectStartTime = -1;\r\n\r\n    // Store duration on the next nearest Profiler ancestor\r\n    // Or the root (for the DevTools Profiler to read)\r\n    let parentFiber = fiber.return;\r\n    while (parentFiber !== null) {\r\n      switch (parentFiber.tag) {\r\n        case HostRoot:\r\n          const root = parentFiber.stateNode;\r\n          root.effectDuration += elapsedTime;\r\n          return;\r\n        case Profiler:\r\n          const parentStateNode = parentFiber.stateNode;\r\n          parentStateNode.effectDuration += elapsedTime;\r\n          return;\r\n      }\r\n      parentFiber = parentFiber.return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction recordPassiveEffectDuration(fiber: Fiber): void {\r\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\r\n    return;\r\n  }\r\n\r\n  if (passiveEffectStartTime >= 0) {\r\n    const elapsedTime = now() - passiveEffectStartTime;\r\n\r\n    passiveEffectStartTime = -1;\r\n\r\n    // Store duration on the next nearest Profiler ancestor\r\n    // Or the root (for the DevTools Profiler to read)\r\n    let parentFiber = fiber.return;\r\n    while (parentFiber !== null) {\r\n      switch (parentFiber.tag) {\r\n        case HostRoot:\r\n          const root = parentFiber.stateNode;\r\n          if (root !== null) {\r\n            root.passiveEffectDuration += elapsedTime;\r\n          }\r\n          return;\r\n        case Profiler:\r\n          const parentStateNode = parentFiber.stateNode;\r\n          if (parentStateNode !== null) {\r\n            // Detached fibers have their state node cleared out.\r\n            // In this case, the return pointer is also cleared out,\r\n            // so we won't be able to report the time spent in this Profiler's subtree.\r\n            parentStateNode.passiveEffectDuration += elapsedTime;\r\n          }\r\n          return;\r\n      }\r\n      parentFiber = parentFiber.return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction startLayoutEffectTimer(): void {\r\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\r\n    return;\r\n  }\r\n  layoutEffectStartTime = now();\r\n}\r\n\r\nfunction startPassiveEffectTimer(): void {\r\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\r\n    return;\r\n  }\r\n  passiveEffectStartTime = now();\r\n}\r\n\r\nfunction transferActualDuration(fiber: Fiber): void {\r\n  // Transfer time spent rendering these children so we don't lose it\r\n  // after we rerender. This is used as a helper in special cases\r\n  // where we should count the work of multiple passes.\r\n  let child = fiber.child;\r\n  while (child) {\r\n    fiber.actualDuration += child.actualDuration;\r\n    child = child.sibling;\r\n  }\r\n}\r\n\r\nexport {\r\n  getCommitTime,\r\n  isCurrentUpdateNested,\r\n  markNestedUpdateScheduled,\r\n  recordCommitTime,\r\n  recordLayoutEffectDuration,\r\n  recordPassiveEffectDuration,\r\n  resetNestedUpdateFlag,\r\n  startLayoutEffectTimer,\r\n  startPassiveEffectTimer,\r\n  startProfilerTimer,\r\n  stopProfilerTimerIfRunning,\r\n  stopProfilerTimerIfRunningAndRecordDelta,\r\n  syncNestedUpdateFlag,\r\n  transferActualDuration,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}