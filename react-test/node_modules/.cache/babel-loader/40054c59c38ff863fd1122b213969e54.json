{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay } from 'shared/ReactFeatureFlags';\nimport { isDiscreteEventThatRequiresHydration, queueDiscreteEvent, hasQueuedDiscreteEvents, clearIfContinuousEvent, queueIfContinuousEvent, attemptSynchronousHydration } from './ReactDOMEventReplaying';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/src/ReactFiberTreeReflection';\nimport { HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { IS_CAPTURE_PHASE } from './EventSystemFlags';\nimport getEventTarget from './getEventTarget';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { dispatchEventForPluginEventSystem } from './DOMPluginEventSystem';\nimport { getCurrentPriorityLevel as getCurrentSchedulerPriorityLevel, IdlePriority as IdleSchedulerPriority, ImmediatePriority as ImmediateSchedulerPriority, LowPriority as LowSchedulerPriority, NormalPriority as NormalSchedulerPriority, UserBlockingPriority as UserBlockingSchedulerPriority } from 'react-reconciler/src/Scheduler';\nimport { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority, IdleEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority } from 'react-reconciler/src/ReactEventPriorities';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { isRootDehydrated } from 'react-reconciler/src/ReactFiberShellHydration';\nconst {\n  ReactCurrentBatchConfig\n} = ReactSharedInternals; // TODO: can we stop exporting these?\n\nexport let _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\n\nexport function setEnabled(enabled) {\n  _enabled = !!enabled;\n}\nexport function isEnabled() {\n  return _enabled;\n}\nexport function createEventListenerWrapper(targetContainer, domEventName, eventSystemFlags) {\n  return dispatchEvent.bind(null, domEventName, eventSystemFlags, targetContainer);\n}\nexport function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\n  // 调用`getEventPriority` 函数实现从`事件名`到 `事件优先级` 的转化\n  // 默认的优先级是16 \n  const eventPriority = getEventPriority(domEventName);\n  console.log(eventPriority, domEventName, \"eventPriority\");\n  let listenerWrapper; // 2. 根据 `事件优先级` eventPriority 匹配不同的回调函数：（dispatchDiscreteEvent，dispatchContinuousEvent， dispatchEvent）// 2. 根据 `事件优先级` eventPriority 匹配不同的回调函数：（dispatchDiscreteEvent，dispatchContinuousEvent， dispatchEvent）\n\n  switch (eventPriority) {\n    case DiscreteEventPriority:\n      listenerWrapper = dispatchDiscreteEvent;\n      break;\n\n    case ContinuousEventPriority:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n\n    case DefaultEventPriority:\n    default:\n      listenerWrapper = dispatchEvent;\n      break;\n  } // 3. 返回事件回调函数，赋值给 listener\n\n\n  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\n}\n\nfunction dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = null;\n\n  try {\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nfunction dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = null;\n\n  try {\n    setCurrentUpdatePriority(ContinuousEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nexport function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n  } else {\n    dispatchEventOriginal(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n  }\n}\n\nfunction dispatchEventOriginal(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // TODO: replaying capture phase events is currently broken\n  // because we used to do it during top-level native bubble handlers\n  // but now we use different bubble and capture handlers.\n  // In eager mode, we attach capture listeners early, so we need\n  // to filter them out until we fix the logic to handle them correctly.\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\n\n  if (allowReplay && hasQueuedDiscreteEvents() && isDiscreteEventThatRequiresHydration(domEventName)) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.\n    domEventName, eventSystemFlags, targetContainer, nativeEvent);\n    return;\n  }\n\n  const blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n  if (blockedOn === null) {\n    dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n\n    if (allowReplay) {\n      clearIfContinuousEvent(domEventName, nativeEvent);\n    }\n\n    return;\n  }\n\n  if (allowReplay) {\n    if (isDiscreteEventThatRequiresHydration(domEventName)) {\n      // This this to be replayed later once the target is available.\n      queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n      return;\n    }\n\n    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n      return;\n    } // We need to clear only if we didn't queue because\n    // queueing is accumulative.\n\n\n    clearIfContinuousEvent(domEventName, nativeEvent);\n  } // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n\n\n  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n}\n\nfunction dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  let blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n  if (blockedOn === null) {\n    dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n    clearIfContinuousEvent(domEventName, nativeEvent);\n    return;\n  }\n\n  if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n    nativeEvent.stopPropagation();\n    return;\n  } // We need to clear only if we didn't queue because\n  // queueing is accumulative.\n\n\n  clearIfContinuousEvent(domEventName, nativeEvent);\n\n  if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {\n    while (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        attemptSynchronousHydration(fiber);\n      }\n\n      const nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n      if (nextBlockedOn === null) {\n        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n      }\n\n      if (nextBlockedOn === blockedOn) {\n        break;\n      }\n\n      blockedOn = nextBlockedOn;\n    }\n\n    if (blockedOn !== null) {\n      nativeEvent.stopPropagation();\n    }\n\n    return;\n  } // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n\n\n  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n}\n\nexport let return_targetInst = null; // Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\n\nexport function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // TODO: Warn if _enabled is false.\n  return_targetInst = null;\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        } // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n\n\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (isRootDehydrated(root)) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  return_targetInst = targetInst; // We're not blocked on anything.\n\n  return null;\n}\nexport function getEventPriority(domEventName) {\n  switch (domEventName) {\n    // Used by SimpleEventPlugin:\n    case 'cancel':\n    case 'click':\n    case 'close':\n    case 'contextmenu':\n    case 'copy':\n    case 'cut':\n    case 'auxclick':\n    case 'dblclick':\n    case 'dragend':\n    case 'dragstart':\n    case 'drop':\n    case 'focusin':\n    case 'focusout':\n    case 'input':\n    case 'invalid':\n    case 'keydown':\n    case 'keypress':\n    case 'keyup':\n    case 'mousedown':\n    case 'mouseup':\n    case 'paste':\n    case 'pause':\n    case 'play':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n    case 'ratechange':\n    case 'reset':\n    case 'resize':\n    case 'seeked':\n    case 'submit':\n    case 'touchcancel':\n    case 'touchend':\n    case 'touchstart':\n    case 'volumechange': // Used by polyfills:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'change':\n    case 'selectionchange':\n    case 'textInput':\n    case 'compositionstart':\n    case 'compositionend':\n    case 'compositionupdate': // Only enableCreateEventHandleAPI:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'beforeblur':\n    case 'afterblur': // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'beforeinput':\n    case 'blur':\n    case 'fullscreenchange':\n    case 'focus':\n    case 'hashchange':\n    case 'popstate':\n    case 'select':\n    case 'selectstart':\n      // 以上的优先级是1\n      return DiscreteEventPriority;\n\n    case 'drag':\n    case 'dragenter':\n    case 'dragexit':\n    case 'dragleave':\n    case 'dragover':\n    case 'mousemove':\n    case 'mouseout':\n    case 'mouseover':\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'scroll':\n    case 'toggle':\n    case 'touchmove':\n    case 'wheel': // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'mouseenter':\n    case 'mouseleave':\n    case 'pointerenter':\n    case 'pointerleave':\n      // 以上的优先级是4\n      return ContinuousEventPriority;\n\n    case 'message':\n      {\n        // We might be in the Scheduler callback.\n        // Eventually this mechanism will be replaced by a check\n        // of the current priority on the native scheduler.\n        const schedulerPriority = getCurrentSchedulerPriorityLevel();\n\n        switch (schedulerPriority) {\n          case ImmediateSchedulerPriority:\n            return DiscreteEventPriority;\n\n          case UserBlockingSchedulerPriority:\n            return ContinuousEventPriority;\n\n          case NormalSchedulerPriority:\n          case LowSchedulerPriority:\n            // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\n            return DefaultEventPriority;\n\n          case IdleSchedulerPriority:\n            return IdleEventPriority;\n\n          default:\n            return DefaultEventPriority;\n        }\n      }\n\n    default:\n      // 没有找到,使用默认优先级16\n      return DefaultEventPriority;\n  }\n}","map":{"version":3,"names":["enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","isDiscreteEventThatRequiresHydration","queueDiscreteEvent","hasQueuedDiscreteEvents","clearIfContinuousEvent","queueIfContinuousEvent","attemptSynchronousHydration","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","HostRoot","SuspenseComponent","IS_CAPTURE_PHASE","getEventTarget","getInstanceFromNode","getClosestInstanceFromNode","dispatchEventForPluginEventSystem","getCurrentPriorityLevel","getCurrentSchedulerPriorityLevel","IdlePriority","IdleSchedulerPriority","ImmediatePriority","ImmediateSchedulerPriority","LowPriority","LowSchedulerPriority","NormalPriority","NormalSchedulerPriority","UserBlockingPriority","UserBlockingSchedulerPriority","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","ReactSharedInternals","isRootDehydrated","ReactCurrentBatchConfig","_enabled","setEnabled","enabled","isEnabled","createEventListenerWrapper","targetContainer","domEventName","eventSystemFlags","dispatchEvent","bind","createEventListenerWrapperWithPriority","eventPriority","getEventPriority","console","log","listenerWrapper","dispatchDiscreteEvent","dispatchContinuousEvent","container","nativeEvent","previousPriority","prevTransition","transition","dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","dispatchEventOriginal","allowReplay","blockedOn","findInstanceBlockingEvent","return_targetInst","stopPropagation","fiber","nextBlockedOn","nativeEventTarget","targetInst","nearestMounted","tag","instance","root","stateNode","schedulerPriority"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-dom/src/events/ReactDOMEventListener.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { AnyNativeEvent } from '../events/PluginModuleType';\r\nimport type { FiberRoot } from 'react-reconciler/src/ReactInternalTypes';\r\nimport type { Container, SuspenseInstance } from '../client/ReactDOMHostConfig';\r\nimport type { DOMEventName } from '../events/DOMEventNames';\r\nimport { enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay } from 'shared/ReactFeatureFlags';\r\nimport {\r\n  isDiscreteEventThatRequiresHydration,\r\n  queueDiscreteEvent,\r\n  hasQueuedDiscreteEvents,\r\n  clearIfContinuousEvent,\r\n  queueIfContinuousEvent,\r\n  attemptSynchronousHydration,\r\n} from './ReactDOMEventReplaying';\r\nimport {\r\n  getNearestMountedFiber,\r\n  getContainerFromFiber,\r\n  getSuspenseInstanceFromFiber,\r\n} from 'react-reconciler/src/ReactFiberTreeReflection';\r\nimport { HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\r\nimport { type EventSystemFlags, IS_CAPTURE_PHASE } from './EventSystemFlags';\r\n\r\nimport getEventTarget from './getEventTarget';\r\nimport {\r\n  getInstanceFromNode,\r\n  getClosestInstanceFromNode,\r\n} from '../client/ReactDOMComponentTree';\r\n\r\nimport { dispatchEventForPluginEventSystem } from './DOMPluginEventSystem';\r\n\r\nimport {\r\n  getCurrentPriorityLevel as getCurrentSchedulerPriorityLevel,\r\n  IdlePriority as IdleSchedulerPriority,\r\n  ImmediatePriority as ImmediateSchedulerPriority,\r\n  LowPriority as LowSchedulerPriority,\r\n  NormalPriority as NormalSchedulerPriority,\r\n  UserBlockingPriority as UserBlockingSchedulerPriority,\r\n} from 'react-reconciler/src/Scheduler';\r\nimport {\r\n  DiscreteEventPriority,\r\n  ContinuousEventPriority,\r\n  DefaultEventPriority,\r\n  IdleEventPriority,\r\n  getCurrentUpdatePriority,\r\n  setCurrentUpdatePriority,\r\n} from 'react-reconciler/src/ReactEventPriorities';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport { isRootDehydrated } from 'react-reconciler/src/ReactFiberShellHydration';\r\n\r\nconst { ReactCurrentBatchConfig } = ReactSharedInternals;\r\n\r\n// TODO: can we stop exporting these?\r\nexport let _enabled = true;\r\n\r\n// This is exported in FB builds for use by legacy FB layer infra.\r\n// We'd like to remove this but it's not clear if this is safe.\r\nexport function setEnabled (enabled: ?boolean) {\r\n  _enabled = !!enabled;\r\n}\r\n\r\nexport function isEnabled () {\r\n  return _enabled;\r\n}\r\n\r\nexport function createEventListenerWrapper (\r\n  targetContainer: EventTarget,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n): Function {\r\n  return dispatchEvent.bind(\r\n    null,\r\n    domEventName,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n  );\r\n}\r\n\r\nexport function createEventListenerWrapperWithPriority (\r\n  targetContainer: EventTarget,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n): Function {\r\n  // 调用`getEventPriority` 函数实现从`事件名`到 `事件优先级` 的转化\r\n\r\n  // 默认的优先级是16 \r\n  const eventPriority = getEventPriority(domEventName);\r\n  console.log(eventPriority, domEventName, \"eventPriority\")\r\n  let listenerWrapper;\r\n  // 2. 根据 `事件优先级` eventPriority 匹配不同的回调函数：（dispatchDiscreteEvent，dispatchContinuousEvent， dispatchEvent）// 2. 根据 `事件优先级` eventPriority 匹配不同的回调函数：（dispatchDiscreteEvent，dispatchContinuousEvent， dispatchEvent）\r\n  switch (eventPriority) {\r\n    case DiscreteEventPriority:\r\n      listenerWrapper = dispatchDiscreteEvent;\r\n      break;\r\n    case ContinuousEventPriority:\r\n      listenerWrapper = dispatchContinuousEvent;\r\n      break;\r\n    case DefaultEventPriority:\r\n    default:\r\n      listenerWrapper = dispatchEvent;\r\n      break;\r\n  }\r\n  // 3. 返回事件回调函数，赋值给 listener\r\n  return listenerWrapper.bind(\r\n    null,\r\n    domEventName,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n  );\r\n}\r\n\r\nfunction dispatchDiscreteEvent (\r\n  domEventName,\r\n  eventSystemFlags,\r\n  container,\r\n  nativeEvent,\r\n) {\r\n  const previousPriority = getCurrentUpdatePriority();\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n  ReactCurrentBatchConfig.transition = null;\r\n  try {\r\n    setCurrentUpdatePriority(DiscreteEventPriority);\r\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\r\n  } finally {\r\n    setCurrentUpdatePriority(previousPriority);\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n  }\r\n}\r\n\r\nfunction dispatchContinuousEvent (\r\n  domEventName,\r\n  eventSystemFlags,\r\n  container,\r\n  nativeEvent,\r\n) {\r\n  const previousPriority = getCurrentUpdatePriority();\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n  ReactCurrentBatchConfig.transition = null;\r\n  try {\r\n    setCurrentUpdatePriority(ContinuousEventPriority);\r\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\r\n  } finally {\r\n    setCurrentUpdatePriority(previousPriority);\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n  }\r\n}\r\n\r\nexport function dispatchEvent (\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n): void {\r\n  if (!_enabled) {\r\n    return;\r\n  }\r\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\r\n    dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(\r\n      domEventName,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n      nativeEvent,\r\n    );\r\n  } else {\r\n    dispatchEventOriginal(\r\n      domEventName,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n      nativeEvent,\r\n    );\r\n  }\r\n}\r\n\r\nfunction dispatchEventOriginal (\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n) {\r\n  // TODO: replaying capture phase events is currently broken\r\n  // because we used to do it during top-level native bubble handlers\r\n  // but now we use different bubble and capture handlers.\r\n  // In eager mode, we attach capture listeners early, so we need\r\n  // to filter them out until we fix the logic to handle them correctly.\r\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\r\n\r\n  if (\r\n    allowReplay &&\r\n    hasQueuedDiscreteEvents() &&\r\n    isDiscreteEventThatRequiresHydration(domEventName)\r\n  ) {\r\n    // If we already have a queue of discrete events, and this is another discrete\r\n    // event, then we can't dispatch it regardless of its target, since they\r\n    // need to dispatch in order.\r\n    queueDiscreteEvent(\r\n      null, // Flags that we're not actually blocked on anything as far as we know.\r\n      domEventName,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n      nativeEvent,\r\n    );\r\n    return;\r\n  }\r\n\r\n  const blockedOn = findInstanceBlockingEvent(\r\n    domEventName,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n    nativeEvent,\r\n  );\r\n  if (blockedOn === null) {\r\n    dispatchEventForPluginEventSystem(\r\n      domEventName,\r\n      eventSystemFlags,\r\n      nativeEvent,\r\n      return_targetInst,\r\n      targetContainer,\r\n    );\r\n    if (allowReplay) {\r\n      clearIfContinuousEvent(domEventName, nativeEvent);\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (allowReplay) {\r\n    if (isDiscreteEventThatRequiresHydration(domEventName)) {\r\n      // This this to be replayed later once the target is available.\r\n      queueDiscreteEvent(\r\n        blockedOn,\r\n        domEventName,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n        nativeEvent,\r\n      );\r\n      return;\r\n    }\r\n    if (\r\n      queueIfContinuousEvent(\r\n        blockedOn,\r\n        domEventName,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n        nativeEvent,\r\n      )\r\n    ) {\r\n      return;\r\n    }\r\n    // We need to clear only if we didn't queue because\r\n    // queueing is accumulative.\r\n    clearIfContinuousEvent(domEventName, nativeEvent);\r\n  }\r\n\r\n  // This is not replayable so we'll invoke it but without a target,\r\n  // in case the event system needs to trace it.\r\n  dispatchEventForPluginEventSystem(\r\n    domEventName,\r\n    eventSystemFlags,\r\n    nativeEvent,\r\n    null,\r\n    targetContainer,\r\n  );\r\n}\r\n\r\nfunction dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay (\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n) {\r\n  let blockedOn = findInstanceBlockingEvent(\r\n    domEventName,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n    nativeEvent,\r\n  );\r\n  if (blockedOn === null) {\r\n    dispatchEventForPluginEventSystem(\r\n      domEventName,\r\n      eventSystemFlags,\r\n      nativeEvent,\r\n      return_targetInst,\r\n      targetContainer,\r\n    );\r\n    clearIfContinuousEvent(domEventName, nativeEvent);\r\n    return;\r\n  }\r\n\r\n  if (\r\n    queueIfContinuousEvent(\r\n      blockedOn,\r\n      domEventName,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n      nativeEvent,\r\n    )\r\n  ) {\r\n    nativeEvent.stopPropagation();\r\n    return;\r\n  }\r\n  // We need to clear only if we didn't queue because\r\n  // queueing is accumulative.\r\n  clearIfContinuousEvent(domEventName, nativeEvent);\r\n\r\n  if (\r\n    eventSystemFlags & IS_CAPTURE_PHASE &&\r\n    isDiscreteEventThatRequiresHydration(domEventName)\r\n  ) {\r\n    while (blockedOn !== null) {\r\n      const fiber = getInstanceFromNode(blockedOn);\r\n      if (fiber !== null) {\r\n        attemptSynchronousHydration(fiber);\r\n      }\r\n      const nextBlockedOn = findInstanceBlockingEvent(\r\n        domEventName,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n        nativeEvent,\r\n      );\r\n      if (nextBlockedOn === null) {\r\n        dispatchEventForPluginEventSystem(\r\n          domEventName,\r\n          eventSystemFlags,\r\n          nativeEvent,\r\n          return_targetInst,\r\n          targetContainer,\r\n        );\r\n      }\r\n      if (nextBlockedOn === blockedOn) {\r\n        break;\r\n      }\r\n      blockedOn = nextBlockedOn;\r\n    }\r\n    if (blockedOn !== null) {\r\n      nativeEvent.stopPropagation();\r\n    }\r\n    return;\r\n  }\r\n\r\n  // This is not replayable so we'll invoke it but without a target,\r\n  // in case the event system needs to trace it.\r\n  dispatchEventForPluginEventSystem(\r\n    domEventName,\r\n    eventSystemFlags,\r\n    nativeEvent,\r\n    null,\r\n    targetContainer,\r\n  );\r\n}\r\n\r\nexport let return_targetInst = null;\r\n\r\n// Returns a SuspenseInstance or Container if it's blocked.\r\n// The return_targetInst field above is conceptually part of the return value.\r\nexport function findInstanceBlockingEvent (\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n): null | Container | SuspenseInstance {\r\n  // TODO: Warn if _enabled is false.\r\n\r\n  return_targetInst = null;\r\n\r\n  const nativeEventTarget = getEventTarget(nativeEvent);\r\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\r\n\r\n  if (targetInst !== null) {\r\n    const nearestMounted = getNearestMountedFiber(targetInst);\r\n    if (nearestMounted === null) {\r\n      // This tree has been unmounted already. Dispatch without a target.\r\n      targetInst = null;\r\n    } else {\r\n      const tag = nearestMounted.tag;\r\n      if (tag === SuspenseComponent) {\r\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\r\n        if (instance !== null) {\r\n          // Queue the event to be replayed later. Abort dispatching since we\r\n          // don't want this event dispatched twice through the event system.\r\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\r\n          // priority for this boundary.\r\n          return instance;\r\n        }\r\n        // This shouldn't happen, something went wrong but to avoid blocking\r\n        // the whole system, dispatch the event without a target.\r\n        // TODO: Warn.\r\n        targetInst = null;\r\n      } else if (tag === HostRoot) {\r\n        const root: FiberRoot = nearestMounted.stateNode;\r\n        if (isRootDehydrated(root)) {\r\n          // If this happens during a replay something went wrong and it might block\r\n          // the whole system.\r\n          return getContainerFromFiber(nearestMounted);\r\n        }\r\n        targetInst = null;\r\n      } else if (nearestMounted !== targetInst) {\r\n        // If we get an event (ex: img onload) before committing that\r\n        // component's mount, ignore it for now (that is, treat it as if it was an\r\n        // event on a non-React tree). We might also consider queueing events and\r\n        // dispatching them after the mount.\r\n        targetInst = null;\r\n      }\r\n    }\r\n  }\r\n  return_targetInst = targetInst;\r\n  // We're not blocked on anything.\r\n  return null;\r\n}\r\n\r\nexport function getEventPriority (domEventName: DOMEventName): * {\r\n  switch (domEventName) {\r\n    // Used by SimpleEventPlugin:\r\n    case 'cancel':\r\n    case 'click':\r\n    case 'close':\r\n    case 'contextmenu':\r\n    case 'copy':\r\n    case 'cut':\r\n    case 'auxclick':\r\n    case 'dblclick':\r\n    case 'dragend':\r\n    case 'dragstart':\r\n    case 'drop':\r\n    case 'focusin':\r\n    case 'focusout':\r\n    case 'input':\r\n    case 'invalid':\r\n    case 'keydown':\r\n    case 'keypress':\r\n    case 'keyup':\r\n    case 'mousedown':\r\n    case 'mouseup':\r\n    case 'paste':\r\n    case 'pause':\r\n    case 'play':\r\n    case 'pointercancel':\r\n    case 'pointerdown':\r\n    case 'pointerup':\r\n    case 'ratechange':\r\n    case 'reset':\r\n    case 'resize':\r\n    case 'seeked':\r\n    case 'submit':\r\n    case 'touchcancel':\r\n    case 'touchend':\r\n    case 'touchstart':\r\n    case 'volumechange':\r\n    // Used by polyfills:\r\n    // eslint-disable-next-line no-fallthrough\r\n    case 'change':\r\n    case 'selectionchange':\r\n    case 'textInput':\r\n    case 'compositionstart':\r\n    case 'compositionend':\r\n    case 'compositionupdate':\r\n    // Only enableCreateEventHandleAPI:\r\n    // eslint-disable-next-line no-fallthrough\r\n    case 'beforeblur':\r\n    case 'afterblur':\r\n    // Not used by React but could be by user code:\r\n    // eslint-disable-next-line no-fallthrough\r\n    case 'beforeinput':\r\n    case 'blur':\r\n    case 'fullscreenchange':\r\n    case 'focus':\r\n    case 'hashchange':\r\n    case 'popstate':\r\n    case 'select':\r\n    case 'selectstart':\r\n      // 以上的优先级是1\r\n      return DiscreteEventPriority;\r\n    case 'drag':\r\n    case 'dragenter':\r\n    case 'dragexit':\r\n    case 'dragleave':\r\n    case 'dragover':\r\n    case 'mousemove':\r\n    case 'mouseout':\r\n    case 'mouseover':\r\n    case 'pointermove':\r\n    case 'pointerout':\r\n    case 'pointerover':\r\n    case 'scroll':\r\n    case 'toggle':\r\n    case 'touchmove':\r\n    case 'wheel':\r\n    // Not used by React but could be by user code:\r\n    // eslint-disable-next-line no-fallthrough\r\n    case 'mouseenter':\r\n    case 'mouseleave':\r\n    case 'pointerenter':\r\n    case 'pointerleave':\r\n      // 以上的优先级是4\r\n      return ContinuousEventPriority;\r\n    case 'message': {\r\n      // We might be in the Scheduler callback.\r\n      // Eventually this mechanism will be replaced by a check\r\n      // of the current priority on the native scheduler.\r\n      \r\n      const schedulerPriority = getCurrentSchedulerPriorityLevel();\r\n      switch (schedulerPriority) {\r\n        case ImmediateSchedulerPriority:\r\n          return DiscreteEventPriority;\r\n        case UserBlockingSchedulerPriority:\r\n          return ContinuousEventPriority;\r\n        case NormalSchedulerPriority:\r\n        case LowSchedulerPriority:\r\n          // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\r\n          return DefaultEventPriority;\r\n        case IdleSchedulerPriority:\r\n          return IdleEventPriority;\r\n        default:\r\n          return DefaultEventPriority;\r\n      }\r\n    }\r\n    default:\r\n      // 没有找到,使用默认优先级16\r\n      return DefaultEventPriority;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA,SAASA,8DAAT,QAA+E,0BAA/E;AACA,SACEC,oCADF,EAEEC,kBAFF,EAGEC,uBAHF,EAIEC,sBAJF,EAKEC,sBALF,EAMEC,2BANF,QAOO,0BAPP;AAQA,SACEC,sBADF,EAEEC,qBAFF,EAGEC,4BAHF,QAIO,+CAJP;AAKA,SAASC,QAAT,EAAmBC,iBAAnB,QAA4C,oCAA5C;AACA,SAAgCC,gBAAhC,QAAwD,oBAAxD;AAEA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,SACEC,mBADF,EAEEC,0BAFF,QAGO,iCAHP;AAKA,SAASC,iCAAT,QAAkD,wBAAlD;AAEA,SACEC,uBAAuB,IAAIC,gCAD7B,EAEEC,YAAY,IAAIC,qBAFlB,EAGEC,iBAAiB,IAAIC,0BAHvB,EAIEC,WAAW,IAAIC,oBAJjB,EAKEC,cAAc,IAAIC,uBALpB,EAMEC,oBAAoB,IAAIC,6BAN1B,QAOO,gCAPP;AAQA,SACEC,qBADF,EAEEC,uBAFF,EAGEC,oBAHF,EAIEC,iBAJF,EAKEC,wBALF,EAMEC,wBANF,QAOO,2CAPP;AAQA,OAAOC,oBAAP,MAAiC,6BAAjC;AACA,SAASC,gBAAT,QAAiC,+CAAjC;AAEA,MAAM;EAAEC;AAAF,IAA8BF,oBAApC,C,CAEA;;AACA,OAAO,IAAIG,QAAQ,GAAG,IAAf,C,CAEP;AACA;;AACA,OAAO,SAASC,UAAT,CAAqBC,OAArB,EAAwC;EAC7CF,QAAQ,GAAG,CAAC,CAACE,OAAb;AACD;AAED,OAAO,SAASC,SAAT,GAAsB;EAC3B,OAAOH,QAAP;AACD;AAED,OAAO,SAASI,0BAAT,CACLC,eADK,EAELC,YAFK,EAGLC,gBAHK,EAIK;EACV,OAAOC,aAAa,CAACC,IAAd,CACL,IADK,EAELH,YAFK,EAGLC,gBAHK,EAILF,eAJK,CAAP;AAMD;AAED,OAAO,SAASK,sCAAT,CACLL,eADK,EAELC,YAFK,EAGLC,gBAHK,EAIK;EACV;EAEA;EACA,MAAMI,aAAa,GAAGC,gBAAgB,CAACN,YAAD,CAAtC;EACAO,OAAO,CAACC,GAAR,CAAYH,aAAZ,EAA2BL,YAA3B,EAAyC,eAAzC;EACA,IAAIS,eAAJ,CANU,CAOV;;EACA,QAAQJ,aAAR;IACE,KAAKpB,qBAAL;MACEwB,eAAe,GAAGC,qBAAlB;MACA;;IACF,KAAKxB,uBAAL;MACEuB,eAAe,GAAGE,uBAAlB;MACA;;IACF,KAAKxB,oBAAL;IACA;MACEsB,eAAe,GAAGP,aAAlB;MACA;EAVJ,CARU,CAoBV;;;EACA,OAAOO,eAAe,CAACN,IAAhB,CACL,IADK,EAELH,YAFK,EAGLC,gBAHK,EAILF,eAJK,CAAP;AAMD;;AAED,SAASW,qBAAT,CACEV,YADF,EAEEC,gBAFF,EAGEW,SAHF,EAIEC,WAJF,EAKE;EACA,MAAMC,gBAAgB,GAAGzB,wBAAwB,EAAjD;EACA,MAAM0B,cAAc,GAAGtB,uBAAuB,CAACuB,UAA/C;EACAvB,uBAAuB,CAACuB,UAAxB,GAAqC,IAArC;;EACA,IAAI;IACF1B,wBAAwB,CAACL,qBAAD,CAAxB;IACAiB,aAAa,CAACF,YAAD,EAAeC,gBAAf,EAAiCW,SAAjC,EAA4CC,WAA5C,CAAb;EACD,CAHD,SAGU;IACRvB,wBAAwB,CAACwB,gBAAD,CAAxB;IACArB,uBAAuB,CAACuB,UAAxB,GAAqCD,cAArC;EACD;AACF;;AAED,SAASJ,uBAAT,CACEX,YADF,EAEEC,gBAFF,EAGEW,SAHF,EAIEC,WAJF,EAKE;EACA,MAAMC,gBAAgB,GAAGzB,wBAAwB,EAAjD;EACA,MAAM0B,cAAc,GAAGtB,uBAAuB,CAACuB,UAA/C;EACAvB,uBAAuB,CAACuB,UAAxB,GAAqC,IAArC;;EACA,IAAI;IACF1B,wBAAwB,CAACJ,uBAAD,CAAxB;IACAgB,aAAa,CAACF,YAAD,EAAeC,gBAAf,EAAiCW,SAAjC,EAA4CC,WAA5C,CAAb;EACD,CAHD,SAGU;IACRvB,wBAAwB,CAACwB,gBAAD,CAAxB;IACArB,uBAAuB,CAACuB,UAAxB,GAAqCD,cAArC;EACD;AACF;;AAED,OAAO,SAASb,aAAT,CACLF,YADK,EAELC,gBAFK,EAGLF,eAHK,EAILc,WAJK,EAKC;EACN,IAAI,CAACnB,QAAL,EAAe;IACb;EACD;;EACD,IAAItC,8DAAJ,EAAoE;IAClE6D,+EAA+E,CAC7EjB,YAD6E,EAE7EC,gBAF6E,EAG7EF,eAH6E,EAI7Ec,WAJ6E,CAA/E;EAMD,CAPD,MAOO;IACLK,qBAAqB,CACnBlB,YADmB,EAEnBC,gBAFmB,EAGnBF,eAHmB,EAInBc,WAJmB,CAArB;EAMD;AACF;;AAED,SAASK,qBAAT,CACElB,YADF,EAEEC,gBAFF,EAGEF,eAHF,EAIEc,WAJF,EAKE;EACA;EACA;EACA;EACA;EACA;EACA,MAAMM,WAAW,GAAG,CAAClB,gBAAgB,GAAGjC,gBAApB,MAA0C,CAA9D;;EAEA,IACEmD,WAAW,IACX5D,uBAAuB,EADvB,IAEAF,oCAAoC,CAAC2C,YAAD,CAHtC,EAIE;IACA;IACA;IACA;IACA1C,kBAAkB,CAChB,IADgB,EACV;IACN0C,YAFgB,EAGhBC,gBAHgB,EAIhBF,eAJgB,EAKhBc,WALgB,CAAlB;IAOA;EACD;;EAED,MAAMO,SAAS,GAAGC,yBAAyB,CACzCrB,YADyC,EAEzCC,gBAFyC,EAGzCF,eAHyC,EAIzCc,WAJyC,CAA3C;;EAMA,IAAIO,SAAS,KAAK,IAAlB,EAAwB;IACtBhD,iCAAiC,CAC/B4B,YAD+B,EAE/BC,gBAF+B,EAG/BY,WAH+B,EAI/BS,iBAJ+B,EAK/BvB,eAL+B,CAAjC;;IAOA,IAAIoB,WAAJ,EAAiB;MACf3D,sBAAsB,CAACwC,YAAD,EAAea,WAAf,CAAtB;IACD;;IACD;EACD;;EAED,IAAIM,WAAJ,EAAiB;IACf,IAAI9D,oCAAoC,CAAC2C,YAAD,CAAxC,EAAwD;MACtD;MACA1C,kBAAkB,CAChB8D,SADgB,EAEhBpB,YAFgB,EAGhBC,gBAHgB,EAIhBF,eAJgB,EAKhBc,WALgB,CAAlB;MAOA;IACD;;IACD,IACEpD,sBAAsB,CACpB2D,SADoB,EAEpBpB,YAFoB,EAGpBC,gBAHoB,EAIpBF,eAJoB,EAKpBc,WALoB,CADxB,EAQE;MACA;IACD,CAtBc,CAuBf;IACA;;;IACArD,sBAAsB,CAACwC,YAAD,EAAea,WAAf,CAAtB;EACD,CAxED,CA0EA;EACA;;;EACAzC,iCAAiC,CAC/B4B,YAD+B,EAE/BC,gBAF+B,EAG/BY,WAH+B,EAI/B,IAJ+B,EAK/Bd,eAL+B,CAAjC;AAOD;;AAED,SAASkB,+EAAT,CACEjB,YADF,EAEEC,gBAFF,EAGEF,eAHF,EAIEc,WAJF,EAKE;EACA,IAAIO,SAAS,GAAGC,yBAAyB,CACvCrB,YADuC,EAEvCC,gBAFuC,EAGvCF,eAHuC,EAIvCc,WAJuC,CAAzC;;EAMA,IAAIO,SAAS,KAAK,IAAlB,EAAwB;IACtBhD,iCAAiC,CAC/B4B,YAD+B,EAE/BC,gBAF+B,EAG/BY,WAH+B,EAI/BS,iBAJ+B,EAK/BvB,eAL+B,CAAjC;IAOAvC,sBAAsB,CAACwC,YAAD,EAAea,WAAf,CAAtB;IACA;EACD;;EAED,IACEpD,sBAAsB,CACpB2D,SADoB,EAEpBpB,YAFoB,EAGpBC,gBAHoB,EAIpBF,eAJoB,EAKpBc,WALoB,CADxB,EAQE;IACAA,WAAW,CAACU,eAAZ;IACA;EACD,CA9BD,CA+BA;EACA;;;EACA/D,sBAAsB,CAACwC,YAAD,EAAea,WAAf,CAAtB;;EAEA,IACEZ,gBAAgB,GAAGjC,gBAAnB,IACAX,oCAAoC,CAAC2C,YAAD,CAFtC,EAGE;IACA,OAAOoB,SAAS,KAAK,IAArB,EAA2B;MACzB,MAAMI,KAAK,GAAGtD,mBAAmB,CAACkD,SAAD,CAAjC;;MACA,IAAII,KAAK,KAAK,IAAd,EAAoB;QAClB9D,2BAA2B,CAAC8D,KAAD,CAA3B;MACD;;MACD,MAAMC,aAAa,GAAGJ,yBAAyB,CAC7CrB,YAD6C,EAE7CC,gBAF6C,EAG7CF,eAH6C,EAI7Cc,WAJ6C,CAA/C;;MAMA,IAAIY,aAAa,KAAK,IAAtB,EAA4B;QAC1BrD,iCAAiC,CAC/B4B,YAD+B,EAE/BC,gBAF+B,EAG/BY,WAH+B,EAI/BS,iBAJ+B,EAK/BvB,eAL+B,CAAjC;MAOD;;MACD,IAAI0B,aAAa,KAAKL,SAAtB,EAAiC;QAC/B;MACD;;MACDA,SAAS,GAAGK,aAAZ;IACD;;IACD,IAAIL,SAAS,KAAK,IAAlB,EAAwB;MACtBP,WAAW,CAACU,eAAZ;IACD;;IACD;EACD,CApED,CAsEA;EACA;;;EACAnD,iCAAiC,CAC/B4B,YAD+B,EAE/BC,gBAF+B,EAG/BY,WAH+B,EAI/B,IAJ+B,EAK/Bd,eAL+B,CAAjC;AAOD;;AAED,OAAO,IAAIuB,iBAAiB,GAAG,IAAxB,C,CAEP;AACA;;AACA,OAAO,SAASD,yBAAT,CACLrB,YADK,EAELC,gBAFK,EAGLF,eAHK,EAILc,WAJK,EAKgC;EACrC;EAEAS,iBAAiB,GAAG,IAApB;EAEA,MAAMI,iBAAiB,GAAGzD,cAAc,CAAC4C,WAAD,CAAxC;EACA,IAAIc,UAAU,GAAGxD,0BAA0B,CAACuD,iBAAD,CAA3C;;EAEA,IAAIC,UAAU,KAAK,IAAnB,EAAyB;IACvB,MAAMC,cAAc,GAAGjE,sBAAsB,CAACgE,UAAD,CAA7C;;IACA,IAAIC,cAAc,KAAK,IAAvB,EAA6B;MAC3B;MACAD,UAAU,GAAG,IAAb;IACD,CAHD,MAGO;MACL,MAAME,GAAG,GAAGD,cAAc,CAACC,GAA3B;;MACA,IAAIA,GAAG,KAAK9D,iBAAZ,EAA+B;QAC7B,MAAM+D,QAAQ,GAAGjE,4BAA4B,CAAC+D,cAAD,CAA7C;;QACA,IAAIE,QAAQ,KAAK,IAAjB,EAAuB;UACrB;UACA;UACA;UACA;UACA,OAAOA,QAAP;QACD,CAR4B,CAS7B;QACA;QACA;;;QACAH,UAAU,GAAG,IAAb;MACD,CAbD,MAaO,IAAIE,GAAG,KAAK/D,QAAZ,EAAsB;QAC3B,MAAMiE,IAAe,GAAGH,cAAc,CAACI,SAAvC;;QACA,IAAIxC,gBAAgB,CAACuC,IAAD,CAApB,EAA4B;UAC1B;UACA;UACA,OAAOnE,qBAAqB,CAACgE,cAAD,CAA5B;QACD;;QACDD,UAAU,GAAG,IAAb;MACD,CARM,MAQA,IAAIC,cAAc,KAAKD,UAAvB,EAAmC;QACxC;QACA;QACA;QACA;QACAA,UAAU,GAAG,IAAb;MACD;IACF;EACF;;EACDL,iBAAiB,GAAGK,UAApB,CA7CqC,CA8CrC;;EACA,OAAO,IAAP;AACD;AAED,OAAO,SAASrB,gBAAT,CAA2BN,YAA3B,EAA0D;EAC/D,QAAQA,YAAR;IACE;IACA,KAAK,QAAL;IACA,KAAK,OAAL;IACA,KAAK,OAAL;IACA,KAAK,aAAL;IACA,KAAK,MAAL;IACA,KAAK,KAAL;IACA,KAAK,UAAL;IACA,KAAK,UAAL;IACA,KAAK,SAAL;IACA,KAAK,WAAL;IACA,KAAK,MAAL;IACA,KAAK,SAAL;IACA,KAAK,UAAL;IACA,KAAK,OAAL;IACA,KAAK,SAAL;IACA,KAAK,SAAL;IACA,KAAK,UAAL;IACA,KAAK,OAAL;IACA,KAAK,WAAL;IACA,KAAK,SAAL;IACA,KAAK,OAAL;IACA,KAAK,OAAL;IACA,KAAK,MAAL;IACA,KAAK,eAAL;IACA,KAAK,aAAL;IACA,KAAK,WAAL;IACA,KAAK,YAAL;IACA,KAAK,OAAL;IACA,KAAK,QAAL;IACA,KAAK,QAAL;IACA,KAAK,QAAL;IACA,KAAK,aAAL;IACA,KAAK,UAAL;IACA,KAAK,YAAL;IACA,KAAK,cAAL,CApCF,CAqCE;IACA;;IACA,KAAK,QAAL;IACA,KAAK,iBAAL;IACA,KAAK,WAAL;IACA,KAAK,kBAAL;IACA,KAAK,gBAAL;IACA,KAAK,mBAAL,CA5CF,CA6CE;IACA;;IACA,KAAK,YAAL;IACA,KAAK,WAAL,CAhDF,CAiDE;IACA;;IACA,KAAK,aAAL;IACA,KAAK,MAAL;IACA,KAAK,kBAAL;IACA,KAAK,OAAL;IACA,KAAK,YAAL;IACA,KAAK,UAAL;IACA,KAAK,QAAL;IACA,KAAK,aAAL;MACE;MACA,OAAOf,qBAAP;;IACF,KAAK,MAAL;IACA,KAAK,WAAL;IACA,KAAK,UAAL;IACA,KAAK,WAAL;IACA,KAAK,UAAL;IACA,KAAK,WAAL;IACA,KAAK,UAAL;IACA,KAAK,WAAL;IACA,KAAK,aAAL;IACA,KAAK,YAAL;IACA,KAAK,aAAL;IACA,KAAK,QAAL;IACA,KAAK,QAAL;IACA,KAAK,WAAL;IACA,KAAK,OAAL,CA3EF,CA4EE;IACA;;IACA,KAAK,YAAL;IACA,KAAK,YAAL;IACA,KAAK,cAAL;IACA,KAAK,cAAL;MACE;MACA,OAAOC,uBAAP;;IACF,KAAK,SAAL;MAAgB;QACd;QACA;QACA;QAEA,MAAM+C,iBAAiB,GAAG3D,gCAAgC,EAA1D;;QACA,QAAQ2D,iBAAR;UACE,KAAKvD,0BAAL;YACE,OAAOO,qBAAP;;UACF,KAAKD,6BAAL;YACE,OAAOE,uBAAP;;UACF,KAAKJ,uBAAL;UACA,KAAKF,oBAAL;YACE;YACA,OAAOO,oBAAP;;UACF,KAAKX,qBAAL;YACE,OAAOY,iBAAP;;UACF;YACE,OAAOD,oBAAP;QAZJ;MAcD;;IACD;MACE;MACA,OAAOA,oBAAP;EA3GJ;AA6GD"},"metadata":{},"sourceType":"module"}