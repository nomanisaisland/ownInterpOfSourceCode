{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { enableDebugTracing, enableSchedulingProfiler, enableNewReconciler, enableCache, enableUseRefAccessWarning, enableStrictEffects, enableLazyContextPropagation, enableSuspenseLayoutEffectSemantics, enableUseMutableSource, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { NoMode, ConcurrentMode, DebugTracingMode, StrictEffectsMode } from './ReactTypeOfMode';\nimport { NoLane, SyncLane, NoLanes, isSubsetOfLanes, includesBlockingLane, includesOnlyNonUrgentLanes, claimNextTransitionLane, mergeLanes, removeLanes, intersectLanes, isTransitionLane, markRootEntangled, markRootMutableRead, NoTimestamp } from './ReactFiberLane.new';\nimport { ContinuousEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority, higherEventPriority } from './ReactEventPriorities.new';\nimport { readContext, checkIfContextChanged } from './ReactFiberNewContext.new';\nimport { HostRoot, CacheComponent } from './ReactWorkTags';\nimport { LayoutStatic as LayoutStaticEffect, MountLayoutDev as MountLayoutDevEffect, MountPassiveDev as MountPassiveDevEffect, Passive as PassiveEffect, PassiveStatic as PassiveStaticEffect, StaticMask as StaticMaskEffect, Update as UpdateEffect, StoreConsistency } from './ReactFiberFlags';\nimport { HasEffect as HookHasEffect, Layout as HookLayout, Passive as HookPassive, Insertion as HookInsertion } from './ReactHookEffectTags';\nimport { getWorkInProgressRoot, scheduleUpdateOnFiber, requestUpdateLane, requestEventTime, markSkippedUpdateLanes, isInterleavedUpdate } from './ReactFiberWorkLoop.new';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport is from 'shared/objectIs';\nimport isArray from 'shared/isArray';\nimport { markWorkInProgressReceivedUpdate, checkIfWorkInProgressReceivedUpdate } from './ReactFiberBeginWork.new';\nimport { getIsHydrating } from './ReactFiberHydrationContext.new';\nimport { getWorkInProgressVersion, markSourceAsDirty, setWorkInProgressVersion, warnAboutMultipleRenderersDEV } from './ReactMutableSource.new';\nimport { logStateUpdateScheduled } from './DebugTracing';\nimport { markStateUpdateScheduled } from './ReactFiberDevToolsHook.new';\nimport { createCache, CacheContext } from './ReactFiberCacheComponent.new';\nimport { createUpdate as createLegacyQueueUpdate, enqueueUpdate as enqueueLegacyQueueUpdate, entangleTransitions as entangleLegacyQueueTransitions } from './ReactUpdateQueue.new';\nimport { pushInterleavedQueue } from './ReactFiberInterleavedUpdates.new';\nimport { getTreeId } from './ReactFiberTreeContext.new';\nimport { now } from './Scheduler';\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentBatchConfig\n} = ReactSharedInternals;\nlet didWarnAboutMismatchedHooksForComponent;\nlet didWarnUncachedGetSnapshot;\n\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\n// These are set right before calling the component.\nlet renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nlet currentlyRenderingFiber = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nlet currentHook = null;\nlet workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\n\nlet didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\nlet didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n\nlet localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\n\nlet globalClientIdCounter = 0;\nconst RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nlet currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nlet hookTypesDev = null;\nlet hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nlet ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      console.error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          let row = `${i + 1}. ${oldHookName}`; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        console.error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, `[${prevDeps.join(', ')}]`, `[${nextDeps.join(', ')}]`);\n    }\n  }\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nexport function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes; // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, secondArg); // Check if there was a render phase update\n\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    let numberOfReRenders = 0;\n\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      localIdCounter = 0;\n\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n        throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n      }\n\n      numberOfReRenders += 1;\n\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      } // Start over from the beginning of the list\n\n\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__ ? HooksDispatcherOnRerenderInDEV : HooksDispatcherOnRerender;\n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  } // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n\n\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  const didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n\n    if (current !== null && (current.flags & StaticMaskEffect) !== (workInProgress.flags & StaticMaskEffect) && // Disable this warning in legacy mode, because legacy Suspense is weird\n    // and creates false positives. To make this work in legacy mode, we'd\n    // need to mark fibers that commit in an incomplete state, somehow. For\n    // now I'll disable the warning that most of the bugs that would trigger\n    // it are either exclusive to concurrent mode or exist in both.\n    (current.mode & ConcurrentMode) !== NoMode) {\n      console.error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  if (didRenderTooFewHooks) {\n    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  }\n\n  if (enableLazyContextPropagation) {\n    if (current !== null) {\n      if (!checkIfWorkInProgressReceivedUpdate()) {\n        // If there were no changes to props or state, we need to check if there\n        // was a context change. We didn't already do this because there's no\n        // 1:1 correspondence between dependencies and hooks. Although, because\n        // there almost always is in the common case (`readContext` is an\n        // internal API), we could compare in there. OTOH, we only hit this case\n        // if everything else bails out, so on the whole it might be better to\n        // keep the comparison out of the common path.\n        const currentDependencies = current.dependencies;\n\n        if (currentDependencies !== null && checkIfContextChanged(currentDependencies)) {\n          markWorkInProgressReceivedUpdate();\n        }\n      }\n    }\n  }\n\n  return children;\n}\nexport function checkDidRenderIdHook() {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  const didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nexport function bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n\n  if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n    workInProgress.flags &= ~(MountPassiveDevEffect | MountLayoutDevEffect | PassiveEffect | UpdateEffect);\n  } else {\n    workInProgress.flags &= ~(PassiveEffect | UpdateEffect);\n  }\n\n  current.lanes = removeLanes(current.lanes, lanes);\n}\nexport function resetHooksAfterThrow() {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    let hook = currentlyRenderingFiber.memoizedState;\n\n    while (hook !== null) {\n      const queue = hook.queue;\n\n      if (queue !== null) {\n        queue.pending = null;\n      }\n\n      hook = hook.next;\n    }\n\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n    isUpdatingOpaqueValueInRenderPhase = false;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n}\n\nfunction mountWorkInProgressHook() {\n  const hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  let nextCurrentHook;\n\n  if (currentHook === null) {\n    const current = currentlyRenderingFiber.alternate;\n\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook;\n\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n    if (nextCurrentHook === null) {\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n\n    currentHook = nextCurrentHook;\n    const newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue() {\n  return {\n    lastEffect: null,\n    stores: null\n  };\n}\n\nfunction basicStateReducer(state, action) {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  const dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer;\n  const current = currentHook; // The last rebase update that is NOT part of the base state.\n\n  let baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n\n  const pendingQueue = queue.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      const baseFirst = baseQueue.next;\n      const pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    if (__DEV__) {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        console.error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n      }\n    }\n\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    const first = baseQueue.next;\n    let newState = current.baseState;\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n\n    do {\n      const updateLane = update.lane;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        };\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n\n\n        currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane);\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newBaseQueueLast !== null) {\n          const clone = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Process this update.\n\n\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState;\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = newState;\n  } // Interleaved updates are stored on a separate queue. We aren't going to\n  // process them during this render, but we do need to track which lanes\n  // are remaining.\n\n\n  const lastInterleaved = queue.interleaved;\n\n  if (lastInterleaved !== null) {\n    let interleaved = lastInterleaved;\n\n    do {\n      const interleavedLane = interleaved.lane;\n      currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, interleavedLane);\n      markSkippedUpdateLanes(interleavedLane);\n      interleaved = interleaved.next;\n    } while (interleaved !== lastInterleaved);\n  } else if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n\n  const dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n\n  const dispatch = queue.dispatch;\n  const lastRenderPhaseUpdate = queue.pending;\n  let newState = hook.memoizedState;\n\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    let update = firstRenderPhaseUpdate;\n\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n\n  return [newState, dispatch];\n}\n\nfunction readFromUnsubscribedMutableSource(root, source, getSnapshot) {\n  if (__DEV__) {\n    warnAboutMultipleRenderersDEV(source);\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?\n\n  let isSafeToReadFromSource = false; // Check the version first.\n  // If this render has already been started with a specific version,\n  // we can use it alone to determine if we can safely read from the source.\n\n  const currentRenderVersion = getWorkInProgressVersion(source);\n\n  if (currentRenderVersion !== null) {\n    // It's safe to read if the store hasn't been mutated since the last time\n    // we read something.\n    isSafeToReadFromSource = currentRenderVersion === version;\n  } else {\n    // If there's no version, then this is the first time we've read from the\n    // source during the current render pass, so we need to do a bit more work.\n    // What we need to determine is if there are any hooks that already\n    // subscribed to the source, and if so, whether there are any pending\n    // mutations that haven't been synchronized yet.\n    //\n    // If there are no pending mutations, then `root.mutableReadLanes` will be\n    // empty, and we know we can safely read.\n    //\n    // If there *are* pending mutations, we may still be able to safely read\n    // if the currently rendering lanes are inclusive of the pending mutation\n    // lanes, since that guarantees that the value we're about to read from\n    // the source is consistent with the values that we read during the most\n    // recent mutation.\n    isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);\n\n    if (isSafeToReadFromSource) {\n      // If it's safe to read from this source during the current render,\n      // store the version in case other components read from it.\n      // A changed version number will let those components know to throw and restart the render.\n      setWorkInProgressVersion(source, version);\n    }\n  }\n\n  if (isSafeToReadFromSource) {\n    const snapshot = getSnapshot(source._source);\n\n    if (__DEV__) {\n      if (typeof snapshot === 'function') {\n        console.error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\n      }\n    }\n\n    return snapshot;\n  } else {\n    // This handles the special case of a mutable source being shared between renderers.\n    // In that case, if the source is mutated between the first and second renderer,\n    // The second renderer don't know that it needs to reset the WIP version during unwind,\n    // (because the hook only marks sources as dirty if it's written to their WIP version).\n    // That would cause this tear check to throw again and eventually be visible to the user.\n    // We can avoid this infinite loop by explicitly marking the source as dirty.\n    //\n    // This can lead to tearing in the first renderer when it resumes,\n    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).\n    markSourceAsDirty(source); // Intentioally throw an error to force React to retry synchronously. During\n    // the synchronous retry, it will block interleaved mutations, so we should\n    // get a consistent read. Therefore, the following error should never be\n    // visible to the user.\n    // We expect this error not to be thrown during the synchronous retry,\n    // because we blocked interleaved mutations.\n\n    throw new Error('Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.');\n  }\n}\n\nfunction useMutableSource(hook, source, getSnapshot, subscribe) {\n  _s();\n\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const root = getWorkInProgressRoot();\n\n  if (root === null) {\n    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source);\n  const dispatcher = ReactCurrentDispatcher.current; // eslint-disable-next-line prefer-const\n\n  let [currentSnapshot, setSnapshot] = dispatcher.useState(() => readFromUnsubscribedMutableSource(root, source, getSnapshot));\n  let snapshot = currentSnapshot; // Grab a handle to the state hook as well.\n  // We use it to clear the pending update queue if we have a new source.\n\n  const stateHook = workInProgressHook;\n  const memoizedState = hook.memoizedState;\n  const refs = memoizedState.refs;\n  const prevGetSnapshot = refs.getSnapshot;\n  const prevSource = memoizedState.source;\n  const prevSubscribe = memoizedState.subscribe;\n  const fiber = currentlyRenderingFiber;\n  hook.memoizedState = {\n    refs,\n    source,\n    subscribe\n  }; // Sync the values needed by our subscription handler after each commit.\n\n  dispatcher.useEffect(() => {\n    refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,\n    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.\n    // handleChange() below needs to reference the dispatch function without re-subscribing,\n    // so we use a ref to ensure that it always has the latest version.\n\n    refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.\n\n    const maybeNewVersion = getVersion(source._source);\n\n    if (!is(version, maybeNewVersion)) {\n      const maybeNewSnapshot = getSnapshot(source._source);\n\n      if (__DEV__) {\n        if (typeof maybeNewSnapshot === 'function') {\n          console.error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\n        }\n      }\n\n      if (!is(snapshot, maybeNewSnapshot)) {\n        setSnapshot(maybeNewSnapshot);\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      } // If the source mutated between render and now,\n      // there may be state updates already scheduled from the old source.\n      // Entangle the updates so that they render in the same batch.\n\n\n      markRootEntangled(root, root.mutableReadLanes);\n    }\n  }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.\n\n  dispatcher.useEffect(() => {\n    const handleChange = () => {\n      const latestGetSnapshot = refs.getSnapshot;\n      const latestSetSnapshot = refs.setSnapshot;\n\n      try {\n        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.\n\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      } catch (error) {\n        // A selector might throw after a source mutation.\n        // e.g. it might try to read from a part of the store that no longer exists.\n        // In this case we should still schedule an update with React.\n        // Worst case the selector will throw again and then an error boundary will handle it.\n        latestSetSnapshot(() => {\n          throw error;\n        });\n      }\n    };\n\n    const unsubscribe = subscribe(source._source, handleChange);\n\n    if (__DEV__) {\n      if (typeof unsubscribe !== 'function') {\n        console.error('Mutable source subscribe function must return an unsubscribe function.');\n      }\n    }\n\n    return unsubscribe;\n  }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.\n  //\n  // If either the source or the subscription have changed we can't can't trust the update queue.\n  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.\n  //\n  // If the getSnapshot function changed, we also shouldn't rely on the update queue.\n  // It's possible that the underlying source was mutated between the when the last \"change\" event fired,\n  // and when the current render (with the new getSnapshot function) is processed.\n  //\n  // In both cases, we need to throw away pending updates (since they are no longer relevant)\n  // and treat reading from the source as we do in the mount case.\n\n  if (!is(prevGetSnapshot, getSnapshot) || !is(prevSource, source) || !is(prevSubscribe, subscribe)) {\n    // Create a new queue and setState method,\n    // So if there are interleaved updates, they get pushed to the older queue.\n    // When this becomes current, the previous queue and dispatch method will be discarded,\n    // including any interleaving updates that occur.\n    const newQueue = {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: snapshot\n    };\n    newQueue.dispatch = setSnapshot = dispatchSetState.bind(null, currentlyRenderingFiber, newQueue);\n    stateHook.queue = newQueue;\n    stateHook.baseQueue = null;\n    snapshot = readFromUnsubscribedMutableSource(root, source, getSnapshot);\n    stateHook.memoizedState = stateHook.baseState = snapshot;\n  }\n\n  return snapshot;\n}\n\n_s(useMutableSource, \"nsNcU3GwWLhBRY1TfYM9FeMpxi8=\");\n\nfunction mountMutableSource(source, getSnapshot, subscribe) {\n  _s2();\n\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = {\n    refs: {\n      getSnapshot,\n      setSnapshot: null\n    },\n    source,\n    subscribe\n  };\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\n_s2(mountMutableSource, \"G46HpqTIWGoryMbF+wh82aRle1o=\", false, function () {\n  return [useMutableSource];\n});\n\nfunction updateMutableSource(source, getSnapshot, subscribe) {\n  _s3();\n\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const hook = updateWorkInProgressHook();\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\n_s3(updateMutableSource, \"G46HpqTIWGoryMbF+wh82aRle1o=\", false, function () {\n  return [useMutableSource];\n});\n\nfunction mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  const fiber = currentlyRenderingFiber;\n  const hook = mountWorkInProgressHook();\n  let nextSnapshot;\n  const isHydrating = getIsHydrating();\n\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n    }\n\n    nextSnapshot = getServerSnapshot();\n\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          console.error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        const cachedSnapshot = getSnapshot();\n\n        if (!is(nextSnapshot, cachedSnapshot)) {\n          console.error('The result of getSnapshot should be cached to avoid an infinite loop');\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    } // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n\n\n    const root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  } // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n\n  hook.memoizedState = nextSnapshot;\n  const inst = {\n    value: nextSnapshot,\n    getSnapshot\n  };\n  hook.queue = inst; // Schedule an effect to subscribe to the store.\n\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n\n  fiber.flags |= PassiveEffect;\n  pushEffect(HookHasEffect | HookPassive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  const fiber = currentlyRenderingFiber;\n  const hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n  const nextSnapshot = getSnapshot();\n\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      const cachedSnapshot = getSnapshot();\n\n      if (!is(nextSnapshot, cachedSnapshot)) {\n        console.error('The result of getSnapshot should be cached to avoid an infinite loop');\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  const prevSnapshot = hook.memoizedState;\n  const snapshotChanged = !is(prevSnapshot, nextSnapshot);\n\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n\n  const inst = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n\n  if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n  // checking whether we scheduled a subscription effect above.\n  workInProgressHook !== null && workInProgressHook.memoizedState.tag & HookHasEffect) {\n    fiber.flags |= PassiveEffect;\n    pushEffect(HookHasEffect | HookPassive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n\n    const root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= StoreConsistency;\n  const check = {\n    getSnapshot,\n    value: renderedSnapshot\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.stores = [check];\n  } else {\n    const stores = componentUpdateQueue.stores;\n\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore(fiber, inst, subscribe) {\n  const handleStoreChange = () => {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  }; // Subscribe to the store and return a clean-up function.\n\n\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n}\n\nfunction mountState(initialState) {\n  const hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  const dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer, initialState);\n}\n\nfunction rerenderState(initialState) {\n  return rerenderReducer(basicStateReducer, initialState);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: null\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nlet stackContainsErrorMessage = null;\n\nfunction getCallerStackFrame() {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const stackFrames = new Error('Error message').stack.split('\\n'); // Some browsers (e.g. Chrome) include the error message in the stack\n  // but others (e.g. Firefox) do not.\n\n  if (stackContainsErrorMessage === null) {\n    stackContainsErrorMessage = stackFrames[0].includes('Error message');\n  }\n\n  return stackContainsErrorMessage ? stackFrames.slice(3, 4).join('\\n') : stackFrames.slice(2, 3).join('\\n');\n}\n\nfunction mountRef(initialValue) {\n  const hook = mountWorkInProgressHook();\n\n  if (enableUseRefAccessWarning) {\n    if (__DEV__) {\n      // Support lazy initialization pattern shown in docs.\n      // We need to store the caller stack frame so that we don't warn on subsequent renders.\n      let hasBeenInitialized = initialValue != null;\n      let lazyInitGetterStack = null;\n      let didCheckForLazyInit = false; // Only warn once per component+hook.\n\n      let didWarnAboutRead = false;\n      let didWarnAboutWrite = false;\n      let current = initialValue;\n      const ref = {\n        get current() {\n          if (!hasBeenInitialized) {\n            didCheckForLazyInit = true;\n            lazyInitGetterStack = getCallerStackFrame();\n          } else if (currentlyRenderingFiber !== null && !didWarnAboutRead) {\n            if (lazyInitGetterStack === null || lazyInitGetterStack !== getCallerStackFrame()) {\n              didWarnAboutRead = true;\n              console.warn('%s: Unsafe read of a mutable value during render.\\n\\n' + 'Reading from a ref during render is only safe if:\\n' + '1. The ref value has not been updated, or\\n' + '2. The ref holds a lazily-initialized value that is only set once.\\n', getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown');\n            }\n          }\n\n          return current;\n        },\n\n        set current(value) {\n          if (currentlyRenderingFiber !== null && !didWarnAboutWrite) {\n            if (hasBeenInitialized || !didCheckForLazyInit) {\n              didWarnAboutWrite = true;\n              console.warn('%s: Unsafe write of a mutable value during render.\\n\\n' + 'Writing to a ref during render is only safe if the ref holds ' + 'a lazily-initialized value that is only set once.\\n', getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown');\n            }\n          }\n\n          hasBeenInitialized = true;\n          current = value;\n        }\n\n      };\n      Object.seal(ref);\n      hook.memoizedState = ref;\n      return ref;\n    } else {\n      const ref = {\n        current: initialValue\n      };\n      hook.memoizedState = ref;\n      return ref;\n    }\n  } else {\n    const ref = {\n      current: initialValue\n    };\n    hook.memoizedState = ref;\n    return ref;\n  }\n}\n\nfunction updateRef(initialValue) {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);\n}\n\nfunction mountEffect(create, deps) {\n  if (__DEV__ && enableStrictEffects && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    return mountEffectImpl(MountPassiveDevEffect | PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);\n  } else {\n    return mountEffectImpl(PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);\n  }\n}\n\nfunction updateEffect(create, deps) {\n  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);\n}\n\nfunction mountInsertionEffect(create, deps) {\n  return mountEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  let fiberFlags = UpdateEffect;\n\n  if (enableSuspenseLayoutEffectSemantics) {\n    fiberFlags |= LayoutStaticEffect;\n  }\n\n  if (__DEV__ && enableStrictEffects && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n\n  return mountEffectImpl(fiberFlags, HookLayout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty('current')) {\n        console.error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n      }\n    }\n\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  let fiberFlags = UpdateEffect;\n\n  if (enableSuspenseLayoutEffectSemantics) {\n    fiberFlags |= LayoutStaticEffect;\n  }\n\n  if (__DEV__ && enableStrictEffects && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n\n  return mountEffectImpl(fiberFlags, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return updateEffectImpl(UpdateEffect, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue(value) {\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = value;\n  return value;\n}\n\nfunction updateDeferredValue(value) {\n  const hook = updateWorkInProgressHook();\n  const resolvedCurrentHook = currentHook;\n  const prevValue = resolvedCurrentHook.memoizedState;\n  return updateDeferredValueImpl(hook, prevValue, value);\n}\n\nfunction rerenderDeferredValue(value) {\n  const hook = updateWorkInProgressHook();\n\n  if (currentHook === null) {\n    // This is a rerender during a mount.\n    hook.memoizedState = value;\n    return value;\n  } else {\n    // This is a rerender during an update.\n    const prevValue = currentHook.memoizedState;\n    return updateDeferredValueImpl(hook, prevValue, value);\n  }\n}\n\nfunction updateDeferredValueImpl(hook, prevValue, value) {\n  const shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n\n  if (shouldDeferValue) {\n    // This is an urgent update. If the value has changed, keep using the\n    // previous value and spawn a deferred render to update it later.\n    if (!is(value, prevValue)) {\n      // Schedule a deferred render\n      const deferredLane = claimNextTransitionLane();\n      currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, deferredLane);\n      markSkippedUpdateLanes(deferredLane); // Set this to true to indicate that the rendered value is inconsistent\n      // from the latest value. The name \"baseState\" doesn't really match how we\n      // use it because we're reusing a state hook field instead of creating a\n      // new one.\n\n      hook.baseState = true;\n    } // Reuse the previous value\n\n\n    return prevValue;\n  } else {\n    // This is not an urgent update, so we can use the latest value regardless\n    // of what it is. No need to defer it.\n    // However, if we're currently inside a spawned render, then we need to mark\n    // this as an update to prevent the fiber from bailing out.\n    //\n    // `baseState` is true when the current value is different from the rendered\n    // value. The name doesn't really match how we use it because we're reusing\n    // a state hook field instead of creating a new one.\n    if (hook.baseState) {\n      // Flip this back to false.\n      hook.baseState = false;\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = value;\n    return value;\n  }\n}\n\nfunction startTransition(setPending, callback, options) {\n  const previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n  setPending(true);\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = {};\n  const currentTransition = ReactCurrentBatchConfig.transition;\n\n  if (enableTransitionTracing) {\n    if (options !== undefined && options.name !== undefined) {\n      ReactCurrentBatchConfig.transition.name = options.name;\n      ReactCurrentBatchConfig.transition.startTime = now();\n    }\n  }\n\n  if (__DEV__) {\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n  }\n\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    if (__DEV__) {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        const updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          console.warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition() {\n  const [isPending, setPending] = mountState(false); // The `start` method never changes.\n\n  const start = startTransition.bind(null, setPending);\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition() {\n  const [isPending] = updateState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition() {\n  const [isPending] = rerenderState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nlet isUpdatingOpaqueValueInRenderPhase = false;\nexport function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n  if (__DEV__) {\n    return isUpdatingOpaqueValueInRenderPhase;\n  }\n}\n\nfunction mountId() {\n  const hook = mountWorkInProgressHook();\n  const root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n  // should do this in Fiber, too? Deferring this decision for now because\n  // there's no other place to store the prefix except for an internal field on\n  // the public createRoot object, which the fiber tree does not currently have\n  // a reference to.\n\n  const identifierPrefix = root.identifierPrefix;\n  let id;\n\n  if (getIsHydrating()) {\n    const treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n\n    id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n\n    const localId = localIdCounter++;\n\n    if (localId > 0) {\n      id += 'H' + localId.toString(32);\n    }\n\n    id += ':';\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    const globalClientId = globalClientIdCounter++;\n    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId() {\n  const hook = updateWorkInProgressHook();\n  const id = hook.memoizedState;\n  return id;\n}\n\nfunction mountRefresh() {\n  const hook = mountWorkInProgressHook();\n  const refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber);\n  return refresh;\n}\n\nfunction updateRefresh() {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction refreshCache(fiber, seedKey, seedValue) {\n  if (!enableCache) {\n    return;\n  } // TODO: Does Cache work in legacy mode? Should decide and write a test.\n  // TODO: Consider warning if the refresh is at discrete priority, or if we\n  // otherwise suspect that it wasn't batched properly.\n\n\n  let provider = fiber.return;\n\n  while (provider !== null) {\n    switch (provider.tag) {\n      case CacheComponent:\n      case HostRoot:\n        {\n          const lane = requestUpdateLane(provider);\n          const eventTime = requestEventTime();\n          const root = scheduleUpdateOnFiber(provider, lane, eventTime);\n\n          if (root !== null) {\n            entangleLegacyQueueTransitions(root, provider, lane);\n          } // TODO: If a refresh never commits, the new cache created here must be\n          // released. A simple case is start refreshing a cache boundary, but then\n          // unmount that boundary before the refresh completes.\n\n\n          const seededCache = createCache();\n\n          if (seedKey !== null && seedKey !== undefined && root !== null) {\n            // Seed the cache with the value passed by the caller. This could be\n            // from a server mutation, or it could be a streaming response.\n            seededCache.data.set(seedKey, seedValue);\n          } // Schedule an update on the cache boundary to trigger a refresh.\n\n\n          const refreshUpdate = createLegacyQueueUpdate(eventTime, lane);\n          const payload = {\n            cache: seededCache\n          };\n          refreshUpdate.payload = payload;\n          enqueueLegacyQueueUpdate(provider, refreshUpdate, lane);\n          return;\n        }\n    }\n\n    provider = provider.return;\n  } // TODO: Warn if unmounted?\n\n}\n\nfunction dispatchReducerAction(fiber, queue, action) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n  const update = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate(fiber, queue, update, lane);\n    const eventTime = requestEventTime();\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction dispatchSetState(fiber, queue, action) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n  const update = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate(fiber, queue, update, lane);\n    const alternate = fiber.alternate;\n\n    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          const currentState = queue.lastRenderedState;\n          const eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    const eventTime = requestEventTime();\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction isRenderPhaseUpdate(fiber) {\n  const alternate = fiber.alternate;\n  return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;\n}\n\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  const pending = queue.pending;\n\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n\n  queue.pending = update;\n}\n\nfunction enqueueUpdate(fiber, queue, update, lane) {\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = queue.interleaved;\n\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update; // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n\n      pushInterleavedQueue(queue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n\n    queue.interleaved = update;\n  } else {\n    const pending = queue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    queue.pending = update;\n  }\n}\n\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (isTransitionLane(lane)) {\n    let queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools(fiber, lane, action) {\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      if (fiber.mode & DebugTracingMode) {\n        const name = getComponentNameFromFiber(fiber) || 'Unknown';\n        logStateUpdateScheduled(name, lane, action);\n      }\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nfunction getCacheSignal() {\n  if (!enableCache) {\n    throw new Error('Not implemented.');\n  }\n\n  const cache = readContext(CacheContext);\n  return cache.controller.signal;\n}\n\nfunction getCacheForType(resourceType) {\n  if (!enableCache) {\n    throw new Error('Not implemented.');\n  }\n\n  const cache = readContext(CacheContext);\n  let cacheForType = cache.data.get(resourceType);\n\n  if (cacheForType === undefined) {\n    cacheForType = resourceType();\n    cache.data.set(resourceType, cacheForType);\n  }\n\n  return cacheForType;\n}\n\nexport const ContextOnlyDispatcher = {\n  readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  ContextOnlyDispatcher.getCacheSignal = getCacheSignal;\n  ContextOnlyDispatcher.getCacheForType = getCacheForType;\n  ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n}\n\nconst HooksDispatcherOnMount = {\n  readContext,\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useInsertionEffect: mountInsertionEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n  useMutableSource: mountMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: mountId,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  HooksDispatcherOnMount.getCacheSignal = getCacheSignal;\n  HooksDispatcherOnMount.getCacheForType = getCacheForType;\n  HooksDispatcherOnMount.useCacheRefresh = mountRefresh;\n}\n\nconst HooksDispatcherOnUpdate = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  HooksDispatcherOnUpdate.getCacheSignal = getCacheSignal;\n  HooksDispatcherOnUpdate.getCacheForType = getCacheForType;\n  HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;\n}\n\nconst HooksDispatcherOnRerender = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  HooksDispatcherOnRerender.getCacheSignal = getCacheSignal;\n  HooksDispatcherOnRerender.getCacheForType = getCacheForType;\n  HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;\n}\n\nlet HooksDispatcherOnMountInDEV = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV = null;\nlet HooksDispatcherOnUpdateInDEV = null;\nlet HooksDispatcherOnRerenderInDEV = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV = null;\nlet InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    console.error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  const warnInvalidHookAccess = () => {\n    console.error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnMountInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnMountInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnMountWithHookTypesInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnMountWithHookTypesInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnUpdateInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnUpdateInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnRerenderInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnRerenderInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnMountInDEV.getCacheSignal = getCacheSignal;\n    InvalidNestedHooksDispatcherOnMountInDEV.getCacheForType = getCacheForType;\n\n    InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnUpdateInDEV.getCacheSignal = getCacheSignal;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.getCacheForType = getCacheForType;\n\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnRerenderInDEV.getCacheSignal = getCacheSignal;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.getCacheForType = getCacheForType;\n\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n}","map":{"version":3,"names":["ReactSharedInternals","enableDebugTracing","enableSchedulingProfiler","enableNewReconciler","enableCache","enableUseRefAccessWarning","enableStrictEffects","enableLazyContextPropagation","enableSuspenseLayoutEffectSemantics","enableUseMutableSource","enableTransitionTracing","NoMode","ConcurrentMode","DebugTracingMode","StrictEffectsMode","NoLane","SyncLane","NoLanes","isSubsetOfLanes","includesBlockingLane","includesOnlyNonUrgentLanes","claimNextTransitionLane","mergeLanes","removeLanes","intersectLanes","isTransitionLane","markRootEntangled","markRootMutableRead","NoTimestamp","ContinuousEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","higherEventPriority","readContext","checkIfContextChanged","HostRoot","CacheComponent","LayoutStatic","LayoutStaticEffect","MountLayoutDev","MountLayoutDevEffect","MountPassiveDev","MountPassiveDevEffect","Passive","PassiveEffect","PassiveStatic","PassiveStaticEffect","StaticMask","StaticMaskEffect","Update","UpdateEffect","StoreConsistency","HasEffect","HookHasEffect","Layout","HookLayout","HookPassive","Insertion","HookInsertion","getWorkInProgressRoot","scheduleUpdateOnFiber","requestUpdateLane","requestEventTime","markSkippedUpdateLanes","isInterleavedUpdate","getComponentNameFromFiber","is","isArray","markWorkInProgressReceivedUpdate","checkIfWorkInProgressReceivedUpdate","getIsHydrating","getWorkInProgressVersion","markSourceAsDirty","setWorkInProgressVersion","warnAboutMultipleRenderersDEV","logStateUpdateScheduled","markStateUpdateScheduled","createCache","CacheContext","createUpdate","createLegacyQueueUpdate","enqueueUpdate","enqueueLegacyQueueUpdate","entangleTransitions","entangleLegacyQueueTransitions","pushInterleavedQueue","getTreeId","now","ReactCurrentDispatcher","ReactCurrentBatchConfig","didWarnAboutMismatchedHooksForComponent","didWarnUncachedGetSnapshot","__DEV__","Set","renderLanes","currentlyRenderingFiber","currentHook","workInProgressHook","didScheduleRenderPhaseUpdate","didScheduleRenderPhaseUpdateDuringThisPass","localIdCounter","globalClientIdCounter","RE_RENDER_LIMIT","currentHookNameInDev","hookTypesDev","hookTypesUpdateIndexDev","ignorePreviousDependencies","mountHookTypesDev","hookName","push","updateHookTypesDev","warnOnHookMismatchInDev","checkDepsAreArrayDev","deps","undefined","console","error","currentHookName","componentName","has","add","table","secondColumnStart","i","oldHookName","newHookName","row","length","throwInvalidHookError","Error","areHookInputsEqual","nextDeps","prevDeps","join","renderWithHooks","current","workInProgress","Component","props","secondArg","nextRenderLanes","_debugHookTypes","type","memoizedState","updateQueue","lanes","HooksDispatcherOnUpdateInDEV","HooksDispatcherOnMountWithHookTypesInDEV","HooksDispatcherOnMountInDEV","HooksDispatcherOnMount","HooksDispatcherOnUpdate","children","numberOfReRenders","HooksDispatcherOnRerenderInDEV","HooksDispatcherOnRerender","ContextOnlyDispatcher","didRenderTooFewHooks","next","flags","mode","currentDependencies","dependencies","checkDidRenderIdHook","didRenderIdHook","bailoutHooks","resetHooksAfterThrow","hook","queue","pending","isUpdatingOpaqueValueInRenderPhase","mountWorkInProgressHook","baseState","baseQueue","updateWorkInProgressHook","nextCurrentHook","alternate","nextWorkInProgressHook","newHook","createFunctionComponentUpdateQueue","lastEffect","stores","basicStateReducer","state","action","mountReducer","reducer","initialArg","init","initialState","interleaved","dispatch","lastRenderedReducer","lastRenderedState","dispatchReducerAction","bind","updateReducer","pendingQueue","baseFirst","pendingFirst","first","newState","newBaseState","newBaseQueueFirst","newBaseQueueLast","update","updateLane","lane","clone","hasEagerState","eagerState","lastInterleaved","interleavedLane","rerenderReducer","lastRenderPhaseUpdate","firstRenderPhaseUpdate","readFromUnsubscribedMutableSource","root","source","getSnapshot","getVersion","_getVersion","version","_source","isSafeToReadFromSource","currentRenderVersion","mutableReadLanes","snapshot","useMutableSource","subscribe","dispatcher","currentSnapshot","setSnapshot","useState","stateHook","refs","prevGetSnapshot","prevSource","prevSubscribe","fiber","useEffect","maybeNewVersion","maybeNewSnapshot","handleChange","latestGetSnapshot","latestSetSnapshot","unsubscribe","newQueue","dispatchSetState","mountMutableSource","updateMutableSource","mountSyncExternalStore","getServerSnapshot","nextSnapshot","isHydrating","cachedSnapshot","pushStoreConsistencyCheck","inst","value","mountEffect","subscribeToStore","pushEffect","updateStoreInstance","updateSyncExternalStore","prevSnapshot","snapshotChanged","updateEffect","tag","renderedSnapshot","check","componentUpdateQueue","checkIfSnapshotChanged","forceStoreRerender","handleStoreChange","prevValue","nextValue","mountState","updateState","rerenderState","create","destroy","effect","firstEffect","stackContainsErrorMessage","getCallerStackFrame","stackFrames","stack","split","includes","slice","mountRef","initialValue","hasBeenInitialized","lazyInitGetterStack","didCheckForLazyInit","didWarnAboutRead","didWarnAboutWrite","ref","warn","Object","seal","updateRef","mountEffectImpl","fiberFlags","hookFlags","updateEffectImpl","prevEffect","mountInsertionEffect","updateInsertionEffect","mountLayoutEffect","updateLayoutEffect","imperativeHandleEffect","refCallback","refObject","hasOwnProperty","keys","mountImperativeHandle","effectDeps","concat","updateImperativeHandle","mountDebugValue","formatterFn","updateDebugValue","mountCallback","callback","updateCallback","prevState","mountMemo","nextCreate","updateMemo","mountDeferredValue","updateDeferredValue","resolvedCurrentHook","updateDeferredValueImpl","rerenderDeferredValue","shouldDeferValue","deferredLane","startTransition","setPending","options","previousPriority","prevTransition","transition","currentTransition","name","startTime","_updatedFibers","updatedFibersCount","size","clear","mountTransition","isPending","start","updateTransition","rerenderTransition","getIsUpdatingOpaqueValueInRenderPhaseInDEV","mountId","identifierPrefix","id","treeId","localId","toString","globalClientId","updateId","mountRefresh","refresh","refreshCache","updateRefresh","seedKey","seedValue","provider","return","eventTime","seededCache","data","set","refreshUpdate","payload","cache","arguments","isRenderPhaseUpdate","enqueueRenderPhaseUpdate","entangleTransitionUpdate","markUpdateInDevTools","prevDispatcher","InvalidNestedHooksDispatcherOnUpdateInDEV","currentState","queueLanes","pendingLanes","newQueueLanes","getCacheSignal","controller","signal","getCacheForType","resourceType","cacheForType","get","useCallback","useContext","useImperativeHandle","useInsertionEffect","useLayoutEffect","useMemo","useReducer","useRef","useDebugValue","useDeferredValue","useTransition","useSyncExternalStore","useId","unstable_isNewReconciler","useCacheRefresh","InvalidNestedHooksDispatcherOnMountInDEV","InvalidNestedHooksDispatcherOnRerenderInDEV","warnInvalidContextAccess","warnInvalidHookAccess","context"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberHooks.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {\r\n  MutableSource,\r\n  MutableSourceGetSnapshotFn,\r\n  MutableSourceSubscribeFn,\r\n  ReactContext,\r\n  StartTransitionOptions,\r\n} from 'shared/ReactTypes';\r\nimport type {Fiber, Dispatcher, HookType} from './ReactInternalTypes';\r\nimport type {Lanes, Lane} from './ReactFiberLane.new';\r\nimport type {HookFlags} from './ReactHookEffectTags';\r\nimport type {FiberRoot} from './ReactInternalTypes';\r\nimport type {Cache} from './ReactFiberCacheComponent.new';\r\nimport type {Flags} from './ReactFiberFlags';\r\n\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport {\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  enableNewReconciler,\r\n  enableCache,\r\n  enableUseRefAccessWarning,\r\n  enableStrictEffects,\r\n  enableLazyContextPropagation,\r\n  enableSuspenseLayoutEffectSemantics,\r\n  enableUseMutableSource,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\n\r\nimport {\r\n  NoMode,\r\n  ConcurrentMode,\r\n  DebugTracingMode,\r\n  StrictEffectsMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  NoLane,\r\n  SyncLane,\r\n  NoLanes,\r\n  isSubsetOfLanes,\r\n  includesBlockingLane,\r\n  includesOnlyNonUrgentLanes,\r\n  claimNextTransitionLane,\r\n  mergeLanes,\r\n  removeLanes,\r\n  intersectLanes,\r\n  isTransitionLane,\r\n  markRootEntangled,\r\n  markRootMutableRead,\r\n  NoTimestamp,\r\n} from './ReactFiberLane.new';\r\nimport {\r\n  ContinuousEventPriority,\r\n  getCurrentUpdatePriority,\r\n  setCurrentUpdatePriority,\r\n  higherEventPriority,\r\n} from './ReactEventPriorities.new';\r\nimport {readContext, checkIfContextChanged} from './ReactFiberNewContext.new';\r\nimport {HostRoot, CacheComponent} from './ReactWorkTags';\r\nimport {\r\n  LayoutStatic as LayoutStaticEffect,\r\n  MountLayoutDev as MountLayoutDevEffect,\r\n  MountPassiveDev as MountPassiveDevEffect,\r\n  Passive as PassiveEffect,\r\n  PassiveStatic as PassiveStaticEffect,\r\n  StaticMask as StaticMaskEffect,\r\n  Update as UpdateEffect,\r\n  StoreConsistency,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  HasEffect as HookHasEffect,\r\n  Layout as HookLayout,\r\n  Passive as HookPassive,\r\n  Insertion as HookInsertion,\r\n} from './ReactHookEffectTags';\r\nimport {\r\n  getWorkInProgressRoot,\r\n  scheduleUpdateOnFiber,\r\n  requestUpdateLane,\r\n  requestEventTime,\r\n  markSkippedUpdateLanes,\r\n  isInterleavedUpdate,\r\n} from './ReactFiberWorkLoop.new';\r\n\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport is from 'shared/objectIs';\r\nimport isArray from 'shared/isArray';\r\nimport {\r\n  markWorkInProgressReceivedUpdate,\r\n  checkIfWorkInProgressReceivedUpdate,\r\n} from './ReactFiberBeginWork.new';\r\nimport {getIsHydrating} from './ReactFiberHydrationContext.new';\r\nimport {\r\n  getWorkInProgressVersion,\r\n  markSourceAsDirty,\r\n  setWorkInProgressVersion,\r\n  warnAboutMultipleRenderersDEV,\r\n} from './ReactMutableSource.new';\r\nimport {logStateUpdateScheduled} from './DebugTracing';\r\nimport {markStateUpdateScheduled} from './ReactFiberDevToolsHook.new';\r\nimport {createCache, CacheContext} from './ReactFiberCacheComponent.new';\r\nimport {\r\n  createUpdate as createLegacyQueueUpdate,\r\n  enqueueUpdate as enqueueLegacyQueueUpdate,\r\n  entangleTransitions as entangleLegacyQueueTransitions,\r\n} from './ReactUpdateQueue.new';\r\nimport {pushInterleavedQueue} from './ReactFiberInterleavedUpdates.new';\r\nimport {getTreeId} from './ReactFiberTreeContext.new';\r\nimport {now} from './Scheduler';\r\n\r\nconst {ReactCurrentDispatcher, ReactCurrentBatchConfig} = ReactSharedInternals;\r\n\r\ntype Update<S, A> = {|\r\n  lane: Lane,\r\n  action: A,\r\n  hasEagerState: boolean,\r\n  eagerState: S | null,\r\n  next: Update<S, A>,\r\n|};\r\n\r\nexport type UpdateQueue<S, A> = {|\r\n  pending: Update<S, A> | null,\r\n  interleaved: Update<S, A> | null,\r\n  lanes: Lanes,\r\n  dispatch: (A => mixed) | null,\r\n  lastRenderedReducer: ((S, A) => S) | null,\r\n  lastRenderedState: S | null,\r\n|};\r\n\r\nlet didWarnAboutMismatchedHooksForComponent;\r\nlet didWarnUncachedGetSnapshot;\r\nif (__DEV__) {\r\n  didWarnAboutMismatchedHooksForComponent = new Set();\r\n}\r\n\r\nexport type Hook = {|\r\n  memoizedState: any,\r\n  baseState: any,\r\n  baseQueue: Update<any, any> | null,\r\n  queue: any,\r\n  next: Hook | null,\r\n|};\r\n\r\nexport type Effect = {|\r\n  tag: HookFlags,\r\n  create: () => (() => void) | void,\r\n  destroy: (() => void) | void,\r\n  deps: Array<mixed> | null,\r\n  next: Effect,\r\n|};\r\n\r\ntype StoreInstance<T> = {|\r\n  value: T,\r\n  getSnapshot: () => T,\r\n|};\r\n\r\ntype StoreConsistencyCheck<T> = {|\r\n  value: T,\r\n  getSnapshot: () => T,\r\n|};\r\n\r\nexport type FunctionComponentUpdateQueue = {|\r\n  lastEffect: Effect | null,\r\n  stores: Array<StoreConsistencyCheck<any>> | null,\r\n|};\r\n\r\ntype BasicStateAction<S> = (S => S) | S;\r\n\r\ntype Dispatch<A> = A => void;\r\n\r\n// These are set right before calling the component.\r\nlet renderLanes: Lanes = NoLanes;\r\n// The work-in-progress fiber. I've named it differently to distinguish it from\r\n// the work-in-progress hook.\r\nlet currentlyRenderingFiber: Fiber = (null: any);\r\n\r\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\r\n// current hook list is the list that belongs to the current fiber. The\r\n// work-in-progress hook list is a new list that will be added to the\r\n// work-in-progress fiber.\r\nlet currentHook: Hook | null = null;\r\nlet workInProgressHook: Hook | null = null;\r\n\r\n// Whether an update was scheduled at any point during the render phase. This\r\n// does not get reset if we do another render pass; only when we're completely\r\n// finished evaluating this component. This is an optimization so we know\r\n// whether we need to clear render phase updates after a throw.\r\nlet didScheduleRenderPhaseUpdate: boolean = false;\r\n// Where an update was scheduled only during the current render pass. This\r\n// gets reset after each attempt.\r\n// TODO: Maybe there's some way to consolidate this with\r\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\r\nlet didScheduleRenderPhaseUpdateDuringThisPass: boolean = false;\r\n// Counts the number of useId hooks in this component.\r\nlet localIdCounter: number = 0;\r\n// Used for ids that are generated completely client-side (i.e. not during\r\n// hydration). This counter is global, so client ids are not stable across\r\n// render attempts.\r\nlet globalClientIdCounter: number = 0;\r\n\r\nconst RE_RENDER_LIMIT = 25;\r\n\r\n// In DEV, this is the name of the currently executing primitive hook\r\nlet currentHookNameInDev: ?HookType = null;\r\n\r\n// In DEV, this list ensures that hooks are called in the same order between renders.\r\n// The list stores the order of hooks used during the initial render (mount).\r\n// Subsequent renders (updates) reference this list.\r\nlet hookTypesDev: Array<HookType> | null = null;\r\nlet hookTypesUpdateIndexDev: number = -1;\r\n\r\n// In DEV, this tracks whether currently rendering component needs to ignore\r\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\r\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\r\nlet ignorePreviousDependencies: boolean = false;\r\n\r\nfunction mountHookTypesDev() {\r\n  if (__DEV__) {\r\n    const hookName = ((currentHookNameInDev: any): HookType);\r\n\r\n    if (hookTypesDev === null) {\r\n      hookTypesDev = [hookName];\r\n    } else {\r\n      hookTypesDev.push(hookName);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateHookTypesDev() {\r\n  if (__DEV__) {\r\n    const hookName = ((currentHookNameInDev: any): HookType);\r\n\r\n    if (hookTypesDev !== null) {\r\n      hookTypesUpdateIndexDev++;\r\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\r\n        warnOnHookMismatchInDev(hookName);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkDepsAreArrayDev(deps: mixed) {\r\n  if (__DEV__) {\r\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\r\n      // Verify deps, but only on mount to avoid extra checks.\r\n      // It's unlikely their type would change as usually you define them inline.\r\n      console.error(\r\n        '%s received a final argument that is not an array (instead, received `%s`). When ' +\r\n          'specified, the final argument must be an array.',\r\n        currentHookNameInDev,\r\n        typeof deps,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnOnHookMismatchInDev(currentHookName: HookType) {\r\n  if (__DEV__) {\r\n    const componentName = getComponentNameFromFiber(currentlyRenderingFiber);\r\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\r\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\r\n\r\n      if (hookTypesDev !== null) {\r\n        let table = '';\r\n\r\n        const secondColumnStart = 30;\r\n\r\n        for (let i = 0; i <= ((hookTypesUpdateIndexDev: any): number); i++) {\r\n          const oldHookName = hookTypesDev[i];\r\n          const newHookName =\r\n            i === ((hookTypesUpdateIndexDev: any): number)\r\n              ? currentHookName\r\n              : oldHookName;\r\n\r\n          let row = `${i + 1}. ${oldHookName}`;\r\n\r\n          // Extra space so second column lines up\r\n          // lol @ IE not supporting String#repeat\r\n          while (row.length < secondColumnStart) {\r\n            row += ' ';\r\n          }\r\n\r\n          row += newHookName + '\\n';\r\n\r\n          table += row;\r\n        }\r\n\r\n        console.error(\r\n          'React has detected a change in the order of Hooks called by %s. ' +\r\n            'This will lead to bugs and errors if not fixed. ' +\r\n            'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' +\r\n            '   Previous render            Next render\\n' +\r\n            '   ------------------------------------------------------\\n' +\r\n            '%s' +\r\n            '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',\r\n          componentName,\r\n          table,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction throwInvalidHookError() {\r\n  throw new Error(\r\n    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\r\n      ' one of the following reasons:\\n' +\r\n      '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\r\n      '2. You might be breaking the Rules of Hooks\\n' +\r\n      '3. You might have more than one copy of React in the same app\\n' +\r\n      'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',\r\n  );\r\n}\r\n\r\nfunction areHookInputsEqual(\r\n  nextDeps: Array<mixed>,\r\n  prevDeps: Array<mixed> | null,\r\n) {\r\n  if (__DEV__) {\r\n    if (ignorePreviousDependencies) {\r\n      // Only true when this component is being hot reloaded.\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (prevDeps === null) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        '%s received a final argument during this render, but not during ' +\r\n          'the previous render. Even though the final argument is optional, ' +\r\n          'its type cannot change between renders.',\r\n        currentHookNameInDev,\r\n      );\r\n    }\r\n    return false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    // Don't bother comparing lengths in prod because these arrays should be\r\n    // passed inline.\r\n    if (nextDeps.length !== prevDeps.length) {\r\n      console.error(\r\n        'The final argument passed to %s changed size between renders. The ' +\r\n          'order and size of this array must remain constant.\\n\\n' +\r\n          'Previous: %s\\n' +\r\n          'Incoming: %s',\r\n        currentHookNameInDev,\r\n        `[${prevDeps.join(', ')}]`,\r\n        `[${nextDeps.join(', ')}]`,\r\n      );\r\n    }\r\n  }\r\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\r\n    if (is(nextDeps[i], prevDeps[i])) {\r\n      continue;\r\n    }\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function renderWithHooks<Props, SecondArg>(\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: (p: Props, arg: SecondArg) => any,\r\n  props: Props,\r\n  secondArg: SecondArg,\r\n  nextRenderLanes: Lanes,\r\n): any {\r\n  renderLanes = nextRenderLanes;\r\n  currentlyRenderingFiber = workInProgress;\r\n\r\n  if (__DEV__) {\r\n    hookTypesDev =\r\n      current !== null\r\n        ? ((current._debugHookTypes: any): Array<HookType>)\r\n        : null;\r\n    hookTypesUpdateIndexDev = -1;\r\n    // Used for hot reloading:\r\n    ignorePreviousDependencies =\r\n      current !== null && current.type !== workInProgress.type;\r\n  }\r\n\r\n  workInProgress.memoizedState = null;\r\n  workInProgress.updateQueue = null;\r\n  workInProgress.lanes = NoLanes;\r\n\r\n  // The following should have already been reset\r\n  // currentHook = null;\r\n  // workInProgressHook = null;\r\n\r\n  // didScheduleRenderPhaseUpdate = false;\r\n  // localIdCounter = 0;\r\n\r\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\r\n  // Currently we will identify the update render as a mount because memoizedState === null.\r\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\r\n\r\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\r\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\r\n  // so memoizedState would be null during updates and mounts.\r\n  if (__DEV__) {\r\n    if (current !== null && current.memoizedState !== null) {\r\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\r\n    } else if (hookTypesDev !== null) {\r\n      // This dispatcher handles an edge case where a component is updating,\r\n      // but no stateful hooks have been used.\r\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\r\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\r\n      // This dispatcher does that.\r\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\r\n    } else {\r\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\r\n    }\r\n  } else {\r\n    ReactCurrentDispatcher.current =\r\n      current === null || current.memoizedState === null\r\n        ? HooksDispatcherOnMount\r\n        : HooksDispatcherOnUpdate;\r\n  }\r\n\r\n  let children = Component(props, secondArg);\r\n\r\n  // Check if there was a render phase update\r\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\r\n    // Keep rendering in a loop for as long as render phase updates continue to\r\n    // be scheduled. Use a counter to prevent infinite loops.\r\n    let numberOfReRenders: number = 0;\r\n    do {\r\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\r\n      localIdCounter = 0;\r\n\r\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\r\n        throw new Error(\r\n          'Too many re-renders. React limits the number of renders to prevent ' +\r\n            'an infinite loop.',\r\n        );\r\n      }\r\n\r\n      numberOfReRenders += 1;\r\n      if (__DEV__) {\r\n        // Even when hot reloading, allow dependencies to stabilize\r\n        // after first render to prevent infinite render phase updates.\r\n        ignorePreviousDependencies = false;\r\n      }\r\n\r\n      // Start over from the beginning of the list\r\n      currentHook = null;\r\n      workInProgressHook = null;\r\n\r\n      workInProgress.updateQueue = null;\r\n\r\n      if (__DEV__) {\r\n        // Also validate hook order for cascading updates.\r\n        hookTypesUpdateIndexDev = -1;\r\n      }\r\n\r\n      ReactCurrentDispatcher.current = __DEV__\r\n        ? HooksDispatcherOnRerenderInDEV\r\n        : HooksDispatcherOnRerender;\r\n\r\n      children = Component(props, secondArg);\r\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\r\n  }\r\n\r\n  // We can assume the previous dispatcher is always this one, since we set it\r\n  // at the beginning of the render phase and there's no re-entrance.\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n\r\n  if (__DEV__) {\r\n    workInProgress._debugHookTypes = hookTypesDev;\r\n  }\r\n\r\n  // This check uses currentHook so that it works the same in DEV and prod bundles.\r\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\r\n  const didRenderTooFewHooks =\r\n    currentHook !== null && currentHook.next !== null;\r\n\r\n  renderLanes = NoLanes;\r\n  currentlyRenderingFiber = (null: any);\r\n\r\n  currentHook = null;\r\n  workInProgressHook = null;\r\n\r\n  if (__DEV__) {\r\n    currentHookNameInDev = null;\r\n    hookTypesDev = null;\r\n    hookTypesUpdateIndexDev = -1;\r\n\r\n    // Confirm that a static flag was not added or removed since the last\r\n    // render. If this fires, it suggests that we incorrectly reset the static\r\n    // flags in some other part of the codebase. This has happened before, for\r\n    // example, in the SuspenseList implementation.\r\n    if (\r\n      current !== null &&\r\n      (current.flags & StaticMaskEffect) !==\r\n        (workInProgress.flags & StaticMaskEffect) &&\r\n      // Disable this warning in legacy mode, because legacy Suspense is weird\r\n      // and creates false positives. To make this work in legacy mode, we'd\r\n      // need to mark fibers that commit in an incomplete state, somehow. For\r\n      // now I'll disable the warning that most of the bugs that would trigger\r\n      // it are either exclusive to concurrent mode or exist in both.\r\n      (current.mode & ConcurrentMode) !== NoMode\r\n    ) {\r\n      console.error(\r\n        'Internal React error: Expected static flag was missing. Please ' +\r\n          'notify the React team.',\r\n      );\r\n    }\r\n  }\r\n\r\n  didScheduleRenderPhaseUpdate = false;\r\n  // This is reset by checkDidRenderIdHook\r\n  // localIdCounter = 0;\r\n\r\n  if (didRenderTooFewHooks) {\r\n    throw new Error(\r\n      'Rendered fewer hooks than expected. This may be caused by an accidental ' +\r\n        'early return statement.',\r\n    );\r\n  }\r\n\r\n  if (enableLazyContextPropagation) {\r\n    if (current !== null) {\r\n      if (!checkIfWorkInProgressReceivedUpdate()) {\r\n        // If there were no changes to props or state, we need to check if there\r\n        // was a context change. We didn't already do this because there's no\r\n        // 1:1 correspondence between dependencies and hooks. Although, because\r\n        // there almost always is in the common case (`readContext` is an\r\n        // internal API), we could compare in there. OTOH, we only hit this case\r\n        // if everything else bails out, so on the whole it might be better to\r\n        // keep the comparison out of the common path.\r\n        const currentDependencies = current.dependencies;\r\n        if (\r\n          currentDependencies !== null &&\r\n          checkIfContextChanged(currentDependencies)\r\n        ) {\r\n          markWorkInProgressReceivedUpdate();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return children;\r\n}\r\n\r\nexport function checkDidRenderIdHook() {\r\n  // This should be called immediately after every renderWithHooks call.\r\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\r\n  // separate function to avoid using an array tuple.\r\n  const didRenderIdHook = localIdCounter !== 0;\r\n  localIdCounter = 0;\r\n  return didRenderIdHook;\r\n}\r\n\r\nexport function bailoutHooks(\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  lanes: Lanes,\r\n) {\r\n  workInProgress.updateQueue = current.updateQueue;\r\n  // TODO: Don't need to reset the flags here, because they're reset in the\r\n  // complete phase (bubbleProperties).\r\n  if (\r\n    __DEV__ &&\r\n    enableStrictEffects &&\r\n    (workInProgress.mode & StrictEffectsMode) !== NoMode\r\n  ) {\r\n    workInProgress.flags &= ~(\r\n      MountPassiveDevEffect |\r\n      MountLayoutDevEffect |\r\n      PassiveEffect |\r\n      UpdateEffect\r\n    );\r\n  } else {\r\n    workInProgress.flags &= ~(PassiveEffect | UpdateEffect);\r\n  }\r\n  current.lanes = removeLanes(current.lanes, lanes);\r\n}\r\n\r\nexport function resetHooksAfterThrow(): void {\r\n  // We can assume the previous dispatcher is always this one, since we set it\r\n  // at the beginning of the render phase and there's no re-entrance.\r\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\r\n\r\n  if (didScheduleRenderPhaseUpdate) {\r\n    // There were render phase updates. These are only valid for this render\r\n    // phase, which we are now aborting. Remove the updates from the queues so\r\n    // they do not persist to the next render. Do not remove updates from hooks\r\n    // that weren't processed.\r\n    //\r\n    // Only reset the updates from the queue if it has a clone. If it does\r\n    // not have a clone, that means it wasn't processed, and the updates were\r\n    // scheduled before we entered the render phase.\r\n    let hook: Hook | null = currentlyRenderingFiber.memoizedState;\r\n    while (hook !== null) {\r\n      const queue = hook.queue;\r\n      if (queue !== null) {\r\n        queue.pending = null;\r\n      }\r\n      hook = hook.next;\r\n    }\r\n    didScheduleRenderPhaseUpdate = false;\r\n  }\r\n\r\n  renderLanes = NoLanes;\r\n  currentlyRenderingFiber = (null: any);\r\n\r\n  currentHook = null;\r\n  workInProgressHook = null;\r\n\r\n  if (__DEV__) {\r\n    hookTypesDev = null;\r\n    hookTypesUpdateIndexDev = -1;\r\n\r\n    currentHookNameInDev = null;\r\n\r\n    isUpdatingOpaqueValueInRenderPhase = false;\r\n  }\r\n\r\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\r\n  localIdCounter = 0;\r\n}\r\n\r\nfunction mountWorkInProgressHook(): Hook {\r\n  const hook: Hook = {\r\n    memoizedState: null,\r\n\r\n    baseState: null,\r\n    baseQueue: null,\r\n    queue: null,\r\n\r\n    next: null,\r\n  };\r\n\r\n  if (workInProgressHook === null) {\r\n    // This is the first hook in the list\r\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\r\n  } else {\r\n    // Append to the end of the list\r\n    workInProgressHook = workInProgressHook.next = hook;\r\n  }\r\n  return workInProgressHook;\r\n}\r\n\r\nfunction updateWorkInProgressHook(): Hook {\r\n  // This function is used both for updates and for re-renders triggered by a\r\n  // render phase update. It assumes there is either a current hook we can\r\n  // clone, or a work-in-progress hook from a previous render pass that we can\r\n  // use as a base. When we reach the end of the base list, we must switch to\r\n  // the dispatcher used for mounts.\r\n  let nextCurrentHook: null | Hook;\r\n  if (currentHook === null) {\r\n    const current = currentlyRenderingFiber.alternate;\r\n    if (current !== null) {\r\n      nextCurrentHook = current.memoizedState;\r\n    } else {\r\n      nextCurrentHook = null;\r\n    }\r\n  } else {\r\n    nextCurrentHook = currentHook.next;\r\n  }\r\n\r\n  let nextWorkInProgressHook: null | Hook;\r\n  if (workInProgressHook === null) {\r\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\r\n  } else {\r\n    nextWorkInProgressHook = workInProgressHook.next;\r\n  }\r\n\r\n  if (nextWorkInProgressHook !== null) {\r\n    // There's already a work-in-progress. Reuse it.\r\n    workInProgressHook = nextWorkInProgressHook;\r\n    nextWorkInProgressHook = workInProgressHook.next;\r\n\r\n    currentHook = nextCurrentHook;\r\n  } else {\r\n    // Clone from the current hook.\r\n\r\n    if (nextCurrentHook === null) {\r\n      throw new Error('Rendered more hooks than during the previous render.');\r\n    }\r\n\r\n    currentHook = nextCurrentHook;\r\n\r\n    const newHook: Hook = {\r\n      memoizedState: currentHook.memoizedState,\r\n\r\n      baseState: currentHook.baseState,\r\n      baseQueue: currentHook.baseQueue,\r\n      queue: currentHook.queue,\r\n\r\n      next: null,\r\n    };\r\n\r\n    if (workInProgressHook === null) {\r\n      // This is the first hook in the list.\r\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\r\n    } else {\r\n      // Append to the end of the list.\r\n      workInProgressHook = workInProgressHook.next = newHook;\r\n    }\r\n  }\r\n  return workInProgressHook;\r\n}\r\n\r\nfunction createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue {\r\n  return {\r\n    lastEffect: null,\r\n    stores: null,\r\n  };\r\n}\r\n\r\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\r\n  // $FlowFixMe: Flow doesn't like mixed types\r\n  return typeof action === 'function' ? action(state) : action;\r\n}\r\n\r\nfunction mountReducer<S, I, A>(\r\n  reducer: (S, A) => S,\r\n  initialArg: I,\r\n  init?: I => S,\r\n): [S, Dispatch<A>] {\r\n  const hook = mountWorkInProgressHook();\r\n  let initialState;\r\n  if (init !== undefined) {\r\n    initialState = init(initialArg);\r\n  } else {\r\n    initialState = ((initialArg: any): S);\r\n  }\r\n  hook.memoizedState = hook.baseState = initialState;\r\n  const queue: UpdateQueue<S, A> = {\r\n    pending: null,\r\n    interleaved: null,\r\n    lanes: NoLanes,\r\n    dispatch: null,\r\n    lastRenderedReducer: reducer,\r\n    lastRenderedState: (initialState: any),\r\n  };\r\n  hook.queue = queue;\r\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchReducerAction.bind(\r\n    null,\r\n    currentlyRenderingFiber,\r\n    queue,\r\n  ): any));\r\n  return [hook.memoizedState, dispatch];\r\n}\r\n\r\nfunction updateReducer<S, I, A>(\r\n  reducer: (S, A) => S,\r\n  initialArg: I,\r\n  init?: I => S,\r\n): [S, Dispatch<A>] {\r\n  const hook = updateWorkInProgressHook();\r\n  const queue = hook.queue;\r\n\r\n  if (queue === null) {\r\n    throw new Error(\r\n      'Should have a queue. This is likely a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  queue.lastRenderedReducer = reducer;\r\n\r\n  const current: Hook = (currentHook: any);\r\n\r\n  // The last rebase update that is NOT part of the base state.\r\n  let baseQueue = current.baseQueue;\r\n\r\n  // The last pending update that hasn't been processed yet.\r\n  const pendingQueue = queue.pending;\r\n  if (pendingQueue !== null) {\r\n    // We have new updates that haven't been processed yet.\r\n    // We'll add them to the base queue.\r\n    if (baseQueue !== null) {\r\n      // Merge the pending queue and the base queue.\r\n      const baseFirst = baseQueue.next;\r\n      const pendingFirst = pendingQueue.next;\r\n      baseQueue.next = pendingFirst;\r\n      pendingQueue.next = baseFirst;\r\n    }\r\n    if (__DEV__) {\r\n      if (current.baseQueue !== baseQueue) {\r\n        // Internal invariant that should never happen, but feasibly could in\r\n        // the future if we implement resuming, or some form of that.\r\n        console.error(\r\n          'Internal error: Expected work-in-progress queue to be a clone. ' +\r\n            'This is a bug in React.',\r\n        );\r\n      }\r\n    }\r\n    current.baseQueue = baseQueue = pendingQueue;\r\n    queue.pending = null;\r\n  }\r\n\r\n  if (baseQueue !== null) {\r\n    // We have a queue to process.\r\n    const first = baseQueue.next;\r\n    let newState = current.baseState;\r\n\r\n    let newBaseState = null;\r\n    let newBaseQueueFirst = null;\r\n    let newBaseQueueLast = null;\r\n    let update = first;\r\n    do {\r\n      const updateLane = update.lane;\r\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\r\n        // Priority is insufficient. Skip this update. If this is the first\r\n        // skipped update, the previous update/state is the new base\r\n        // update/state.\r\n        const clone: Update<S, A> = {\r\n          lane: updateLane,\r\n          action: update.action,\r\n          hasEagerState: update.hasEagerState,\r\n          eagerState: update.eagerState,\r\n          next: (null: any),\r\n        };\r\n        if (newBaseQueueLast === null) {\r\n          newBaseQueueFirst = newBaseQueueLast = clone;\r\n          newBaseState = newState;\r\n        } else {\r\n          newBaseQueueLast = newBaseQueueLast.next = clone;\r\n        }\r\n        // Update the remaining priority in the queue.\r\n        // TODO: Don't need to accumulate this. Instead, we can remove\r\n        // renderLanes from the original lanes.\r\n        currentlyRenderingFiber.lanes = mergeLanes(\r\n          currentlyRenderingFiber.lanes,\r\n          updateLane,\r\n        );\r\n        markSkippedUpdateLanes(updateLane);\r\n      } else {\r\n        // This update does have sufficient priority.\r\n\r\n        if (newBaseQueueLast !== null) {\r\n          const clone: Update<S, A> = {\r\n            // This update is going to be committed so we never want uncommit\r\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\r\n            // this will never be skipped by the check above.\r\n            lane: NoLane,\r\n            action: update.action,\r\n            hasEagerState: update.hasEagerState,\r\n            eagerState: update.eagerState,\r\n            next: (null: any),\r\n          };\r\n          newBaseQueueLast = newBaseQueueLast.next = clone;\r\n        }\r\n\r\n        // Process this update.\r\n        if (update.hasEagerState) {\r\n          // If this update is a state update (not a reducer) and was processed eagerly,\r\n          // we can use the eagerly computed state\r\n          newState = ((update.eagerState: any): S);\r\n        } else {\r\n          const action = update.action;\r\n          newState = reducer(newState, action);\r\n        }\r\n      }\r\n      update = update.next;\r\n    } while (update !== null && update !== first);\r\n\r\n    if (newBaseQueueLast === null) {\r\n      newBaseState = newState;\r\n    } else {\r\n      newBaseQueueLast.next = (newBaseQueueFirst: any);\r\n    }\r\n\r\n    // Mark that the fiber performed work, but only if the new state is\r\n    // different from the current state.\r\n    if (!is(newState, hook.memoizedState)) {\r\n      markWorkInProgressReceivedUpdate();\r\n    }\r\n\r\n    hook.memoizedState = newState;\r\n    hook.baseState = newBaseState;\r\n    hook.baseQueue = newBaseQueueLast;\r\n\r\n    queue.lastRenderedState = newState;\r\n  }\r\n\r\n  // Interleaved updates are stored on a separate queue. We aren't going to\r\n  // process them during this render, but we do need to track which lanes\r\n  // are remaining.\r\n  const lastInterleaved = queue.interleaved;\r\n  if (lastInterleaved !== null) {\r\n    let interleaved = lastInterleaved;\r\n    do {\r\n      const interleavedLane = interleaved.lane;\r\n      currentlyRenderingFiber.lanes = mergeLanes(\r\n        currentlyRenderingFiber.lanes,\r\n        interleavedLane,\r\n      );\r\n      markSkippedUpdateLanes(interleavedLane);\r\n      interleaved = ((interleaved: any).next: Update<S, A>);\r\n    } while (interleaved !== lastInterleaved);\r\n  } else if (baseQueue === null) {\r\n    // `queue.lanes` is used for entangling transitions. We can set it back to\r\n    // zero once the queue is empty.\r\n    queue.lanes = NoLanes;\r\n  }\r\n\r\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\r\n  return [hook.memoizedState, dispatch];\r\n}\r\n\r\nfunction rerenderReducer<S, I, A>(\r\n  reducer: (S, A) => S,\r\n  initialArg: I,\r\n  init?: I => S,\r\n): [S, Dispatch<A>] {\r\n  const hook = updateWorkInProgressHook();\r\n  const queue = hook.queue;\r\n\r\n  if (queue === null) {\r\n    throw new Error(\r\n      'Should have a queue. This is likely a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  queue.lastRenderedReducer = reducer;\r\n\r\n  // This is a re-render. Apply the new render phase updates to the previous\r\n  // work-in-progress hook.\r\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\r\n  const lastRenderPhaseUpdate = queue.pending;\r\n  let newState = hook.memoizedState;\r\n  if (lastRenderPhaseUpdate !== null) {\r\n    // The queue doesn't persist past this render pass.\r\n    queue.pending = null;\r\n\r\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\r\n    let update = firstRenderPhaseUpdate;\r\n    do {\r\n      // Process this render phase update. We don't have to check the\r\n      // priority because it will always be the same as the current\r\n      // render's.\r\n      const action = update.action;\r\n      newState = reducer(newState, action);\r\n      update = update.next;\r\n    } while (update !== firstRenderPhaseUpdate);\r\n\r\n    // Mark that the fiber performed work, but only if the new state is\r\n    // different from the current state.\r\n    if (!is(newState, hook.memoizedState)) {\r\n      markWorkInProgressReceivedUpdate();\r\n    }\r\n\r\n    hook.memoizedState = newState;\r\n    // Don't persist the state accumulated from the render phase updates to\r\n    // the base state unless the queue is empty.\r\n    // TODO: Not sure if this is the desired semantics, but it's what we\r\n    // do for gDSFP. I can't remember why.\r\n    if (hook.baseQueue === null) {\r\n      hook.baseState = newState;\r\n    }\r\n\r\n    queue.lastRenderedState = newState;\r\n  }\r\n  return [newState, dispatch];\r\n}\r\n\r\ntype MutableSourceMemoizedState<Source, Snapshot> = {|\r\n  refs: {\r\n    getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n    setSnapshot: Snapshot => void,\r\n  },\r\n  source: MutableSource<any>,\r\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n|};\r\n\r\nfunction readFromUnsubscribedMutableSource<Source, Snapshot>(\r\n  root: FiberRoot,\r\n  source: MutableSource<Source>,\r\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n): Snapshot {\r\n  if (__DEV__) {\r\n    warnAboutMultipleRenderersDEV(source);\r\n  }\r\n\r\n  const getVersion = source._getVersion;\r\n  const version = getVersion(source._source);\r\n\r\n  // Is it safe for this component to read from this source during the current render?\r\n  let isSafeToReadFromSource = false;\r\n\r\n  // Check the version first.\r\n  // If this render has already been started with a specific version,\r\n  // we can use it alone to determine if we can safely read from the source.\r\n  const currentRenderVersion = getWorkInProgressVersion(source);\r\n  if (currentRenderVersion !== null) {\r\n    // It's safe to read if the store hasn't been mutated since the last time\r\n    // we read something.\r\n    isSafeToReadFromSource = currentRenderVersion === version;\r\n  } else {\r\n    // If there's no version, then this is the first time we've read from the\r\n    // source during the current render pass, so we need to do a bit more work.\r\n    // What we need to determine is if there are any hooks that already\r\n    // subscribed to the source, and if so, whether there are any pending\r\n    // mutations that haven't been synchronized yet.\r\n    //\r\n    // If there are no pending mutations, then `root.mutableReadLanes` will be\r\n    // empty, and we know we can safely read.\r\n    //\r\n    // If there *are* pending mutations, we may still be able to safely read\r\n    // if the currently rendering lanes are inclusive of the pending mutation\r\n    // lanes, since that guarantees that the value we're about to read from\r\n    // the source is consistent with the values that we read during the most\r\n    // recent mutation.\r\n    isSafeToReadFromSource = isSubsetOfLanes(\r\n      renderLanes,\r\n      root.mutableReadLanes,\r\n    );\r\n\r\n    if (isSafeToReadFromSource) {\r\n      // If it's safe to read from this source during the current render,\r\n      // store the version in case other components read from it.\r\n      // A changed version number will let those components know to throw and restart the render.\r\n      setWorkInProgressVersion(source, version);\r\n    }\r\n  }\r\n\r\n  if (isSafeToReadFromSource) {\r\n    const snapshot = getSnapshot(source._source);\r\n    if (__DEV__) {\r\n      if (typeof snapshot === 'function') {\r\n        console.error(\r\n          'Mutable source should not return a function as the snapshot value. ' +\r\n            'Functions may close over mutable values and cause tearing.',\r\n        );\r\n      }\r\n    }\r\n    return snapshot;\r\n  } else {\r\n    // This handles the special case of a mutable source being shared between renderers.\r\n    // In that case, if the source is mutated between the first and second renderer,\r\n    // The second renderer don't know that it needs to reset the WIP version during unwind,\r\n    // (because the hook only marks sources as dirty if it's written to their WIP version).\r\n    // That would cause this tear check to throw again and eventually be visible to the user.\r\n    // We can avoid this infinite loop by explicitly marking the source as dirty.\r\n    //\r\n    // This can lead to tearing in the first renderer when it resumes,\r\n    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).\r\n    markSourceAsDirty(source);\r\n\r\n    // Intentioally throw an error to force React to retry synchronously. During\r\n    // the synchronous retry, it will block interleaved mutations, so we should\r\n    // get a consistent read. Therefore, the following error should never be\r\n    // visible to the user.\r\n\r\n    // We expect this error not to be thrown during the synchronous retry,\r\n    // because we blocked interleaved mutations.\r\n    throw new Error(\r\n      'Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n}\r\n\r\nfunction useMutableSource<Source, Snapshot>(\r\n  hook: Hook,\r\n  source: MutableSource<Source>,\r\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n): Snapshot {\r\n  if (!enableUseMutableSource) {\r\n    return (undefined: any);\r\n  }\r\n\r\n  const root = ((getWorkInProgressRoot(): any): FiberRoot);\r\n\r\n  if (root === null) {\r\n    throw new Error(\r\n      'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  const getVersion = source._getVersion;\r\n  const version = getVersion(source._source);\r\n\r\n  const dispatcher = ReactCurrentDispatcher.current;\r\n\r\n  // eslint-disable-next-line prefer-const\r\n  let [currentSnapshot, setSnapshot] = dispatcher.useState(() =>\r\n    readFromUnsubscribedMutableSource(root, source, getSnapshot),\r\n  );\r\n  let snapshot = currentSnapshot;\r\n\r\n  // Grab a handle to the state hook as well.\r\n  // We use it to clear the pending update queue if we have a new source.\r\n  const stateHook = ((workInProgressHook: any): Hook);\r\n\r\n  const memoizedState = ((hook.memoizedState: any): MutableSourceMemoizedState<\r\n    Source,\r\n    Snapshot,\r\n  >);\r\n  const refs = memoizedState.refs;\r\n  const prevGetSnapshot = refs.getSnapshot;\r\n  const prevSource = memoizedState.source;\r\n  const prevSubscribe = memoizedState.subscribe;\r\n\r\n  const fiber = currentlyRenderingFiber;\r\n\r\n  hook.memoizedState = ({\r\n    refs,\r\n    source,\r\n    subscribe,\r\n  }: MutableSourceMemoizedState<Source, Snapshot>);\r\n\r\n  // Sync the values needed by our subscription handler after each commit.\r\n  dispatcher.useEffect(() => {\r\n    refs.getSnapshot = getSnapshot;\r\n\r\n    // Normally the dispatch function for a state hook never changes,\r\n    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.\r\n    // handleChange() below needs to reference the dispatch function without re-subscribing,\r\n    // so we use a ref to ensure that it always has the latest version.\r\n    refs.setSnapshot = setSnapshot;\r\n\r\n    // Check for a possible change between when we last rendered now.\r\n    const maybeNewVersion = getVersion(source._source);\r\n    if (!is(version, maybeNewVersion)) {\r\n      const maybeNewSnapshot = getSnapshot(source._source);\r\n      if (__DEV__) {\r\n        if (typeof maybeNewSnapshot === 'function') {\r\n          console.error(\r\n            'Mutable source should not return a function as the snapshot value. ' +\r\n              'Functions may close over mutable values and cause tearing.',\r\n          );\r\n        }\r\n      }\r\n\r\n      if (!is(snapshot, maybeNewSnapshot)) {\r\n        setSnapshot(maybeNewSnapshot);\r\n\r\n        const lane = requestUpdateLane(fiber);\r\n        markRootMutableRead(root, lane);\r\n      }\r\n      // If the source mutated between render and now,\r\n      // there may be state updates already scheduled from the old source.\r\n      // Entangle the updates so that they render in the same batch.\r\n      markRootEntangled(root, root.mutableReadLanes);\r\n    }\r\n  }, [getSnapshot, source, subscribe]);\r\n\r\n  // If we got a new source or subscribe function, re-subscribe in a passive effect.\r\n  dispatcher.useEffect(() => {\r\n    const handleChange = () => {\r\n      const latestGetSnapshot = refs.getSnapshot;\r\n      const latestSetSnapshot = refs.setSnapshot;\r\n\r\n      try {\r\n        latestSetSnapshot(latestGetSnapshot(source._source));\r\n\r\n        // Record a pending mutable source update with the same expiration time.\r\n        const lane = requestUpdateLane(fiber);\r\n\r\n        markRootMutableRead(root, lane);\r\n      } catch (error) {\r\n        // A selector might throw after a source mutation.\r\n        // e.g. it might try to read from a part of the store that no longer exists.\r\n        // In this case we should still schedule an update with React.\r\n        // Worst case the selector will throw again and then an error boundary will handle it.\r\n        latestSetSnapshot(\r\n          (() => {\r\n            throw error;\r\n          }: any),\r\n        );\r\n      }\r\n    };\r\n\r\n    const unsubscribe = subscribe(source._source, handleChange);\r\n    if (__DEV__) {\r\n      if (typeof unsubscribe !== 'function') {\r\n        console.error(\r\n          'Mutable source subscribe function must return an unsubscribe function.',\r\n        );\r\n      }\r\n    }\r\n\r\n    return unsubscribe;\r\n  }, [source, subscribe]);\r\n\r\n  // If any of the inputs to useMutableSource change, reading is potentially unsafe.\r\n  //\r\n  // If either the source or the subscription have changed we can't can't trust the update queue.\r\n  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.\r\n  //\r\n  // If the getSnapshot function changed, we also shouldn't rely on the update queue.\r\n  // It's possible that the underlying source was mutated between the when the last \"change\" event fired,\r\n  // and when the current render (with the new getSnapshot function) is processed.\r\n  //\r\n  // In both cases, we need to throw away pending updates (since they are no longer relevant)\r\n  // and treat reading from the source as we do in the mount case.\r\n  if (\r\n    !is(prevGetSnapshot, getSnapshot) ||\r\n    !is(prevSource, source) ||\r\n    !is(prevSubscribe, subscribe)\r\n  ) {\r\n    // Create a new queue and setState method,\r\n    // So if there are interleaved updates, they get pushed to the older queue.\r\n    // When this becomes current, the previous queue and dispatch method will be discarded,\r\n    // including any interleaving updates that occur.\r\n    const newQueue: UpdateQueue<Snapshot, BasicStateAction<Snapshot>> = {\r\n      pending: null,\r\n      interleaved: null,\r\n      lanes: NoLanes,\r\n      dispatch: null,\r\n      lastRenderedReducer: basicStateReducer,\r\n      lastRenderedState: snapshot,\r\n    };\r\n    newQueue.dispatch = setSnapshot = (dispatchSetState.bind(\r\n      null,\r\n      currentlyRenderingFiber,\r\n      newQueue,\r\n    ): any);\r\n    stateHook.queue = newQueue;\r\n    stateHook.baseQueue = null;\r\n    snapshot = readFromUnsubscribedMutableSource(root, source, getSnapshot);\r\n    stateHook.memoizedState = stateHook.baseState = snapshot;\r\n  }\r\n\r\n  return snapshot;\r\n}\r\n\r\nfunction mountMutableSource<Source, Snapshot>(\r\n  source: MutableSource<Source>,\r\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n): Snapshot {\r\n  if (!enableUseMutableSource) {\r\n    return (undefined: any);\r\n  }\r\n\r\n  const hook = mountWorkInProgressHook();\r\n  hook.memoizedState = ({\r\n    refs: {\r\n      getSnapshot,\r\n      setSnapshot: (null: any),\r\n    },\r\n    source,\r\n    subscribe,\r\n  }: MutableSourceMemoizedState<Source, Snapshot>);\r\n  return useMutableSource(hook, source, getSnapshot, subscribe);\r\n}\r\n\r\nfunction updateMutableSource<Source, Snapshot>(\r\n  source: MutableSource<Source>,\r\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n): Snapshot {\r\n  if (!enableUseMutableSource) {\r\n    return (undefined: any);\r\n  }\r\n\r\n  const hook = updateWorkInProgressHook();\r\n  return useMutableSource(hook, source, getSnapshot, subscribe);\r\n}\r\n\r\nfunction mountSyncExternalStore<T>(\r\n  subscribe: (() => void) => () => void,\r\n  getSnapshot: () => T,\r\n  getServerSnapshot?: () => T,\r\n): T {\r\n  const fiber = currentlyRenderingFiber;\r\n  const hook = mountWorkInProgressHook();\r\n\r\n  let nextSnapshot;\r\n  const isHydrating = getIsHydrating();\r\n  if (isHydrating) {\r\n    if (getServerSnapshot === undefined) {\r\n      throw new Error(\r\n        'Missing getServerSnapshot, which is required for ' +\r\n          'server-rendered content. Will revert to client rendering.',\r\n      );\r\n    }\r\n    nextSnapshot = getServerSnapshot();\r\n    if (__DEV__) {\r\n      if (!didWarnUncachedGetSnapshot) {\r\n        if (nextSnapshot !== getServerSnapshot()) {\r\n          console.error(\r\n            'The result of getServerSnapshot should be cached to avoid an infinite loop',\r\n          );\r\n          didWarnUncachedGetSnapshot = true;\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    nextSnapshot = getSnapshot();\r\n    if (__DEV__) {\r\n      if (!didWarnUncachedGetSnapshot) {\r\n        const cachedSnapshot = getSnapshot();\r\n        if (!is(nextSnapshot, cachedSnapshot)) {\r\n          console.error(\r\n            'The result of getSnapshot should be cached to avoid an infinite loop',\r\n          );\r\n          didWarnUncachedGetSnapshot = true;\r\n        }\r\n      }\r\n    }\r\n    // Unless we're rendering a blocking lane, schedule a consistency check.\r\n    // Right before committing, we will walk the tree and check if any of the\r\n    // stores were mutated.\r\n    //\r\n    // We won't do this if we're hydrating server-rendered content, because if\r\n    // the content is stale, it's already visible anyway. Instead we'll patch\r\n    // it up in a passive effect.\r\n    const root: FiberRoot | null = getWorkInProgressRoot();\r\n\r\n    if (root === null) {\r\n      throw new Error(\r\n        'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n\r\n    if (!includesBlockingLane(root, renderLanes)) {\r\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\r\n    }\r\n  }\r\n\r\n  // Read the current snapshot from the store on every render. This breaks the\r\n  // normal rules of React, and only works because store updates are\r\n  // always synchronous.\r\n  hook.memoizedState = nextSnapshot;\r\n  const inst: StoreInstance<T> = {\r\n    value: nextSnapshot,\r\n    getSnapshot,\r\n  };\r\n  hook.queue = inst;\r\n\r\n  // Schedule an effect to subscribe to the store.\r\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\r\n\r\n  // Schedule an effect to update the mutable instance fields. We will update\r\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\r\n  // clean-up function, and we track the deps correctly, we can call pushEffect\r\n  // directly, without storing any additional state. For the same reason, we\r\n  // don't need to set a static flag, either.\r\n  // TODO: We can move this to the passive phase once we add a pre-commit\r\n  // consistency check. See the next comment.\r\n  fiber.flags |= PassiveEffect;\r\n  pushEffect(\r\n    HookHasEffect | HookPassive,\r\n    updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\r\n    undefined,\r\n    null,\r\n  );\r\n\r\n  return nextSnapshot;\r\n}\r\n\r\nfunction updateSyncExternalStore<T>(\r\n  subscribe: (() => void) => () => void,\r\n  getSnapshot: () => T,\r\n  getServerSnapshot?: () => T,\r\n): T {\r\n  const fiber = currentlyRenderingFiber;\r\n  const hook = updateWorkInProgressHook();\r\n  // Read the current snapshot from the store on every render. This breaks the\r\n  // normal rules of React, and only works because store updates are\r\n  // always synchronous.\r\n  const nextSnapshot = getSnapshot();\r\n  if (__DEV__) {\r\n    if (!didWarnUncachedGetSnapshot) {\r\n      const cachedSnapshot = getSnapshot();\r\n      if (!is(nextSnapshot, cachedSnapshot)) {\r\n        console.error(\r\n          'The result of getSnapshot should be cached to avoid an infinite loop',\r\n        );\r\n        didWarnUncachedGetSnapshot = true;\r\n      }\r\n    }\r\n  }\r\n  const prevSnapshot = hook.memoizedState;\r\n  const snapshotChanged = !is(prevSnapshot, nextSnapshot);\r\n  if (snapshotChanged) {\r\n    hook.memoizedState = nextSnapshot;\r\n    markWorkInProgressReceivedUpdate();\r\n  }\r\n  const inst = hook.queue;\r\n\r\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\r\n    subscribe,\r\n  ]);\r\n\r\n  // Whenever getSnapshot or subscribe changes, we need to check in the\r\n  // commit phase if there was an interleaved mutation. In concurrent mode\r\n  // this can happen all the time, but even in synchronous mode, an earlier\r\n  // effect may have mutated the store.\r\n  if (\r\n    inst.getSnapshot !== getSnapshot ||\r\n    snapshotChanged ||\r\n    // Check if the susbcribe function changed. We can save some memory by\r\n    // checking whether we scheduled a subscription effect above.\r\n    (workInProgressHook !== null &&\r\n      workInProgressHook.memoizedState.tag & HookHasEffect)\r\n  ) {\r\n    fiber.flags |= PassiveEffect;\r\n    pushEffect(\r\n      HookHasEffect | HookPassive,\r\n      updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\r\n      undefined,\r\n      null,\r\n    );\r\n\r\n    // Unless we're rendering a blocking lane, schedule a consistency check.\r\n    // Right before committing, we will walk the tree and check if any of the\r\n    // stores were mutated.\r\n    const root: FiberRoot | null = getWorkInProgressRoot();\r\n\r\n    if (root === null) {\r\n      throw new Error(\r\n        'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n\r\n    if (!includesBlockingLane(root, renderLanes)) {\r\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\r\n    }\r\n  }\r\n\r\n  return nextSnapshot;\r\n}\r\n\r\nfunction pushStoreConsistencyCheck<T>(\r\n  fiber: Fiber,\r\n  getSnapshot: () => T,\r\n  renderedSnapshot: T,\r\n) {\r\n  fiber.flags |= StoreConsistency;\r\n  const check: StoreConsistencyCheck<T> = {\r\n    getSnapshot,\r\n    value: renderedSnapshot,\r\n  };\r\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\r\n  if (componentUpdateQueue === null) {\r\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\r\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\r\n    componentUpdateQueue.stores = [check];\r\n  } else {\r\n    const stores = componentUpdateQueue.stores;\r\n    if (stores === null) {\r\n      componentUpdateQueue.stores = [check];\r\n    } else {\r\n      stores.push(check);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateStoreInstance<T>(\r\n  fiber: Fiber,\r\n  inst: StoreInstance<T>,\r\n  nextSnapshot: T,\r\n  getSnapshot: () => T,\r\n) {\r\n  // These are updated in the passive phase\r\n  inst.value = nextSnapshot;\r\n  inst.getSnapshot = getSnapshot;\r\n\r\n  // Something may have been mutated in between render and commit. This could\r\n  // have been in an event that fired before the passive effects, or it could\r\n  // have been in a layout effect. In that case, we would have used the old\r\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\r\n  if (checkIfSnapshotChanged(inst)) {\r\n    // Force a re-render.\r\n    forceStoreRerender(fiber);\r\n  }\r\n}\r\n\r\nfunction subscribeToStore(fiber, inst, subscribe) {\r\n  const handleStoreChange = () => {\r\n    // The store changed. Check if the snapshot changed since the last time we\r\n    // read from the store.\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceStoreRerender(fiber);\r\n    }\r\n  };\r\n  // Subscribe to the store and return a clean-up function.\r\n  return subscribe(handleStoreChange);\r\n}\r\n\r\nfunction checkIfSnapshotChanged(inst) {\r\n  const latestGetSnapshot = inst.getSnapshot;\r\n  const prevValue = inst.value;\r\n  try {\r\n    const nextValue = latestGetSnapshot();\r\n    return !is(prevValue, nextValue);\r\n  } catch (error) {\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction forceStoreRerender(fiber) {\r\n  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n}\r\n\r\nfunction mountState<S>(\r\n  initialState: (() => S) | S,\r\n): [S, Dispatch<BasicStateAction<S>>] {\r\n  const hook = mountWorkInProgressHook();\r\n  if (typeof initialState === 'function') {\r\n    // $FlowFixMe: Flow doesn't like mixed types\r\n    initialState = initialState();\r\n  }\r\n  hook.memoizedState = hook.baseState = initialState;\r\n  const queue: UpdateQueue<S, BasicStateAction<S>> = {\r\n    pending: null,\r\n    interleaved: null,\r\n    lanes: NoLanes,\r\n    dispatch: null,\r\n    lastRenderedReducer: basicStateReducer,\r\n    lastRenderedState: (initialState: any),\r\n  };\r\n  hook.queue = queue;\r\n  const dispatch: Dispatch<\r\n    BasicStateAction<S>,\r\n  > = (queue.dispatch = (dispatchSetState.bind(\r\n    null,\r\n    currentlyRenderingFiber,\r\n    queue,\r\n  ): any));\r\n  return [hook.memoizedState, dispatch];\r\n}\r\n\r\nfunction updateState<S>(\r\n  initialState: (() => S) | S,\r\n): [S, Dispatch<BasicStateAction<S>>] {\r\n  return updateReducer(basicStateReducer, (initialState: any));\r\n}\r\n\r\nfunction rerenderState<S>(\r\n  initialState: (() => S) | S,\r\n): [S, Dispatch<BasicStateAction<S>>] {\r\n  return rerenderReducer(basicStateReducer, (initialState: any));\r\n}\r\n\r\nfunction pushEffect(tag, create, destroy, deps) {\r\n  const effect: Effect = {\r\n    tag,\r\n    create,\r\n    destroy,\r\n    deps,\r\n    // Circular\r\n    next: (null: any),\r\n  };\r\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\r\n  if (componentUpdateQueue === null) {\r\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\r\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\r\n    componentUpdateQueue.lastEffect = effect.next = effect;\r\n  } else {\r\n    const lastEffect = componentUpdateQueue.lastEffect;\r\n    if (lastEffect === null) {\r\n      componentUpdateQueue.lastEffect = effect.next = effect;\r\n    } else {\r\n      const firstEffect = lastEffect.next;\r\n      lastEffect.next = effect;\r\n      effect.next = firstEffect;\r\n      componentUpdateQueue.lastEffect = effect;\r\n    }\r\n  }\r\n  return effect;\r\n}\r\n\r\nlet stackContainsErrorMessage: boolean | null = null;\r\n\r\nfunction getCallerStackFrame(): string {\r\n  // eslint-disable-next-line react-internal/prod-error-codes\r\n  const stackFrames = new Error('Error message').stack.split('\\n');\r\n\r\n  // Some browsers (e.g. Chrome) include the error message in the stack\r\n  // but others (e.g. Firefox) do not.\r\n  if (stackContainsErrorMessage === null) {\r\n    stackContainsErrorMessage = stackFrames[0].includes('Error message');\r\n  }\r\n\r\n  return stackContainsErrorMessage\r\n    ? stackFrames.slice(3, 4).join('\\n')\r\n    : stackFrames.slice(2, 3).join('\\n');\r\n}\r\n\r\nfunction mountRef<T>(initialValue: T): {|current: T|} {\r\n  const hook = mountWorkInProgressHook();\r\n  if (enableUseRefAccessWarning) {\r\n    if (__DEV__) {\r\n      // Support lazy initialization pattern shown in docs.\r\n      // We need to store the caller stack frame so that we don't warn on subsequent renders.\r\n      let hasBeenInitialized = initialValue != null;\r\n      let lazyInitGetterStack = null;\r\n      let didCheckForLazyInit = false;\r\n\r\n      // Only warn once per component+hook.\r\n      let didWarnAboutRead = false;\r\n      let didWarnAboutWrite = false;\r\n\r\n      let current = initialValue;\r\n      const ref = {\r\n        get current() {\r\n          if (!hasBeenInitialized) {\r\n            didCheckForLazyInit = true;\r\n            lazyInitGetterStack = getCallerStackFrame();\r\n          } else if (currentlyRenderingFiber !== null && !didWarnAboutRead) {\r\n            if (\r\n              lazyInitGetterStack === null ||\r\n              lazyInitGetterStack !== getCallerStackFrame()\r\n            ) {\r\n              didWarnAboutRead = true;\r\n              console.warn(\r\n                '%s: Unsafe read of a mutable value during render.\\n\\n' +\r\n                  'Reading from a ref during render is only safe if:\\n' +\r\n                  '1. The ref value has not been updated, or\\n' +\r\n                  '2. The ref holds a lazily-initialized value that is only set once.\\n',\r\n                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',\r\n              );\r\n            }\r\n          }\r\n          return current;\r\n        },\r\n        set current(value) {\r\n          if (currentlyRenderingFiber !== null && !didWarnAboutWrite) {\r\n            if (hasBeenInitialized || !didCheckForLazyInit) {\r\n              didWarnAboutWrite = true;\r\n              console.warn(\r\n                '%s: Unsafe write of a mutable value during render.\\n\\n' +\r\n                  'Writing to a ref during render is only safe if the ref holds ' +\r\n                  'a lazily-initialized value that is only set once.\\n',\r\n                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',\r\n              );\r\n            }\r\n          }\r\n\r\n          hasBeenInitialized = true;\r\n          current = value;\r\n        },\r\n      };\r\n      Object.seal(ref);\r\n      hook.memoizedState = ref;\r\n      return ref;\r\n    } else {\r\n      const ref = {current: initialValue};\r\n      hook.memoizedState = ref;\r\n      return ref;\r\n    }\r\n  } else {\r\n    const ref = {current: initialValue};\r\n    hook.memoizedState = ref;\r\n    return ref;\r\n  }\r\n}\r\n\r\nfunction updateRef<T>(initialValue: T): {|current: T|} {\r\n  const hook = updateWorkInProgressHook();\r\n  return hook.memoizedState;\r\n}\r\n\r\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps): void {\r\n  const hook = mountWorkInProgressHook();\r\n  const nextDeps = deps === undefined ? null : deps;\r\n  currentlyRenderingFiber.flags |= fiberFlags;\r\n  hook.memoizedState = pushEffect(\r\n    HookHasEffect | hookFlags,\r\n    create,\r\n    undefined,\r\n    nextDeps,\r\n  );\r\n}\r\n\r\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps): void {\r\n  const hook = updateWorkInProgressHook();\r\n  const nextDeps = deps === undefined ? null : deps;\r\n  let destroy = undefined;\r\n\r\n  if (currentHook !== null) {\r\n    const prevEffect = currentHook.memoizedState;\r\n    destroy = prevEffect.destroy;\r\n    if (nextDeps !== null) {\r\n      const prevDeps = prevEffect.deps;\r\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\r\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  currentlyRenderingFiber.flags |= fiberFlags;\r\n\r\n  hook.memoizedState = pushEffect(\r\n    HookHasEffect | hookFlags,\r\n    create,\r\n    destroy,\r\n    nextDeps,\r\n  );\r\n}\r\n\r\nfunction mountEffect(\r\n  create: () => (() => void) | void,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  if (\r\n    __DEV__ &&\r\n    enableStrictEffects &&\r\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\r\n  ) {\r\n    return mountEffectImpl(\r\n      MountPassiveDevEffect | PassiveEffect | PassiveStaticEffect,\r\n      HookPassive,\r\n      create,\r\n      deps,\r\n    );\r\n  } else {\r\n    return mountEffectImpl(\r\n      PassiveEffect | PassiveStaticEffect,\r\n      HookPassive,\r\n      create,\r\n      deps,\r\n    );\r\n  }\r\n}\r\n\r\nfunction updateEffect(\r\n  create: () => (() => void) | void,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);\r\n}\r\n\r\nfunction mountInsertionEffect(\r\n  create: () => (() => void) | void,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  return mountEffectImpl(UpdateEffect, HookInsertion, create, deps);\r\n}\r\n\r\nfunction updateInsertionEffect(\r\n  create: () => (() => void) | void,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  return updateEffectImpl(UpdateEffect, HookInsertion, create, deps);\r\n}\r\n\r\nfunction mountLayoutEffect(\r\n  create: () => (() => void) | void,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  let fiberFlags: Flags = UpdateEffect;\r\n  if (enableSuspenseLayoutEffectSemantics) {\r\n    fiberFlags |= LayoutStaticEffect;\r\n  }\r\n  if (\r\n    __DEV__ &&\r\n    enableStrictEffects &&\r\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\r\n  ) {\r\n    fiberFlags |= MountLayoutDevEffect;\r\n  }\r\n  return mountEffectImpl(fiberFlags, HookLayout, create, deps);\r\n}\r\n\r\nfunction updateLayoutEffect(\r\n  create: () => (() => void) | void,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\r\n}\r\n\r\nfunction imperativeHandleEffect<T>(\r\n  create: () => T,\r\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n) {\r\n  if (typeof ref === 'function') {\r\n    const refCallback = ref;\r\n    const inst = create();\r\n    refCallback(inst);\r\n    return () => {\r\n      refCallback(null);\r\n    };\r\n  } else if (ref !== null && ref !== undefined) {\r\n    const refObject = ref;\r\n    if (__DEV__) {\r\n      if (!refObject.hasOwnProperty('current')) {\r\n        console.error(\r\n          'Expected useImperativeHandle() first argument to either be a ' +\r\n            'ref callback or React.createRef() object. Instead received: %s.',\r\n          'an object with keys {' + Object.keys(refObject).join(', ') + '}',\r\n        );\r\n      }\r\n    }\r\n    const inst = create();\r\n    refObject.current = inst;\r\n    return () => {\r\n      refObject.current = null;\r\n    };\r\n  }\r\n}\r\n\r\nfunction mountImperativeHandle<T>(\r\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n  create: () => T,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  if (__DEV__) {\r\n    if (typeof create !== 'function') {\r\n      console.error(\r\n        'Expected useImperativeHandle() second argument to be a function ' +\r\n          'that creates a handle. Instead received: %s.',\r\n        create !== null ? typeof create : 'null',\r\n      );\r\n    }\r\n  }\r\n\r\n  // TODO: If deps are provided, should we skip comparing the ref itself?\r\n  const effectDeps =\r\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\r\n\r\n  let fiberFlags: Flags = UpdateEffect;\r\n  if (enableSuspenseLayoutEffectSemantics) {\r\n    fiberFlags |= LayoutStaticEffect;\r\n  }\r\n  if (\r\n    __DEV__ &&\r\n    enableStrictEffects &&\r\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\r\n  ) {\r\n    fiberFlags |= MountLayoutDevEffect;\r\n  }\r\n  return mountEffectImpl(\r\n    fiberFlags,\r\n    HookLayout,\r\n    imperativeHandleEffect.bind(null, create, ref),\r\n    effectDeps,\r\n  );\r\n}\r\n\r\nfunction updateImperativeHandle<T>(\r\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n  create: () => T,\r\n  deps: Array<mixed> | void | null,\r\n): void {\r\n  if (__DEV__) {\r\n    if (typeof create !== 'function') {\r\n      console.error(\r\n        'Expected useImperativeHandle() second argument to be a function ' +\r\n          'that creates a handle. Instead received: %s.',\r\n        create !== null ? typeof create : 'null',\r\n      );\r\n    }\r\n  }\r\n\r\n  // TODO: If deps are provided, should we skip comparing the ref itself?\r\n  const effectDeps =\r\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\r\n\r\n  return updateEffectImpl(\r\n    UpdateEffect,\r\n    HookLayout,\r\n    imperativeHandleEffect.bind(null, create, ref),\r\n    effectDeps,\r\n  );\r\n}\r\n\r\nfunction mountDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n  // This hook is normally a no-op.\r\n  // The react-debug-hooks package injects its own implementation\r\n  // so that e.g. DevTools can display custom hook values.\r\n}\r\n\r\nconst updateDebugValue = mountDebugValue;\r\n\r\nfunction mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n  const hook = mountWorkInProgressHook();\r\n  const nextDeps = deps === undefined ? null : deps;\r\n  hook.memoizedState = [callback, nextDeps];\r\n  return callback;\r\n}\r\n\r\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n  const hook = updateWorkInProgressHook();\r\n  const nextDeps = deps === undefined ? null : deps;\r\n  const prevState = hook.memoizedState;\r\n  if (prevState !== null) {\r\n    if (nextDeps !== null) {\r\n      const prevDeps: Array<mixed> | null = prevState[1];\r\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\r\n        return prevState[0];\r\n      }\r\n    }\r\n  }\r\n  hook.memoizedState = [callback, nextDeps];\r\n  return callback;\r\n}\r\n\r\nfunction mountMemo<T>(\r\n  nextCreate: () => T,\r\n  deps: Array<mixed> | void | null,\r\n): T {\r\n  const hook = mountWorkInProgressHook();\r\n  const nextDeps = deps === undefined ? null : deps;\r\n  const nextValue = nextCreate();\r\n  hook.memoizedState = [nextValue, nextDeps];\r\n  return nextValue;\r\n}\r\n\r\nfunction updateMemo<T>(\r\n  nextCreate: () => T,\r\n  deps: Array<mixed> | void | null,\r\n): T {\r\n  const hook = updateWorkInProgressHook();\r\n  const nextDeps = deps === undefined ? null : deps;\r\n  const prevState = hook.memoizedState;\r\n  if (prevState !== null) {\r\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\r\n    if (nextDeps !== null) {\r\n      const prevDeps: Array<mixed> | null = prevState[1];\r\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\r\n        return prevState[0];\r\n      }\r\n    }\r\n  }\r\n  const nextValue = nextCreate();\r\n  hook.memoizedState = [nextValue, nextDeps];\r\n  return nextValue;\r\n}\r\n\r\nfunction mountDeferredValue<T>(value: T): T {\r\n  const hook = mountWorkInProgressHook();\r\n  hook.memoizedState = value;\r\n  return value;\r\n}\r\n\r\nfunction updateDeferredValue<T>(value: T): T {\r\n  const hook = updateWorkInProgressHook();\r\n  const resolvedCurrentHook: Hook = (currentHook: any);\r\n  const prevValue: T = resolvedCurrentHook.memoizedState;\r\n  return updateDeferredValueImpl(hook, prevValue, value);\r\n}\r\n\r\nfunction rerenderDeferredValue<T>(value: T): T {\r\n  const hook = updateWorkInProgressHook();\r\n  if (currentHook === null) {\r\n    // This is a rerender during a mount.\r\n    hook.memoizedState = value;\r\n    return value;\r\n  } else {\r\n    // This is a rerender during an update.\r\n    const prevValue: T = currentHook.memoizedState;\r\n    return updateDeferredValueImpl(hook, prevValue, value);\r\n  }\r\n}\r\n\r\nfunction updateDeferredValueImpl<T>(hook: Hook, prevValue: T, value: T): T {\r\n  const shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\r\n  if (shouldDeferValue) {\r\n    // This is an urgent update. If the value has changed, keep using the\r\n    // previous value and spawn a deferred render to update it later.\r\n\r\n    if (!is(value, prevValue)) {\r\n      // Schedule a deferred render\r\n      const deferredLane = claimNextTransitionLane();\r\n      currentlyRenderingFiber.lanes = mergeLanes(\r\n        currentlyRenderingFiber.lanes,\r\n        deferredLane,\r\n      );\r\n      markSkippedUpdateLanes(deferredLane);\r\n\r\n      // Set this to true to indicate that the rendered value is inconsistent\r\n      // from the latest value. The name \"baseState\" doesn't really match how we\r\n      // use it because we're reusing a state hook field instead of creating a\r\n      // new one.\r\n      hook.baseState = true;\r\n    }\r\n\r\n    // Reuse the previous value\r\n    return prevValue;\r\n  } else {\r\n    // This is not an urgent update, so we can use the latest value regardless\r\n    // of what it is. No need to defer it.\r\n\r\n    // However, if we're currently inside a spawned render, then we need to mark\r\n    // this as an update to prevent the fiber from bailing out.\r\n    //\r\n    // `baseState` is true when the current value is different from the rendered\r\n    // value. The name doesn't really match how we use it because we're reusing\r\n    // a state hook field instead of creating a new one.\r\n    if (hook.baseState) {\r\n      // Flip this back to false.\r\n      hook.baseState = false;\r\n      markWorkInProgressReceivedUpdate();\r\n    }\r\n\r\n    hook.memoizedState = value;\r\n    return value;\r\n  }\r\n}\r\n\r\nfunction startTransition(setPending, callback, options) {\r\n  const previousPriority = getCurrentUpdatePriority();\r\n  setCurrentUpdatePriority(\r\n    higherEventPriority(previousPriority, ContinuousEventPriority),\r\n  );\r\n\r\n  setPending(true);\r\n\r\n  const prevTransition = ReactCurrentBatchConfig.transition;\r\n  ReactCurrentBatchConfig.transition = {};\r\n  const currentTransition = ReactCurrentBatchConfig.transition;\r\n\r\n  if (enableTransitionTracing) {\r\n    if (options !== undefined && options.name !== undefined) {\r\n      ReactCurrentBatchConfig.transition.name = options.name;\r\n      ReactCurrentBatchConfig.transition.startTime = now();\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\r\n  }\r\n\r\n  try {\r\n    setPending(false);\r\n    callback();\r\n  } finally {\r\n    setCurrentUpdatePriority(previousPriority);\r\n\r\n    ReactCurrentBatchConfig.transition = prevTransition;\r\n\r\n    if (__DEV__) {\r\n      if (prevTransition === null && currentTransition._updatedFibers) {\r\n        const updatedFibersCount = currentTransition._updatedFibers.size;\r\n        if (updatedFibersCount > 10) {\r\n          console.warn(\r\n            'Detected a large number of updates inside startTransition. ' +\r\n              'If this is due to a subscription please re-write it to use React provided hooks. ' +\r\n              'Otherwise concurrent mode guarantees are off the table.',\r\n          );\r\n        }\r\n        currentTransition._updatedFibers.clear();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction mountTransition(): [\r\n  boolean,\r\n  (callback: () => void, options?: StartTransitionOptions) => void,\r\n] {\r\n  const [isPending, setPending] = mountState(false);\r\n  // The `start` method never changes.\r\n  const start = startTransition.bind(null, setPending);\r\n  const hook = mountWorkInProgressHook();\r\n  hook.memoizedState = start;\r\n  return [isPending, start];\r\n}\r\n\r\nfunction updateTransition(): [\r\n  boolean,\r\n  (callback: () => void, options?: StartTransitionOptions) => void,\r\n] {\r\n  const [isPending] = updateState(false);\r\n  const hook = updateWorkInProgressHook();\r\n  const start = hook.memoizedState;\r\n  return [isPending, start];\r\n}\r\n\r\nfunction rerenderTransition(): [\r\n  boolean,\r\n  (callback: () => void, options?: StartTransitionOptions) => void,\r\n] {\r\n  const [isPending] = rerenderState(false);\r\n  const hook = updateWorkInProgressHook();\r\n  const start = hook.memoizedState;\r\n  return [isPending, start];\r\n}\r\n\r\nlet isUpdatingOpaqueValueInRenderPhase = false;\r\nexport function getIsUpdatingOpaqueValueInRenderPhaseInDEV(): boolean | void {\r\n  if (__DEV__) {\r\n    return isUpdatingOpaqueValueInRenderPhase;\r\n  }\r\n}\r\n\r\nfunction mountId(): string {\r\n  const hook = mountWorkInProgressHook();\r\n\r\n  const root = ((getWorkInProgressRoot(): any): FiberRoot);\r\n  // TODO: In Fizz, id generation is specific to each server config. Maybe we\r\n  // should do this in Fiber, too? Deferring this decision for now because\r\n  // there's no other place to store the prefix except for an internal field on\r\n  // the public createRoot object, which the fiber tree does not currently have\r\n  // a reference to.\r\n  const identifierPrefix = root.identifierPrefix;\r\n\r\n  let id;\r\n  if (getIsHydrating()) {\r\n    const treeId = getTreeId();\r\n\r\n    // Use a captial R prefix for server-generated ids.\r\n    id = ':' + identifierPrefix + 'R' + treeId;\r\n\r\n    // Unless this is the first id at this level, append a number at the end\r\n    // that represents the position of this useId hook among all the useId\r\n    // hooks for this fiber.\r\n    const localId = localIdCounter++;\r\n    if (localId > 0) {\r\n      id += 'H' + localId.toString(32);\r\n    }\r\n\r\n    id += ':';\r\n  } else {\r\n    // Use a lowercase r prefix for client-generated ids.\r\n    const globalClientId = globalClientIdCounter++;\r\n    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\r\n  }\r\n\r\n  hook.memoizedState = id;\r\n  return id;\r\n}\r\n\r\nfunction updateId(): string {\r\n  const hook = updateWorkInProgressHook();\r\n  const id: string = hook.memoizedState;\r\n  return id;\r\n}\r\n\r\nfunction mountRefresh() {\r\n  const hook = mountWorkInProgressHook();\r\n  const refresh = (hook.memoizedState = refreshCache.bind(\r\n    null,\r\n    currentlyRenderingFiber,\r\n  ));\r\n  return refresh;\r\n}\r\n\r\nfunction updateRefresh() {\r\n  const hook = updateWorkInProgressHook();\r\n  return hook.memoizedState;\r\n}\r\n\r\nfunction refreshCache<T>(fiber: Fiber, seedKey: ?() => T, seedValue: T) {\r\n  if (!enableCache) {\r\n    return;\r\n  }\r\n  // TODO: Does Cache work in legacy mode? Should decide and write a test.\r\n  // TODO: Consider warning if the refresh is at discrete priority, or if we\r\n  // otherwise suspect that it wasn't batched properly.\r\n  let provider = fiber.return;\r\n  while (provider !== null) {\r\n    switch (provider.tag) {\r\n      case CacheComponent:\r\n      case HostRoot: {\r\n        const lane = requestUpdateLane(provider);\r\n        const eventTime = requestEventTime();\r\n        const root = scheduleUpdateOnFiber(provider, lane, eventTime);\r\n        if (root !== null) {\r\n          entangleLegacyQueueTransitions(root, provider, lane);\r\n        }\r\n\r\n        // TODO: If a refresh never commits, the new cache created here must be\r\n        // released. A simple case is start refreshing a cache boundary, but then\r\n        // unmount that boundary before the refresh completes.\r\n        const seededCache = createCache();\r\n        if (seedKey !== null && seedKey !== undefined && root !== null) {\r\n          // Seed the cache with the value passed by the caller. This could be\r\n          // from a server mutation, or it could be a streaming response.\r\n          seededCache.data.set(seedKey, seedValue);\r\n        }\r\n\r\n        // Schedule an update on the cache boundary to trigger a refresh.\r\n        const refreshUpdate = createLegacyQueueUpdate(eventTime, lane);\r\n        const payload = {\r\n          cache: seededCache,\r\n        };\r\n        refreshUpdate.payload = payload;\r\n        enqueueLegacyQueueUpdate(provider, refreshUpdate, lane);\r\n        return;\r\n      }\r\n    }\r\n    provider = provider.return;\r\n  }\r\n  // TODO: Warn if unmounted?\r\n}\r\n\r\nfunction dispatchReducerAction<S, A>(\r\n  fiber: Fiber,\r\n  queue: UpdateQueue<S, A>,\r\n  action: A,\r\n) {\r\n  if (__DEV__) {\r\n    if (typeof arguments[3] === 'function') {\r\n      console.error(\r\n        \"State updates from the useState() and useReducer() Hooks don't support the \" +\r\n          'second callback argument. To execute a side effect after ' +\r\n          'rendering, declare it in the component body with useEffect().',\r\n      );\r\n    }\r\n  }\r\n\r\n  const lane = requestUpdateLane(fiber);\r\n\r\n  const update: Update<S, A> = {\r\n    lane,\r\n    action,\r\n    hasEagerState: false,\r\n    eagerState: null,\r\n    next: (null: any),\r\n  };\r\n\r\n  if (isRenderPhaseUpdate(fiber)) {\r\n    enqueueRenderPhaseUpdate(queue, update);\r\n  } else {\r\n    enqueueUpdate(fiber, queue, update, lane);\r\n    const eventTime = requestEventTime();\r\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n    if (root !== null) {\r\n      entangleTransitionUpdate(root, queue, lane);\r\n    }\r\n  }\r\n\r\n  markUpdateInDevTools(fiber, lane, action);\r\n}\r\n\r\nfunction dispatchSetState<S, A>(\r\n  fiber: Fiber,\r\n  queue: UpdateQueue<S, A>,\r\n  action: A,\r\n) {\r\n  if (__DEV__) {\r\n    if (typeof arguments[3] === 'function') {\r\n      console.error(\r\n        \"State updates from the useState() and useReducer() Hooks don't support the \" +\r\n          'second callback argument. To execute a side effect after ' +\r\n          'rendering, declare it in the component body with useEffect().',\r\n      );\r\n    }\r\n  }\r\n\r\n  const lane = requestUpdateLane(fiber);\r\n\r\n  const update: Update<S, A> = {\r\n    lane,\r\n    action,\r\n    hasEagerState: false,\r\n    eagerState: null,\r\n    next: (null: any),\r\n  };\r\n\r\n  if (isRenderPhaseUpdate(fiber)) {\r\n    enqueueRenderPhaseUpdate(queue, update);\r\n  } else {\r\n    enqueueUpdate(fiber, queue, update, lane);\r\n\r\n    const alternate = fiber.alternate;\r\n    if (\r\n      fiber.lanes === NoLanes &&\r\n      (alternate === null || alternate.lanes === NoLanes)\r\n    ) {\r\n      // The queue is currently empty, which means we can eagerly compute the\r\n      // next state before entering the render phase. If the new state is the\r\n      // same as the current state, we may be able to bail out entirely.\r\n      const lastRenderedReducer = queue.lastRenderedReducer;\r\n      if (lastRenderedReducer !== null) {\r\n        let prevDispatcher;\r\n        if (__DEV__) {\r\n          prevDispatcher = ReactCurrentDispatcher.current;\r\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n        }\r\n        try {\r\n          const currentState: S = (queue.lastRenderedState: any);\r\n          const eagerState = lastRenderedReducer(currentState, action);\r\n          // Stash the eagerly computed state, and the reducer used to compute\r\n          // it, on the update object. If the reducer hasn't changed by the\r\n          // time we enter the render phase, then the eager state can be used\r\n          // without calling the reducer again.\r\n          update.hasEagerState = true;\r\n          update.eagerState = eagerState;\r\n          if (is(eagerState, currentState)) {\r\n            // Fast path. We can bail out without scheduling React to re-render.\r\n            // It's still possible that we'll need to rebase this update later,\r\n            // if the component re-renders for a different reason and by that\r\n            // time the reducer has changed.\r\n            return;\r\n          }\r\n        } catch (error) {\r\n          // Suppress the error. It will throw again in the render phase.\r\n        } finally {\r\n          if (__DEV__) {\r\n            ReactCurrentDispatcher.current = prevDispatcher;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    const eventTime = requestEventTime();\r\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n    if (root !== null) {\r\n      entangleTransitionUpdate(root, queue, lane);\r\n    }\r\n  }\r\n\r\n  markUpdateInDevTools(fiber, lane, action);\r\n}\r\n\r\nfunction isRenderPhaseUpdate(fiber: Fiber) {\r\n  const alternate = fiber.alternate;\r\n  return (\r\n    fiber === currentlyRenderingFiber ||\r\n    (alternate !== null && alternate === currentlyRenderingFiber)\r\n  );\r\n}\r\n\r\nfunction enqueueRenderPhaseUpdate<S, A>(\r\n  queue: UpdateQueue<S, A>,\r\n  update: Update<S, A>,\r\n) {\r\n  // This is a render phase update. Stash it in a lazily-created map of\r\n  // queue -> linked list of updates. After this render pass, we'll restart\r\n  // and apply the stashed updates on top of the work-in-progress hook.\r\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\r\n  const pending = queue.pending;\r\n  if (pending === null) {\r\n    // This is the first update. Create a circular list.\r\n    update.next = update;\r\n  } else {\r\n    update.next = pending.next;\r\n    pending.next = update;\r\n  }\r\n  queue.pending = update;\r\n}\r\n\r\nfunction enqueueUpdate<S, A>(\r\n  fiber: Fiber,\r\n  queue: UpdateQueue<S, A>,\r\n  update: Update<S, A>,\r\n  lane: Lane,\r\n) {\r\n  if (isInterleavedUpdate(fiber, lane)) {\r\n    const interleaved = queue.interleaved;\r\n    if (interleaved === null) {\r\n      // This is the first update. Create a circular list.\r\n      update.next = update;\r\n      // At the end of the current render, this queue's interleaved updates will\r\n      // be transferred to the pending queue.\r\n      pushInterleavedQueue(queue);\r\n    } else {\r\n      update.next = interleaved.next;\r\n      interleaved.next = update;\r\n    }\r\n    queue.interleaved = update;\r\n  } else {\r\n    const pending = queue.pending;\r\n    if (pending === null) {\r\n      // This is the first update. Create a circular list.\r\n      update.next = update;\r\n    } else {\r\n      update.next = pending.next;\r\n      pending.next = update;\r\n    }\r\n    queue.pending = update;\r\n  }\r\n}\r\n\r\nfunction entangleTransitionUpdate<S, A>(\r\n  root: FiberRoot,\r\n  queue: UpdateQueue<S, A>,\r\n  lane: Lane,\r\n) {\r\n  if (isTransitionLane(lane)) {\r\n    let queueLanes = queue.lanes;\r\n\r\n    // If any entangled lanes are no longer pending on the root, then they\r\n    // must have finished. We can remove them from the shared queue, which\r\n    // represents a superset of the actually pending lanes. In some cases we\r\n    // may entangle more than we need to, but that's OK. In fact it's worse if\r\n    // we *don't* entangle when we should.\r\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes);\r\n\r\n    // Entangle the new transition lane with the other transition lanes.\r\n    const newQueueLanes = mergeLanes(queueLanes, lane);\r\n    queue.lanes = newQueueLanes;\r\n    // Even if queue.lanes already include lane, we don't know for certain if\r\n    // the lane finished since the last time we entangled it. So we need to\r\n    // entangle it again, just to be sure.\r\n    markRootEntangled(root, newQueueLanes);\r\n  }\r\n}\r\n\r\nfunction markUpdateInDevTools(fiber, lane, action) {\r\n  if (__DEV__) {\r\n    if (enableDebugTracing) {\r\n      if (fiber.mode & DebugTracingMode) {\r\n        const name = getComponentNameFromFiber(fiber) || 'Unknown';\r\n        logStateUpdateScheduled(name, lane, action);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markStateUpdateScheduled(fiber, lane);\r\n  }\r\n}\r\n\r\nfunction getCacheSignal(): AbortSignal {\r\n  if (!enableCache) {\r\n    throw new Error('Not implemented.');\r\n  }\r\n  const cache: Cache = readContext(CacheContext);\r\n  return cache.controller.signal;\r\n}\r\n\r\nfunction getCacheForType<T>(resourceType: () => T): T {\r\n  if (!enableCache) {\r\n    throw new Error('Not implemented.');\r\n  }\r\n  const cache: Cache = readContext(CacheContext);\r\n  let cacheForType: T | void = (cache.data.get(resourceType): any);\r\n  if (cacheForType === undefined) {\r\n    cacheForType = resourceType();\r\n    cache.data.set(resourceType, cacheForType);\r\n  }\r\n  return cacheForType;\r\n}\r\n\r\nexport const ContextOnlyDispatcher: Dispatcher = {\r\n  readContext,\r\n\r\n  useCallback: throwInvalidHookError,\r\n  useContext: throwInvalidHookError,\r\n  useEffect: throwInvalidHookError,\r\n  useImperativeHandle: throwInvalidHookError,\r\n  useInsertionEffect: throwInvalidHookError,\r\n  useLayoutEffect: throwInvalidHookError,\r\n  useMemo: throwInvalidHookError,\r\n  useReducer: throwInvalidHookError,\r\n  useRef: throwInvalidHookError,\r\n  useState: throwInvalidHookError,\r\n  useDebugValue: throwInvalidHookError,\r\n  useDeferredValue: throwInvalidHookError,\r\n  useTransition: throwInvalidHookError,\r\n  useMutableSource: throwInvalidHookError,\r\n  useSyncExternalStore: throwInvalidHookError,\r\n  useId: throwInvalidHookError,\r\n\r\n  unstable_isNewReconciler: enableNewReconciler,\r\n};\r\nif (enableCache) {\r\n  (ContextOnlyDispatcher: Dispatcher).getCacheSignal = getCacheSignal;\r\n  (ContextOnlyDispatcher: Dispatcher).getCacheForType = getCacheForType;\r\n  (ContextOnlyDispatcher: Dispatcher).useCacheRefresh = throwInvalidHookError;\r\n}\r\n\r\nconst HooksDispatcherOnMount: Dispatcher = {\r\n  readContext,\r\n\r\n  useCallback: mountCallback,\r\n  useContext: readContext,\r\n  useEffect: mountEffect,\r\n  useImperativeHandle: mountImperativeHandle,\r\n  useLayoutEffect: mountLayoutEffect,\r\n  useInsertionEffect: mountInsertionEffect,\r\n  useMemo: mountMemo,\r\n  useReducer: mountReducer,\r\n  useRef: mountRef,\r\n  useState: mountState,\r\n  useDebugValue: mountDebugValue,\r\n  useDeferredValue: mountDeferredValue,\r\n  useTransition: mountTransition,\r\n  useMutableSource: mountMutableSource,\r\n  useSyncExternalStore: mountSyncExternalStore,\r\n  useId: mountId,\r\n\r\n  unstable_isNewReconciler: enableNewReconciler,\r\n};\r\nif (enableCache) {\r\n  (HooksDispatcherOnMount: Dispatcher).getCacheSignal = getCacheSignal;\r\n  (HooksDispatcherOnMount: Dispatcher).getCacheForType = getCacheForType;\r\n  (HooksDispatcherOnMount: Dispatcher).useCacheRefresh = mountRefresh;\r\n}\r\nconst HooksDispatcherOnUpdate: Dispatcher = {\r\n  readContext,\r\n\r\n  useCallback: updateCallback,\r\n  useContext: readContext,\r\n  useEffect: updateEffect,\r\n  useImperativeHandle: updateImperativeHandle,\r\n  useInsertionEffect: updateInsertionEffect,\r\n  useLayoutEffect: updateLayoutEffect,\r\n  useMemo: updateMemo,\r\n  useReducer: updateReducer,\r\n  useRef: updateRef,\r\n  useState: updateState,\r\n  useDebugValue: updateDebugValue,\r\n  useDeferredValue: updateDeferredValue,\r\n  useTransition: updateTransition,\r\n  useMutableSource: updateMutableSource,\r\n  useSyncExternalStore: updateSyncExternalStore,\r\n  useId: updateId,\r\n\r\n  unstable_isNewReconciler: enableNewReconciler,\r\n};\r\nif (enableCache) {\r\n  (HooksDispatcherOnUpdate: Dispatcher).getCacheSignal = getCacheSignal;\r\n  (HooksDispatcherOnUpdate: Dispatcher).getCacheForType = getCacheForType;\r\n  (HooksDispatcherOnUpdate: Dispatcher).useCacheRefresh = updateRefresh;\r\n}\r\n\r\nconst HooksDispatcherOnRerender: Dispatcher = {\r\n  readContext,\r\n\r\n  useCallback: updateCallback,\r\n  useContext: readContext,\r\n  useEffect: updateEffect,\r\n  useImperativeHandle: updateImperativeHandle,\r\n  useInsertionEffect: updateInsertionEffect,\r\n  useLayoutEffect: updateLayoutEffect,\r\n  useMemo: updateMemo,\r\n  useReducer: rerenderReducer,\r\n  useRef: updateRef,\r\n  useState: rerenderState,\r\n  useDebugValue: updateDebugValue,\r\n  useDeferredValue: rerenderDeferredValue,\r\n  useTransition: rerenderTransition,\r\n  useMutableSource: updateMutableSource,\r\n  useSyncExternalStore: updateSyncExternalStore,\r\n  useId: updateId,\r\n\r\n  unstable_isNewReconciler: enableNewReconciler,\r\n};\r\nif (enableCache) {\r\n  (HooksDispatcherOnRerender: Dispatcher).getCacheSignal = getCacheSignal;\r\n  (HooksDispatcherOnRerender: Dispatcher).getCacheForType = getCacheForType;\r\n  (HooksDispatcherOnRerender: Dispatcher).useCacheRefresh = updateRefresh;\r\n}\r\n\r\nlet HooksDispatcherOnMountInDEV: Dispatcher | null = null;\r\nlet HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | null = null;\r\nlet HooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\r\nlet HooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\r\nlet InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | null = null;\r\nlet InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\r\nlet InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\r\n\r\nif (__DEV__) {\r\n  const warnInvalidContextAccess = () => {\r\n    console.error(\r\n      'Context can only be read while React is rendering. ' +\r\n        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +\r\n        'In function components, you can read it directly in the function body, but not ' +\r\n        'inside Hooks like useReducer() or useMemo().',\r\n    );\r\n  };\r\n\r\n  const warnInvalidHookAccess = () => {\r\n    console.error(\r\n      'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' +\r\n        'You can only call Hooks at the top level of your React function. ' +\r\n        'For more information, see ' +\r\n        'https://reactjs.org/link/rules-of-hooks',\r\n    );\r\n  };\r\n\r\n  HooksDispatcherOnMountInDEV = {\r\n    readContext<T>(context: ReactContext<T>): T {\r\n      return readContext(context);\r\n    },\r\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useCallback';\r\n      mountHookTypesDev();\r\n      checkDepsAreArrayDev(deps);\r\n      return mountCallback(callback, deps);\r\n    },\r\n    useContext<T>(context: ReactContext<T>): T {\r\n      currentHookNameInDev = 'useContext';\r\n      mountHookTypesDev();\r\n      return readContext(context);\r\n    },\r\n    useEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useEffect';\r\n      mountHookTypesDev();\r\n      checkDepsAreArrayDev(deps);\r\n      return mountEffect(create, deps);\r\n    },\r\n    useImperativeHandle<T>(\r\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n      create: () => T,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useImperativeHandle';\r\n      mountHookTypesDev();\r\n      checkDepsAreArrayDev(deps);\r\n      return mountImperativeHandle(ref, create, deps);\r\n    },\r\n    useInsertionEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useInsertionEffect';\r\n      mountHookTypesDev();\r\n      checkDepsAreArrayDev(deps);\r\n      return mountInsertionEffect(create, deps);\r\n    },\r\n    useLayoutEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useLayoutEffect';\r\n      mountHookTypesDev();\r\n      checkDepsAreArrayDev(deps);\r\n      return mountLayoutEffect(create, deps);\r\n    },\r\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useMemo';\r\n      mountHookTypesDev();\r\n      checkDepsAreArrayDev(deps);\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountMemo(create, deps);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useReducer<S, I, A>(\r\n      reducer: (S, A) => S,\r\n      initialArg: I,\r\n      init?: I => S,\r\n    ): [S, Dispatch<A>] {\r\n      currentHookNameInDev = 'useReducer';\r\n      mountHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountReducer(reducer, initialArg, init);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useRef<T>(initialValue: T): {|current: T|} {\r\n      currentHookNameInDev = 'useRef';\r\n      mountHookTypesDev();\r\n      return mountRef(initialValue);\r\n    },\r\n    useState<S>(\r\n      initialState: (() => S) | S,\r\n    ): [S, Dispatch<BasicStateAction<S>>] {\r\n      currentHookNameInDev = 'useState';\r\n      mountHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountState(initialState);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n      currentHookNameInDev = 'useDebugValue';\r\n      mountHookTypesDev();\r\n      return mountDebugValue(value, formatterFn);\r\n    },\r\n    useDeferredValue<T>(value: T): T {\r\n      currentHookNameInDev = 'useDeferredValue';\r\n      mountHookTypesDev();\r\n      return mountDeferredValue(value);\r\n    },\r\n    useTransition(): [boolean, (() => void) => void] {\r\n      currentHookNameInDev = 'useTransition';\r\n      mountHookTypesDev();\r\n      return mountTransition();\r\n    },\r\n    useMutableSource<Source, Snapshot>(\r\n      source: MutableSource<Source>,\r\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n    ): Snapshot {\r\n      currentHookNameInDev = 'useMutableSource';\r\n      mountHookTypesDev();\r\n      return mountMutableSource(source, getSnapshot, subscribe);\r\n    },\r\n    useSyncExternalStore<T>(\r\n      subscribe: (() => void) => () => void,\r\n      getSnapshot: () => T,\r\n      getServerSnapshot?: () => T,\r\n    ): T {\r\n      currentHookNameInDev = 'useSyncExternalStore';\r\n      mountHookTypesDev();\r\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n    },\r\n    useId(): string {\r\n      currentHookNameInDev = 'useId';\r\n      mountHookTypesDev();\r\n      return mountId();\r\n    },\r\n\r\n    unstable_isNewReconciler: enableNewReconciler,\r\n  };\r\n  if (enableCache) {\r\n    (HooksDispatcherOnMountInDEV: Dispatcher).getCacheSignal = getCacheSignal;\r\n    (HooksDispatcherOnMountInDEV: Dispatcher).getCacheForType = getCacheForType;\r\n    (HooksDispatcherOnMountInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\r\n      currentHookNameInDev = 'useCacheRefresh';\r\n      mountHookTypesDev();\r\n      return mountRefresh();\r\n    };\r\n  }\r\n\r\n  HooksDispatcherOnMountWithHookTypesInDEV = {\r\n    readContext<T>(context: ReactContext<T>): T {\r\n      return readContext(context);\r\n    },\r\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useCallback';\r\n      updateHookTypesDev();\r\n      return mountCallback(callback, deps);\r\n    },\r\n    useContext<T>(context: ReactContext<T>): T {\r\n      currentHookNameInDev = 'useContext';\r\n      updateHookTypesDev();\r\n      return readContext(context);\r\n    },\r\n    useEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useEffect';\r\n      updateHookTypesDev();\r\n      return mountEffect(create, deps);\r\n    },\r\n    useImperativeHandle<T>(\r\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n      create: () => T,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useImperativeHandle';\r\n      updateHookTypesDev();\r\n      return mountImperativeHandle(ref, create, deps);\r\n    },\r\n    useInsertionEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useInsertionEffect';\r\n      updateHookTypesDev();\r\n      return mountInsertionEffect(create, deps);\r\n    },\r\n    useLayoutEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useLayoutEffect';\r\n      updateHookTypesDev();\r\n      return mountLayoutEffect(create, deps);\r\n    },\r\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useMemo';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountMemo(create, deps);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useReducer<S, I, A>(\r\n      reducer: (S, A) => S,\r\n      initialArg: I,\r\n      init?: I => S,\r\n    ): [S, Dispatch<A>] {\r\n      currentHookNameInDev = 'useReducer';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountReducer(reducer, initialArg, init);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useRef<T>(initialValue: T): {|current: T|} {\r\n      currentHookNameInDev = 'useRef';\r\n      updateHookTypesDev();\r\n      return mountRef(initialValue);\r\n    },\r\n    useState<S>(\r\n      initialState: (() => S) | S,\r\n    ): [S, Dispatch<BasicStateAction<S>>] {\r\n      currentHookNameInDev = 'useState';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountState(initialState);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n      currentHookNameInDev = 'useDebugValue';\r\n      updateHookTypesDev();\r\n      return mountDebugValue(value, formatterFn);\r\n    },\r\n    useDeferredValue<T>(value: T): T {\r\n      currentHookNameInDev = 'useDeferredValue';\r\n      updateHookTypesDev();\r\n      return mountDeferredValue(value);\r\n    },\r\n    useTransition(): [boolean, (() => void) => void] {\r\n      currentHookNameInDev = 'useTransition';\r\n      updateHookTypesDev();\r\n      return mountTransition();\r\n    },\r\n    useMutableSource<Source, Snapshot>(\r\n      source: MutableSource<Source>,\r\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n    ): Snapshot {\r\n      currentHookNameInDev = 'useMutableSource';\r\n      updateHookTypesDev();\r\n      return mountMutableSource(source, getSnapshot, subscribe);\r\n    },\r\n    useSyncExternalStore<T>(\r\n      subscribe: (() => void) => () => void,\r\n      getSnapshot: () => T,\r\n      getServerSnapshot?: () => T,\r\n    ): T {\r\n      currentHookNameInDev = 'useSyncExternalStore';\r\n      updateHookTypesDev();\r\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n    },\r\n    useId(): string {\r\n      currentHookNameInDev = 'useId';\r\n      updateHookTypesDev();\r\n      return mountId();\r\n    },\r\n\r\n    unstable_isNewReconciler: enableNewReconciler,\r\n  };\r\n  if (enableCache) {\r\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).getCacheSignal = getCacheSignal;\r\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).getCacheForType = getCacheForType;\r\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\r\n      currentHookNameInDev = 'useCacheRefresh';\r\n      updateHookTypesDev();\r\n      return mountRefresh();\r\n    };\r\n  }\r\n\r\n  HooksDispatcherOnUpdateInDEV = {\r\n    readContext<T>(context: ReactContext<T>): T {\r\n      return readContext(context);\r\n    },\r\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useCallback';\r\n      updateHookTypesDev();\r\n      return updateCallback(callback, deps);\r\n    },\r\n    useContext<T>(context: ReactContext<T>): T {\r\n      currentHookNameInDev = 'useContext';\r\n      updateHookTypesDev();\r\n      return readContext(context);\r\n    },\r\n    useEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useEffect';\r\n      updateHookTypesDev();\r\n      return updateEffect(create, deps);\r\n    },\r\n    useImperativeHandle<T>(\r\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n      create: () => T,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useImperativeHandle';\r\n      updateHookTypesDev();\r\n      return updateImperativeHandle(ref, create, deps);\r\n    },\r\n    useInsertionEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useInsertionEffect';\r\n      updateHookTypesDev();\r\n      return updateInsertionEffect(create, deps);\r\n    },\r\n    useLayoutEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useLayoutEffect';\r\n      updateHookTypesDev();\r\n      return updateLayoutEffect(create, deps);\r\n    },\r\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useMemo';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return updateMemo(create, deps);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useReducer<S, I, A>(\r\n      reducer: (S, A) => S,\r\n      initialArg: I,\r\n      init?: I => S,\r\n    ): [S, Dispatch<A>] {\r\n      currentHookNameInDev = 'useReducer';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return updateReducer(reducer, initialArg, init);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useRef<T>(initialValue: T): {|current: T|} {\r\n      currentHookNameInDev = 'useRef';\r\n      updateHookTypesDev();\r\n      return updateRef(initialValue);\r\n    },\r\n    useState<S>(\r\n      initialState: (() => S) | S,\r\n    ): [S, Dispatch<BasicStateAction<S>>] {\r\n      currentHookNameInDev = 'useState';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return updateState(initialState);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n      currentHookNameInDev = 'useDebugValue';\r\n      updateHookTypesDev();\r\n      return updateDebugValue(value, formatterFn);\r\n    },\r\n    useDeferredValue<T>(value: T): T {\r\n      currentHookNameInDev = 'useDeferredValue';\r\n      updateHookTypesDev();\r\n      return updateDeferredValue(value);\r\n    },\r\n    useTransition(): [boolean, (() => void) => void] {\r\n      currentHookNameInDev = 'useTransition';\r\n      updateHookTypesDev();\r\n      return updateTransition();\r\n    },\r\n    useMutableSource<Source, Snapshot>(\r\n      source: MutableSource<Source>,\r\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n    ): Snapshot {\r\n      currentHookNameInDev = 'useMutableSource';\r\n      updateHookTypesDev();\r\n      return updateMutableSource(source, getSnapshot, subscribe);\r\n    },\r\n    useSyncExternalStore<T>(\r\n      subscribe: (() => void) => () => void,\r\n      getSnapshot: () => T,\r\n      getServerSnapshot?: () => T,\r\n    ): T {\r\n      currentHookNameInDev = 'useSyncExternalStore';\r\n      updateHookTypesDev();\r\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n    },\r\n    useId(): string {\r\n      currentHookNameInDev = 'useId';\r\n      updateHookTypesDev();\r\n      return updateId();\r\n    },\r\n\r\n    unstable_isNewReconciler: enableNewReconciler,\r\n  };\r\n  if (enableCache) {\r\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).getCacheSignal = getCacheSignal;\r\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).getCacheForType = getCacheForType;\r\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\r\n      currentHookNameInDev = 'useCacheRefresh';\r\n      updateHookTypesDev();\r\n      return updateRefresh();\r\n    };\r\n  }\r\n\r\n  HooksDispatcherOnRerenderInDEV = {\r\n    readContext<T>(context: ReactContext<T>): T {\r\n      return readContext(context);\r\n    },\r\n\r\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useCallback';\r\n      updateHookTypesDev();\r\n      return updateCallback(callback, deps);\r\n    },\r\n    useContext<T>(context: ReactContext<T>): T {\r\n      currentHookNameInDev = 'useContext';\r\n      updateHookTypesDev();\r\n      return readContext(context);\r\n    },\r\n    useEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useEffect';\r\n      updateHookTypesDev();\r\n      return updateEffect(create, deps);\r\n    },\r\n    useImperativeHandle<T>(\r\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n      create: () => T,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useImperativeHandle';\r\n      updateHookTypesDev();\r\n      return updateImperativeHandle(ref, create, deps);\r\n    },\r\n    useInsertionEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useInsertionEffect';\r\n      updateHookTypesDev();\r\n      return updateInsertionEffect(create, deps);\r\n    },\r\n    useLayoutEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useLayoutEffect';\r\n      updateHookTypesDev();\r\n      return updateLayoutEffect(create, deps);\r\n    },\r\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useMemo';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\r\n      try {\r\n        return updateMemo(create, deps);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useReducer<S, I, A>(\r\n      reducer: (S, A) => S,\r\n      initialArg: I,\r\n      init?: I => S,\r\n    ): [S, Dispatch<A>] {\r\n      currentHookNameInDev = 'useReducer';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\r\n      try {\r\n        return rerenderReducer(reducer, initialArg, init);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useRef<T>(initialValue: T): {|current: T|} {\r\n      currentHookNameInDev = 'useRef';\r\n      updateHookTypesDev();\r\n      return updateRef(initialValue);\r\n    },\r\n    useState<S>(\r\n      initialState: (() => S) | S,\r\n    ): [S, Dispatch<BasicStateAction<S>>] {\r\n      currentHookNameInDev = 'useState';\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\r\n      try {\r\n        return rerenderState(initialState);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n      currentHookNameInDev = 'useDebugValue';\r\n      updateHookTypesDev();\r\n      return updateDebugValue(value, formatterFn);\r\n    },\r\n    useDeferredValue<T>(value: T): T {\r\n      currentHookNameInDev = 'useDeferredValue';\r\n      updateHookTypesDev();\r\n      return rerenderDeferredValue(value);\r\n    },\r\n    useTransition(): [boolean, (() => void) => void] {\r\n      currentHookNameInDev = 'useTransition';\r\n      updateHookTypesDev();\r\n      return rerenderTransition();\r\n    },\r\n    useMutableSource<Source, Snapshot>(\r\n      source: MutableSource<Source>,\r\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n    ): Snapshot {\r\n      currentHookNameInDev = 'useMutableSource';\r\n      updateHookTypesDev();\r\n      return updateMutableSource(source, getSnapshot, subscribe);\r\n    },\r\n    useSyncExternalStore<T>(\r\n      subscribe: (() => void) => () => void,\r\n      getSnapshot: () => T,\r\n      getServerSnapshot?: () => T,\r\n    ): T {\r\n      currentHookNameInDev = 'useSyncExternalStore';\r\n      updateHookTypesDev();\r\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n    },\r\n    useId(): string {\r\n      currentHookNameInDev = 'useId';\r\n      updateHookTypesDev();\r\n      return updateId();\r\n    },\r\n\r\n    unstable_isNewReconciler: enableNewReconciler,\r\n  };\r\n  if (enableCache) {\r\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).getCacheSignal = getCacheSignal;\r\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).getCacheForType = getCacheForType;\r\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\r\n      currentHookNameInDev = 'useCacheRefresh';\r\n      updateHookTypesDev();\r\n      return updateRefresh();\r\n    };\r\n  }\r\n\r\n  InvalidNestedHooksDispatcherOnMountInDEV = {\r\n    readContext<T>(context: ReactContext<T>): T {\r\n      warnInvalidContextAccess();\r\n      return readContext(context);\r\n    },\r\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useCallback';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountCallback(callback, deps);\r\n    },\r\n    useContext<T>(context: ReactContext<T>): T {\r\n      currentHookNameInDev = 'useContext';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return readContext(context);\r\n    },\r\n    useEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useEffect';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountEffect(create, deps);\r\n    },\r\n    useImperativeHandle<T>(\r\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n      create: () => T,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useImperativeHandle';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountImperativeHandle(ref, create, deps);\r\n    },\r\n    useInsertionEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useInsertionEffect';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountInsertionEffect(create, deps);\r\n    },\r\n    useLayoutEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useLayoutEffect';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountLayoutEffect(create, deps);\r\n    },\r\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useMemo';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountMemo(create, deps);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useReducer<S, I, A>(\r\n      reducer: (S, A) => S,\r\n      initialArg: I,\r\n      init?: I => S,\r\n    ): [S, Dispatch<A>] {\r\n      currentHookNameInDev = 'useReducer';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountReducer(reducer, initialArg, init);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useRef<T>(initialValue: T): {|current: T|} {\r\n      currentHookNameInDev = 'useRef';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountRef(initialValue);\r\n    },\r\n    useState<S>(\r\n      initialState: (() => S) | S,\r\n    ): [S, Dispatch<BasicStateAction<S>>] {\r\n      currentHookNameInDev = 'useState';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n      try {\r\n        return mountState(initialState);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n      currentHookNameInDev = 'useDebugValue';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountDebugValue(value, formatterFn);\r\n    },\r\n    useDeferredValue<T>(value: T): T {\r\n      currentHookNameInDev = 'useDeferredValue';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountDeferredValue(value);\r\n    },\r\n    useTransition(): [boolean, (() => void) => void] {\r\n      currentHookNameInDev = 'useTransition';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountTransition();\r\n    },\r\n    useMutableSource<Source, Snapshot>(\r\n      source: MutableSource<Source>,\r\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n    ): Snapshot {\r\n      currentHookNameInDev = 'useMutableSource';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountMutableSource(source, getSnapshot, subscribe);\r\n    },\r\n    useSyncExternalStore<T>(\r\n      subscribe: (() => void) => () => void,\r\n      getSnapshot: () => T,\r\n      getServerSnapshot?: () => T,\r\n    ): T {\r\n      currentHookNameInDev = 'useSyncExternalStore';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n    },\r\n    useId(): string {\r\n      currentHookNameInDev = 'useId';\r\n      warnInvalidHookAccess();\r\n      mountHookTypesDev();\r\n      return mountId();\r\n    },\r\n\r\n    unstable_isNewReconciler: enableNewReconciler,\r\n  };\r\n  if (enableCache) {\r\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).getCacheSignal = getCacheSignal;\r\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).getCacheForType = getCacheForType;\r\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\r\n      currentHookNameInDev = 'useCacheRefresh';\r\n      mountHookTypesDev();\r\n      return mountRefresh();\r\n    };\r\n  }\r\n\r\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\r\n    readContext<T>(context: ReactContext<T>): T {\r\n      warnInvalidContextAccess();\r\n      return readContext(context);\r\n    },\r\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useCallback';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateCallback(callback, deps);\r\n    },\r\n    useContext<T>(context: ReactContext<T>): T {\r\n      currentHookNameInDev = 'useContext';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return readContext(context);\r\n    },\r\n    useEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useEffect';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateEffect(create, deps);\r\n    },\r\n    useImperativeHandle<T>(\r\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n      create: () => T,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useImperativeHandle';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateImperativeHandle(ref, create, deps);\r\n    },\r\n    useInsertionEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useInsertionEffect';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateInsertionEffect(create, deps);\r\n    },\r\n    useLayoutEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useLayoutEffect';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateLayoutEffect(create, deps);\r\n    },\r\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useMemo';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return updateMemo(create, deps);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useReducer<S, I, A>(\r\n      reducer: (S, A) => S,\r\n      initialArg: I,\r\n      init?: I => S,\r\n    ): [S, Dispatch<A>] {\r\n      currentHookNameInDev = 'useReducer';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return updateReducer(reducer, initialArg, init);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useRef<T>(initialValue: T): {|current: T|} {\r\n      currentHookNameInDev = 'useRef';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateRef(initialValue);\r\n    },\r\n    useState<S>(\r\n      initialState: (() => S) | S,\r\n    ): [S, Dispatch<BasicStateAction<S>>] {\r\n      currentHookNameInDev = 'useState';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return updateState(initialState);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n      currentHookNameInDev = 'useDebugValue';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateDebugValue(value, formatterFn);\r\n    },\r\n    useDeferredValue<T>(value: T): T {\r\n      currentHookNameInDev = 'useDeferredValue';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateDeferredValue(value);\r\n    },\r\n    useTransition(): [boolean, (() => void) => void] {\r\n      currentHookNameInDev = 'useTransition';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateTransition();\r\n    },\r\n    useMutableSource<Source, Snapshot>(\r\n      source: MutableSource<Source>,\r\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n    ): Snapshot {\r\n      currentHookNameInDev = 'useMutableSource';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateMutableSource(source, getSnapshot, subscribe);\r\n    },\r\n    useSyncExternalStore<T>(\r\n      subscribe: (() => void) => () => void,\r\n      getSnapshot: () => T,\r\n      getServerSnapshot?: () => T,\r\n    ): T {\r\n      currentHookNameInDev = 'useSyncExternalStore';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n    },\r\n    useId(): string {\r\n      currentHookNameInDev = 'useId';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateId();\r\n    },\r\n\r\n    unstable_isNewReconciler: enableNewReconciler,\r\n  };\r\n  if (enableCache) {\r\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).getCacheSignal = getCacheSignal;\r\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).getCacheForType = getCacheForType;\r\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\r\n      currentHookNameInDev = 'useCacheRefresh';\r\n      updateHookTypesDev();\r\n      return updateRefresh();\r\n    };\r\n  }\r\n\r\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\r\n    readContext<T>(context: ReactContext<T>): T {\r\n      warnInvalidContextAccess();\r\n      return readContext(context);\r\n    },\r\n\r\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useCallback';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateCallback(callback, deps);\r\n    },\r\n    useContext<T>(context: ReactContext<T>): T {\r\n      currentHookNameInDev = 'useContext';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return readContext(context);\r\n    },\r\n    useEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useEffect';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateEffect(create, deps);\r\n    },\r\n    useImperativeHandle<T>(\r\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\r\n      create: () => T,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useImperativeHandle';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateImperativeHandle(ref, create, deps);\r\n    },\r\n    useInsertionEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useInsertionEffect';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateInsertionEffect(create, deps);\r\n    },\r\n    useLayoutEffect(\r\n      create: () => (() => void) | void,\r\n      deps: Array<mixed> | void | null,\r\n    ): void {\r\n      currentHookNameInDev = 'useLayoutEffect';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateLayoutEffect(create, deps);\r\n    },\r\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\r\n      currentHookNameInDev = 'useMemo';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return updateMemo(create, deps);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useReducer<S, I, A>(\r\n      reducer: (S, A) => S,\r\n      initialArg: I,\r\n      init?: I => S,\r\n    ): [S, Dispatch<A>] {\r\n      currentHookNameInDev = 'useReducer';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return rerenderReducer(reducer, initialArg, init);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useRef<T>(initialValue: T): {|current: T|} {\r\n      currentHookNameInDev = 'useRef';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateRef(initialValue);\r\n    },\r\n    useState<S>(\r\n      initialState: (() => S) | S,\r\n    ): [S, Dispatch<BasicStateAction<S>>] {\r\n      currentHookNameInDev = 'useState';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      const prevDispatcher = ReactCurrentDispatcher.current;\r\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n      try {\r\n        return rerenderState(initialState);\r\n      } finally {\r\n        ReactCurrentDispatcher.current = prevDispatcher;\r\n      }\r\n    },\r\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\r\n      currentHookNameInDev = 'useDebugValue';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateDebugValue(value, formatterFn);\r\n    },\r\n    useDeferredValue<T>(value: T): T {\r\n      currentHookNameInDev = 'useDeferredValue';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return rerenderDeferredValue(value);\r\n    },\r\n    useTransition(): [boolean, (() => void) => void] {\r\n      currentHookNameInDev = 'useTransition';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return rerenderTransition();\r\n    },\r\n    useMutableSource<Source, Snapshot>(\r\n      source: MutableSource<Source>,\r\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\r\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\r\n    ): Snapshot {\r\n      currentHookNameInDev = 'useMutableSource';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateMutableSource(source, getSnapshot, subscribe);\r\n    },\r\n    useSyncExternalStore<T>(\r\n      subscribe: (() => void) => () => void,\r\n      getSnapshot: () => T,\r\n      getServerSnapshot?: () => T,\r\n    ): T {\r\n      currentHookNameInDev = 'useSyncExternalStore';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n    },\r\n    useId(): string {\r\n      currentHookNameInDev = 'useId';\r\n      warnInvalidHookAccess();\r\n      updateHookTypesDev();\r\n      return updateId();\r\n    },\r\n\r\n    unstable_isNewReconciler: enableNewReconciler,\r\n  };\r\n  if (enableCache) {\r\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).getCacheSignal = getCacheSignal;\r\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).getCacheForType = getCacheForType;\r\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\r\n      currentHookNameInDev = 'useCacheRefresh';\r\n      updateHookTypesDev();\r\n      return updateRefresh();\r\n    };\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}