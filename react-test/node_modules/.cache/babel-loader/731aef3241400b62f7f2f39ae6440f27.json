{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nconst Uninitialized = -1;\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\nfunction lazyInitializer(payload) {\n  if (payload._status === Uninitialized) {\n    const ctor = payload._result;\n    const thenable = ctor(); // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n\n    thenable.then(moduleObject => {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        const resolved = payload;\n        resolved._status = Resolved;\n        resolved._result = moduleObject;\n      }\n    }, error => {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        const rejected = payload;\n        rejected._status = Rejected;\n        rejected._result = error;\n      }\n    });\n\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      const pending = payload;\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n\n  if (payload._status === Resolved) {\n    const moduleObject = payload._result;\n\n    if (__DEV__) {\n      if (moduleObject === undefined) {\n        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n      }\n    }\n\n    if (__DEV__) {\n      if (!('default' in moduleObject)) {\n        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n      }\n    }\n\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nexport function lazy(ctor) {\n  const payload = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor\n  };\n  const lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer\n  };\n\n  if (__DEV__) {\n    // In production, this would just set it on the object.\n    let defaultProps;\n    let propTypes; // $FlowFixMe\n\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n\n        get() {\n          return defaultProps;\n        },\n\n        set(newDefaultProps) {\n          console.error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n\n      },\n      propTypes: {\n        configurable: true,\n\n        get() {\n          return propTypes;\n        },\n\n        set(newPropTypes) {\n          console.error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n          propTypes = newPropTypes; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n\n      }\n    });\n  }\n\n  return lazyType;\n}","map":{"version":3,"names":["REACT_LAZY_TYPE","Uninitialized","Pending","Resolved","Rejected","lazyInitializer","payload","_status","ctor","_result","thenable","then","moduleObject","resolved","error","rejected","pending","__DEV__","undefined","console","default","lazy","lazyType","$$typeof","_payload","_init","defaultProps","propTypes","Object","defineProperties","configurable","get","set","newDefaultProps","defineProperty","enumerable","newPropTypes"],"sources":["E:/debug-anything/react-test/src/react/packages/react/src/ReactLazy.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Wakeable, Thenable} from 'shared/ReactTypes';\r\n\r\nimport {REACT_LAZY_TYPE} from 'shared/ReactSymbols';\r\n\r\nconst Uninitialized = -1;\r\nconst Pending = 0;\r\nconst Resolved = 1;\r\nconst Rejected = 2;\r\n\r\ntype UninitializedPayload<T> = {\r\n  _status: -1,\r\n  _result: () => Thenable<{default: T, ...}>,\r\n};\r\n\r\ntype PendingPayload = {\r\n  _status: 0,\r\n  _result: Wakeable,\r\n};\r\n\r\ntype ResolvedPayload<T> = {\r\n  _status: 1,\r\n  _result: {default: T},\r\n};\r\n\r\ntype RejectedPayload = {\r\n  _status: 2,\r\n  _result: mixed,\r\n};\r\n\r\ntype Payload<T> =\r\n  | UninitializedPayload<T>\r\n  | PendingPayload\r\n  | ResolvedPayload<T>\r\n  | RejectedPayload;\r\n\r\nexport type LazyComponent<T, P> = {\r\n  $$typeof: Symbol | number,\r\n  _payload: P,\r\n  _init: (payload: P) => T,\r\n};\r\n\r\nfunction lazyInitializer<T>(payload: Payload<T>): T {\r\n  if (payload._status === Uninitialized) {\r\n    const ctor = payload._result;\r\n    const thenable = ctor();\r\n    // Transition to the next state.\r\n    // This might throw either because it's missing or throws. If so, we treat it\r\n    // as still uninitialized and try again next time. Which is the same as what\r\n    // happens if the ctor or any wrappers processing the ctor throws. This might\r\n    // end up fixing it if the resolution was a concurrency bug.\r\n    thenable.then(\r\n      moduleObject => {\r\n        if (payload._status === Pending || payload._status === Uninitialized) {\r\n          // Transition to the next state.\r\n          const resolved: ResolvedPayload<T> = (payload: any);\r\n          resolved._status = Resolved;\r\n          resolved._result = moduleObject;\r\n        }\r\n      },\r\n      error => {\r\n        if (payload._status === Pending || payload._status === Uninitialized) {\r\n          // Transition to the next state.\r\n          const rejected: RejectedPayload = (payload: any);\r\n          rejected._status = Rejected;\r\n          rejected._result = error;\r\n        }\r\n      },\r\n    );\r\n    if (payload._status === Uninitialized) {\r\n      // In case, we're still uninitialized, then we're waiting for the thenable\r\n      // to resolve. Set it as pending in the meantime.\r\n      const pending: PendingPayload = (payload: any);\r\n      pending._status = Pending;\r\n      pending._result = thenable;\r\n    }\r\n  }\r\n  if (payload._status === Resolved) {\r\n    const moduleObject = payload._result;\r\n    if (__DEV__) {\r\n      if (moduleObject === undefined) {\r\n        console.error(\r\n          'lazy: Expected the result of a dynamic imp' +\r\n            'ort() call. ' +\r\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'const MyComponent = lazy(() => imp' +\r\n            \"ort('./MyComponent'))\\n\\n\" +\r\n            'Did you accidentally put curly braces around the import?',\r\n          moduleObject,\r\n        );\r\n      }\r\n    }\r\n    if (__DEV__) {\r\n      if (!('default' in moduleObject)) {\r\n        console.error(\r\n          'lazy: Expected the result of a dynamic imp' +\r\n            'ort() call. ' +\r\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\r\n            // Break up imports to avoid accidentally parsing them as dependencies.\r\n            'const MyComponent = lazy(() => imp' +\r\n            \"ort('./MyComponent'))\",\r\n          moduleObject,\r\n        );\r\n      }\r\n    }\r\n    return moduleObject.default;\r\n  } else {\r\n    throw payload._result;\r\n  }\r\n}\r\n\r\nexport function lazy<T>(\r\n  ctor: () => Thenable<{default: T, ...}>,\r\n): LazyComponent<T, Payload<T>> {\r\n  const payload: Payload<T> = {\r\n    // We use these fields to store the result.\r\n    _status: Uninitialized,\r\n    _result: ctor,\r\n  };\r\n\r\n  const lazyType: LazyComponent<T, Payload<T>> = {\r\n    $$typeof: REACT_LAZY_TYPE,\r\n    _payload: payload,\r\n    _init: lazyInitializer,\r\n  };\r\n\r\n  if (__DEV__) {\r\n    // In production, this would just set it on the object.\r\n    let defaultProps;\r\n    let propTypes;\r\n    // $FlowFixMe\r\n    Object.defineProperties(lazyType, {\r\n      defaultProps: {\r\n        configurable: true,\r\n        get() {\r\n          return defaultProps;\r\n        },\r\n        set(newDefaultProps) {\r\n          console.error(\r\n            'React.lazy(...): It is not supported to assign `defaultProps` to ' +\r\n              'a lazy component import. Either specify them where the component ' +\r\n              'is defined, or create a wrapping component around it.',\r\n          );\r\n          defaultProps = newDefaultProps;\r\n          // Match production behavior more closely:\r\n          // $FlowFixMe\r\n          Object.defineProperty(lazyType, 'defaultProps', {\r\n            enumerable: true,\r\n          });\r\n        },\r\n      },\r\n      propTypes: {\r\n        configurable: true,\r\n        get() {\r\n          return propTypes;\r\n        },\r\n        set(newPropTypes) {\r\n          console.error(\r\n            'React.lazy(...): It is not supported to assign `propTypes` to ' +\r\n              'a lazy component import. Either specify them where the component ' +\r\n              'is defined, or create a wrapping component around it.',\r\n          );\r\n          propTypes = newPropTypes;\r\n          // Match production behavior more closely:\r\n          // $FlowFixMe\r\n          Object.defineProperty(lazyType, 'propTypes', {\r\n            enumerable: true,\r\n          });\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  return lazyType;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}