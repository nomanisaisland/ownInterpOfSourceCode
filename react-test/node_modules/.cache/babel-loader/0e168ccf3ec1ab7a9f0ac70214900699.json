{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableComponentStackLocations, disableNativeComponentFrames } from 'shared/ReactFeatureFlags';\nimport { REACT_SUSPENSE_TYPE, REACT_SUSPENSE_LIST_TYPE, REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nimport { disableLogs, reenableLogs } from 'shared/ConsolePatchingDev';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nconst {\n  ReactCurrentDispatcher\n} = ReactSharedInternals;\nlet prefix;\nexport function describeBuiltInComponentFrame(name, source, ownerFn) {\n  if (enableComponentStackLocations) {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        const match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  } else {\n    let ownerName = null;\n\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\nlet reentry = false;\nlet componentFrameCache;\n\nif (__DEV__) {\n  const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nexport function describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (disableNativeComponentFrames || !fn || reentry) {\n    return '';\n  }\n\n  if (__DEV__) {\n    const frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  let control;\n  reentry = true;\n  const previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  let previousDispatcher;\n\n  if (__DEV__) {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      const Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      const sampleLines = sample.stack.split('\\n');\n      const controlLines = control.stack.split('\\n');\n      let s = sampleLines.length - 1;\n      let c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                let frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n                if (fn.displayName && frame.includes('<anonymous>')) {\n                  frame = frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (__DEV__) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, frame);\n                  }\n                } // Return the line we found.\n\n\n                return frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    if (__DEV__) {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  const name = fn ? fn.displayName || fn.name : '';\n  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  if (__DEV__) {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nconst BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nfunction describeComponentFrame(name, source, ownerName) {\n  let sourceInfo = '';\n\n  if (__DEV__ && source) {\n    const path = source.fileName;\n    let fileName = path.replace(BEFORE_SLASH_RE, ''); // In DEV, include code for a common special case:\n    // prefer \"folder/index.js\" instead of just \"index.js\".\n\n    if (/^index\\./.test(fileName)) {\n      const match = path.match(BEFORE_SLASH_RE);\n\n      if (match) {\n        const pathBeforeSlash = match[1];\n\n        if (pathBeforeSlash) {\n          const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n          fileName = folderName + '/' + fileName;\n        }\n      }\n    }\n\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n\nexport function describeClassComponentFrame(ctor, source, ownerFn) {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(ctor, true);\n  } else {\n    return describeFunctionComponentFrame(ctor, source, ownerFn);\n  }\n}\nexport function describeFunctionComponentFrame(fn, source, ownerFn) {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(fn, false);\n  } else {\n    if (!fn) {\n      return '';\n    }\n\n    const name = fn.displayName || fn.name || null;\n    let ownerName = null;\n\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  const prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nexport function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n  if (!__DEV__) {\n    return '';\n  }\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    if (enableComponentStackLocations) {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    } else {\n      return describeFunctionComponentFrame(type, source, ownerFn);\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type, source, ownerFn);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense', source, ownerFn);\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render, source, ownerFn);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          const lazyComponent = type;\n          const payload = lazyComponent._payload;\n          const init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}","map":{"version":3,"names":["enableComponentStackLocations","disableNativeComponentFrames","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","disableLogs","reenableLogs","ReactSharedInternals","ReactCurrentDispatcher","prefix","describeBuiltInComponentFrame","name","source","ownerFn","undefined","Error","x","match","stack","trim","ownerName","__DEV__","displayName","describeComponentFrame","reentry","componentFrameCache","PossiblyWeakMap","WeakMap","Map","describeNativeComponentFrame","fn","construct","frame","get","control","previousPrepareStackTrace","prepareStackTrace","previousDispatcher","current","Fake","Object","defineProperty","prototype","set","Reflect","call","sample","sampleLines","split","controlLines","s","length","c","replace","includes","syntheticFrame","BEFORE_SLASH_RE","sourceInfo","path","fileName","test","pathBeforeSlash","folderName","lineNumber","describeClassComponentFrame","ctor","describeFunctionComponentFrame","shouldConstruct","Component","isReactComponent","describeUnknownElementTypeFrameInDEV","type","$$typeof","render","lazyComponent","payload","_payload","init","_init"],"sources":["E:/debug-anything/react-test/src/react/packages/shared/ReactComponentStackFrame.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Source} from 'shared/ReactElementType';\r\nimport type {LazyComponent} from 'react/src/ReactLazy';\r\n\r\nimport {\r\n  enableComponentStackLocations,\r\n  disableNativeComponentFrames,\r\n} from 'shared/ReactFeatureFlags';\r\n\r\nimport {\r\n  REACT_SUSPENSE_TYPE,\r\n  REACT_SUSPENSE_LIST_TYPE,\r\n  REACT_FORWARD_REF_TYPE,\r\n  REACT_MEMO_TYPE,\r\n  REACT_LAZY_TYPE,\r\n} from 'shared/ReactSymbols';\r\n\r\nimport {disableLogs, reenableLogs} from 'shared/ConsolePatchingDev';\r\n\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\n\r\nconst {ReactCurrentDispatcher} = ReactSharedInternals;\r\n\r\nlet prefix;\r\nexport function describeBuiltInComponentFrame(\r\n  name: string,\r\n  source: void | null | Source,\r\n  ownerFn: void | null | Function,\r\n): string {\r\n  if (enableComponentStackLocations) {\r\n    if (prefix === undefined) {\r\n      // Extract the VM specific prefix used by each line.\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        const match = x.stack.trim().match(/\\n( *(at )?)/);\r\n        prefix = (match && match[1]) || '';\r\n      }\r\n    }\r\n    // We use the prefix to ensure our stacks line up with native stack frames.\r\n    return '\\n' + prefix + name;\r\n  } else {\r\n    let ownerName = null;\r\n    if (__DEV__ && ownerFn) {\r\n      ownerName = ownerFn.displayName || ownerFn.name || null;\r\n    }\r\n    return describeComponentFrame(name, source, ownerName);\r\n  }\r\n}\r\n\r\nlet reentry = false;\r\nlet componentFrameCache;\r\nif (__DEV__) {\r\n  const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n  componentFrameCache = new PossiblyWeakMap();\r\n}\r\n\r\nexport function describeNativeComponentFrame(\r\n  fn: Function,\r\n  construct: boolean,\r\n): string {\r\n  // If something asked for a stack inside a fake render, it should get ignored.\r\n  if (disableNativeComponentFrames || !fn || reentry) {\r\n    return '';\r\n  }\r\n\r\n  if (__DEV__) {\r\n    const frame = componentFrameCache.get(fn);\r\n    if (frame !== undefined) {\r\n      return frame;\r\n    }\r\n  }\r\n\r\n  let control;\r\n\r\n  reentry = true;\r\n  const previousPrepareStackTrace = Error.prepareStackTrace;\r\n  // $FlowFixMe It does accept undefined.\r\n  Error.prepareStackTrace = undefined;\r\n  let previousDispatcher;\r\n  if (__DEV__) {\r\n    previousDispatcher = ReactCurrentDispatcher.current;\r\n    // Set the dispatcher in DEV because this might be call in the render function\r\n    // for warnings.\r\n    ReactCurrentDispatcher.current = null;\r\n    disableLogs();\r\n  }\r\n  try {\r\n    // This should throw.\r\n    if (construct) {\r\n      // Something should be setting the props in the constructor.\r\n      const Fake = function() {\r\n        throw Error();\r\n      };\r\n      // $FlowFixMe\r\n      Object.defineProperty(Fake.prototype, 'props', {\r\n        set: function() {\r\n          // We use a throwing setter instead of frozen or non-writable props\r\n          // because that won't throw in a non-strict mode function.\r\n          throw Error();\r\n        },\r\n      });\r\n      if (typeof Reflect === 'object' && Reflect.construct) {\r\n        // We construct a different control for this case to include any extra\r\n        // frames added by the construct call.\r\n        try {\r\n          Reflect.construct(Fake, []);\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n        Reflect.construct(fn, [], Fake);\r\n      } else {\r\n        try {\r\n          Fake.call();\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n        fn.call(Fake.prototype);\r\n      }\r\n    } else {\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        control = x;\r\n      }\r\n      fn();\r\n    }\r\n  } catch (sample) {\r\n    // This is inlined manually because closure doesn't do it for us.\r\n    if (sample && control && typeof sample.stack === 'string') {\r\n      // This extracts the first frame from the sample that isn't also in the control.\r\n      // Skipping one frame that we assume is the frame that calls the two.\r\n      const sampleLines = sample.stack.split('\\n');\r\n      const controlLines = control.stack.split('\\n');\r\n      let s = sampleLines.length - 1;\r\n      let c = controlLines.length - 1;\r\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\r\n        // We expect at least one stack frame to be shared.\r\n        // Typically this will be the root most one. However, stack frames may be\r\n        // cut off due to maximum stack limits. In this case, one maybe cut off\r\n        // earlier than the other. We assume that the sample is longer or the same\r\n        // and there for cut off earlier. So we should find the root most frame in\r\n        // the sample somewhere in the control.\r\n        c--;\r\n      }\r\n      for (; s >= 1 && c >= 0; s--, c--) {\r\n        // Next we find the first one that isn't the same which should be the\r\n        // frame that called our sample function and the control.\r\n        if (sampleLines[s] !== controlLines[c]) {\r\n          // In V8, the first line is describing the message but other VMs don't.\r\n          // If we're about to return the first line, and the control is also on the same\r\n          // line, that's a pretty good indicator that our sample threw at same line as\r\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\r\n          // This can happen if you passed a class to function component, or non-function.\r\n          if (s !== 1 || c !== 1) {\r\n            do {\r\n              s--;\r\n              c--;\r\n              // We may still have similar intermediate frames from the construct call.\r\n              // The next one that isn't the same should be our match though.\r\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\r\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\r\n                let frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\r\n\r\n                // If our component frame is labeled \"<anonymous>\"\r\n                // but we have a user-provided \"displayName\"\r\n                // splice it in to make the stack more readable.\r\n                if (fn.displayName && frame.includes('<anonymous>')) {\r\n                  frame = frame.replace('<anonymous>', fn.displayName);\r\n                }\r\n\r\n                if (__DEV__) {\r\n                  if (typeof fn === 'function') {\r\n                    componentFrameCache.set(fn, frame);\r\n                  }\r\n                }\r\n                // Return the line we found.\r\n                return frame;\r\n              }\r\n            } while (s >= 1 && c >= 0);\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } finally {\r\n    reentry = false;\r\n    if (__DEV__) {\r\n      ReactCurrentDispatcher.current = previousDispatcher;\r\n      reenableLogs();\r\n    }\r\n    Error.prepareStackTrace = previousPrepareStackTrace;\r\n  }\r\n  // Fallback to just using the name if we couldn't make it throw.\r\n  const name = fn ? fn.displayName || fn.name : '';\r\n  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\r\n  if (__DEV__) {\r\n    if (typeof fn === 'function') {\r\n      componentFrameCache.set(fn, syntheticFrame);\r\n    }\r\n  }\r\n  return syntheticFrame;\r\n}\r\n\r\nconst BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\r\n\r\nfunction describeComponentFrame(\r\n  name: null | string,\r\n  source: void | null | Source,\r\n  ownerName: null | string,\r\n) {\r\n  let sourceInfo = '';\r\n  if (__DEV__ && source) {\r\n    const path = source.fileName;\r\n    let fileName = path.replace(BEFORE_SLASH_RE, '');\r\n    // In DEV, include code for a common special case:\r\n    // prefer \"folder/index.js\" instead of just \"index.js\".\r\n    if (/^index\\./.test(fileName)) {\r\n      const match = path.match(BEFORE_SLASH_RE);\r\n      if (match) {\r\n        const pathBeforeSlash = match[1];\r\n        if (pathBeforeSlash) {\r\n          const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\r\n          fileName = folderName + '/' + fileName;\r\n        }\r\n      }\r\n    }\r\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\r\n  } else if (ownerName) {\r\n    sourceInfo = ' (created by ' + ownerName + ')';\r\n  }\r\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\r\n}\r\n\r\nexport function describeClassComponentFrame(\r\n  ctor: Function,\r\n  source: void | null | Source,\r\n  ownerFn: void | null | Function,\r\n): string {\r\n  if (enableComponentStackLocations) {\r\n    return describeNativeComponentFrame(ctor, true);\r\n  } else {\r\n    return describeFunctionComponentFrame(ctor, source, ownerFn);\r\n  }\r\n}\r\n\r\nexport function describeFunctionComponentFrame(\r\n  fn: Function,\r\n  source: void | null | Source,\r\n  ownerFn: void | null | Function,\r\n): string {\r\n  if (enableComponentStackLocations) {\r\n    return describeNativeComponentFrame(fn, false);\r\n  } else {\r\n    if (!fn) {\r\n      return '';\r\n    }\r\n    const name = fn.displayName || fn.name || null;\r\n    let ownerName = null;\r\n    if (__DEV__ && ownerFn) {\r\n      ownerName = ownerFn.displayName || ownerFn.name || null;\r\n    }\r\n    return describeComponentFrame(name, source, ownerName);\r\n  }\r\n}\r\n\r\nfunction shouldConstruct(Component: Function) {\r\n  const prototype = Component.prototype;\r\n  return !!(prototype && prototype.isReactComponent);\r\n}\r\n\r\nexport function describeUnknownElementTypeFrameInDEV(\r\n  type: any,\r\n  source: void | null | Source,\r\n  ownerFn: void | null | Function,\r\n): string {\r\n  if (!__DEV__) {\r\n    return '';\r\n  }\r\n  if (type == null) {\r\n    return '';\r\n  }\r\n  if (typeof type === 'function') {\r\n    if (enableComponentStackLocations) {\r\n      return describeNativeComponentFrame(type, shouldConstruct(type));\r\n    } else {\r\n      return describeFunctionComponentFrame(type, source, ownerFn);\r\n    }\r\n  }\r\n  if (typeof type === 'string') {\r\n    return describeBuiltInComponentFrame(type, source, ownerFn);\r\n  }\r\n  switch (type) {\r\n    case REACT_SUSPENSE_TYPE:\r\n      return describeBuiltInComponentFrame('Suspense', source, ownerFn);\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);\r\n  }\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return describeFunctionComponentFrame(type.render, source, ownerFn);\r\n      case REACT_MEMO_TYPE:\r\n        // Memo may contain any component type so we recursively resolve it.\r\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n      case REACT_LAZY_TYPE: {\r\n        const lazyComponent: LazyComponent<any, any> = (type: any);\r\n        const payload = lazyComponent._payload;\r\n        const init = lazyComponent._init;\r\n        try {\r\n          // Lazy may contain any component type so we recursively resolve it.\r\n          return describeUnknownElementTypeFrameInDEV(\r\n            init(payload),\r\n            source,\r\n            ownerFn,\r\n          );\r\n        } catch (x) {}\r\n      }\r\n    }\r\n  }\r\n  return '';\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,SACEA,6BADF,EAEEC,4BAFF,QAGO,0BAHP;AAKA,SACEC,mBADF,EAEEC,wBAFF,EAGEC,sBAHF,EAIEC,eAJF,EAKEC,eALF,QAMO,qBANP;AAQA,SAAQC,WAAR,EAAqBC,YAArB,QAAwC,2BAAxC;AAEA,OAAOC,oBAAP,MAAiC,6BAAjC;AAEA,MAAM;EAACC;AAAD,IAA2BD,oBAAjC;AAEA,IAAIE,MAAJ;AACA,OAAO,SAASC,6BAAT,CACLC,IADK,EAELC,MAFK,EAGLC,OAHK,EAIG;EACR,IAAIf,6BAAJ,EAAmC;IACjC,IAAIW,MAAM,KAAKK,SAAf,EAA0B;MACxB;MACA,IAAI;QACF,MAAMC,KAAK,EAAX;MACD,CAFD,CAEE,OAAOC,CAAP,EAAU;QACV,MAAMC,KAAK,GAAGD,CAAC,CAACE,KAAF,CAAQC,IAAR,GAAeF,KAAf,CAAqB,cAArB,CAAd;QACAR,MAAM,GAAIQ,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAf,IAAuB,EAAhC;MACD;IACF,CATgC,CAUjC;;;IACA,OAAO,OAAOR,MAAP,GAAgBE,IAAvB;EACD,CAZD,MAYO;IACL,IAAIS,SAAS,GAAG,IAAhB;;IACA,IAAIC,OAAO,IAAIR,OAAf,EAAwB;MACtBO,SAAS,GAAGP,OAAO,CAACS,WAAR,IAAuBT,OAAO,CAACF,IAA/B,IAAuC,IAAnD;IACD;;IACD,OAAOY,sBAAsB,CAACZ,IAAD,EAAOC,MAAP,EAAeQ,SAAf,CAA7B;EACD;AACF;AAED,IAAII,OAAO,GAAG,KAAd;AACA,IAAIC,mBAAJ;;AACA,IAAIJ,OAAJ,EAAa;EACX,MAAMK,eAAe,GAAG,OAAOC,OAAP,KAAmB,UAAnB,GAAgCA,OAAhC,GAA0CC,GAAlE;EACAH,mBAAmB,GAAG,IAAIC,eAAJ,EAAtB;AACD;;AAED,OAAO,SAASG,4BAAT,CACLC,EADK,EAELC,SAFK,EAGG;EACR;EACA,IAAIhC,4BAA4B,IAAI,CAAC+B,EAAjC,IAAuCN,OAA3C,EAAoD;IAClD,OAAO,EAAP;EACD;;EAED,IAAIH,OAAJ,EAAa;IACX,MAAMW,KAAK,GAAGP,mBAAmB,CAACQ,GAApB,CAAwBH,EAAxB,CAAd;;IACA,IAAIE,KAAK,KAAKlB,SAAd,EAAyB;MACvB,OAAOkB,KAAP;IACD;EACF;;EAED,IAAIE,OAAJ;EAEAV,OAAO,GAAG,IAAV;EACA,MAAMW,yBAAyB,GAAGpB,KAAK,CAACqB,iBAAxC,CAhBQ,CAiBR;;EACArB,KAAK,CAACqB,iBAAN,GAA0BtB,SAA1B;EACA,IAAIuB,kBAAJ;;EACA,IAAIhB,OAAJ,EAAa;IACXgB,kBAAkB,GAAG7B,sBAAsB,CAAC8B,OAA5C,CADW,CAEX;IACA;;IACA9B,sBAAsB,CAAC8B,OAAvB,GAAiC,IAAjC;IACAjC,WAAW;EACZ;;EACD,IAAI;IACF;IACA,IAAI0B,SAAJ,EAAe;MACb;MACA,MAAMQ,IAAI,GAAG,YAAW;QACtB,MAAMxB,KAAK,EAAX;MACD,CAFD,CAFa,CAKb;;;MACAyB,MAAM,CAACC,cAAP,CAAsBF,IAAI,CAACG,SAA3B,EAAsC,OAAtC,EAA+C;QAC7CC,GAAG,EAAE,YAAW;UACd;UACA;UACA,MAAM5B,KAAK,EAAX;QACD;MAL4C,CAA/C;;MAOA,IAAI,OAAO6B,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACb,SAA3C,EAAsD;QACpD;QACA;QACA,IAAI;UACFa,OAAO,CAACb,SAAR,CAAkBQ,IAAlB,EAAwB,EAAxB;QACD,CAFD,CAEE,OAAOvB,CAAP,EAAU;UACVkB,OAAO,GAAGlB,CAAV;QACD;;QACD4B,OAAO,CAACb,SAAR,CAAkBD,EAAlB,EAAsB,EAAtB,EAA0BS,IAA1B;MACD,CATD,MASO;QACL,IAAI;UACFA,IAAI,CAACM,IAAL;QACD,CAFD,CAEE,OAAO7B,CAAP,EAAU;UACVkB,OAAO,GAAGlB,CAAV;QACD;;QACDc,EAAE,CAACe,IAAH,CAAQN,IAAI,CAACG,SAAb;MACD;IACF,CA9BD,MA8BO;MACL,IAAI;QACF,MAAM3B,KAAK,EAAX;MACD,CAFD,CAEE,OAAOC,CAAP,EAAU;QACVkB,OAAO,GAAGlB,CAAV;MACD;;MACDc,EAAE;IACH;EACF,CAxCD,CAwCE,OAAOgB,MAAP,EAAe;IACf;IACA,IAAIA,MAAM,IAAIZ,OAAV,IAAqB,OAAOY,MAAM,CAAC5B,KAAd,KAAwB,QAAjD,EAA2D;MACzD;MACA;MACA,MAAM6B,WAAW,GAAGD,MAAM,CAAC5B,KAAP,CAAa8B,KAAb,CAAmB,IAAnB,CAApB;MACA,MAAMC,YAAY,GAAGf,OAAO,CAAChB,KAAR,CAAc8B,KAAd,CAAoB,IAApB,CAArB;MACA,IAAIE,CAAC,GAAGH,WAAW,CAACI,MAAZ,GAAqB,CAA7B;MACA,IAAIC,CAAC,GAAGH,YAAY,CAACE,MAAb,GAAsB,CAA9B;;MACA,OAAOD,CAAC,IAAI,CAAL,IAAUE,CAAC,IAAI,CAAf,IAAoBL,WAAW,CAACG,CAAD,CAAX,KAAmBD,YAAY,CAACG,CAAD,CAA1D,EAA+D;QAC7D;QACA;QACA;QACA;QACA;QACA;QACAA,CAAC;MACF;;MACD,OAAOF,CAAC,IAAI,CAAL,IAAUE,CAAC,IAAI,CAAtB,EAAyBF,CAAC,IAAIE,CAAC,EAA/B,EAAmC;QACjC;QACA;QACA,IAAIL,WAAW,CAACG,CAAD,CAAX,KAAmBD,YAAY,CAACG,CAAD,CAAnC,EAAwC;UACtC;UACA;UACA;UACA;UACA;UACA,IAAIF,CAAC,KAAK,CAAN,IAAWE,CAAC,KAAK,CAArB,EAAwB;YACtB,GAAG;cACDF,CAAC;cACDE,CAAC,GAFA,CAGD;cACA;;cACA,IAAIA,CAAC,GAAG,CAAJ,IAASL,WAAW,CAACG,CAAD,CAAX,KAAmBD,YAAY,CAACG,CAAD,CAA5C,EAAiD;gBAC/C;gBACA,IAAIpB,KAAK,GAAG,OAAOe,WAAW,CAACG,CAAD,CAAX,CAAeG,OAAf,CAAuB,UAAvB,EAAmC,MAAnC,CAAnB,CAF+C,CAI/C;gBACA;gBACA;;gBACA,IAAIvB,EAAE,CAACR,WAAH,IAAkBU,KAAK,CAACsB,QAAN,CAAe,aAAf,CAAtB,EAAqD;kBACnDtB,KAAK,GAAGA,KAAK,CAACqB,OAAN,CAAc,aAAd,EAA6BvB,EAAE,CAACR,WAAhC,CAAR;gBACD;;gBAED,IAAID,OAAJ,EAAa;kBACX,IAAI,OAAOS,EAAP,KAAc,UAAlB,EAA8B;oBAC5BL,mBAAmB,CAACkB,GAApB,CAAwBb,EAAxB,EAA4BE,KAA5B;kBACD;gBACF,CAf8C,CAgB/C;;;gBACA,OAAOA,KAAP;cACD;YACF,CAxBD,QAwBSkB,CAAC,IAAI,CAAL,IAAUE,CAAC,IAAI,CAxBxB;UAyBD;;UACD;QACD;MACF;IACF;EACF,CAlGD,SAkGU;IACR5B,OAAO,GAAG,KAAV;;IACA,IAAIH,OAAJ,EAAa;MACXb,sBAAsB,CAAC8B,OAAvB,GAAiCD,kBAAjC;MACA/B,YAAY;IACb;;IACDS,KAAK,CAACqB,iBAAN,GAA0BD,yBAA1B;EACD,CApIO,CAqIR;;;EACA,MAAMxB,IAAI,GAAGmB,EAAE,GAAGA,EAAE,CAACR,WAAH,IAAkBQ,EAAE,CAACnB,IAAxB,GAA+B,EAA9C;EACA,MAAM4C,cAAc,GAAG5C,IAAI,GAAGD,6BAA6B,CAACC,IAAD,CAAhC,GAAyC,EAApE;;EACA,IAAIU,OAAJ,EAAa;IACX,IAAI,OAAOS,EAAP,KAAc,UAAlB,EAA8B;MAC5BL,mBAAmB,CAACkB,GAApB,CAAwBb,EAAxB,EAA4ByB,cAA5B;IACD;EACF;;EACD,OAAOA,cAAP;AACD;AAED,MAAMC,eAAe,GAAG,aAAxB;;AAEA,SAASjC,sBAAT,CACEZ,IADF,EAEEC,MAFF,EAGEQ,SAHF,EAIE;EACA,IAAIqC,UAAU,GAAG,EAAjB;;EACA,IAAIpC,OAAO,IAAIT,MAAf,EAAuB;IACrB,MAAM8C,IAAI,GAAG9C,MAAM,CAAC+C,QAApB;IACA,IAAIA,QAAQ,GAAGD,IAAI,CAACL,OAAL,CAAaG,eAAb,EAA8B,EAA9B,CAAf,CAFqB,CAGrB;IACA;;IACA,IAAI,WAAWI,IAAX,CAAgBD,QAAhB,CAAJ,EAA+B;MAC7B,MAAM1C,KAAK,GAAGyC,IAAI,CAACzC,KAAL,CAAWuC,eAAX,CAAd;;MACA,IAAIvC,KAAJ,EAAW;QACT,MAAM4C,eAAe,GAAG5C,KAAK,CAAC,CAAD,CAA7B;;QACA,IAAI4C,eAAJ,EAAqB;UACnB,MAAMC,UAAU,GAAGD,eAAe,CAACR,OAAhB,CAAwBG,eAAxB,EAAyC,EAAzC,CAAnB;UACAG,QAAQ,GAAGG,UAAU,GAAG,GAAb,GAAmBH,QAA9B;QACD;MACF;IACF;;IACDF,UAAU,GAAG,UAAUE,QAAV,GAAqB,GAArB,GAA2B/C,MAAM,CAACmD,UAAlC,GAA+C,GAA5D;EACD,CAhBD,MAgBO,IAAI3C,SAAJ,EAAe;IACpBqC,UAAU,GAAG,kBAAkBrC,SAAlB,GAA8B,GAA3C;EACD;;EACD,OAAO,eAAeT,IAAI,IAAI,SAAvB,IAAoC8C,UAA3C;AACD;;AAED,OAAO,SAASO,2BAAT,CACLC,IADK,EAELrD,MAFK,EAGLC,OAHK,EAIG;EACR,IAAIf,6BAAJ,EAAmC;IACjC,OAAO+B,4BAA4B,CAACoC,IAAD,EAAO,IAAP,CAAnC;EACD,CAFD,MAEO;IACL,OAAOC,8BAA8B,CAACD,IAAD,EAAOrD,MAAP,EAAeC,OAAf,CAArC;EACD;AACF;AAED,OAAO,SAASqD,8BAAT,CACLpC,EADK,EAELlB,MAFK,EAGLC,OAHK,EAIG;EACR,IAAIf,6BAAJ,EAAmC;IACjC,OAAO+B,4BAA4B,CAACC,EAAD,EAAK,KAAL,CAAnC;EACD,CAFD,MAEO;IACL,IAAI,CAACA,EAAL,EAAS;MACP,OAAO,EAAP;IACD;;IACD,MAAMnB,IAAI,GAAGmB,EAAE,CAACR,WAAH,IAAkBQ,EAAE,CAACnB,IAArB,IAA6B,IAA1C;IACA,IAAIS,SAAS,GAAG,IAAhB;;IACA,IAAIC,OAAO,IAAIR,OAAf,EAAwB;MACtBO,SAAS,GAAGP,OAAO,CAACS,WAAR,IAAuBT,OAAO,CAACF,IAA/B,IAAuC,IAAnD;IACD;;IACD,OAAOY,sBAAsB,CAACZ,IAAD,EAAOC,MAAP,EAAeQ,SAAf,CAA7B;EACD;AACF;;AAED,SAAS+C,eAAT,CAAyBC,SAAzB,EAA8C;EAC5C,MAAM1B,SAAS,GAAG0B,SAAS,CAAC1B,SAA5B;EACA,OAAO,CAAC,EAAEA,SAAS,IAAIA,SAAS,CAAC2B,gBAAzB,CAAR;AACD;;AAED,OAAO,SAASC,oCAAT,CACLC,IADK,EAEL3D,MAFK,EAGLC,OAHK,EAIG;EACR,IAAI,CAACQ,OAAL,EAAc;IACZ,OAAO,EAAP;EACD;;EACD,IAAIkD,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAO,EAAP;EACD;;EACD,IAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;IAC9B,IAAIzE,6BAAJ,EAAmC;MACjC,OAAO+B,4BAA4B,CAAC0C,IAAD,EAAOJ,eAAe,CAACI,IAAD,CAAtB,CAAnC;IACD,CAFD,MAEO;MACL,OAAOL,8BAA8B,CAACK,IAAD,EAAO3D,MAAP,EAAeC,OAAf,CAArC;IACD;EACF;;EACD,IAAI,OAAO0D,IAAP,KAAgB,QAApB,EAA8B;IAC5B,OAAO7D,6BAA6B,CAAC6D,IAAD,EAAO3D,MAAP,EAAeC,OAAf,CAApC;EACD;;EACD,QAAQ0D,IAAR;IACE,KAAKvE,mBAAL;MACE,OAAOU,6BAA6B,CAAC,UAAD,EAAaE,MAAb,EAAqBC,OAArB,CAApC;;IACF,KAAKZ,wBAAL;MACE,OAAOS,6BAA6B,CAAC,cAAD,EAAiBE,MAAjB,EAAyBC,OAAzB,CAApC;EAJJ;;EAMA,IAAI,OAAO0D,IAAP,KAAgB,QAApB,EAA8B;IAC5B,QAAQA,IAAI,CAACC,QAAb;MACE,KAAKtE,sBAAL;QACE,OAAOgE,8BAA8B,CAACK,IAAI,CAACE,MAAN,EAAc7D,MAAd,EAAsBC,OAAtB,CAArC;;MACF,KAAKV,eAAL;QACE;QACA,OAAOmE,oCAAoC,CAACC,IAAI,CAACA,IAAN,EAAY3D,MAAZ,EAAoBC,OAApB,CAA3C;;MACF,KAAKT,eAAL;QAAsB;UACpB,MAAMsE,aAAsC,GAAIH,IAAhD;UACA,MAAMI,OAAO,GAAGD,aAAa,CAACE,QAA9B;UACA,MAAMC,IAAI,GAAGH,aAAa,CAACI,KAA3B;;UACA,IAAI;YACF;YACA,OAAOR,oCAAoC,CACzCO,IAAI,CAACF,OAAD,CADqC,EAEzC/D,MAFyC,EAGzCC,OAHyC,CAA3C;UAKD,CAPD,CAOE,OAAOG,CAAP,EAAU,CAAE;QACf;IAlBH;EAoBD;;EACD,OAAO,EAAP;AACD"},"metadata":{},"sourceType":"module"}