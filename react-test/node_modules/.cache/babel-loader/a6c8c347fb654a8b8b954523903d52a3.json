{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport * as React from 'react';\nimport { LayoutStatic, MountLayoutDev, Update, Snapshot } from './ReactFiberFlags';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, enableDebugTracing, enableSchedulingProfiler, warnAboutDeprecatedLifecycles, enableStrictEffects, enableLazyContextPropagation, enableSuspenseLayoutEffectSemantics } from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\nimport { isMounted } from './ReactFiberTreeReflection';\nimport { get as getInstance, set as setInstance } from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport assign from 'shared/assign';\nimport isArray from 'shared/isArray';\nimport { REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE } from 'shared/ReactSymbols';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.old';\nimport { DebugTracingMode, NoMode, StrictLegacyMode, StrictEffectsMode } from './ReactTypeOfMode';\nimport { enqueueUpdate, entangleTransitions, processUpdateQueue, checkHasForceUpdateAfterProcessing, resetHasForceUpdateBeforeProcessing, createUpdate, ReplaceState, ForceUpdate, initializeUpdateQueue, cloneUpdateQueue } from './ReactUpdateQueue.old';\nimport { NoLanes } from './ReactFiberLane.old';\nimport { cacheContext, getMaskedContext, getUnmaskedContext, hasContextChanged, emptyContextObject } from './ReactFiberContext.old';\nimport { readContext, checkIfContextChanged } from './ReactFiberNewContext.old';\nimport { requestEventTime, requestUpdateLane, scheduleUpdateOnFiber } from './ReactFiberWorkLoop.old';\nimport { logForceUpdateScheduled, logStateUpdateScheduled } from './DebugTracing';\nimport { markForceUpdateScheduled, markStateUpdateScheduled, setIsStrictModeForDevtools } from './ReactFiberDevToolsHook.old';\nconst fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\n\nexport const emptyRefsObject = new React.Component().refs;\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n\n    const key = callerName + '_' + callback;\n\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      console.error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentNameFromType(type) || 'Component';\n\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        console.error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  }; // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n\n\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  const prevState = workInProgress.memoizedState;\n  let partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        // Invoke the function an extra time to help detect side-effects.\n        partialState = getDerivedStateFromProps(nextProps, prevState);\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    warnOnUndefinedDerivedState(ctor, partialState);\n  } // Merge the partial state and the previous state.\n\n\n  const memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n  // base state.\n\n  if (workInProgress.lanes === NoLanes) {\n    // Queue is always non-null for classes\n    const updateQueue = workInProgress.updateQueue;\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nconst classComponentUpdater = {\n  isMounted,\n\n  // this.setState\n  enqueueSetState(inst, payload, callback) {\n    // 通过组件实例获取对应fiber\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime(); // 获取优先级\n\n    const lane = requestUpdateLane(fiber); // 创建update\n\n    const update = createUpdate(eventTime, lane); // 这里值得注意的是对于ClassComponent，update.payload为this.setState的第一个传参（即要改变的state）\n\n    update.payload = payload; // 赋值回调函数\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    } // 将update插入updateQueue\n\n\n    enqueueUpdate(fiber, update, lane); // 调度update\n\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logStateUpdateScheduled(name, lane, payload);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n    const update = createUpdate(eventTime, lane);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logStateUpdateScheduled(name, lane, payload);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n\n  // this.forceUpdate\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n    const update = createUpdate(eventTime, lane); // 当tag为ForceUpdate\n\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logForceUpdateScheduled(name, lane);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markForceUpdateScheduled(fiber, lane);\n    }\n  }\n\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  const instance = workInProgress.stateNode;\n\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    let shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n\n    if (__DEV__) {\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          // Invoke the function an extra time to help detect side-effects.\n          shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      if (shouldUpdate === undefined) {\n        console.error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  const instance = workInProgress.stateNode;\n\n  if (__DEV__) {\n    const name = getComponentNameFromType(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        console.error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        console.error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n      console.error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n    }\n\n    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n      console.error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n    }\n\n    if (instance.propTypes) {\n      console.error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n    }\n\n    if (instance.contextType) {\n      console.error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n    }\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        console.error('%s uses the legacy childContextTypes API which is no longer supported. ' + 'Use React.createContext() instead.', name);\n      }\n\n      if (ctor.contextTypes) {\n        console.error('%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with static contextType instead.', name);\n      }\n    } else {\n      if (instance.contextTypes) {\n        console.error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      }\n\n      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        console.error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      console.error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      console.error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n    }\n\n    if (typeof instance.componentDidUnmount === 'function') {\n      console.error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n    }\n\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      console.error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n    }\n\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      console.error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n    }\n\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      console.error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n    }\n\n    const hasMutatedProps = instance.props !== newProps;\n\n    if (instance.props !== undefined && hasMutatedProps) {\n      console.error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n    }\n\n    if (instance.defaultProps) {\n      console.error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      console.error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      console.error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      console.error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      console.error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n    }\n\n    const state = instance.state;\n\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      console.error('%s.state: must be set to an object or null', name);\n    }\n\n    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n      console.error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n  setInstance(instance, workInProgress);\n\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props) {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      const isValid = // Allow null for conditional declaration\n      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n        let addendum = '';\n\n        if (contextType === undefined) {\n          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n        }\n\n        console.error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n  }\n\n  let instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        instance = new ctor(props, context); // eslint-disable-line no-new\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n  }\n\n  const state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        console.error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        const componentName = getComponentNameFromType(ctor) || 'Component';\n        const newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          console.error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', componentName, newApiName, foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '', foundWillReceivePropsName !== null ? `\\n  ${foundWillReceivePropsName}` : '', foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '');\n        }\n      }\n    }\n  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      console.error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        console.error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\nfunction mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  initializeUpdateQueue(workInProgress);\n  const contextType = ctor.contextType;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        console.error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n    }\n  }\n\n  instance.state = workInProgress.memoizedState;\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  } // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n    // process them now.\n\n    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    let fiberFlags = Update;\n\n    if (enableSuspenseLayoutEffectSemantics) {\n      fiberFlags |= LayoutStatic;\n    }\n\n    if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n      fiberFlags |= MountLayoutDev;\n    }\n\n    workInProgress.flags |= fiberFlags;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  const instance = workInProgress.stateNode;\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags = Update;\n\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n    }\n\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags = Update;\n\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags = Update;\n\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n  const instance = workInProgress.stateNode;\n  cloneUpdateQueue(current, workInProgress);\n  const unresolvedOldProps = workInProgress.memoizedProps;\n  const oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n  instance.props = oldProps;\n  const unresolvedNewProps = workInProgress.pendingProps;\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(enableLazyContextPropagation && current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies))) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n  // both before and after `shouldComponentUpdate` has been called. Not ideal,\n  // but I'm loath to refactor this function. This only happens for memoized\n  // components so it's not that common.\n  enableLazyContextPropagation && current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n    }\n\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.flags |= Update;\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.flags |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n}\n\nexport { adoptClassInstance, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance };","map":{"version":3,"names":["React","LayoutStatic","MountLayoutDev","Update","Snapshot","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","enableDebugTracing","enableSchedulingProfiler","warnAboutDeprecatedLifecycles","enableStrictEffects","enableLazyContextPropagation","enableSuspenseLayoutEffectSemantics","ReactStrictModeWarnings","isMounted","get","getInstance","set","setInstance","shallowEqual","getComponentNameFromFiber","getComponentNameFromType","assign","isArray","REACT_CONTEXT_TYPE","REACT_PROVIDER_TYPE","resolveDefaultProps","DebugTracingMode","NoMode","StrictLegacyMode","StrictEffectsMode","enqueueUpdate","entangleTransitions","processUpdateQueue","checkHasForceUpdateAfterProcessing","resetHasForceUpdateBeforeProcessing","createUpdate","ReplaceState","ForceUpdate","initializeUpdateQueue","cloneUpdateQueue","NoLanes","cacheContext","getMaskedContext","getUnmaskedContext","hasContextChanged","emptyContextObject","readContext","checkIfContextChanged","requestEventTime","requestUpdateLane","scheduleUpdateOnFiber","logForceUpdateScheduled","logStateUpdateScheduled","markForceUpdateScheduled","markStateUpdateScheduled","setIsStrictModeForDevtools","fakeInternalInstance","emptyRefsObject","Component","refs","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnAboutDirectlyAssigningPropsToState","didWarnAboutContextTypeAndContextTypes","didWarnAboutInvalidateContextType","__DEV__","Set","didWarnOnInvalidCallback","callback","callerName","key","has","add","console","error","type","partialState","undefined","componentName","Object","defineProperty","enumerable","value","Error","freeze","applyDerivedStateFromProps","workInProgress","ctor","getDerivedStateFromProps","nextProps","prevState","memoizedState","mode","lanes","updateQueue","baseState","classComponentUpdater","enqueueSetState","inst","payload","fiber","eventTime","lane","update","root","name","enqueueReplaceState","tag","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","nextContext","instance","stateNode","shouldComponentUpdate","shouldUpdate","prototype","isPureReactComponent","checkClassInstance","renderPresent","render","getInitialState","isReactClassApproved","state","getDefaultProps","propTypes","contextType","childContextTypes","contextTypes","componentShouldUpdate","componentDidUnmount","componentDidReceiveProps","componentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","props","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","getDerivedStateFromError","getChildContext","adoptClassInstance","updater","_reactInternalInstance","constructClassInstance","isLegacyContextConsumer","unmaskedContext","context","isValid","$$typeof","_context","addendum","keys","join","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","componentWillMount","__suppressDeprecationWarning","UNSAFE_componentWillMount","componentWillReceiveProps","UNSAFE_componentWillReceiveProps","componentWillUpdate","UNSAFE_componentWillUpdate","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","renderLanes","recordLegacyContextWarning","recordUnsafeLifecycleWarnings","componentDidMount","fiberFlags","flags","resumeMountClassInstance","memoizedProps","oldContext","nextLegacyUnmaskedContext","hasNewLifecycles","updateClassInstance","current","unresolvedOldProps","elementType","unresolvedNewProps","pendingProps","nextUnmaskedContext","dependencies"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberClassComponent.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { Fiber } from './ReactInternalTypes';\r\nimport type { Lanes } from './ReactFiberLane.old';\r\nimport type { UpdateQueue } from './ReactUpdateQueue.old';\r\nimport type { Flags } from './ReactFiberFlags';\r\n\r\nimport * as React from 'react';\r\nimport {\r\n  LayoutStatic,\r\n  MountLayoutDev,\r\n  Update,\r\n  Snapshot,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  debugRenderPhaseSideEffectsForStrictMode,\r\n  disableLegacyContext,\r\n  enableDebugTracing,\r\n  enableSchedulingProfiler,\r\n  warnAboutDeprecatedLifecycles,\r\n  enableStrictEffects,\r\n  enableLazyContextPropagation,\r\n  enableSuspenseLayoutEffectSemantics,\r\n} from 'shared/ReactFeatureFlags';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport { isMounted } from './ReactFiberTreeReflection';\r\nimport { get as getInstance, set as setInstance } from 'shared/ReactInstanceMap';\r\nimport shallowEqual from 'shared/shallowEqual';\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\r\nimport assign from 'shared/assign';\r\nimport isArray from 'shared/isArray';\r\nimport { REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE } from 'shared/ReactSymbols';\r\n\r\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.old';\r\nimport {\r\n  DebugTracingMode,\r\n  NoMode,\r\n  StrictLegacyMode,\r\n  StrictEffectsMode,\r\n} from './ReactTypeOfMode';\r\n\r\nimport {\r\n  enqueueUpdate,\r\n  entangleTransitions,\r\n  processUpdateQueue,\r\n  checkHasForceUpdateAfterProcessing,\r\n  resetHasForceUpdateBeforeProcessing,\r\n  createUpdate,\r\n  ReplaceState,\r\n  ForceUpdate,\r\n  initializeUpdateQueue,\r\n  cloneUpdateQueue,\r\n} from './ReactUpdateQueue.old';\r\nimport { NoLanes } from './ReactFiberLane.old';\r\nimport {\r\n  cacheContext,\r\n  getMaskedContext,\r\n  getUnmaskedContext,\r\n  hasContextChanged,\r\n  emptyContextObject,\r\n} from './ReactFiberContext.old';\r\nimport { readContext, checkIfContextChanged } from './ReactFiberNewContext.old';\r\nimport {\r\n  requestEventTime,\r\n  requestUpdateLane,\r\n  scheduleUpdateOnFiber,\r\n} from './ReactFiberWorkLoop.old';\r\nimport { logForceUpdateScheduled, logStateUpdateScheduled } from './DebugTracing';\r\nimport {\r\n  markForceUpdateScheduled,\r\n  markStateUpdateScheduled,\r\n  setIsStrictModeForDevtools,\r\n} from './ReactFiberDevToolsHook.old';\r\n\r\nconst fakeInternalInstance = {};\r\n\r\n// React.Component uses a shared frozen object by default.\r\n// We'll use it to determine whether we need to initialize legacy refs.\r\nexport const emptyRefsObject = new React.Component().refs;\r\n\r\nlet didWarnAboutStateAssignmentForComponent;\r\nlet didWarnAboutUninitializedState;\r\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\r\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\r\nlet didWarnAboutUndefinedDerivedState;\r\nlet warnOnUndefinedDerivedState;\r\nlet warnOnInvalidCallback;\r\nlet didWarnAboutDirectlyAssigningPropsToState;\r\nlet didWarnAboutContextTypeAndContextTypes;\r\nlet didWarnAboutInvalidateContextType;\r\n\r\nif (__DEV__) {\r\n  didWarnAboutStateAssignmentForComponent = new Set();\r\n  didWarnAboutUninitializedState = new Set();\r\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\r\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\r\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\r\n  didWarnAboutUndefinedDerivedState = new Set();\r\n  didWarnAboutContextTypeAndContextTypes = new Set();\r\n  didWarnAboutInvalidateContextType = new Set();\r\n\r\n  const didWarnOnInvalidCallback = new Set();\r\n\r\n  warnOnInvalidCallback = function (callback: mixed, callerName: string) {\r\n    if (callback === null || typeof callback === 'function') {\r\n      return;\r\n    }\r\n    const key = callerName + '_' + (callback: any);\r\n    if (!didWarnOnInvalidCallback.has(key)) {\r\n      didWarnOnInvalidCallback.add(key);\r\n      console.error(\r\n        '%s(...): Expected the last optional `callback` argument to be a ' +\r\n        'function. Instead received: %s.',\r\n        callerName,\r\n        callback,\r\n      );\r\n    }\r\n  };\r\n\r\n  warnOnUndefinedDerivedState = function (type, partialState) {\r\n    if (partialState === undefined) {\r\n      const componentName = getComponentNameFromType(type) || 'Component';\r\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\r\n        didWarnAboutUndefinedDerivedState.add(componentName);\r\n        console.error(\r\n          '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' +\r\n          'You have returned undefined.',\r\n          componentName,\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  // This is so gross but it's at least non-critical and can be removed if\r\n  // it causes problems. This is meant to give a nicer error message for\r\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\r\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\r\n  // exception.\r\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\r\n    enumerable: false,\r\n    value: function () {\r\n      throw new Error(\r\n        '_processChildContext is not available in React 16+. This likely ' +\r\n        'means you have multiple copies of React and are attempting to nest ' +\r\n        'a React 15 tree inside a React 16 tree using ' +\r\n        \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\r\n        'to make sure you have only one copy of React (and ideally, switch ' +\r\n        'to ReactDOM.createPortal).',\r\n      );\r\n    },\r\n  });\r\n  Object.freeze(fakeInternalInstance);\r\n}\r\n\r\nfunction applyDerivedStateFromProps (\r\n  workInProgress: Fiber,\r\n  ctor: any,\r\n  getDerivedStateFromProps: (props: any, state: any) => any,\r\n  nextProps: any,\r\n) {\r\n  const prevState = workInProgress.memoizedState;\r\n  let partialState = getDerivedStateFromProps(nextProps, prevState);\r\n  if (__DEV__) {\r\n    if (\r\n      debugRenderPhaseSideEffectsForStrictMode &&\r\n      workInProgress.mode & StrictLegacyMode\r\n    ) {\r\n      setIsStrictModeForDevtools(true);\r\n      try {\r\n        // Invoke the function an extra time to help detect side-effects.\r\n        partialState = getDerivedStateFromProps(nextProps, prevState);\r\n      } finally {\r\n        setIsStrictModeForDevtools(false);\r\n      }\r\n    }\r\n    warnOnUndefinedDerivedState(ctor, partialState);\r\n  }\r\n  // Merge the partial state and the previous state.\r\n  const memoizedState =\r\n    partialState === null || partialState === undefined\r\n      ? prevState\r\n      : assign({}, prevState, partialState);\r\n  workInProgress.memoizedState = memoizedState;\r\n\r\n  // Once the update queue is empty, persist the derived state onto the\r\n  // base state.\r\n  if (workInProgress.lanes === NoLanes) {\r\n    // Queue is always non-null for classes\r\n    const updateQueue: UpdateQueue<any> = (workInProgress.updateQueue: any);\r\n    updateQueue.baseState = memoizedState;\r\n  }\r\n}\r\n\r\nconst classComponentUpdater = {\r\n  isMounted,\r\n  // this.setState\r\n  enqueueSetState (inst, payload, callback) {\r\n    // 通过组件实例获取对应fiber\r\n    const fiber = getInstance(inst);\r\n    const eventTime = requestEventTime();\r\n    // 获取优先级\r\n    const lane = requestUpdateLane(fiber);\r\n    // 创建update\r\n    const update = createUpdate(eventTime, lane);\r\n\r\n    // 这里值得注意的是对于ClassComponent，update.payload为this.setState的第一个传参（即要改变的state）\r\n    update.payload = payload;\r\n\r\n    // 赋值回调函数\r\n    if (callback !== undefined && callback !== null) {\r\n      if (__DEV__) {\r\n        warnOnInvalidCallback(callback, 'setState');\r\n      }\r\n      update.callback = callback;\r\n    }\r\n    // 将update插入updateQueue\r\n    enqueueUpdate(fiber, update, lane);\r\n    // 调度update\r\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n    if (root !== null) {\r\n      entangleTransitions(root, fiber, lane);\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        if (fiber.mode & DebugTracingMode) {\r\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\r\n          logStateUpdateScheduled(name, lane, payload);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markStateUpdateScheduled(fiber, lane);\r\n    }\r\n  },\r\n  enqueueReplaceState (inst, payload, callback) {\r\n    const fiber = getInstance(inst);\r\n    const eventTime = requestEventTime();\r\n    const lane = requestUpdateLane(fiber);\r\n\r\n    const update = createUpdate(eventTime, lane);\r\n    update.tag = ReplaceState;\r\n    update.payload = payload;\r\n\r\n    if (callback !== undefined && callback !== null) {\r\n      if (__DEV__) {\r\n        warnOnInvalidCallback(callback, 'replaceState');\r\n      }\r\n      update.callback = callback;\r\n    }\r\n\r\n    enqueueUpdate(fiber, update, lane);\r\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n    if (root !== null) {\r\n      entangleTransitions(root, fiber, lane);\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        if (fiber.mode & DebugTracingMode) {\r\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\r\n          logStateUpdateScheduled(name, lane, payload);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markStateUpdateScheduled(fiber, lane);\r\n    }\r\n  },\r\n  // this.forceUpdate\r\n  enqueueForceUpdate (inst, callback) {\r\n    const fiber = getInstance(inst);\r\n    const eventTime = requestEventTime();\r\n    const lane = requestUpdateLane(fiber);\r\n\r\n    const update = createUpdate(eventTime, lane);\r\n\r\n    // 当tag为ForceUpdate\r\n    update.tag = ForceUpdate;\r\n\r\n    if (callback !== undefined && callback !== null) {\r\n      if (__DEV__) {\r\n        warnOnInvalidCallback(callback, 'forceUpdate');\r\n      }\r\n      update.callback = callback;\r\n    }\r\n\r\n    enqueueUpdate(fiber, update, lane);\r\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n    if (root !== null) {\r\n      entangleTransitions(root, fiber, lane);\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        if (fiber.mode & DebugTracingMode) {\r\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\r\n          logForceUpdateScheduled(name, lane);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (enableSchedulingProfiler) {\r\n      markForceUpdateScheduled(fiber, lane);\r\n    }\r\n  },\r\n};\r\n\r\nfunction checkShouldComponentUpdate (\r\n  workInProgress,\r\n  ctor,\r\n  oldProps,\r\n  newProps,\r\n  oldState,\r\n  newState,\r\n  nextContext,\r\n) {\r\n  const instance = workInProgress.stateNode;\r\n  if (typeof instance.shouldComponentUpdate === 'function') {\r\n    let shouldUpdate = instance.shouldComponentUpdate(\r\n      newProps,\r\n      newState,\r\n      nextContext,\r\n    );\r\n    if (__DEV__) {\r\n      if (\r\n        debugRenderPhaseSideEffectsForStrictMode &&\r\n        workInProgress.mode & StrictLegacyMode\r\n      ) {\r\n        setIsStrictModeForDevtools(true);\r\n        try {\r\n          // Invoke the function an extra time to help detect side-effects.\r\n          shouldUpdate = instance.shouldComponentUpdate(\r\n            newProps,\r\n            newState,\r\n            nextContext,\r\n          );\r\n        } finally {\r\n          setIsStrictModeForDevtools(false);\r\n        }\r\n      }\r\n      if (shouldUpdate === undefined) {\r\n        console.error(\r\n          '%s.shouldComponentUpdate(): Returned undefined instead of a ' +\r\n          'boolean value. Make sure to return true or false.',\r\n          getComponentNameFromType(ctor) || 'Component',\r\n        );\r\n      }\r\n    }\r\n\r\n    return shouldUpdate;\r\n  }\r\n\r\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\r\n    return (\r\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\r\n    );\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction checkClassInstance (workInProgress: Fiber, ctor: any, newProps: any) {\r\n  const instance = workInProgress.stateNode;\r\n  if (__DEV__) {\r\n    const name = getComponentNameFromType(ctor) || 'Component';\r\n    const renderPresent = instance.render;\r\n\r\n    if (!renderPresent) {\r\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\r\n        console.error(\r\n          '%s(...): No `render` method found on the returned component ' +\r\n          'instance: did you accidentally return an object from the constructor?',\r\n          name,\r\n        );\r\n      } else {\r\n        console.error(\r\n          '%s(...): No `render` method found on the returned component ' +\r\n          'instance: you may have forgotten to define `render`.',\r\n          name,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      instance.getInitialState &&\r\n      !instance.getInitialState.isReactClassApproved &&\r\n      !instance.state\r\n    ) {\r\n      console.error(\r\n        'getInitialState was defined on %s, a plain JavaScript class. ' +\r\n        'This is only supported for classes created using React.createClass. ' +\r\n        'Did you mean to define a state property instead?',\r\n        name,\r\n      );\r\n    }\r\n    if (\r\n      instance.getDefaultProps &&\r\n      !instance.getDefaultProps.isReactClassApproved\r\n    ) {\r\n      console.error(\r\n        'getDefaultProps was defined on %s, a plain JavaScript class. ' +\r\n        'This is only supported for classes created using React.createClass. ' +\r\n        'Use a static property to define defaultProps instead.',\r\n        name,\r\n      );\r\n    }\r\n    if (instance.propTypes) {\r\n      console.error(\r\n        'propTypes was defined as an instance property on %s. Use a static ' +\r\n        'property to define propTypes instead.',\r\n        name,\r\n      );\r\n    }\r\n    if (instance.contextType) {\r\n      console.error(\r\n        'contextType was defined as an instance property on %s. Use a static ' +\r\n        'property to define contextType instead.',\r\n        name,\r\n      );\r\n    }\r\n\r\n    if (disableLegacyContext) {\r\n      if (ctor.childContextTypes) {\r\n        console.error(\r\n          '%s uses the legacy childContextTypes API which is no longer supported. ' +\r\n          'Use React.createContext() instead.',\r\n          name,\r\n        );\r\n      }\r\n      if (ctor.contextTypes) {\r\n        console.error(\r\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\r\n          'Use React.createContext() with static contextType instead.',\r\n          name,\r\n        );\r\n      }\r\n    } else {\r\n      if (instance.contextTypes) {\r\n        console.error(\r\n          'contextTypes was defined as an instance property on %s. Use a static ' +\r\n          'property to define contextTypes instead.',\r\n          name,\r\n        );\r\n      }\r\n\r\n      if (\r\n        ctor.contextType &&\r\n        ctor.contextTypes &&\r\n        !didWarnAboutContextTypeAndContextTypes.has(ctor)\r\n      ) {\r\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\r\n        console.error(\r\n          '%s declares both contextTypes and contextType static properties. ' +\r\n          'The legacy contextTypes property will be ignored.',\r\n          name,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (typeof instance.componentShouldUpdate === 'function') {\r\n      console.error(\r\n        '%s has a method called ' +\r\n        'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\r\n        'The name is phrased as a question because the function is ' +\r\n        'expected to return a value.',\r\n        name,\r\n      );\r\n    }\r\n    if (\r\n      ctor.prototype &&\r\n      ctor.prototype.isPureReactComponent &&\r\n      typeof instance.shouldComponentUpdate !== 'undefined'\r\n    ) {\r\n      console.error(\r\n        '%s has a method called shouldComponentUpdate(). ' +\r\n        'shouldComponentUpdate should not be used when extending React.PureComponent. ' +\r\n        'Please extend React.Component if shouldComponentUpdate is used.',\r\n        getComponentNameFromType(ctor) || 'A pure component',\r\n      );\r\n    }\r\n    if (typeof instance.componentDidUnmount === 'function') {\r\n      console.error(\r\n        '%s has a method called ' +\r\n        'componentDidUnmount(). But there is no such lifecycle method. ' +\r\n        'Did you mean componentWillUnmount()?',\r\n        name,\r\n      );\r\n    }\r\n    if (typeof instance.componentDidReceiveProps === 'function') {\r\n      console.error(\r\n        '%s has a method called ' +\r\n        'componentDidReceiveProps(). But there is no such lifecycle method. ' +\r\n        'If you meant to update the state in response to changing props, ' +\r\n        'use componentWillReceiveProps(). If you meant to fetch data or ' +\r\n        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',\r\n        name,\r\n      );\r\n    }\r\n    if (typeof instance.componentWillRecieveProps === 'function') {\r\n      console.error(\r\n        '%s has a method called ' +\r\n        'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\r\n        name,\r\n      );\r\n    }\r\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\r\n      console.error(\r\n        '%s has a method called ' +\r\n        'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',\r\n        name,\r\n      );\r\n    }\r\n    const hasMutatedProps = instance.props !== newProps;\r\n    if (instance.props !== undefined && hasMutatedProps) {\r\n      console.error(\r\n        '%s(...): When calling super() in `%s`, make sure to pass ' +\r\n        \"up the same props that your component's constructor was passed.\",\r\n        name,\r\n        name,\r\n      );\r\n    }\r\n    if (instance.defaultProps) {\r\n      console.error(\r\n        'Setting defaultProps as an instance property on %s is not supported and will be ignored.' +\r\n        ' Instead, define defaultProps as a static property on %s.',\r\n        name,\r\n        name,\r\n      );\r\n    }\r\n\r\n    if (\r\n      typeof instance.getSnapshotBeforeUpdate === 'function' &&\r\n      typeof instance.componentDidUpdate !== 'function' &&\r\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\r\n    ) {\r\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\r\n      console.error(\r\n        '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' +\r\n        'This component defines getSnapshotBeforeUpdate() only.',\r\n        getComponentNameFromType(ctor),\r\n      );\r\n    }\r\n\r\n    if (typeof instance.getDerivedStateFromProps === 'function') {\r\n      console.error(\r\n        '%s: getDerivedStateFromProps() is defined as an instance method ' +\r\n        'and will be ignored. Instead, declare it as a static method.',\r\n        name,\r\n      );\r\n    }\r\n    if (typeof instance.getDerivedStateFromError === 'function') {\r\n      console.error(\r\n        '%s: getDerivedStateFromError() is defined as an instance method ' +\r\n        'and will be ignored. Instead, declare it as a static method.',\r\n        name,\r\n      );\r\n    }\r\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\r\n      console.error(\r\n        '%s: getSnapshotBeforeUpdate() is defined as a static method ' +\r\n        'and will be ignored. Instead, declare it as an instance method.',\r\n        name,\r\n      );\r\n    }\r\n    const state = instance.state;\r\n    if (state && (typeof state !== 'object' || isArray(state))) {\r\n      console.error('%s.state: must be set to an object or null', name);\r\n    }\r\n    if (\r\n      typeof instance.getChildContext === 'function' &&\r\n      typeof ctor.childContextTypes !== 'object'\r\n    ) {\r\n      console.error(\r\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\r\n        'use getChildContext().',\r\n        name,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction adoptClassInstance (workInProgress: Fiber, instance: any): void {\r\n  instance.updater = classComponentUpdater;\r\n  workInProgress.stateNode = instance;\r\n  // The instance needs access to the fiber so that it can schedule updates\r\n  setInstance(instance, workInProgress);\r\n  if (__DEV__) {\r\n    instance._reactInternalInstance = fakeInternalInstance;\r\n  }\r\n}\r\n\r\nfunction constructClassInstance (\r\n  workInProgress: Fiber,\r\n  ctor: any,\r\n  props: any,\r\n): any {\r\n  let isLegacyContextConsumer = false;\r\n  let unmaskedContext = emptyContextObject;\r\n  let context = emptyContextObject;\r\n  const contextType = ctor.contextType;\r\n\r\n  if (__DEV__) {\r\n    if ('contextType' in ctor) {\r\n      const isValid =\r\n        // Allow null for conditional declaration\r\n        contextType === null ||\r\n        (contextType !== undefined &&\r\n          contextType.$$typeof === REACT_CONTEXT_TYPE &&\r\n          contextType._context === undefined); // Not a <Context.Consumer>\r\n\r\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\r\n        didWarnAboutInvalidateContextType.add(ctor);\r\n\r\n        let addendum = '';\r\n        if (contextType === undefined) {\r\n          addendum =\r\n            ' However, it is set to undefined. ' +\r\n            'This can be caused by a typo or by mixing up named and default imports. ' +\r\n            'This can also happen due to a circular dependency, so ' +\r\n            'try moving the createContext() call to a separate file.';\r\n        } else if (typeof contextType !== 'object') {\r\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\r\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\r\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\r\n        } else if (contextType._context !== undefined) {\r\n          // <Context.Consumer>\r\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\r\n        } else {\r\n          addendum =\r\n            ' However, it is set to an object with keys {' +\r\n            Object.keys(contextType).join(', ') +\r\n            '}.';\r\n        }\r\n        console.error(\r\n          '%s defines an invalid contextType. ' +\r\n          'contextType should point to the Context object returned by React.createContext().%s',\r\n          getComponentNameFromType(ctor) || 'Component',\r\n          addendum,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  if (typeof contextType === 'object' && contextType !== null) {\r\n    context = readContext((contextType: any));\r\n  } else if (!disableLegacyContext) {\r\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\r\n    const contextTypes = ctor.contextTypes;\r\n    isLegacyContextConsumer =\r\n      contextTypes !== null && contextTypes !== undefined;\r\n    context = isLegacyContextConsumer\r\n      ? getMaskedContext(workInProgress, unmaskedContext)\r\n      : emptyContextObject;\r\n  }\r\n\r\n  let instance = new ctor(props, context);\r\n  // Instantiate twice to help detect side-effects.\r\n  if (__DEV__) {\r\n    if (\r\n      debugRenderPhaseSideEffectsForStrictMode &&\r\n      workInProgress.mode & StrictLegacyMode\r\n    ) {\r\n      setIsStrictModeForDevtools(true);\r\n      try {\r\n        instance = new ctor(props, context); // eslint-disable-line no-new\r\n      } finally {\r\n        setIsStrictModeForDevtools(false);\r\n      }\r\n    }\r\n  }\r\n\r\n  const state = (workInProgress.memoizedState =\r\n    instance.state !== null && instance.state !== undefined\r\n      ? instance.state\r\n      : null);\r\n  adoptClassInstance(workInProgress, instance);\r\n\r\n  if (__DEV__) {\r\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\r\n      const componentName = getComponentNameFromType(ctor) || 'Component';\r\n      if (!didWarnAboutUninitializedState.has(componentName)) {\r\n        didWarnAboutUninitializedState.add(componentName);\r\n        console.error(\r\n          '`%s` uses `getDerivedStateFromProps` but its initial state is ' +\r\n          '%s. This is not recommended. Instead, define the initial state by ' +\r\n          'assigning an object to `this.state` in the constructor of `%s`. ' +\r\n          'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',\r\n          componentName,\r\n          instance.state === null ? 'null' : 'undefined',\r\n          componentName,\r\n        );\r\n      }\r\n    }\r\n\r\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\r\n    // Warn about these lifecycles if they are present.\r\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\r\n    if (\r\n      typeof ctor.getDerivedStateFromProps === 'function' ||\r\n      typeof instance.getSnapshotBeforeUpdate === 'function'\r\n    ) {\r\n      let foundWillMountName = null;\r\n      let foundWillReceivePropsName = null;\r\n      let foundWillUpdateName = null;\r\n      if (\r\n        typeof instance.componentWillMount === 'function' &&\r\n        instance.componentWillMount.__suppressDeprecationWarning !== true\r\n      ) {\r\n        foundWillMountName = 'componentWillMount';\r\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\r\n        foundWillMountName = 'UNSAFE_componentWillMount';\r\n      }\r\n      if (\r\n        typeof instance.componentWillReceiveProps === 'function' &&\r\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\r\n      ) {\r\n        foundWillReceivePropsName = 'componentWillReceiveProps';\r\n      } else if (\r\n        typeof instance.UNSAFE_componentWillReceiveProps === 'function'\r\n      ) {\r\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\r\n      }\r\n      if (\r\n        typeof instance.componentWillUpdate === 'function' &&\r\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\r\n      ) {\r\n        foundWillUpdateName = 'componentWillUpdate';\r\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\r\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\r\n      }\r\n      if (\r\n        foundWillMountName !== null ||\r\n        foundWillReceivePropsName !== null ||\r\n        foundWillUpdateName !== null\r\n      ) {\r\n        const componentName = getComponentNameFromType(ctor) || 'Component';\r\n        const newApiName =\r\n          typeof ctor.getDerivedStateFromProps === 'function'\r\n            ? 'getDerivedStateFromProps()'\r\n            : 'getSnapshotBeforeUpdate()';\r\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\r\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\r\n          console.error(\r\n            'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\r\n            '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' +\r\n            'The above lifecycles should be removed. Learn more about this warning here:\\n' +\r\n            'https://reactjs.org/link/unsafe-component-lifecycles',\r\n            componentName,\r\n            newApiName,\r\n            foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '',\r\n            foundWillReceivePropsName !== null\r\n              ? `\\n  ${foundWillReceivePropsName}`\r\n              : '',\r\n            foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '',\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\r\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\r\n  if (isLegacyContextConsumer) {\r\n    cacheContext(workInProgress, unmaskedContext, context);\r\n  }\r\n\r\n  return instance;\r\n}\r\n\r\nfunction callComponentWillMount (workInProgress, instance) {\r\n  const oldState = instance.state;\r\n\r\n  if (typeof instance.componentWillMount === 'function') {\r\n    instance.componentWillMount();\r\n  }\r\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\r\n    instance.UNSAFE_componentWillMount();\r\n  }\r\n\r\n  if (oldState !== instance.state) {\r\n    if (__DEV__) {\r\n      console.error(\r\n        '%s.componentWillMount(): Assigning directly to this.state is ' +\r\n        \"deprecated (except inside a component's \" +\r\n        'constructor). Use setState instead.',\r\n        getComponentNameFromFiber(workInProgress) || 'Component',\r\n      );\r\n    }\r\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\r\n  }\r\n}\r\n\r\nfunction callComponentWillReceiveProps (\r\n  workInProgress,\r\n  instance,\r\n  newProps,\r\n  nextContext,\r\n) {\r\n  const oldState = instance.state;\r\n  if (typeof instance.componentWillReceiveProps === 'function') {\r\n    instance.componentWillReceiveProps(newProps, nextContext);\r\n  }\r\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\r\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\r\n  }\r\n\r\n  if (instance.state !== oldState) {\r\n    if (__DEV__) {\r\n      const componentName =\r\n        getComponentNameFromFiber(workInProgress) || 'Component';\r\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\r\n        didWarnAboutStateAssignmentForComponent.add(componentName);\r\n        console.error(\r\n          '%s.componentWillReceiveProps(): Assigning directly to ' +\r\n          \"this.state is deprecated (except inside a component's \" +\r\n          'constructor). Use setState instead.',\r\n          componentName,\r\n        );\r\n      }\r\n    }\r\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\r\n  }\r\n}\r\n\r\n// Invokes the mount life-cycles on a previously never rendered instance.\r\nfunction mountClassInstance (\r\n  workInProgress: Fiber,\r\n  ctor: any,\r\n  newProps: any,\r\n  renderLanes: Lanes,\r\n): void {\r\n  if (__DEV__) {\r\n    checkClassInstance(workInProgress, ctor, newProps);\r\n  }\r\n\r\n  const instance = workInProgress.stateNode;\r\n  instance.props = newProps;\r\n  instance.state = workInProgress.memoizedState;\r\n  instance.refs = emptyRefsObject;\r\n\r\n  initializeUpdateQueue(workInProgress);\r\n\r\n  const contextType = ctor.contextType;\r\n  if (typeof contextType === 'object' && contextType !== null) {\r\n    instance.context = readContext(contextType);\r\n  } else if (disableLegacyContext) {\r\n    instance.context = emptyContextObject;\r\n  } else {\r\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\r\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (instance.state === newProps) {\r\n      const componentName = getComponentNameFromType(ctor) || 'Component';\r\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\r\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\r\n        console.error(\r\n          '%s: It is not recommended to assign props directly to state ' +\r\n          \"because updates to props won't be reflected in state. \" +\r\n          'In most cases, it is better to use props directly.',\r\n          componentName,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (workInProgress.mode & StrictLegacyMode) {\r\n      ReactStrictModeWarnings.recordLegacyContextWarning(\r\n        workInProgress,\r\n        instance,\r\n      );\r\n    }\r\n\r\n    if (warnAboutDeprecatedLifecycles) {\r\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\r\n        workInProgress,\r\n        instance,\r\n      );\r\n    }\r\n  }\r\n\r\n  instance.state = workInProgress.memoizedState;\r\n\r\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\r\n  if (typeof getDerivedStateFromProps === 'function') {\r\n    applyDerivedStateFromProps(\r\n      workInProgress,\r\n      ctor,\r\n      getDerivedStateFromProps,\r\n      newProps,\r\n    );\r\n    instance.state = workInProgress.memoizedState;\r\n  }\r\n\r\n  // In order to support react-lifecycles-compat polyfilled components,\r\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n  if (\r\n    typeof ctor.getDerivedStateFromProps !== 'function' &&\r\n    typeof instance.getSnapshotBeforeUpdate !== 'function' &&\r\n    (typeof instance.UNSAFE_componentWillMount === 'function' ||\r\n      typeof instance.componentWillMount === 'function')\r\n  ) {\r\n    callComponentWillMount(workInProgress, instance);\r\n    // If we had additional state updates during this life-cycle, let's\r\n    // process them now.\r\n    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\r\n    instance.state = workInProgress.memoizedState;\r\n  }\r\n\r\n  if (typeof instance.componentDidMount === 'function') {\r\n    let fiberFlags: Flags = Update;\r\n    if (enableSuspenseLayoutEffectSemantics) {\r\n      fiberFlags |= LayoutStatic;\r\n    }\r\n    if (\r\n      __DEV__ &&\r\n      enableStrictEffects &&\r\n      (workInProgress.mode & StrictEffectsMode) !== NoMode\r\n    ) {\r\n      fiberFlags |= MountLayoutDev;\r\n    }\r\n    workInProgress.flags |= fiberFlags;\r\n  }\r\n}\r\n\r\nfunction resumeMountClassInstance (\r\n  workInProgress: Fiber,\r\n  ctor: any,\r\n  newProps: any,\r\n  renderLanes: Lanes,\r\n): boolean {\r\n  const instance = workInProgress.stateNode;\r\n\r\n  const oldProps = workInProgress.memoizedProps;\r\n  instance.props = oldProps;\r\n\r\n  const oldContext = instance.context;\r\n  const contextType = ctor.contextType;\r\n  let nextContext = emptyContextObject;\r\n  if (typeof contextType === 'object' && contextType !== null) {\r\n    nextContext = readContext(contextType);\r\n  } else if (!disableLegacyContext) {\r\n    const nextLegacyUnmaskedContext = getUnmaskedContext(\r\n      workInProgress,\r\n      ctor,\r\n      true,\r\n    );\r\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\r\n  }\r\n\r\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\r\n  const hasNewLifecycles =\r\n    typeof getDerivedStateFromProps === 'function' ||\r\n    typeof instance.getSnapshotBeforeUpdate === 'function';\r\n\r\n  // Note: During these life-cycles, instance.props/instance.state are what\r\n  // ever the previously attempted to render - not the \"current\". However,\r\n  // during componentDidUpdate we pass the \"current\" props.\r\n\r\n  // In order to support react-lifecycles-compat polyfilled components,\r\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n  if (\r\n    !hasNewLifecycles &&\r\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\r\n      typeof instance.componentWillReceiveProps === 'function')\r\n  ) {\r\n    if (oldProps !== newProps || oldContext !== nextContext) {\r\n      callComponentWillReceiveProps(\r\n        workInProgress,\r\n        instance,\r\n        newProps,\r\n        nextContext,\r\n      );\r\n    }\r\n  }\r\n\r\n  resetHasForceUpdateBeforeProcessing();\r\n\r\n  const oldState = workInProgress.memoizedState;\r\n  let newState = (instance.state = oldState);\r\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\r\n  newState = workInProgress.memoizedState;\r\n  if (\r\n    oldProps === newProps &&\r\n    oldState === newState &&\r\n    !hasContextChanged() &&\r\n    !checkHasForceUpdateAfterProcessing()\r\n  ) {\r\n    // If an update was already in progress, we should schedule an Update\r\n    // effect even though we're bailing out, so that cWU/cDU are called.\r\n    if (typeof instance.componentDidMount === 'function') {\r\n      let fiberFlags: Flags = Update;\r\n      if (enableSuspenseLayoutEffectSemantics) {\r\n        fiberFlags |= LayoutStatic;\r\n      }\r\n      if (\r\n        __DEV__ &&\r\n        enableStrictEffects &&\r\n        (workInProgress.mode & StrictEffectsMode) !== NoMode\r\n      ) {\r\n        fiberFlags |= MountLayoutDev;\r\n      }\r\n      workInProgress.flags |= fiberFlags;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  if (typeof getDerivedStateFromProps === 'function') {\r\n    applyDerivedStateFromProps(\r\n      workInProgress,\r\n      ctor,\r\n      getDerivedStateFromProps,\r\n      newProps,\r\n    );\r\n    newState = workInProgress.memoizedState;\r\n  }\r\n\r\n  const shouldUpdate =\r\n    checkHasForceUpdateAfterProcessing() ||\r\n    checkShouldComponentUpdate(\r\n      workInProgress,\r\n      ctor,\r\n      oldProps,\r\n      newProps,\r\n      oldState,\r\n      newState,\r\n      nextContext,\r\n    );\r\n\r\n  if (shouldUpdate) {\r\n    // In order to support react-lifecycles-compat polyfilled components,\r\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n    if (\r\n      !hasNewLifecycles &&\r\n      (typeof instance.UNSAFE_componentWillMount === 'function' ||\r\n        typeof instance.componentWillMount === 'function')\r\n    ) {\r\n      if (typeof instance.componentWillMount === 'function') {\r\n        instance.componentWillMount();\r\n      }\r\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\r\n        instance.UNSAFE_componentWillMount();\r\n      }\r\n    }\r\n    if (typeof instance.componentDidMount === 'function') {\r\n      let fiberFlags: Flags = Update;\r\n      if (enableSuspenseLayoutEffectSemantics) {\r\n        fiberFlags |= LayoutStatic;\r\n      }\r\n      if (\r\n        __DEV__ &&\r\n        enableStrictEffects &&\r\n        (workInProgress.mode & StrictEffectsMode) !== NoMode\r\n      ) {\r\n        fiberFlags |= MountLayoutDev;\r\n      }\r\n      workInProgress.flags |= fiberFlags;\r\n    }\r\n  } else {\r\n    // If an update was already in progress, we should schedule an Update\r\n    // effect even though we're bailing out, so that cWU/cDU are called.\r\n    if (typeof instance.componentDidMount === 'function') {\r\n      let fiberFlags: Flags = Update;\r\n      if (enableSuspenseLayoutEffectSemantics) {\r\n        fiberFlags |= LayoutStatic;\r\n      }\r\n      if (\r\n        __DEV__ &&\r\n        enableStrictEffects &&\r\n        (workInProgress.mode & StrictEffectsMode) !== NoMode\r\n      ) {\r\n        fiberFlags |= MountLayoutDev;\r\n      }\r\n      workInProgress.flags |= fiberFlags;\r\n    }\r\n\r\n    // If shouldComponentUpdate returned false, we should still update the\r\n    // memoized state to indicate that this work can be reused.\r\n    workInProgress.memoizedProps = newProps;\r\n    workInProgress.memoizedState = newState;\r\n  }\r\n\r\n  // Update the existing instance's state, props, and context pointers even\r\n  // if shouldComponentUpdate returns false.\r\n  instance.props = newProps;\r\n  instance.state = newState;\r\n  instance.context = nextContext;\r\n\r\n  return shouldUpdate;\r\n}\r\n\r\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\r\nfunction updateClassInstance (\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  ctor: any,\r\n  newProps: any,\r\n  renderLanes: Lanes,\r\n): boolean {\r\n  const instance = workInProgress.stateNode;\r\n\r\n  cloneUpdateQueue(current, workInProgress);\r\n\r\n  const unresolvedOldProps = workInProgress.memoizedProps;\r\n  const oldProps =\r\n    workInProgress.type === workInProgress.elementType\r\n      ? unresolvedOldProps\r\n      : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\r\n  instance.props = oldProps;\r\n  const unresolvedNewProps = workInProgress.pendingProps;\r\n\r\n  const oldContext = instance.context;\r\n  const contextType = ctor.contextType;\r\n  let nextContext = emptyContextObject;\r\n  if (typeof contextType === 'object' && contextType !== null) {\r\n    nextContext = readContext(contextType);\r\n  } else if (!disableLegacyContext) {\r\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\r\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\r\n  }\r\n\r\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\r\n  const hasNewLifecycles =\r\n    typeof getDerivedStateFromProps === 'function' ||\r\n    typeof instance.getSnapshotBeforeUpdate === 'function';\r\n\r\n  // Note: During these life-cycles, instance.props/instance.state are what\r\n  // ever the previously attempted to render - not the \"current\". However,\r\n  // during componentDidUpdate we pass the \"current\" props.\r\n\r\n  // In order to support react-lifecycles-compat polyfilled components,\r\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n  if (\r\n    !hasNewLifecycles &&\r\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\r\n      typeof instance.componentWillReceiveProps === 'function')\r\n  ) {\r\n    if (\r\n      unresolvedOldProps !== unresolvedNewProps ||\r\n      oldContext !== nextContext\r\n    ) {\r\n      callComponentWillReceiveProps(\r\n        workInProgress,\r\n        instance,\r\n        newProps,\r\n        nextContext,\r\n      );\r\n    }\r\n  }\r\n\r\n  resetHasForceUpdateBeforeProcessing();\r\n\r\n  const oldState = workInProgress.memoizedState;\r\n  let newState = (instance.state = oldState);\r\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\r\n  newState = workInProgress.memoizedState;\r\n\r\n  if (\r\n    unresolvedOldProps === unresolvedNewProps &&\r\n    oldState === newState &&\r\n    !hasContextChanged() &&\r\n    !checkHasForceUpdateAfterProcessing() &&\r\n    !(\r\n      enableLazyContextPropagation &&\r\n      current !== null &&\r\n      current.dependencies !== null &&\r\n      checkIfContextChanged(current.dependencies)\r\n    )\r\n  ) {\r\n    // If an update was already in progress, we should schedule an Update\r\n    // effect even though we're bailing out, so that cWU/cDU are called.\r\n    if (typeof instance.componentDidUpdate === 'function') {\r\n      if (\r\n        unresolvedOldProps !== current.memoizedProps ||\r\n        oldState !== current.memoizedState\r\n      ) {\r\n        workInProgress.flags |= Update;\r\n      }\r\n    }\r\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\r\n      if (\r\n        unresolvedOldProps !== current.memoizedProps ||\r\n        oldState !== current.memoizedState\r\n      ) {\r\n        workInProgress.flags |= Snapshot;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  if (typeof getDerivedStateFromProps === 'function') {\r\n    applyDerivedStateFromProps(\r\n      workInProgress,\r\n      ctor,\r\n      getDerivedStateFromProps,\r\n      newProps,\r\n    );\r\n    newState = workInProgress.memoizedState;\r\n  }\r\n\r\n  const shouldUpdate =\r\n    checkHasForceUpdateAfterProcessing() ||\r\n    checkShouldComponentUpdate(\r\n      workInProgress,\r\n      ctor,\r\n      oldProps,\r\n      newProps,\r\n      oldState,\r\n      newState,\r\n      nextContext,\r\n    ) ||\r\n    // TODO: In some cases, we'll end up checking if context has changed twice,\r\n    // both before and after `shouldComponentUpdate` has been called. Not ideal,\r\n    // but I'm loath to refactor this function. This only happens for memoized\r\n    // components so it's not that common.\r\n    (enableLazyContextPropagation &&\r\n      current !== null &&\r\n      current.dependencies !== null &&\r\n      checkIfContextChanged(current.dependencies));\r\n\r\n  if (shouldUpdate) {\r\n    // In order to support react-lifecycles-compat polyfilled components,\r\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n    if (\r\n      !hasNewLifecycles &&\r\n      (typeof instance.UNSAFE_componentWillUpdate === 'function' ||\r\n        typeof instance.componentWillUpdate === 'function')\r\n    ) {\r\n      if (typeof instance.componentWillUpdate === 'function') {\r\n        instance.componentWillUpdate(newProps, newState, nextContext);\r\n      }\r\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\r\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\r\n      }\r\n    }\r\n    if (typeof instance.componentDidUpdate === 'function') {\r\n      workInProgress.flags |= Update;\r\n    }\r\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\r\n      workInProgress.flags |= Snapshot;\r\n    }\r\n  } else {\r\n    // If an update was already in progress, we should schedule an Update\r\n    // effect even though we're bailing out, so that cWU/cDU are called.\r\n    if (typeof instance.componentDidUpdate === 'function') {\r\n      if (\r\n        unresolvedOldProps !== current.memoizedProps ||\r\n        oldState !== current.memoizedState\r\n      ) {\r\n        workInProgress.flags |= Update;\r\n      }\r\n    }\r\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\r\n      if (\r\n        unresolvedOldProps !== current.memoizedProps ||\r\n        oldState !== current.memoizedState\r\n      ) {\r\n        workInProgress.flags |= Snapshot;\r\n      }\r\n    }\r\n\r\n    // If shouldComponentUpdate returned false, we should still update the\r\n    // memoized props/state to indicate that this work can be reused.\r\n    workInProgress.memoizedProps = newProps;\r\n    workInProgress.memoizedState = newState;\r\n  }\r\n\r\n  // Update the existing instance's state, props, and context pointers even\r\n  // if shouldComponentUpdate returns false.\r\n  instance.props = newProps;\r\n  instance.state = newState;\r\n  instance.context = nextContext;\r\n\r\n  return shouldUpdate;\r\n}\r\n\r\nexport {\r\n  adoptClassInstance,\r\n  constructClassInstance,\r\n  mountClassInstance,\r\n  resumeMountClassInstance,\r\n  updateClassInstance,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}