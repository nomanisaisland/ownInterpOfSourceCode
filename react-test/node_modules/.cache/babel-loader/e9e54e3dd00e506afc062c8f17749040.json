{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { findCurrentHostFiber, findCurrentHostFiberWithNoPortals } from './ReactFiberTreeReflection';\nimport { get as getInstance } from 'shared/ReactInstanceMap';\nimport { HostComponent, ClassComponent, HostRoot, SuspenseComponent } from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport isArray from 'shared/isArray';\nimport { enableSchedulingProfiler } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { getPublicInstance } from './ReactFiberHostConfig';\nimport { findCurrentUnmaskedContext, processChildContext, emptyContextObject, isContextProvider as isLegacyContextProvider } from './ReactFiberContext.old';\nimport { createFiberRoot } from './ReactFiberRoot.old';\nimport { isRootDehydrated } from './ReactFiberShellHydration';\nimport { injectInternals, markRenderScheduled, onScheduleRoot } from './ReactFiberDevToolsHook.old';\nimport { requestEventTime, requestUpdateLane, scheduleUpdateOnFiber, scheduleInitialHydrationOnRoot, flushRoot, batchedUpdates, flushSync, isAlreadyRendering, flushControlled, deferredUpdates, discreteUpdates, flushPassiveEffects } from './ReactFiberWorkLoop.old';\nimport { createUpdate, enqueueUpdate, entangleTransitions } from './ReactUpdateQueue.old';\nimport { isRendering as ReactCurrentFiberIsRendering, current as ReactCurrentFiberCurrent, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { SyncLane, SelectiveHydrationLane, NoTimestamp, getHighestPriorityPendingLanes, higherPriorityLane } from './ReactFiberLane.old';\nimport { getCurrentUpdatePriority, runWithPriority } from './ReactEventPriorities.old';\nimport { scheduleRefresh, scheduleRoot, setRefreshHandler, findHostInstancesForRefresh } from './ReactFiberHotReloading.old';\nimport ReactVersion from 'shared/ReactVersion';\nexport { registerMutableSourceForHydration } from './ReactMutableSource.old';\nexport { createPortal } from './ReactPortal';\nexport { createComponentSelector, createHasPseudoClassSelector, createRoleSelector, createTestNameSelector, createTextSelector, getFindAllNodesFailureDescription, findAllNodes, findBoundingRects, focusWithin, observeVisibleRects } from './ReactTestSelectors';\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  const fiber = getInstance(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      const keys = Object.keys(component).join(',');\n      throw new Error(`Argument appears to not be a ReactComponent. Keys: ${keys}`);\n    }\n  }\n\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        const keys = Object.keys(component).join(',');\n        throw new Error(`Argument appears to not be a ReactComponent. Keys: ${keys}`);\n      }\n    }\n\n    const hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictLegacyMode) {\n      const componentName = getComponentNameFromFiber(fiber) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        const previousFiber = ReactCurrentFiberCurrent;\n\n        try {\n          setCurrentDebugFiberInDEV(hostFiber);\n\n          if (fiber.mode & StrictLegacyMode) {\n            console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          } else {\n            console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentDebugFiberInDEV(previousFiber);\n          } else {\n            resetCurrentDebugFiberInDEV();\n          }\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n\n  return findHostInstance(component);\n}\n\nexport function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  // console.log(containerInfo)\n  // console.log({\n  //   containerInfo,\n  //   tag,\n  //   hydrationCallbacks,\n  //   isStrictMode,\n  //   concurrentUpdatesByDefaultOverride,\n  //   identifierPrefix,\n  //   onRecoverableError,\n  //   transitionCallbacks,\n  // })\n  // containerInfo 根节点\n  // tag 节点类型标记 1\n  // hydrationCallbacks null\n  // isStrictMode false\n  // concurrentUpdatesByDefaultOverride false\n  // identifierPrefix \" \"\n  // onRecoverableError  一个reportError报告错误的原生方法(不会阻止其他回调被处理，仍然可以调试)\n  // transitionCallbacks null\n  const hydrate = false; // initialChildren为子节点，浏览器渲染不需要这个，所以子节点为null\n\n  const initialChildren = null; // createFiberRoot是浏览器渲染和服务器渲染的公共方法，浏览器渲染需要把hydrate设为false\n\n  return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks);\n}\nexport function createHydrationContainer(initialChildren, // TODO: Remove `callback` when we delete legacy mode.\ncallback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  const hydrate = true;\n  const root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks); // TODO: Move this to FiberRoot constructor\n\n  root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n  // a regular update because the initial render must match was was rendered\n  // on the server.\n  // NOTE: This update intentionally doesn't have a payload. We're only using\n  // the update to schedule work on the root fiber (and, for legacy roots, to\n  // enqueue the callback if one is provided).\n\n  const current = root.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n  const update = createUpdate(eventTime, lane);\n  update.callback = callback !== undefined && callback !== null ? callback : null;\n  enqueueUpdate(current, update, lane);\n  scheduleInitialHydrationOnRoot(root, lane, eventTime);\n  return root;\n}\n/**\r\n * @description 创建update对象，保存在updateQueue环状链表中\r\n * @param {*} element \r\n * @param {*} container \r\n * @param {*} parentComponent \r\n * @param {*} callback \r\n * @returns \r\n */\n\nexport function updateContainer(element, container, parentComponent, callback) {\n  if (__DEV__) {\n    onScheduleRoot(container, element);\n  }\n\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  if (enableSchedulingProfiler) {\n    markRenderScheduled(lane);\n  }\n\n  const context = getContextForSubtree(parentComponent);\n\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (ReactCurrentFiberIsRendering && ReactCurrentFiberCurrent !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      console.error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(ReactCurrentFiberCurrent) || 'Unknown');\n    }\n  } // 创建update\n\n\n  const update = createUpdate(eventTime, lane); //创建update\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element\n  };\n  callback = callback === undefined ? null : callback;\n\n  if (callback !== null) {\n    if (__DEV__) {\n      if (typeof callback !== 'function') {\n        console.error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n\n    update.callback = callback;\n  }\n\n  enqueueUpdate(current, update, lane); //update入队\n\n  const root = scheduleUpdateOnFiber(current, lane, eventTime); //调度update\n\n  if (root !== null) {\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\nexport { batchedUpdates, deferredUpdates, discreteUpdates, flushControlled, flushSync, isAlreadyRendering, flushPassiveEffects };\nexport function getPublicRootInstance(container) {\n  const containerFiber = container.current;\n\n  if (!containerFiber.child) {\n    return null;\n  }\n\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\nexport function attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      const root = fiber.stateNode;\n\n      if (isRootDehydrated(root)) {\n        // Flush the first scheduled \"update\".\n        const lanes = getHighestPriorityPendingLanes(root);\n        flushRoot(root, lanes);\n      }\n\n      break;\n\n    case SuspenseComponent:\n      const eventTime = requestEventTime();\n      flushSync(() => scheduleUpdateOnFiber(fiber, SyncLane, eventTime)); // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n\n      const retryLane = SyncLane;\n      markRetryLaneIfNotHydrated(fiber, retryLane);\n      break;\n  }\n}\n\nfunction markRetryLaneImpl(fiber, retryLane) {\n  const suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n  }\n} // Increases the priority of thenables when they resolve within this boundary.\n\n\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  const alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nexport function attemptDiscreteHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  const eventTime = requestEventTime();\n  const lane = SyncLane;\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport function attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  const eventTime = requestEventTime();\n  const lane = SelectiveHydrationLane;\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport function attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(fiber);\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport { getCurrentUpdatePriority, runWithPriority };\nexport { findHostInstance };\nexport { findHostInstanceWithWarning };\nexport function findHostInstanceWithNoPortals(fiber) {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nlet shouldErrorImpl = fiber => null;\n\nexport function shouldError(fiber) {\n  return shouldErrorImpl(fiber);\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nlet overrideHookState = null;\nlet overrideHookStateDeletePath = null;\nlet overrideHookStateRenamePath = null;\nlet overrideProps = null;\nlet overridePropsDeletePath = null;\nlet overridePropsRenamePath = null;\nlet scheduleUpdate = null;\nlet setErrorHandler = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithDeleteImpl = (obj, path, index) => {\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    };\n\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(key, 1);\n      } else {\n        delete updated[key];\n      }\n\n      return updated;\n    } // $FlowFixMe number or string is fine here\n\n\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  const copyWithDelete = (obj, path) => {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  const copyWithRenameImpl = (obj, oldPath, newPath, index) => {\n    const oldKey = oldPath[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    };\n\n    if (index + 1 === oldPath.length) {\n      const newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n      updated[newKey] = updated[oldKey];\n\n      if (isArray(updated)) {\n        updated.splice(oldKey, 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here\n      obj[oldKey], oldPath, newPath, index + 1);\n    }\n\n    return updated;\n  };\n\n  const copyWithRename = (obj, oldPath, newPath) => {\n    if (oldPath.length !== newPath.length) {\n      console.warn('copyWithRename() expects paths of the same length');\n      return;\n    } else {\n      for (let i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          console.warn('copyWithRename() expects paths to be the same except for the deepest key');\n          return;\n        }\n      }\n    }\n\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  const copyWithSetImpl = (obj, path, index, value) => {\n    if (index >= path.length) {\n      return value;\n    }\n\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    }; // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (obj, path, value) => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  const findHook = (fiber, id) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    return currentHook;\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = (fiber, id, path, value) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overrideHookStateDeletePath = (fiber, id, path) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overrideHookStateRenamePath = (fiber, id, oldPath, newPath) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = (fiber, path, value) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  overridePropsDeletePath = (fiber, path) => {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  overridePropsRenamePath = (fiber, oldPath, newPath) => {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  scheduleUpdate = fiber => {\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  setErrorHandler = newShouldErrorImpl => {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = newShouldSuspendImpl => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber) {\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(instance) {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return ReactCurrentFiberCurrent;\n}\n\nexport function injectIntoDevTools(devToolsConfig) {\n  const {\n    findFiberByHostInstance\n  } = devToolsConfig;\n  const {\n    ReactCurrentDispatcher\n  } = ReactSharedInternals;\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState,\n    overrideHookStateDeletePath,\n    overrideHookStateRenamePath,\n    overrideProps,\n    overridePropsDeletePath,\n    overridePropsRenamePath,\n    setErrorHandler,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber,\n    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? getCurrentFiberForDevTools : null,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion\n  });\n}","map":{"version":3,"names":["findCurrentHostFiber","findCurrentHostFiberWithNoPortals","get","getInstance","HostComponent","ClassComponent","HostRoot","SuspenseComponent","getComponentNameFromFiber","isArray","enableSchedulingProfiler","ReactSharedInternals","getPublicInstance","findCurrentUnmaskedContext","processChildContext","emptyContextObject","isContextProvider","isLegacyContextProvider","createFiberRoot","isRootDehydrated","injectInternals","markRenderScheduled","onScheduleRoot","requestEventTime","requestUpdateLane","scheduleUpdateOnFiber","scheduleInitialHydrationOnRoot","flushRoot","batchedUpdates","flushSync","isAlreadyRendering","flushControlled","deferredUpdates","discreteUpdates","flushPassiveEffects","createUpdate","enqueueUpdate","entangleTransitions","isRendering","ReactCurrentFiberIsRendering","current","ReactCurrentFiberCurrent","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","StrictLegacyMode","SyncLane","SelectiveHydrationLane","NoTimestamp","getHighestPriorityPendingLanes","higherPriorityLane","getCurrentUpdatePriority","runWithPriority","scheduleRefresh","scheduleRoot","setRefreshHandler","findHostInstancesForRefresh","ReactVersion","registerMutableSourceForHydration","createPortal","createComponentSelector","createHasPseudoClassSelector","createRoleSelector","createTestNameSelector","createTextSelector","getFindAllNodesFailureDescription","findAllNodes","findBoundingRects","focusWithin","observeVisibleRects","didWarnAboutNestedUpdates","didWarnAboutFindNodeInStrictMode","__DEV__","getContextForSubtree","parentComponent","fiber","parentContext","tag","Component","type","findHostInstance","component","undefined","render","Error","keys","Object","join","hostFiber","stateNode","findHostInstanceWithWarning","methodName","mode","componentName","previousFiber","console","error","createContainer","containerInfo","hydrationCallbacks","isStrictMode","concurrentUpdatesByDefaultOverride","identifierPrefix","onRecoverableError","transitionCallbacks","hydrate","initialChildren","createHydrationContainer","callback","root","context","eventTime","lane","update","updateContainer","element","container","pendingContext","payload","getPublicRootInstance","containerFiber","child","attemptSynchronousHydration","lanes","retryLane","markRetryLaneIfNotHydrated","markRetryLaneImpl","suspenseState","memoizedState","dehydrated","alternate","attemptDiscreteHydration","attemptContinuousHydration","attemptHydrationAtCurrentPriority","findHostInstanceWithNoPortals","shouldErrorImpl","shouldError","shouldSuspendImpl","shouldSuspend","overrideHookState","overrideHookStateDeletePath","overrideHookStateRenamePath","overrideProps","overridePropsDeletePath","overridePropsRenamePath","scheduleUpdate","setErrorHandler","setSuspenseHandler","copyWithDeleteImpl","obj","path","index","key","updated","slice","length","splice","copyWithDelete","copyWithRenameImpl","oldPath","newPath","oldKey","newKey","copyWithRename","warn","i","copyWithSetImpl","value","copyWithSet","findHook","id","currentHook","next","hook","newState","baseState","memoizedProps","pendingProps","newShouldErrorImpl","newShouldSuspendImpl","findHostInstanceByFiber","emptyFindFiberByHostInstance","instance","getCurrentFiberForDevTools","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","ReactCurrentDispatcher","bundleType","version","rendererPackageName","rendererConfig","currentDispatcherRef","getCurrentFiber","reconcilerVersion"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberReconciler.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {\r\n  Fiber,\r\n  SuspenseHydrationCallbacks,\r\n  TransitionTracingCallbacks,\r\n} from './ReactInternalTypes';\r\nimport type { FiberRoot } from './ReactInternalTypes';\r\nimport type { RootTag } from './ReactRootTags';\r\nimport type {\r\n  Instance,\r\n  TextInstance,\r\n  Container,\r\n  PublicInstance,\r\n} from './ReactFiberHostConfig';\r\nimport type { RendererInspectionConfig } from './ReactFiberHostConfig';\r\nimport type { ReactNodeList } from 'shared/ReactTypes';\r\nimport type { Lane } from './ReactFiberLane.old';\r\nimport type { SuspenseState } from './ReactFiberSuspenseComponent.old';\r\n\r\nimport {\r\n  findCurrentHostFiber,\r\n  findCurrentHostFiberWithNoPortals,\r\n} from './ReactFiberTreeReflection';\r\nimport { get as getInstance } from 'shared/ReactInstanceMap';\r\nimport {\r\n  HostComponent,\r\n  ClassComponent,\r\n  HostRoot,\r\n  SuspenseComponent,\r\n} from './ReactWorkTags';\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport isArray from 'shared/isArray';\r\nimport { enableSchedulingProfiler } from 'shared/ReactFeatureFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport { getPublicInstance } from './ReactFiberHostConfig';\r\nimport {\r\n  findCurrentUnmaskedContext,\r\n  processChildContext,\r\n  emptyContextObject,\r\n  isContextProvider as isLegacyContextProvider,\r\n} from './ReactFiberContext.old';\r\nimport { createFiberRoot } from './ReactFiberRoot.old';\r\nimport { isRootDehydrated } from './ReactFiberShellHydration';\r\nimport {\r\n  injectInternals,\r\n  markRenderScheduled,\r\n  onScheduleRoot,\r\n} from './ReactFiberDevToolsHook.old';\r\nimport {\r\n  requestEventTime,\r\n  requestUpdateLane,\r\n  scheduleUpdateOnFiber,\r\n  scheduleInitialHydrationOnRoot,\r\n  flushRoot,\r\n  batchedUpdates,\r\n  flushSync,\r\n  isAlreadyRendering,\r\n  flushControlled,\r\n  deferredUpdates,\r\n  discreteUpdates,\r\n  flushPassiveEffects,\r\n} from './ReactFiberWorkLoop.old';\r\nimport {\r\n  createUpdate,\r\n  enqueueUpdate,\r\n  entangleTransitions,\r\n} from './ReactUpdateQueue.old';\r\nimport {\r\n  isRendering as ReactCurrentFiberIsRendering,\r\n  current as ReactCurrentFiberCurrent,\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport { StrictLegacyMode } from './ReactTypeOfMode';\r\nimport {\r\n  SyncLane,\r\n  SelectiveHydrationLane,\r\n  NoTimestamp,\r\n  getHighestPriorityPendingLanes,\r\n  higherPriorityLane,\r\n} from './ReactFiberLane.old';\r\nimport {\r\n  getCurrentUpdatePriority,\r\n  runWithPriority,\r\n} from './ReactEventPriorities.old';\r\nimport {\r\n  scheduleRefresh,\r\n  scheduleRoot,\r\n  setRefreshHandler,\r\n  findHostInstancesForRefresh,\r\n} from './ReactFiberHotReloading.old';\r\nimport ReactVersion from 'shared/ReactVersion';\r\nexport { registerMutableSourceForHydration } from './ReactMutableSource.old';\r\nexport { createPortal } from './ReactPortal';\r\nexport {\r\n  createComponentSelector,\r\n  createHasPseudoClassSelector,\r\n  createRoleSelector,\r\n  createTestNameSelector,\r\n  createTextSelector,\r\n  getFindAllNodesFailureDescription,\r\n  findAllNodes,\r\n  findBoundingRects,\r\n  focusWithin,\r\n  observeVisibleRects,\r\n} from './ReactTestSelectors';\r\n\r\ntype OpaqueRoot = FiberRoot;\r\n\r\n// 0 is PROD, 1 is DEV.\r\n// Might add PROFILE later.\r\ntype BundleType = 0 | 1;\r\n\r\ntype DevToolsConfig = {|\r\n  bundleType: BundleType,\r\n    version: string,\r\n      rendererPackageName: string,\r\n        // Note: this actually *does* depend on Fiber internal fields.\r\n        // Used by \"inspect clicked DOM element\" in React DevTools.\r\n        findFiberByHostInstance ?: (instance: Instance | TextInstance) => Fiber | null,\r\n        rendererConfig ?: RendererInspectionConfig,\r\n|};\r\n\r\nlet didWarnAboutNestedUpdates;\r\nlet didWarnAboutFindNodeInStrictMode;\r\n\r\nif (__DEV__) {\r\n  didWarnAboutNestedUpdates = false;\r\n  didWarnAboutFindNodeInStrictMode = {};\r\n}\r\n\r\nfunction getContextForSubtree (\r\n  parentComponent: ?React$Component<any, any>,\r\n): Object {\r\n  if (!parentComponent) {\r\n    return emptyContextObject;\r\n  }\r\n\r\n  const fiber = getInstance(parentComponent);\r\n  const parentContext = findCurrentUnmaskedContext(fiber);\r\n\r\n  if (fiber.tag === ClassComponent) {\r\n    const Component = fiber.type;\r\n    if (isLegacyContextProvider(Component)) {\r\n      return processChildContext(fiber, Component, parentContext);\r\n    }\r\n  }\r\n\r\n  return parentContext;\r\n}\r\n\r\nfunction findHostInstance (component: Object): PublicInstance | null {\r\n  const fiber = getInstance(component);\r\n  if (fiber === undefined) {\r\n    if (typeof component.render === 'function') {\r\n      throw new Error('Unable to find node on an unmounted component.');\r\n    } else {\r\n      const keys = Object.keys(component).join(',');\r\n      throw new Error(\r\n        `Argument appears to not be a ReactComponent. Keys: ${keys}`,\r\n      );\r\n    }\r\n  }\r\n  const hostFiber = findCurrentHostFiber(fiber);\r\n  if (hostFiber === null) {\r\n    return null;\r\n  }\r\n  return hostFiber.stateNode;\r\n}\r\n\r\nfunction findHostInstanceWithWarning (\r\n  component: Object,\r\n  methodName: string,\r\n): PublicInstance | null {\r\n  if (__DEV__) {\r\n    const fiber = getInstance(component);\r\n    if (fiber === undefined) {\r\n      if (typeof component.render === 'function') {\r\n        throw new Error('Unable to find node on an unmounted component.');\r\n      } else {\r\n        const keys = Object.keys(component).join(',');\r\n        throw new Error(\r\n          `Argument appears to not be a ReactComponent. Keys: ${keys}`,\r\n        );\r\n      }\r\n    }\r\n    const hostFiber = findCurrentHostFiber(fiber);\r\n    if (hostFiber === null) {\r\n      return null;\r\n    }\r\n    if (hostFiber.mode & StrictLegacyMode) {\r\n      const componentName = getComponentNameFromFiber(fiber) || 'Component';\r\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\r\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\r\n\r\n        const previousFiber = ReactCurrentFiberCurrent;\r\n        try {\r\n          setCurrentDebugFiberInDEV(hostFiber);\r\n          if (fiber.mode & StrictLegacyMode) {\r\n            console.error(\r\n              '%s is deprecated in StrictMode. ' +\r\n              '%s was passed an instance of %s which is inside StrictMode. ' +\r\n              'Instead, add a ref directly to the element you want to reference. ' +\r\n              'Learn more about using refs safely here: ' +\r\n              'https://reactjs.org/link/strict-mode-find-node',\r\n              methodName,\r\n              methodName,\r\n              componentName,\r\n            );\r\n          } else {\r\n            console.error(\r\n              '%s is deprecated in StrictMode. ' +\r\n              '%s was passed an instance of %s which renders StrictMode children. ' +\r\n              'Instead, add a ref directly to the element you want to reference. ' +\r\n              'Learn more about using refs safely here: ' +\r\n              'https://reactjs.org/link/strict-mode-find-node',\r\n              methodName,\r\n              methodName,\r\n              componentName,\r\n            );\r\n          }\r\n        } finally {\r\n          // Ideally this should reset to previous but this shouldn't be called in\r\n          // render and there's another warning for that anyway.\r\n          if (previousFiber) {\r\n            setCurrentDebugFiberInDEV(previousFiber);\r\n          } else {\r\n            resetCurrentDebugFiberInDEV();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return hostFiber.stateNode;\r\n  }\r\n  return findHostInstance(component);\r\n}\r\n\r\nexport function createContainer (\r\n  containerInfo: Container,\r\n  tag: RootTag,\r\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\r\n  isStrictMode: boolean,\r\n  concurrentUpdatesByDefaultOverride: null | boolean,\r\n  identifierPrefix: string,\r\n  onRecoverableError: (error: mixed) => void,\r\n  transitionCallbacks: null | TransitionTracingCallbacks,\r\n): OpaqueRoot {\r\n  // console.log(containerInfo)\r\n  // console.log({\r\n  //   containerInfo,\r\n  //   tag,\r\n  //   hydrationCallbacks,\r\n  //   isStrictMode,\r\n  //   concurrentUpdatesByDefaultOverride,\r\n  //   identifierPrefix,\r\n  //   onRecoverableError,\r\n  //   transitionCallbacks,\r\n  // })\r\n\r\n\r\n  // containerInfo 根节点\r\n  // tag 节点类型标记 1\r\n  // hydrationCallbacks null\r\n  // isStrictMode false\r\n  // concurrentUpdatesByDefaultOverride false\r\n  // identifierPrefix \" \"\r\n  // onRecoverableError  一个reportError报告错误的原生方法(不会阻止其他回调被处理，仍然可以调试)\r\n  // transitionCallbacks null\r\n\r\n\r\n  const hydrate = false;\r\n  // initialChildren为子节点，浏览器渲染不需要这个，所以子节点为null\r\n  const initialChildren = null;\r\n  // createFiberRoot是浏览器渲染和服务器渲染的公共方法，浏览器渲染需要把hydrate设为false\r\n  return createFiberRoot(\r\n    containerInfo,\r\n    tag,\r\n    hydrate,\r\n    initialChildren,\r\n    hydrationCallbacks,\r\n    isStrictMode,\r\n    concurrentUpdatesByDefaultOverride,\r\n    identifierPrefix,\r\n    onRecoverableError,\r\n    transitionCallbacks,\r\n  );\r\n}\r\n\r\nexport function createHydrationContainer (\r\n  initialChildren: ReactNodeList,\r\n  // TODO: Remove `callback` when we delete legacy mode.\r\n  callback: ?Function,\r\n  containerInfo: Container,\r\n  tag: RootTag,\r\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\r\n  isStrictMode: boolean,\r\n  concurrentUpdatesByDefaultOverride: null | boolean,\r\n  identifierPrefix: string,\r\n  onRecoverableError: (error: mixed) => void,\r\n  transitionCallbacks: null | TransitionTracingCallbacks,\r\n): OpaqueRoot {\r\n  const hydrate = true;\r\n  const root = createFiberRoot(\r\n    containerInfo,\r\n    tag,\r\n    hydrate,\r\n    initialChildren,\r\n    hydrationCallbacks,\r\n    isStrictMode,\r\n    concurrentUpdatesByDefaultOverride,\r\n    identifierPrefix,\r\n    onRecoverableError,\r\n    transitionCallbacks,\r\n  );\r\n\r\n  // TODO: Move this to FiberRoot constructor\r\n  root.context = getContextForSubtree(null);\r\n\r\n  // Schedule the initial render. In a hydration root, this is different from\r\n  // a regular update because the initial render must match was was rendered\r\n  // on the server.\r\n  // NOTE: This update intentionally doesn't have a payload. We're only using\r\n  // the update to schedule work on the root fiber (and, for legacy roots, to\r\n  // enqueue the callback if one is provided).\r\n  const current = root.current;\r\n  const eventTime = requestEventTime();\r\n  const lane = requestUpdateLane(current);\r\n  const update = createUpdate(eventTime, lane);\r\n  update.callback =\r\n    callback !== undefined && callback !== null ? callback : null;\r\n  enqueueUpdate(current, update, lane);\r\n  scheduleInitialHydrationOnRoot(root, lane, eventTime);\r\n\r\n  return root;\r\n}\r\n\r\n/**\r\n * @description 创建update对象，保存在updateQueue环状链表中\r\n * @param {*} element \r\n * @param {*} container \r\n * @param {*} parentComponent \r\n * @param {*} callback \r\n * @returns \r\n */\r\nexport function updateContainer (\r\n  element: ReactNodeList,\r\n  container: OpaqueRoot,\r\n  parentComponent: ?React$Component<any, any>,\r\n  callback: ?Function,\r\n): Lane {\r\n  if (__DEV__) {\r\n    onScheduleRoot(container, element);\r\n  }\r\n  const current = container.current;\r\n  const eventTime = requestEventTime();\r\n  const lane = requestUpdateLane(current);\r\n\r\n  if (enableSchedulingProfiler) {\r\n    markRenderScheduled(lane);\r\n  }\r\n\r\n  const context = getContextForSubtree(parentComponent);\r\n  if (container.context === null) {\r\n    container.context = context;\r\n  } else {\r\n    container.pendingContext = context;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (\r\n      ReactCurrentFiberIsRendering &&\r\n      ReactCurrentFiberCurrent !== null &&\r\n      !didWarnAboutNestedUpdates\r\n    ) {\r\n      didWarnAboutNestedUpdates = true;\r\n      console.error(\r\n        'Render methods should be a pure function of props and state; ' +\r\n        'triggering nested component updates from render is not allowed. ' +\r\n        'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' +\r\n        'Check the render method of %s.',\r\n        getComponentNameFromFiber(ReactCurrentFiberCurrent) || 'Unknown',\r\n      );\r\n    }\r\n  }\r\n  // 创建update\r\n  const update = createUpdate(eventTime, lane);  //创建update\r\n  // Caution: React DevTools currently depends on this property\r\n  // being called \"element\".\r\n  update.payload = { element };\r\n\r\n  callback = callback === undefined ? null : callback;\r\n  if (callback !== null) {\r\n    if (__DEV__) {\r\n      if (typeof callback !== 'function') {\r\n        console.error(\r\n          'render(...): Expected the last optional `callback` argument to be a ' +\r\n          'function. Instead received: %s.',\r\n          callback,\r\n        );\r\n      }\r\n    }\r\n    update.callback = callback;\r\n  }\r\n\r\n  enqueueUpdate(current, update, lane); //update入队\r\n  const root = scheduleUpdateOnFiber(current, lane, eventTime);  //调度update\r\n  if (root !== null) {\r\n    entangleTransitions(root, current, lane);\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nexport {\r\n  batchedUpdates,\r\n  deferredUpdates,\r\n  discreteUpdates,\r\n  flushControlled,\r\n  flushSync,\r\n  isAlreadyRendering,\r\n  flushPassiveEffects,\r\n};\r\n\r\nexport function getPublicRootInstance (\r\n  container: OpaqueRoot,\r\n): React$Component<any, any> | PublicInstance | null {\r\n  const containerFiber = container.current;\r\n  if (!containerFiber.child) {\r\n    return null;\r\n  }\r\n  switch (containerFiber.child.tag) {\r\n    case HostComponent:\r\n      return getPublicInstance(containerFiber.child.stateNode);\r\n    default:\r\n      return containerFiber.child.stateNode;\r\n  }\r\n}\r\n\r\nexport function attemptSynchronousHydration (fiber: Fiber): void {\r\n  switch (fiber.tag) {\r\n    case HostRoot:\r\n      const root: FiberRoot = fiber.stateNode;\r\n      if (isRootDehydrated(root)) {\r\n        // Flush the first scheduled \"update\".\r\n        const lanes = getHighestPriorityPendingLanes(root);\r\n        flushRoot(root, lanes);\r\n      }\r\n      break;\r\n    case SuspenseComponent:\r\n      const eventTime = requestEventTime();\r\n      flushSync(() => scheduleUpdateOnFiber(fiber, SyncLane, eventTime));\r\n      // If we're still blocked after this, we need to increase\r\n      // the priority of any promises resolving within this\r\n      // boundary so that they next attempt also has higher pri.\r\n      const retryLane = SyncLane;\r\n      markRetryLaneIfNotHydrated(fiber, retryLane);\r\n      break;\r\n  }\r\n}\r\n\r\nfunction markRetryLaneImpl (fiber: Fiber, retryLane: Lane) {\r\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\r\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\r\n    suspenseState.retryLane = higherPriorityLane(\r\n      suspenseState.retryLane,\r\n      retryLane,\r\n    );\r\n  }\r\n}\r\n\r\n// Increases the priority of thenables when they resolve within this boundary.\r\nfunction markRetryLaneIfNotHydrated (fiber: Fiber, retryLane: Lane) {\r\n  markRetryLaneImpl(fiber, retryLane);\r\n  const alternate = fiber.alternate;\r\n  if (alternate) {\r\n    markRetryLaneImpl(alternate, retryLane);\r\n  }\r\n}\r\n\r\nexport function attemptDiscreteHydration (fiber: Fiber): void {\r\n  if (fiber.tag !== SuspenseComponent) {\r\n    // We ignore HostRoots here because we can't increase\r\n    // their priority and they should not suspend on I/O,\r\n    // since you have to wrap anything that might suspend in\r\n    // Suspense.\r\n    return;\r\n  }\r\n  const eventTime = requestEventTime();\r\n  const lane = SyncLane;\r\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n  markRetryLaneIfNotHydrated(fiber, lane);\r\n}\r\n\r\nexport function attemptContinuousHydration (fiber: Fiber): void {\r\n  if (fiber.tag !== SuspenseComponent) {\r\n    // We ignore HostRoots here because we can't increase\r\n    // their priority and they should not suspend on I/O,\r\n    // since you have to wrap anything that might suspend in\r\n    // Suspense.\r\n    return;\r\n  }\r\n  const eventTime = requestEventTime();\r\n  const lane = SelectiveHydrationLane;\r\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n  markRetryLaneIfNotHydrated(fiber, lane);\r\n}\r\n\r\nexport function attemptHydrationAtCurrentPriority (fiber: Fiber): void {\r\n  if (fiber.tag !== SuspenseComponent) {\r\n    // We ignore HostRoots here because we can't increase\r\n    // their priority other than synchronously flush it.\r\n    return;\r\n  }\r\n  const eventTime = requestEventTime();\r\n  const lane = requestUpdateLane(fiber);\r\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n  markRetryLaneIfNotHydrated(fiber, lane);\r\n}\r\n\r\nexport { getCurrentUpdatePriority, runWithPriority };\r\n\r\nexport { findHostInstance };\r\n\r\nexport { findHostInstanceWithWarning };\r\n\r\nexport function findHostInstanceWithNoPortals (\r\n  fiber: Fiber,\r\n): PublicInstance | null {\r\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\r\n  if (hostFiber === null) {\r\n    return null;\r\n  }\r\n  return hostFiber.stateNode;\r\n}\r\n\r\nlet shouldErrorImpl = fiber => null;\r\n\r\nexport function shouldError (fiber: Fiber): ?boolean {\r\n  return shouldErrorImpl(fiber);\r\n}\r\n\r\nlet shouldSuspendImpl = fiber => false;\r\n\r\nexport function shouldSuspend (fiber: Fiber): boolean {\r\n  return shouldSuspendImpl(fiber);\r\n}\r\n\r\nlet overrideHookState = null;\r\nlet overrideHookStateDeletePath = null;\r\nlet overrideHookStateRenamePath = null;\r\nlet overrideProps = null;\r\nlet overridePropsDeletePath = null;\r\nlet overridePropsRenamePath = null;\r\nlet scheduleUpdate = null;\r\nlet setErrorHandler = null;\r\nlet setSuspenseHandler = null;\r\n\r\nif (__DEV__) {\r\n  const copyWithDeleteImpl = (\r\n    obj: Object | Array<any>,\r\n    path: Array<string | number>,\r\n    index: number,\r\n  ) => {\r\n    const key = path[index];\r\n    const updated = isArray(obj) ? obj.slice() : { ...obj };\r\n    if (index + 1 === path.length) {\r\n      if (isArray(updated)) {\r\n        updated.splice(((key: any): number), 1);\r\n      } else {\r\n        delete updated[key];\r\n      }\r\n      return updated;\r\n    }\r\n    // $FlowFixMe number or string is fine here\r\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\r\n    return updated;\r\n  };\r\n\r\n  const copyWithDelete = (\r\n    obj: Object | Array<any>,\r\n    path: Array<string | number>,\r\n  ): Object | Array<any> => {\r\n    return copyWithDeleteImpl(obj, path, 0);\r\n  };\r\n\r\n  const copyWithRenameImpl = (\r\n    obj: Object | Array<any>,\r\n    oldPath: Array<string | number>,\r\n    newPath: Array<string | number>,\r\n    index: number,\r\n  ) => {\r\n    const oldKey = oldPath[index];\r\n    const updated = isArray(obj) ? obj.slice() : { ...obj };\r\n    if (index + 1 === oldPath.length) {\r\n      const newKey = newPath[index];\r\n      // $FlowFixMe number or string is fine here\r\n      updated[newKey] = updated[oldKey];\r\n      if (isArray(updated)) {\r\n        updated.splice(((oldKey: any): number), 1);\r\n      } else {\r\n        delete updated[oldKey];\r\n      }\r\n    } else {\r\n      // $FlowFixMe number or string is fine here\r\n      updated[oldKey] = copyWithRenameImpl(\r\n        // $FlowFixMe number or string is fine here\r\n        obj[oldKey],\r\n        oldPath,\r\n        newPath,\r\n        index + 1,\r\n      );\r\n    }\r\n    return updated;\r\n  };\r\n\r\n  const copyWithRename = (\r\n    obj: Object | Array<any>,\r\n    oldPath: Array<string | number>,\r\n    newPath: Array<string | number>,\r\n  ): Object | Array<any> => {\r\n    if (oldPath.length !== newPath.length) {\r\n      console.warn('copyWithRename() expects paths of the same length');\r\n      return;\r\n    } else {\r\n      for (let i = 0; i < newPath.length - 1; i++) {\r\n        if (oldPath[i] !== newPath[i]) {\r\n          console.warn(\r\n            'copyWithRename() expects paths to be the same except for the deepest key',\r\n          );\r\n          return;\r\n        }\r\n      }\r\n    }\r\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\r\n  };\r\n\r\n  const copyWithSetImpl = (\r\n    obj: Object | Array<any>,\r\n    path: Array<string | number>,\r\n    index: number,\r\n    value: any,\r\n  ) => {\r\n    if (index >= path.length) {\r\n      return value;\r\n    }\r\n    const key = path[index];\r\n    const updated = isArray(obj) ? obj.slice() : { ...obj };\r\n    // $FlowFixMe number or string is fine here\r\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\r\n    return updated;\r\n  };\r\n\r\n  const copyWithSet = (\r\n    obj: Object | Array<any>,\r\n    path: Array<string | number>,\r\n    value: any,\r\n  ): Object | Array<any> => {\r\n    return copyWithSetImpl(obj, path, 0, value);\r\n  };\r\n\r\n  const findHook = (fiber: Fiber, id: number) => {\r\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\r\n    // This may change in the future with e.g. nested hooks.\r\n    let currentHook = fiber.memoizedState;\r\n    while (currentHook !== null && id > 0) {\r\n      currentHook = currentHook.next;\r\n      id--;\r\n    }\r\n    return currentHook;\r\n  };\r\n\r\n  // Support DevTools editable values for useState and useReducer.\r\n  overrideHookState = (\r\n    fiber: Fiber,\r\n    id: number,\r\n    path: Array<string | number>,\r\n    value: any,\r\n  ) => {\r\n    const hook = findHook(fiber, id);\r\n    if (hook !== null) {\r\n      const newState = copyWithSet(hook.memoizedState, path, value);\r\n      hook.memoizedState = newState;\r\n      hook.baseState = newState;\r\n\r\n      // We aren't actually adding an update to the queue,\r\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\r\n      // (There's no appropriate action type for DevTools overrides.)\r\n      // As a result though, React will see the scheduled update as a noop and bailout.\r\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\r\n      fiber.memoizedProps = { ...fiber.memoizedProps };\r\n\r\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n    }\r\n  };\r\n  overrideHookStateDeletePath = (\r\n    fiber: Fiber,\r\n    id: number,\r\n    path: Array<string | number>,\r\n  ) => {\r\n    const hook = findHook(fiber, id);\r\n    if (hook !== null) {\r\n      const newState = copyWithDelete(hook.memoizedState, path);\r\n      hook.memoizedState = newState;\r\n      hook.baseState = newState;\r\n\r\n      // We aren't actually adding an update to the queue,\r\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\r\n      // (There's no appropriate action type for DevTools overrides.)\r\n      // As a result though, React will see the scheduled update as a noop and bailout.\r\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\r\n      fiber.memoizedProps = { ...fiber.memoizedProps };\r\n\r\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n    }\r\n  };\r\n  overrideHookStateRenamePath = (\r\n    fiber: Fiber,\r\n    id: number,\r\n    oldPath: Array<string | number>,\r\n    newPath: Array<string | number>,\r\n  ) => {\r\n    const hook = findHook(fiber, id);\r\n    if (hook !== null) {\r\n      const newState = copyWithRename(hook.memoizedState, oldPath, newPath);\r\n      hook.memoizedState = newState;\r\n      hook.baseState = newState;\r\n\r\n      // We aren't actually adding an update to the queue,\r\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\r\n      // (There's no appropriate action type for DevTools overrides.)\r\n      // As a result though, React will see the scheduled update as a noop and bailout.\r\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\r\n      fiber.memoizedProps = { ...fiber.memoizedProps };\r\n\r\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n    }\r\n  };\r\n\r\n  // Support DevTools props for function components, forwardRef, memo, host components, etc.\r\n  overrideProps = (fiber: Fiber, path: Array<string | number>, value: any) => {\r\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\r\n    if (fiber.alternate) {\r\n      fiber.alternate.pendingProps = fiber.pendingProps;\r\n    }\r\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n  };\r\n  overridePropsDeletePath = (fiber: Fiber, path: Array<string | number>) => {\r\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\r\n    if (fiber.alternate) {\r\n      fiber.alternate.pendingProps = fiber.pendingProps;\r\n    }\r\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n  };\r\n  overridePropsRenamePath = (\r\n    fiber: Fiber,\r\n    oldPath: Array<string | number>,\r\n    newPath: Array<string | number>,\r\n  ) => {\r\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\r\n    if (fiber.alternate) {\r\n      fiber.alternate.pendingProps = fiber.pendingProps;\r\n    }\r\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n  };\r\n\r\n  scheduleUpdate = (fiber: Fiber) => {\r\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n  };\r\n\r\n  setErrorHandler = (newShouldErrorImpl: Fiber => ?boolean) => {\r\n    shouldErrorImpl = newShouldErrorImpl;\r\n  };\r\n\r\n  setSuspenseHandler = (newShouldSuspendImpl: Fiber => boolean) => {\r\n    shouldSuspendImpl = newShouldSuspendImpl;\r\n  };\r\n}\r\n\r\nfunction findHostInstanceByFiber (fiber: Fiber): Instance | TextInstance | null {\r\n  const hostFiber = findCurrentHostFiber(fiber);\r\n  if (hostFiber === null) {\r\n    return null;\r\n  }\r\n  return hostFiber.stateNode;\r\n}\r\n\r\nfunction emptyFindFiberByHostInstance (\r\n  instance: Instance | TextInstance,\r\n): Fiber | null {\r\n  return null;\r\n}\r\n\r\nfunction getCurrentFiberForDevTools () {\r\n  return ReactCurrentFiberCurrent;\r\n}\r\n\r\nexport function injectIntoDevTools (devToolsConfig: DevToolsConfig): boolean {\r\n  const { findFiberByHostInstance } = devToolsConfig;\r\n  const { ReactCurrentDispatcher } = ReactSharedInternals;\r\n\r\n  return injectInternals({\r\n    bundleType: devToolsConfig.bundleType,\r\n    version: devToolsConfig.version,\r\n    rendererPackageName: devToolsConfig.rendererPackageName,\r\n    rendererConfig: devToolsConfig.rendererConfig,\r\n    overrideHookState,\r\n    overrideHookStateDeletePath,\r\n    overrideHookStateRenamePath,\r\n    overrideProps,\r\n    overridePropsDeletePath,\r\n    overridePropsRenamePath,\r\n    setErrorHandler,\r\n    setSuspenseHandler,\r\n    scheduleUpdate,\r\n    currentDispatcherRef: ReactCurrentDispatcher,\r\n    findHostInstanceByFiber,\r\n    findFiberByHostInstance:\r\n      findFiberByHostInstance || emptyFindFiberByHostInstance,\r\n    // React Refresh\r\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\r\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\r\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\r\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\r\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\r\n    getCurrentFiber: __DEV__ ? getCurrentFiberForDevTools : null,\r\n    // Enables DevTools to detect reconciler version rather than renderer version\r\n    // which may not match for third party renderers.\r\n    reconcilerVersion: ReactVersion,\r\n  });\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA,SACEA,oBADF,EAEEC,iCAFF,QAGO,4BAHP;AAIA,SAASC,GAAG,IAAIC,WAAhB,QAAmC,yBAAnC;AACA,SACEC,aADF,EAEEC,cAFF,EAGEC,QAHF,EAIEC,iBAJF,QAKO,iBALP;AAMA,OAAOC,yBAAP,MAAsC,gDAAtC;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SAASC,wBAAT,QAAyC,0BAAzC;AACA,OAAOC,oBAAP,MAAiC,6BAAjC;AACA,SAASC,iBAAT,QAAkC,wBAAlC;AACA,SACEC,0BADF,EAEEC,mBAFF,EAGEC,kBAHF,EAIEC,iBAAiB,IAAIC,uBAJvB,QAKO,yBALP;AAMA,SAASC,eAAT,QAAgC,sBAAhC;AACA,SAASC,gBAAT,QAAiC,4BAAjC;AACA,SACEC,eADF,EAEEC,mBAFF,EAGEC,cAHF,QAIO,8BAJP;AAKA,SACEC,gBADF,EAEEC,iBAFF,EAGEC,qBAHF,EAIEC,8BAJF,EAKEC,SALF,EAMEC,cANF,EAOEC,SAPF,EAQEC,kBARF,EASEC,eATF,EAUEC,eAVF,EAWEC,eAXF,EAYEC,mBAZF,QAaO,0BAbP;AAcA,SACEC,YADF,EAEEC,aAFF,EAGEC,mBAHF,QAIO,wBAJP;AAKA,SACEC,WAAW,IAAIC,4BADjB,EAEEC,OAAO,IAAIC,wBAFb,EAGEC,iBAAiB,IAAIC,2BAHvB,EAIEC,eAAe,IAAIC,yBAJrB,QAKO,qBALP;AAMA,SAASC,gBAAT,QAAiC,mBAAjC;AACA,SACEC,QADF,EAEEC,sBAFF,EAGEC,WAHF,EAIEC,8BAJF,EAKEC,kBALF,QAMO,sBANP;AAOA,SACEC,wBADF,EAEEC,eAFF,QAGO,4BAHP;AAIA,SACEC,eADF,EAEEC,YAFF,EAGEC,iBAHF,EAIEC,2BAJF,QAKO,8BALP;AAMA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SAASC,iCAAT,QAAkD,0BAAlD;AACA,SAASC,YAAT,QAA6B,eAA7B;AACA,SACEC,uBADF,EAEEC,4BAFF,EAGEC,kBAHF,EAIEC,sBAJF,EAKEC,kBALF,EAMEC,iCANF,EAOEC,YAPF,EAQEC,iBARF,EASEC,WATF,EAUEC,mBAVF,QAWO,sBAXP;AA6BA,IAAIC,yBAAJ;AACA,IAAIC,gCAAJ;;AAEA,IAAIC,OAAJ,EAAa;EACXF,yBAAyB,GAAG,KAA5B;EACAC,gCAAgC,GAAG,EAAnC;AACD;;AAED,SAASE,oBAAT,CACEC,eADF,EAEU;EACR,IAAI,CAACA,eAAL,EAAsB;IACpB,OAAO5D,kBAAP;EACD;;EAED,MAAM6D,KAAK,GAAGzE,WAAW,CAACwE,eAAD,CAAzB;EACA,MAAME,aAAa,GAAGhE,0BAA0B,CAAC+D,KAAD,CAAhD;;EAEA,IAAIA,KAAK,CAACE,GAAN,KAAczE,cAAlB,EAAkC;IAChC,MAAM0E,SAAS,GAAGH,KAAK,CAACI,IAAxB;;IACA,IAAI/D,uBAAuB,CAAC8D,SAAD,CAA3B,EAAwC;MACtC,OAAOjE,mBAAmB,CAAC8D,KAAD,EAAQG,SAAR,EAAmBF,aAAnB,CAA1B;IACD;EACF;;EAED,OAAOA,aAAP;AACD;;AAED,SAASI,gBAAT,CAA2BC,SAA3B,EAAqE;EACnE,MAAMN,KAAK,GAAGzE,WAAW,CAAC+E,SAAD,CAAzB;;EACA,IAAIN,KAAK,KAAKO,SAAd,EAAyB;IACvB,IAAI,OAAOD,SAAS,CAACE,MAAjB,KAA4B,UAAhC,EAA4C;MAC1C,MAAM,IAAIC,KAAJ,CAAU,gDAAV,CAAN;IACD,CAFD,MAEO;MACL,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYJ,SAAZ,EAAuBM,IAAvB,CAA4B,GAA5B,CAAb;MACA,MAAM,IAAIH,KAAJ,CACH,sDAAqDC,IAAK,EADvD,CAAN;IAGD;EACF;;EACD,MAAMG,SAAS,GAAGzF,oBAAoB,CAAC4E,KAAD,CAAtC;;EACA,IAAIa,SAAS,KAAK,IAAlB,EAAwB;IACtB,OAAO,IAAP;EACD;;EACD,OAAOA,SAAS,CAACC,SAAjB;AACD;;AAED,SAASC,2BAAT,CACET,SADF,EAEEU,UAFF,EAGyB;EACvB,IAAInB,OAAJ,EAAa;IACX,MAAMG,KAAK,GAAGzE,WAAW,CAAC+E,SAAD,CAAzB;;IACA,IAAIN,KAAK,KAAKO,SAAd,EAAyB;MACvB,IAAI,OAAOD,SAAS,CAACE,MAAjB,KAA4B,UAAhC,EAA4C;QAC1C,MAAM,IAAIC,KAAJ,CAAU,gDAAV,CAAN;MACD,CAFD,MAEO;QACL,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYJ,SAAZ,EAAuBM,IAAvB,CAA4B,GAA5B,CAAb;QACA,MAAM,IAAIH,KAAJ,CACH,sDAAqDC,IAAK,EADvD,CAAN;MAGD;IACF;;IACD,MAAMG,SAAS,GAAGzF,oBAAoB,CAAC4E,KAAD,CAAtC;;IACA,IAAIa,SAAS,KAAK,IAAlB,EAAwB;MACtB,OAAO,IAAP;IACD;;IACD,IAAIA,SAAS,CAACI,IAAV,GAAiB/C,gBAArB,EAAuC;MACrC,MAAMgD,aAAa,GAAGtF,yBAAyB,CAACoE,KAAD,CAAzB,IAAoC,WAA1D;;MACA,IAAI,CAACJ,gCAAgC,CAACsB,aAAD,CAArC,EAAsD;QACpDtB,gCAAgC,CAACsB,aAAD,CAAhC,GAAkD,IAAlD;QAEA,MAAMC,aAAa,GAAGtD,wBAAtB;;QACA,IAAI;UACFI,yBAAyB,CAAC4C,SAAD,CAAzB;;UACA,IAAIb,KAAK,CAACiB,IAAN,GAAa/C,gBAAjB,EAAmC;YACjCkD,OAAO,CAACC,KAAR,CACE,qCACA,8DADA,GAEA,oEAFA,GAGA,2CAHA,GAIA,gDALF,EAMEL,UANF,EAOEA,UAPF,EAQEE,aARF;UAUD,CAXD,MAWO;YACLE,OAAO,CAACC,KAAR,CACE,qCACA,qEADA,GAEA,oEAFA,GAGA,2CAHA,GAIA,gDALF,EAMEL,UANF,EAOEA,UAPF,EAQEE,aARF;UAUD;QACF,CAzBD,SAyBU;UACR;UACA;UACA,IAAIC,aAAJ,EAAmB;YACjBlD,yBAAyB,CAACkD,aAAD,CAAzB;UACD,CAFD,MAEO;YACLpD,2BAA2B;UAC5B;QACF;MACF;IACF;;IACD,OAAO8C,SAAS,CAACC,SAAjB;EACD;;EACD,OAAOT,gBAAgB,CAACC,SAAD,CAAvB;AACD;;AAED,OAAO,SAASgB,eAAT,CACLC,aADK,EAELrB,GAFK,EAGLsB,kBAHK,EAILC,YAJK,EAKLC,kCALK,EAMLC,gBANK,EAOLC,kBAPK,EAQLC,mBARK,EASO;EACZ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA,MAAMC,OAAO,GAAG,KAAhB,CAxBY,CAyBZ;;EACA,MAAMC,eAAe,GAAG,IAAxB,CA1BY,CA2BZ;;EACA,OAAOzF,eAAe,CACpBiF,aADoB,EAEpBrB,GAFoB,EAGpB4B,OAHoB,EAIpBC,eAJoB,EAKpBP,kBALoB,EAMpBC,YANoB,EAOpBC,kCAPoB,EAQpBC,gBARoB,EASpBC,kBAToB,EAUpBC,mBAVoB,CAAtB;AAYD;AAED,OAAO,SAASG,wBAAT,CACLD,eADK,EAEL;AACAE,QAHK,EAILV,aAJK,EAKLrB,GALK,EAMLsB,kBANK,EAOLC,YAPK,EAQLC,kCARK,EASLC,gBATK,EAULC,kBAVK,EAWLC,mBAXK,EAYO;EACZ,MAAMC,OAAO,GAAG,IAAhB;EACA,MAAMI,IAAI,GAAG5F,eAAe,CAC1BiF,aAD0B,EAE1BrB,GAF0B,EAG1B4B,OAH0B,EAI1BC,eAJ0B,EAK1BP,kBAL0B,EAM1BC,YAN0B,EAO1BC,kCAP0B,EAQ1BC,gBAR0B,EAS1BC,kBAT0B,EAU1BC,mBAV0B,CAA5B,CAFY,CAeZ;;EACAK,IAAI,CAACC,OAAL,GAAerC,oBAAoB,CAAC,IAAD,CAAnC,CAhBY,CAkBZ;EACA;EACA;EACA;EACA;EACA;;EACA,MAAMlC,OAAO,GAAGsE,IAAI,CAACtE,OAArB;EACA,MAAMwE,SAAS,GAAGzF,gBAAgB,EAAlC;EACA,MAAM0F,IAAI,GAAGzF,iBAAiB,CAACgB,OAAD,CAA9B;EACA,MAAM0E,MAAM,GAAG/E,YAAY,CAAC6E,SAAD,EAAYC,IAAZ,CAA3B;EACAC,MAAM,CAACL,QAAP,GACEA,QAAQ,KAAK1B,SAAb,IAA0B0B,QAAQ,KAAK,IAAvC,GAA8CA,QAA9C,GAAyD,IAD3D;EAEAzE,aAAa,CAACI,OAAD,EAAU0E,MAAV,EAAkBD,IAAlB,CAAb;EACAvF,8BAA8B,CAACoF,IAAD,EAAOG,IAAP,EAAaD,SAAb,CAA9B;EAEA,OAAOF,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,eAAT,CACLC,OADK,EAELC,SAFK,EAGL1C,eAHK,EAILkC,QAJK,EAKC;EACN,IAAIpC,OAAJ,EAAa;IACXnD,cAAc,CAAC+F,SAAD,EAAYD,OAAZ,CAAd;EACD;;EACD,MAAM5E,OAAO,GAAG6E,SAAS,CAAC7E,OAA1B;EACA,MAAMwE,SAAS,GAAGzF,gBAAgB,EAAlC;EACA,MAAM0F,IAAI,GAAGzF,iBAAiB,CAACgB,OAAD,CAA9B;;EAEA,IAAI9B,wBAAJ,EAA8B;IAC5BW,mBAAmB,CAAC4F,IAAD,CAAnB;EACD;;EAED,MAAMF,OAAO,GAAGrC,oBAAoB,CAACC,eAAD,CAApC;;EACA,IAAI0C,SAAS,CAACN,OAAV,KAAsB,IAA1B,EAAgC;IAC9BM,SAAS,CAACN,OAAV,GAAoBA,OAApB;EACD,CAFD,MAEO;IACLM,SAAS,CAACC,cAAV,GAA2BP,OAA3B;EACD;;EAED,IAAItC,OAAJ,EAAa;IACX,IACElC,4BAA4B,IAC5BE,wBAAwB,KAAK,IAD7B,IAEA,CAAC8B,yBAHH,EAIE;MACAA,yBAAyB,GAAG,IAA5B;MACAyB,OAAO,CAACC,KAAR,CACE,kEACA,kEADA,GAEA,iEAFA,GAGA,gCAJF,EAKEzF,yBAAyB,CAACiC,wBAAD,CAAzB,IAAuD,SALzD;IAOD;EACF,CAlCK,CAmCN;;;EACA,MAAMyE,MAAM,GAAG/E,YAAY,CAAC6E,SAAD,EAAYC,IAAZ,CAA3B,CApCM,CAoCyC;EAC/C;EACA;;EACAC,MAAM,CAACK,OAAP,GAAiB;IAAEH;EAAF,CAAjB;EAEAP,QAAQ,GAAGA,QAAQ,KAAK1B,SAAb,GAAyB,IAAzB,GAAgC0B,QAA3C;;EACA,IAAIA,QAAQ,KAAK,IAAjB,EAAuB;IACrB,IAAIpC,OAAJ,EAAa;MACX,IAAI,OAAOoC,QAAP,KAAoB,UAAxB,EAAoC;QAClCb,OAAO,CAACC,KAAR,CACE,yEACA,iCAFF,EAGEY,QAHF;MAKD;IACF;;IACDK,MAAM,CAACL,QAAP,GAAkBA,QAAlB;EACD;;EAEDzE,aAAa,CAACI,OAAD,EAAU0E,MAAV,EAAkBD,IAAlB,CAAb,CAvDM,CAuDgC;;EACtC,MAAMH,IAAI,GAAGrF,qBAAqB,CAACe,OAAD,EAAUyE,IAAV,EAAgBD,SAAhB,CAAlC,CAxDM,CAwDyD;;EAC/D,IAAIF,IAAI,KAAK,IAAb,EAAmB;IACjBzE,mBAAmB,CAACyE,IAAD,EAAOtE,OAAP,EAAgByE,IAAhB,CAAnB;EACD;;EAED,OAAOA,IAAP;AACD;AAED,SACErF,cADF,EAEEI,eAFF,EAGEC,eAHF,EAIEF,eAJF,EAKEF,SALF,EAMEC,kBANF,EAOEI,mBAPF;AAUA,OAAO,SAASsF,qBAAT,CACLH,SADK,EAE8C;EACnD,MAAMI,cAAc,GAAGJ,SAAS,CAAC7E,OAAjC;;EACA,IAAI,CAACiF,cAAc,CAACC,KAApB,EAA2B;IACzB,OAAO,IAAP;EACD;;EACD,QAAQD,cAAc,CAACC,KAAf,CAAqB5C,GAA7B;IACE,KAAK1E,aAAL;MACE,OAAOQ,iBAAiB,CAAC6G,cAAc,CAACC,KAAf,CAAqBhC,SAAtB,CAAxB;;IACF;MACE,OAAO+B,cAAc,CAACC,KAAf,CAAqBhC,SAA5B;EAJJ;AAMD;AAED,OAAO,SAASiC,2BAAT,CAAsC/C,KAAtC,EAA0D;EAC/D,QAAQA,KAAK,CAACE,GAAd;IACE,KAAKxE,QAAL;MACE,MAAMwG,IAAe,GAAGlC,KAAK,CAACc,SAA9B;;MACA,IAAIvE,gBAAgB,CAAC2F,IAAD,CAApB,EAA4B;QAC1B;QACA,MAAMc,KAAK,GAAG1E,8BAA8B,CAAC4D,IAAD,CAA5C;QACAnF,SAAS,CAACmF,IAAD,EAAOc,KAAP,CAAT;MACD;;MACD;;IACF,KAAKrH,iBAAL;MACE,MAAMyG,SAAS,GAAGzF,gBAAgB,EAAlC;MACAM,SAAS,CAAC,MAAMJ,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBiE,SAAlB,CAA5B,CAAT,CAFF,CAGE;MACA;MACA;;MACA,MAAMa,SAAS,GAAG9E,QAAlB;MACA+E,0BAA0B,CAAClD,KAAD,EAAQiD,SAAR,CAA1B;MACA;EAjBJ;AAmBD;;AAED,SAASE,iBAAT,CAA4BnD,KAA5B,EAA0CiD,SAA1C,EAA2D;EACzD,MAAMG,aAAmC,GAAGpD,KAAK,CAACqD,aAAlD;;EACA,IAAID,aAAa,KAAK,IAAlB,IAA0BA,aAAa,CAACE,UAAd,KAA6B,IAA3D,EAAiE;IAC/DF,aAAa,CAACH,SAAd,GAA0B1E,kBAAkB,CAC1C6E,aAAa,CAACH,SAD4B,EAE1CA,SAF0C,CAA5C;EAID;AACF,C,CAED;;;AACA,SAASC,0BAAT,CAAqClD,KAArC,EAAmDiD,SAAnD,EAAoE;EAClEE,iBAAiB,CAACnD,KAAD,EAAQiD,SAAR,CAAjB;EACA,MAAMM,SAAS,GAAGvD,KAAK,CAACuD,SAAxB;;EACA,IAAIA,SAAJ,EAAe;IACbJ,iBAAiB,CAACI,SAAD,EAAYN,SAAZ,CAAjB;EACD;AACF;;AAED,OAAO,SAASO,wBAAT,CAAmCxD,KAAnC,EAAuD;EAC5D,IAAIA,KAAK,CAACE,GAAN,KAAcvE,iBAAlB,EAAqC;IACnC;IACA;IACA;IACA;IACA;EACD;;EACD,MAAMyG,SAAS,GAAGzF,gBAAgB,EAAlC;EACA,MAAM0F,IAAI,GAAGlE,QAAb;EACAtB,qBAAqB,CAACmD,KAAD,EAAQqC,IAAR,EAAcD,SAAd,CAArB;EACAc,0BAA0B,CAAClD,KAAD,EAAQqC,IAAR,CAA1B;AACD;AAED,OAAO,SAASoB,0BAAT,CAAqCzD,KAArC,EAAyD;EAC9D,IAAIA,KAAK,CAACE,GAAN,KAAcvE,iBAAlB,EAAqC;IACnC;IACA;IACA;IACA;IACA;EACD;;EACD,MAAMyG,SAAS,GAAGzF,gBAAgB,EAAlC;EACA,MAAM0F,IAAI,GAAGjE,sBAAb;EACAvB,qBAAqB,CAACmD,KAAD,EAAQqC,IAAR,EAAcD,SAAd,CAArB;EACAc,0BAA0B,CAAClD,KAAD,EAAQqC,IAAR,CAA1B;AACD;AAED,OAAO,SAASqB,iCAAT,CAA4C1D,KAA5C,EAAgE;EACrE,IAAIA,KAAK,CAACE,GAAN,KAAcvE,iBAAlB,EAAqC;IACnC;IACA;IACA;EACD;;EACD,MAAMyG,SAAS,GAAGzF,gBAAgB,EAAlC;EACA,MAAM0F,IAAI,GAAGzF,iBAAiB,CAACoD,KAAD,CAA9B;EACAnD,qBAAqB,CAACmD,KAAD,EAAQqC,IAAR,EAAcD,SAAd,CAArB;EACAc,0BAA0B,CAAClD,KAAD,EAAQqC,IAAR,CAA1B;AACD;AAED,SAAS7D,wBAAT,EAAmCC,eAAnC;AAEA,SAAS4B,gBAAT;AAEA,SAASU,2BAAT;AAEA,OAAO,SAAS4C,6BAAT,CACL3D,KADK,EAEkB;EACvB,MAAMa,SAAS,GAAGxF,iCAAiC,CAAC2E,KAAD,CAAnD;;EACA,IAAIa,SAAS,KAAK,IAAlB,EAAwB;IACtB,OAAO,IAAP;EACD;;EACD,OAAOA,SAAS,CAACC,SAAjB;AACD;;AAED,IAAI8C,eAAe,GAAG5D,KAAK,IAAI,IAA/B;;AAEA,OAAO,SAAS6D,WAAT,CAAsB7D,KAAtB,EAA8C;EACnD,OAAO4D,eAAe,CAAC5D,KAAD,CAAtB;AACD;;AAED,IAAI8D,iBAAiB,GAAG9D,KAAK,IAAI,KAAjC;;AAEA,OAAO,SAAS+D,aAAT,CAAwB/D,KAAxB,EAA+C;EACpD,OAAO8D,iBAAiB,CAAC9D,KAAD,CAAxB;AACD;AAED,IAAIgE,iBAAiB,GAAG,IAAxB;AACA,IAAIC,2BAA2B,GAAG,IAAlC;AACA,IAAIC,2BAA2B,GAAG,IAAlC;AACA,IAAIC,aAAa,GAAG,IAApB;AACA,IAAIC,uBAAuB,GAAG,IAA9B;AACA,IAAIC,uBAAuB,GAAG,IAA9B;AACA,IAAIC,cAAc,GAAG,IAArB;AACA,IAAIC,eAAe,GAAG,IAAtB;AACA,IAAIC,kBAAkB,GAAG,IAAzB;;AAEA,IAAI3E,OAAJ,EAAa;EACX,MAAM4E,kBAAkB,GAAG,CACzBC,GADyB,EAEzBC,IAFyB,EAGzBC,KAHyB,KAItB;IACH,MAAMC,GAAG,GAAGF,IAAI,CAACC,KAAD,CAAhB;IACA,MAAME,OAAO,GAAGjJ,OAAO,CAAC6I,GAAD,CAAP,GAAeA,GAAG,CAACK,KAAJ,EAAf,GAA6B,EAAE,GAAGL;IAAL,CAA7C;;IACA,IAAIE,KAAK,GAAG,CAAR,KAAcD,IAAI,CAACK,MAAvB,EAA+B;MAC7B,IAAInJ,OAAO,CAACiJ,OAAD,CAAX,EAAsB;QACpBA,OAAO,CAACG,MAAR,CAAiBJ,GAAjB,EAAqC,CAArC;MACD,CAFD,MAEO;QACL,OAAOC,OAAO,CAACD,GAAD,CAAd;MACD;;MACD,OAAOC,OAAP;IACD,CAVE,CAWH;;;IACAA,OAAO,CAACD,GAAD,CAAP,GAAeJ,kBAAkB,CAACC,GAAG,CAACG,GAAD,CAAJ,EAAWF,IAAX,EAAiBC,KAAK,GAAG,CAAzB,CAAjC;IACA,OAAOE,OAAP;EACD,CAlBD;;EAoBA,MAAMI,cAAc,GAAG,CACrBR,GADqB,EAErBC,IAFqB,KAGG;IACxB,OAAOF,kBAAkB,CAACC,GAAD,EAAMC,IAAN,EAAY,CAAZ,CAAzB;EACD,CALD;;EAOA,MAAMQ,kBAAkB,GAAG,CACzBT,GADyB,EAEzBU,OAFyB,EAGzBC,OAHyB,EAIzBT,KAJyB,KAKtB;IACH,MAAMU,MAAM,GAAGF,OAAO,CAACR,KAAD,CAAtB;IACA,MAAME,OAAO,GAAGjJ,OAAO,CAAC6I,GAAD,CAAP,GAAeA,GAAG,CAACK,KAAJ,EAAf,GAA6B,EAAE,GAAGL;IAAL,CAA7C;;IACA,IAAIE,KAAK,GAAG,CAAR,KAAcQ,OAAO,CAACJ,MAA1B,EAAkC;MAChC,MAAMO,MAAM,GAAGF,OAAO,CAACT,KAAD,CAAtB,CADgC,CAEhC;;MACAE,OAAO,CAACS,MAAD,CAAP,GAAkBT,OAAO,CAACQ,MAAD,CAAzB;;MACA,IAAIzJ,OAAO,CAACiJ,OAAD,CAAX,EAAsB;QACpBA,OAAO,CAACG,MAAR,CAAiBK,MAAjB,EAAwC,CAAxC;MACD,CAFD,MAEO;QACL,OAAOR,OAAO,CAACQ,MAAD,CAAd;MACD;IACF,CATD,MASO;MACL;MACAR,OAAO,CAACQ,MAAD,CAAP,GAAkBH,kBAAkB,EAClC;MACAT,GAAG,CAACY,MAAD,CAF+B,EAGlCF,OAHkC,EAIlCC,OAJkC,EAKlCT,KAAK,GAAG,CAL0B,CAApC;IAOD;;IACD,OAAOE,OAAP;EACD,CA5BD;;EA8BA,MAAMU,cAAc,GAAG,CACrBd,GADqB,EAErBU,OAFqB,EAGrBC,OAHqB,KAIG;IACxB,IAAID,OAAO,CAACJ,MAAR,KAAmBK,OAAO,CAACL,MAA/B,EAAuC;MACrC5D,OAAO,CAACqE,IAAR,CAAa,mDAAb;MACA;IACD,CAHD,MAGO;MACL,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAAO,CAACL,MAAR,GAAiB,CAArC,EAAwCU,CAAC,EAAzC,EAA6C;QAC3C,IAAIN,OAAO,CAACM,CAAD,CAAP,KAAeL,OAAO,CAACK,CAAD,CAA1B,EAA+B;UAC7BtE,OAAO,CAACqE,IAAR,CACE,0EADF;UAGA;QACD;MACF;IACF;;IACD,OAAON,kBAAkB,CAACT,GAAD,EAAMU,OAAN,EAAeC,OAAf,EAAwB,CAAxB,CAAzB;EACD,CAnBD;;EAqBA,MAAMM,eAAe,GAAG,CACtBjB,GADsB,EAEtBC,IAFsB,EAGtBC,KAHsB,EAItBgB,KAJsB,KAKnB;IACH,IAAIhB,KAAK,IAAID,IAAI,CAACK,MAAlB,EAA0B;MACxB,OAAOY,KAAP;IACD;;IACD,MAAMf,GAAG,GAAGF,IAAI,CAACC,KAAD,CAAhB;IACA,MAAME,OAAO,GAAGjJ,OAAO,CAAC6I,GAAD,CAAP,GAAeA,GAAG,CAACK,KAAJ,EAAf,GAA6B,EAAE,GAAGL;IAAL,CAA7C,CALG,CAMH;;IACAI,OAAO,CAACD,GAAD,CAAP,GAAec,eAAe,CAACjB,GAAG,CAACG,GAAD,CAAJ,EAAWF,IAAX,EAAiBC,KAAK,GAAG,CAAzB,EAA4BgB,KAA5B,CAA9B;IACA,OAAOd,OAAP;EACD,CAdD;;EAgBA,MAAMe,WAAW,GAAG,CAClBnB,GADkB,EAElBC,IAFkB,EAGlBiB,KAHkB,KAIM;IACxB,OAAOD,eAAe,CAACjB,GAAD,EAAMC,IAAN,EAAY,CAAZ,EAAeiB,KAAf,CAAtB;EACD,CAND;;EAQA,MAAME,QAAQ,GAAG,CAAC9F,KAAD,EAAe+F,EAAf,KAA8B;IAC7C;IACA;IACA,IAAIC,WAAW,GAAGhG,KAAK,CAACqD,aAAxB;;IACA,OAAO2C,WAAW,KAAK,IAAhB,IAAwBD,EAAE,GAAG,CAApC,EAAuC;MACrCC,WAAW,GAAGA,WAAW,CAACC,IAA1B;MACAF,EAAE;IACH;;IACD,OAAOC,WAAP;EACD,CATD,CAvGW,CAkHX;;;EACAhC,iBAAiB,GAAG,CAClBhE,KADkB,EAElB+F,EAFkB,EAGlBpB,IAHkB,EAIlBiB,KAJkB,KAKf;IACH,MAAMM,IAAI,GAAGJ,QAAQ,CAAC9F,KAAD,EAAQ+F,EAAR,CAArB;;IACA,IAAIG,IAAI,KAAK,IAAb,EAAmB;MACjB,MAAMC,QAAQ,GAAGN,WAAW,CAACK,IAAI,CAAC7C,aAAN,EAAqBsB,IAArB,EAA2BiB,KAA3B,CAA5B;MACAM,IAAI,CAAC7C,aAAL,GAAqB8C,QAArB;MACAD,IAAI,CAACE,SAAL,GAAiBD,QAAjB,CAHiB,CAKjB;MACA;MACA;MACA;MACA;;MACAnG,KAAK,CAACqG,aAAN,GAAsB,EAAE,GAAGrG,KAAK,CAACqG;MAAX,CAAtB;MAEAxJ,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBE,WAAlB,CAArB;IACD;EACF,CArBD;;EAsBA4F,2BAA2B,GAAG,CAC5BjE,KAD4B,EAE5B+F,EAF4B,EAG5BpB,IAH4B,KAIzB;IACH,MAAMuB,IAAI,GAAGJ,QAAQ,CAAC9F,KAAD,EAAQ+F,EAAR,CAArB;;IACA,IAAIG,IAAI,KAAK,IAAb,EAAmB;MACjB,MAAMC,QAAQ,GAAGjB,cAAc,CAACgB,IAAI,CAAC7C,aAAN,EAAqBsB,IAArB,CAA/B;MACAuB,IAAI,CAAC7C,aAAL,GAAqB8C,QAArB;MACAD,IAAI,CAACE,SAAL,GAAiBD,QAAjB,CAHiB,CAKjB;MACA;MACA;MACA;MACA;;MACAnG,KAAK,CAACqG,aAAN,GAAsB,EAAE,GAAGrG,KAAK,CAACqG;MAAX,CAAtB;MAEAxJ,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBE,WAAlB,CAArB;IACD;EACF,CApBD;;EAqBA6F,2BAA2B,GAAG,CAC5BlE,KAD4B,EAE5B+F,EAF4B,EAG5BX,OAH4B,EAI5BC,OAJ4B,KAKzB;IACH,MAAMa,IAAI,GAAGJ,QAAQ,CAAC9F,KAAD,EAAQ+F,EAAR,CAArB;;IACA,IAAIG,IAAI,KAAK,IAAb,EAAmB;MACjB,MAAMC,QAAQ,GAAGX,cAAc,CAACU,IAAI,CAAC7C,aAAN,EAAqB+B,OAArB,EAA8BC,OAA9B,CAA/B;MACAa,IAAI,CAAC7C,aAAL,GAAqB8C,QAArB;MACAD,IAAI,CAACE,SAAL,GAAiBD,QAAjB,CAHiB,CAKjB;MACA;MACA;MACA;MACA;;MACAnG,KAAK,CAACqG,aAAN,GAAsB,EAAE,GAAGrG,KAAK,CAACqG;MAAX,CAAtB;MAEAxJ,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBE,WAAlB,CAArB;IACD;EACF,CArBD,CA9JW,CAqLX;;;EACA8F,aAAa,GAAG,CAACnE,KAAD,EAAe2E,IAAf,EAA6CiB,KAA7C,KAA4D;IAC1E5F,KAAK,CAACsG,YAAN,GAAqBT,WAAW,CAAC7F,KAAK,CAACqG,aAAP,EAAsB1B,IAAtB,EAA4BiB,KAA5B,CAAhC;;IACA,IAAI5F,KAAK,CAACuD,SAAV,EAAqB;MACnBvD,KAAK,CAACuD,SAAN,CAAgB+C,YAAhB,GAA+BtG,KAAK,CAACsG,YAArC;IACD;;IACDzJ,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBE,WAAlB,CAArB;EACD,CAND;;EAOA+F,uBAAuB,GAAG,CAACpE,KAAD,EAAe2E,IAAf,KAAgD;IACxE3E,KAAK,CAACsG,YAAN,GAAqBpB,cAAc,CAAClF,KAAK,CAACqG,aAAP,EAAsB1B,IAAtB,CAAnC;;IACA,IAAI3E,KAAK,CAACuD,SAAV,EAAqB;MACnBvD,KAAK,CAACuD,SAAN,CAAgB+C,YAAhB,GAA+BtG,KAAK,CAACsG,YAArC;IACD;;IACDzJ,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBE,WAAlB,CAArB;EACD,CAND;;EAOAgG,uBAAuB,GAAG,CACxBrE,KADwB,EAExBoF,OAFwB,EAGxBC,OAHwB,KAIrB;IACHrF,KAAK,CAACsG,YAAN,GAAqBd,cAAc,CAACxF,KAAK,CAACqG,aAAP,EAAsBjB,OAAtB,EAA+BC,OAA/B,CAAnC;;IACA,IAAIrF,KAAK,CAACuD,SAAV,EAAqB;MACnBvD,KAAK,CAACuD,SAAN,CAAgB+C,YAAhB,GAA+BtG,KAAK,CAACsG,YAArC;IACD;;IACDzJ,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBE,WAAlB,CAArB;EACD,CAVD;;EAYAiG,cAAc,GAAItE,KAAD,IAAkB;IACjCnD,qBAAqB,CAACmD,KAAD,EAAQ7B,QAAR,EAAkBE,WAAlB,CAArB;EACD,CAFD;;EAIAkG,eAAe,GAAIgC,kBAAD,IAA2C;IAC3D3C,eAAe,GAAG2C,kBAAlB;EACD,CAFD;;EAIA/B,kBAAkB,GAAIgC,oBAAD,IAA4C;IAC/D1C,iBAAiB,GAAG0C,oBAApB;EACD,CAFD;AAGD;;AAED,SAASC,uBAAT,CAAkCzG,KAAlC,EAAgF;EAC9E,MAAMa,SAAS,GAAGzF,oBAAoB,CAAC4E,KAAD,CAAtC;;EACA,IAAIa,SAAS,KAAK,IAAlB,EAAwB;IACtB,OAAO,IAAP;EACD;;EACD,OAAOA,SAAS,CAACC,SAAjB;AACD;;AAED,SAAS4F,4BAAT,CACEC,QADF,EAEgB;EACd,OAAO,IAAP;AACD;;AAED,SAASC,0BAAT,GAAuC;EACrC,OAAO/I,wBAAP;AACD;;AAED,OAAO,SAASgJ,kBAAT,CAA6BC,cAA7B,EAAsE;EAC3E,MAAM;IAAEC;EAAF,IAA8BD,cAApC;EACA,MAAM;IAAEE;EAAF,IAA6BjL,oBAAnC;EAEA,OAAOS,eAAe,CAAC;IACrByK,UAAU,EAAEH,cAAc,CAACG,UADN;IAErBC,OAAO,EAAEJ,cAAc,CAACI,OAFH;IAGrBC,mBAAmB,EAAEL,cAAc,CAACK,mBAHf;IAIrBC,cAAc,EAAEN,cAAc,CAACM,cAJV;IAKrBpD,iBALqB;IAMrBC,2BANqB;IAOrBC,2BAPqB;IAQrBC,aARqB;IASrBC,uBATqB;IAUrBC,uBAVqB;IAWrBE,eAXqB;IAYrBC,kBAZqB;IAarBF,cAbqB;IAcrB+C,oBAAoB,EAAEL,sBAdD;IAerBP,uBAfqB;IAgBrBM,uBAAuB,EACrBA,uBAAuB,IAAIL,4BAjBR;IAkBrB;IACA7H,2BAA2B,EAAEgB,OAAO,GAAGhB,2BAAH,GAAiC,IAnBhD;IAoBrBH,eAAe,EAAEmB,OAAO,GAAGnB,eAAH,GAAqB,IApBxB;IAqBrBC,YAAY,EAAEkB,OAAO,GAAGlB,YAAH,GAAkB,IArBlB;IAsBrBC,iBAAiB,EAAEiB,OAAO,GAAGjB,iBAAH,GAAuB,IAtB5B;IAuBrB;IACA0I,eAAe,EAAEzH,OAAO,GAAG+G,0BAAH,GAAgC,IAxBnC;IAyBrB;IACA;IACAW,iBAAiB,EAAEzI;EA3BE,CAAD,CAAtB;AA6BD"},"metadata":{},"sourceType":"module"}