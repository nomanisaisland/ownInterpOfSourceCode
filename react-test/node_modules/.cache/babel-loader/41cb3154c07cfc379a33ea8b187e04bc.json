{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { HostComponent, HostText } from 'react-reconciler/src/ReactWorkTags';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport { findFiberRoot, getBoundingRect, getInstanceFromNode, getTextContent, isHiddenSubtree, matchAccessibilityRole, setFocusIfFocusable, setupIntersectionObserver, supportsTestSelectors } from './ReactFiberHostConfig';\nlet COMPONENT_TYPE = 0b000;\nlet HAS_PSEUDO_CLASS_TYPE = 0b001;\nlet ROLE_TYPE = 0b010;\nlet TEST_NAME_TYPE = 0b011;\nlet TEXT_TYPE = 0b100;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  const symbolFor = Symbol.for;\n  COMPONENT_TYPE = symbolFor('selector.component');\n  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n  ROLE_TYPE = symbolFor('selector.role');\n  TEST_NAME_TYPE = symbolFor('selector.test_id');\n  TEXT_TYPE = symbolFor('selector.text');\n}\n\nexport function createComponentSelector(component) {\n  return {\n    $$typeof: COMPONENT_TYPE,\n    value: component\n  };\n}\nexport function createHasPseudoClassSelector(selectors) {\n  return {\n    $$typeof: HAS_PSEUDO_CLASS_TYPE,\n    value: selectors\n  };\n}\nexport function createRoleSelector(role) {\n  return {\n    $$typeof: ROLE_TYPE,\n    value: role\n  };\n}\nexport function createTextSelector(text) {\n  return {\n    $$typeof: TEXT_TYPE,\n    value: text\n  };\n}\nexport function createTestNameSelector(id) {\n  return {\n    $$typeof: TEST_NAME_TYPE,\n    value: id\n  };\n}\n\nfunction findFiberRootForHostRoot(hostRoot) {\n  const maybeFiber = getInstanceFromNode(hostRoot);\n\n  if (maybeFiber != null) {\n    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n      throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n    }\n\n    return maybeFiber;\n  } else {\n    const fiberRoot = findFiberRoot(hostRoot);\n\n    if (fiberRoot === null) {\n      throw new Error('Could not find React container within specified host subtree.');\n    } // The Flow type for FiberRoot is a little funky.\n    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n\n\n    return fiberRoot.stateNode.current;\n  }\n}\n\nfunction matchSelector(fiber, selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      if (fiber.type === selector.value) {\n        return true;\n      }\n\n      break;\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return hasMatchingPaths(fiber, selector.value);\n\n    case ROLE_TYPE:\n      if (fiber.tag === HostComponent) {\n        const node = fiber.stateNode;\n\n        if (matchAccessibilityRole(node, selector.value)) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEXT_TYPE:\n      if (fiber.tag === HostComponent || fiber.tag === HostText) {\n        const textContent = getTextContent(fiber);\n\n        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEST_NAME_TYPE:\n      if (fiber.tag === HostComponent) {\n        const dataTestID = fiber.memoizedProps['data-testname'];\n\n        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n          return true;\n        }\n      }\n\n      break;\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n\n  return false;\n}\n\nfunction selectorToString(selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      const displayName = getComponentNameFromType(selector.value) || 'Unknown';\n      return `<${displayName}>`;\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return `:has(${selectorToString(selector) || ''})`;\n\n    case ROLE_TYPE:\n      return `[role=\"${selector.value}\"]`;\n\n    case TEXT_TYPE:\n      return `\"${selector.value}\"`;\n\n    case TEST_NAME_TYPE:\n      return `[data-testname=\"${selector.value}\"]`;\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n}\n\nfunction findPaths(root, selectors) {\n  const matchingFibers = [];\n  const stack = [root, 0];\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n    let selectorIndex = stack[index++];\n    let selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      matchingFibers.push(fiber);\n    } else {\n      let child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return matchingFibers;\n} // Same as findPaths but with eager bailout on first match\n\n\nfunction hasMatchingPaths(root, selectors) {\n  const stack = [root, 0];\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n    let selectorIndex = stack[index++];\n    let selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      return true;\n    } else {\n      let child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function findAllNodes(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  const matchingFibers = findPaths(root, selectors);\n  const instanceRoots = [];\n  const stack = Array.from(matchingFibers);\n  let index = 0;\n\n  while (index < stack.length) {\n    const node = stack[index++];\n\n    if (node.tag === HostComponent) {\n      if (isHiddenSubtree(node)) {\n        continue;\n      }\n\n      instanceRoots.push(node.stateNode);\n    } else {\n      let child = node.child;\n\n      while (child !== null) {\n        stack.push(child);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return instanceRoots;\n}\nexport function getFindAllNodesFailureDescription(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  let maxSelectorIndex = 0;\n  const matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n\n  const stack = [root, 0];\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n    let selectorIndex = stack[index++];\n    const selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else if (matchSelector(fiber, selector)) {\n      matchedNames.push(selectorToString(selector));\n      selectorIndex++;\n\n      if (selectorIndex > maxSelectorIndex) {\n        maxSelectorIndex = selectorIndex;\n      }\n    }\n\n    if (selectorIndex < selectors.length) {\n      let child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  if (maxSelectorIndex < selectors.length) {\n    const unmatchedNames = [];\n\n    for (let i = maxSelectorIndex; i < selectors.length; i++) {\n      unmatchedNames.push(selectorToString(selectors[i]));\n    }\n\n    return 'findAllNodes was able to match part of the selector:\\n' + `  ${matchedNames.join(' > ')}\\n\\n` + 'No matching component was found for:\\n' + `  ${unmatchedNames.join(' > ')}`;\n  }\n\n  return null;\n}\nexport function findBoundingRects(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const instanceRoots = findAllNodes(hostRoot, selectors);\n  const boundingRects = [];\n\n  for (let i = 0; i < instanceRoots.length; i++) {\n    boundingRects.push(getBoundingRect(instanceRoots[i]));\n  }\n\n  for (let i = boundingRects.length - 1; i > 0; i--) {\n    const targetRect = boundingRects[i];\n    const targetLeft = targetRect.x;\n    const targetRight = targetLeft + targetRect.width;\n    const targetTop = targetRect.y;\n    const targetBottom = targetTop + targetRect.height;\n\n    for (let j = i - 1; j >= 0; j--) {\n      if (i !== j) {\n        const otherRect = boundingRects[j];\n        const otherLeft = otherRect.x;\n        const otherRight = otherLeft + otherRect.width;\n        const otherTop = otherRect.y;\n        const otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n        // but we can handle the most common cases:\n        // 1. completely overlapping rects\n        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n        //\n        // Even given the above constraints,\n        // we still won't end up with the fewest possible rects without doing multiple passes,\n        // but it's good enough for this purpose.\n\n        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n          // Complete overlapping rects; remove the inner one.\n          boundingRects.splice(i, 1);\n          break;\n        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n          // Adjacent vertical rects; merge them.\n          if (otherTop > targetTop) {\n            otherRect.height += otherTop - targetTop;\n            otherRect.y = targetTop;\n          }\n\n          if (otherBottom < targetBottom) {\n            otherRect.height = targetBottom - otherTop;\n          }\n\n          boundingRects.splice(i, 1);\n          break;\n        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n          // Adjacent horizontal rects; merge them.\n          if (otherLeft > targetLeft) {\n            otherRect.width += otherLeft - targetLeft;\n            otherRect.x = targetLeft;\n          }\n\n          if (otherRight < targetRight) {\n            otherRect.width = targetRight - otherLeft;\n          }\n\n          boundingRects.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return boundingRects;\n}\nexport function focusWithin(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  const matchingFibers = findPaths(root, selectors);\n  const stack = Array.from(matchingFibers);\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n\n    if (isHiddenSubtree(fiber)) {\n      continue;\n    }\n\n    if (fiber.tag === HostComponent) {\n      const node = fiber.stateNode;\n\n      if (setFocusIfFocusable(node)) {\n        return true;\n      }\n    }\n\n    let child = fiber.child;\n\n    while (child !== null) {\n      stack.push(child);\n      child = child.sibling;\n    }\n  }\n\n  return false;\n}\nconst commitHooks = [];\nexport function onCommitRoot() {\n  if (supportsTestSelectors) {\n    commitHooks.forEach(commitHook => commitHook());\n  }\n}\nexport function observeVisibleRects(hostRoot, selectors, callback, options) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const instanceRoots = findAllNodes(hostRoot, selectors);\n  const {\n    disconnect,\n    observe,\n    unobserve\n  } = setupIntersectionObserver(instanceRoots, callback, options); // When React mutates the host environment, we may need to change what we're listening to.\n\n  const commitHook = () => {\n    const nextInstanceRoots = findAllNodes(hostRoot, selectors);\n    instanceRoots.forEach(target => {\n      if (nextInstanceRoots.indexOf(target) < 0) {\n        unobserve(target);\n      }\n    });\n    nextInstanceRoots.forEach(target => {\n      if (instanceRoots.indexOf(target) < 0) {\n        observe(target);\n      }\n    });\n  };\n\n  commitHooks.push(commitHook);\n  return {\n    disconnect: () => {\n      // Stop listening for React mutations:\n      const index = commitHooks.indexOf(commitHook);\n\n      if (index >= 0) {\n        commitHooks.splice(index, 1);\n      } // Disconnect the host observer:\n\n\n      disconnect();\n    }\n  };\n}","map":{"version":3,"names":["HostComponent","HostText","getComponentNameFromType","findFiberRoot","getBoundingRect","getInstanceFromNode","getTextContent","isHiddenSubtree","matchAccessibilityRole","setFocusIfFocusable","setupIntersectionObserver","supportsTestSelectors","COMPONENT_TYPE","HAS_PSEUDO_CLASS_TYPE","ROLE_TYPE","TEST_NAME_TYPE","TEXT_TYPE","Symbol","for","symbolFor","createComponentSelector","component","$$typeof","value","createHasPseudoClassSelector","selectors","createRoleSelector","role","createTextSelector","text","createTestNameSelector","id","findFiberRootForHostRoot","hostRoot","maybeFiber","memoizedProps","Error","fiberRoot","stateNode","current","matchSelector","fiber","selector","type","hasMatchingPaths","tag","node","textContent","indexOf","dataTestID","toLowerCase","selectorToString","displayName","findPaths","root","matchingFibers","stack","index","length","selectorIndex","push","child","sibling","findAllNodes","instanceRoots","Array","from","getFindAllNodesFailureDescription","maxSelectorIndex","matchedNames","unmatchedNames","i","join","findBoundingRects","boundingRects","targetRect","targetLeft","x","targetRight","width","targetTop","y","targetBottom","height","j","otherRect","otherLeft","otherRight","otherTop","otherBottom","splice","focusWithin","commitHooks","onCommitRoot","forEach","commitHook","observeVisibleRects","callback","options","disconnect","observe","unobserve","nextInstanceRoots","target"],"sources":["E:/react-test/src/react/packages/react-reconciler/src/ReactTestSelectors.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\r\nimport type {Instance} from './ReactFiberHostConfig';\r\n\r\nimport {HostComponent, HostText} from 'react-reconciler/src/ReactWorkTags';\r\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\r\nimport {\r\n  findFiberRoot,\r\n  getBoundingRect,\r\n  getInstanceFromNode,\r\n  getTextContent,\r\n  isHiddenSubtree,\r\n  matchAccessibilityRole,\r\n  setFocusIfFocusable,\r\n  setupIntersectionObserver,\r\n  supportsTestSelectors,\r\n} from './ReactFiberHostConfig';\r\n\r\nlet COMPONENT_TYPE = 0b000;\r\nlet HAS_PSEUDO_CLASS_TYPE = 0b001;\r\nlet ROLE_TYPE = 0b010;\r\nlet TEST_NAME_TYPE = 0b011;\r\nlet TEXT_TYPE = 0b100;\r\n\r\nif (typeof Symbol === 'function' && Symbol.for) {\r\n  const symbolFor = Symbol.for;\r\n  COMPONENT_TYPE = symbolFor('selector.component');\r\n  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\r\n  ROLE_TYPE = symbolFor('selector.role');\r\n  TEST_NAME_TYPE = symbolFor('selector.test_id');\r\n  TEXT_TYPE = symbolFor('selector.text');\r\n}\r\n\r\ntype Type = Symbol | number;\r\n\r\ntype ComponentSelector = {|\r\n  $$typeof: Type,\r\n  value: React$AbstractComponent<empty, mixed>,\r\n|};\r\n\r\ntype HasPseudoClassSelector = {|\r\n  $$typeof: Type,\r\n  value: Array<Selector>,\r\n|};\r\n\r\ntype RoleSelector = {|\r\n  $$typeof: Type,\r\n  value: string,\r\n|};\r\n\r\ntype TextSelector = {|\r\n  $$typeof: Type,\r\n  value: string,\r\n|};\r\n\r\ntype TestNameSelector = {|\r\n  $$typeof: Type,\r\n  value: string,\r\n|};\r\n\r\ntype Selector =\r\n  | ComponentSelector\r\n  | HasPseudoClassSelector\r\n  | RoleSelector\r\n  | TextSelector\r\n  | TestNameSelector;\r\n\r\nexport function createComponentSelector(\r\n  component: React$AbstractComponent<empty, mixed>,\r\n): ComponentSelector {\r\n  return {\r\n    $$typeof: COMPONENT_TYPE,\r\n    value: component,\r\n  };\r\n}\r\n\r\nexport function createHasPseudoClassSelector(\r\n  selectors: Array<Selector>,\r\n): HasPseudoClassSelector {\r\n  return {\r\n    $$typeof: HAS_PSEUDO_CLASS_TYPE,\r\n    value: selectors,\r\n  };\r\n}\r\n\r\nexport function createRoleSelector(role: string): RoleSelector {\r\n  return {\r\n    $$typeof: ROLE_TYPE,\r\n    value: role,\r\n  };\r\n}\r\n\r\nexport function createTextSelector(text: string): TextSelector {\r\n  return {\r\n    $$typeof: TEXT_TYPE,\r\n    value: text,\r\n  };\r\n}\r\n\r\nexport function createTestNameSelector(id: string): TestNameSelector {\r\n  return {\r\n    $$typeof: TEST_NAME_TYPE,\r\n    value: id,\r\n  };\r\n}\r\n\r\nfunction findFiberRootForHostRoot(hostRoot: Instance): Fiber {\r\n  const maybeFiber = getInstanceFromNode((hostRoot: any));\r\n  if (maybeFiber != null) {\r\n    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\r\n      throw new Error(\r\n        'Invalid host root specified. Should be either a React container or a node with a testname attribute.',\r\n      );\r\n    }\r\n\r\n    return ((maybeFiber: any): Fiber);\r\n  } else {\r\n    const fiberRoot = findFiberRoot(hostRoot);\r\n\r\n    if (fiberRoot === null) {\r\n      throw new Error(\r\n        'Could not find React container within specified host subtree.',\r\n      );\r\n    }\r\n\r\n    // The Flow type for FiberRoot is a little funky.\r\n    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\r\n    return ((fiberRoot: any).stateNode.current: Fiber);\r\n  }\r\n}\r\n\r\nfunction matchSelector(fiber: Fiber, selector: Selector): boolean {\r\n  switch (selector.$$typeof) {\r\n    case COMPONENT_TYPE:\r\n      if (fiber.type === selector.value) {\r\n        return true;\r\n      }\r\n      break;\r\n    case HAS_PSEUDO_CLASS_TYPE:\r\n      return hasMatchingPaths(\r\n        fiber,\r\n        ((selector: any): HasPseudoClassSelector).value,\r\n      );\r\n    case ROLE_TYPE:\r\n      if (fiber.tag === HostComponent) {\r\n        const node = fiber.stateNode;\r\n        if (\r\n          matchAccessibilityRole(node, ((selector: any): RoleSelector).value)\r\n        ) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case TEXT_TYPE:\r\n      if (fiber.tag === HostComponent || fiber.tag === HostText) {\r\n        const textContent = getTextContent(fiber);\r\n        if (\r\n          textContent !== null &&\r\n          textContent.indexOf(((selector: any): TextSelector).value) >= 0\r\n        ) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case TEST_NAME_TYPE:\r\n      if (fiber.tag === HostComponent) {\r\n        const dataTestID = fiber.memoizedProps['data-testname'];\r\n        if (\r\n          typeof dataTestID === 'string' &&\r\n          dataTestID.toLowerCase() ===\r\n            ((selector: any): TestNameSelector).value.toLowerCase()\r\n        ) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    default:\r\n      throw new Error('Invalid selector type specified.');\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction selectorToString(selector: Selector): string | null {\r\n  switch (selector.$$typeof) {\r\n    case COMPONENT_TYPE:\r\n      const displayName = getComponentNameFromType(selector.value) || 'Unknown';\r\n      return `<${displayName}>`;\r\n    case HAS_PSEUDO_CLASS_TYPE:\r\n      return `:has(${selectorToString(selector) || ''})`;\r\n    case ROLE_TYPE:\r\n      return `[role=\"${((selector: any): RoleSelector).value}\"]`;\r\n    case TEXT_TYPE:\r\n      return `\"${((selector: any): TextSelector).value}\"`;\r\n    case TEST_NAME_TYPE:\r\n      return `[data-testname=\"${((selector: any): TestNameSelector).value}\"]`;\r\n    default:\r\n      throw new Error('Invalid selector type specified.');\r\n  }\r\n}\r\n\r\nfunction findPaths(root: Fiber, selectors: Array<Selector>): Array<Fiber> {\r\n  const matchingFibers: Array<Fiber> = [];\r\n\r\n  const stack = [root, 0];\r\n  let index = 0;\r\n  while (index < stack.length) {\r\n    const fiber = ((stack[index++]: any): Fiber);\r\n    let selectorIndex = ((stack[index++]: any): number);\r\n    let selector = selectors[selectorIndex];\r\n\r\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\r\n      continue;\r\n    } else {\r\n      while (selector != null && matchSelector(fiber, selector)) {\r\n        selectorIndex++;\r\n        selector = selectors[selectorIndex];\r\n      }\r\n    }\r\n\r\n    if (selectorIndex === selectors.length) {\r\n      matchingFibers.push(fiber);\r\n    } else {\r\n      let child = fiber.child;\r\n      while (child !== null) {\r\n        stack.push(child, selectorIndex);\r\n        child = child.sibling;\r\n      }\r\n    }\r\n  }\r\n\r\n  return matchingFibers;\r\n}\r\n\r\n// Same as findPaths but with eager bailout on first match\r\nfunction hasMatchingPaths(root: Fiber, selectors: Array<Selector>): boolean {\r\n  const stack = [root, 0];\r\n  let index = 0;\r\n  while (index < stack.length) {\r\n    const fiber = ((stack[index++]: any): Fiber);\r\n    let selectorIndex = ((stack[index++]: any): number);\r\n    let selector = selectors[selectorIndex];\r\n\r\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\r\n      continue;\r\n    } else {\r\n      while (selector != null && matchSelector(fiber, selector)) {\r\n        selectorIndex++;\r\n        selector = selectors[selectorIndex];\r\n      }\r\n    }\r\n\r\n    if (selectorIndex === selectors.length) {\r\n      return true;\r\n    } else {\r\n      let child = fiber.child;\r\n      while (child !== null) {\r\n        stack.push(child, selectorIndex);\r\n        child = child.sibling;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function findAllNodes(\r\n  hostRoot: Instance,\r\n  selectors: Array<Selector>,\r\n): Array<Instance> {\r\n  if (!supportsTestSelectors) {\r\n    throw new Error('Test selector API is not supported by this renderer.');\r\n  }\r\n\r\n  const root = findFiberRootForHostRoot(hostRoot);\r\n  const matchingFibers = findPaths(root, selectors);\r\n\r\n  const instanceRoots: Array<Instance> = [];\r\n\r\n  const stack = Array.from(matchingFibers);\r\n  let index = 0;\r\n  while (index < stack.length) {\r\n    const node = ((stack[index++]: any): Fiber);\r\n    if (node.tag === HostComponent) {\r\n      if (isHiddenSubtree(node)) {\r\n        continue;\r\n      }\r\n      instanceRoots.push(node.stateNode);\r\n    } else {\r\n      let child = node.child;\r\n      while (child !== null) {\r\n        stack.push(child);\r\n        child = child.sibling;\r\n      }\r\n    }\r\n  }\r\n\r\n  return instanceRoots;\r\n}\r\n\r\nexport function getFindAllNodesFailureDescription(\r\n  hostRoot: Instance,\r\n  selectors: Array<Selector>,\r\n): string | null {\r\n  if (!supportsTestSelectors) {\r\n    throw new Error('Test selector API is not supported by this renderer.');\r\n  }\r\n\r\n  const root = findFiberRootForHostRoot(hostRoot);\r\n\r\n  let maxSelectorIndex: number = 0;\r\n  const matchedNames = [];\r\n\r\n  // The logic of this loop should be kept in sync with findPaths()\r\n  const stack = [root, 0];\r\n  let index = 0;\r\n  while (index < stack.length) {\r\n    const fiber = ((stack[index++]: any): Fiber);\r\n    let selectorIndex = ((stack[index++]: any): number);\r\n    const selector = selectors[selectorIndex];\r\n\r\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\r\n      continue;\r\n    } else if (matchSelector(fiber, selector)) {\r\n      matchedNames.push(selectorToString(selector));\r\n      selectorIndex++;\r\n\r\n      if (selectorIndex > maxSelectorIndex) {\r\n        maxSelectorIndex = selectorIndex;\r\n      }\r\n    }\r\n\r\n    if (selectorIndex < selectors.length) {\r\n      let child = fiber.child;\r\n      while (child !== null) {\r\n        stack.push(child, selectorIndex);\r\n        child = child.sibling;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (maxSelectorIndex < selectors.length) {\r\n    const unmatchedNames = [];\r\n    for (let i = maxSelectorIndex; i < selectors.length; i++) {\r\n      unmatchedNames.push(selectorToString(selectors[i]));\r\n    }\r\n\r\n    return (\r\n      'findAllNodes was able to match part of the selector:\\n' +\r\n      `  ${matchedNames.join(' > ')}\\n\\n` +\r\n      'No matching component was found for:\\n' +\r\n      `  ${unmatchedNames.join(' > ')}`\r\n    );\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport type BoundingRect = {|\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n|};\r\n\r\nexport function findBoundingRects(\r\n  hostRoot: Instance,\r\n  selectors: Array<Selector>,\r\n): Array<BoundingRect> {\r\n  if (!supportsTestSelectors) {\r\n    throw new Error('Test selector API is not supported by this renderer.');\r\n  }\r\n\r\n  const instanceRoots = findAllNodes(hostRoot, selectors);\r\n\r\n  const boundingRects: Array<BoundingRect> = [];\r\n  for (let i = 0; i < instanceRoots.length; i++) {\r\n    boundingRects.push(getBoundingRect(instanceRoots[i]));\r\n  }\r\n\r\n  for (let i = boundingRects.length - 1; i > 0; i--) {\r\n    const targetRect = boundingRects[i];\r\n    const targetLeft = targetRect.x;\r\n    const targetRight = targetLeft + targetRect.width;\r\n    const targetTop = targetRect.y;\r\n    const targetBottom = targetTop + targetRect.height;\r\n\r\n    for (let j = i - 1; j >= 0; j--) {\r\n      if (i !== j) {\r\n        const otherRect = boundingRects[j];\r\n        const otherLeft = otherRect.x;\r\n        const otherRight = otherLeft + otherRect.width;\r\n        const otherTop = otherRect.y;\r\n        const otherBottom = otherTop + otherRect.height;\r\n\r\n        // Merging all rects to the minimums set would be complicated,\r\n        // but we can handle the most common cases:\r\n        // 1. completely overlapping rects\r\n        // 2. adjacent rects that are the same width or height (e.g. items in a list)\r\n        //\r\n        // Even given the above constraints,\r\n        // we still won't end up with the fewest possible rects without doing multiple passes,\r\n        // but it's good enough for this purpose.\r\n\r\n        if (\r\n          targetLeft >= otherLeft &&\r\n          targetTop >= otherTop &&\r\n          targetRight <= otherRight &&\r\n          targetBottom <= otherBottom\r\n        ) {\r\n          // Complete overlapping rects; remove the inner one.\r\n          boundingRects.splice(i, 1);\r\n          break;\r\n        } else if (\r\n          targetLeft === otherLeft &&\r\n          targetRect.width === otherRect.width &&\r\n          !(otherBottom < targetTop) &&\r\n          !(otherTop > targetBottom)\r\n        ) {\r\n          // Adjacent vertical rects; merge them.\r\n          if (otherTop > targetTop) {\r\n            otherRect.height += otherTop - targetTop;\r\n            otherRect.y = targetTop;\r\n          }\r\n          if (otherBottom < targetBottom) {\r\n            otherRect.height = targetBottom - otherTop;\r\n          }\r\n\r\n          boundingRects.splice(i, 1);\r\n          break;\r\n        } else if (\r\n          targetTop === otherTop &&\r\n          targetRect.height === otherRect.height &&\r\n          !(otherRight < targetLeft) &&\r\n          !(otherLeft > targetRight)\r\n        ) {\r\n          // Adjacent horizontal rects; merge them.\r\n          if (otherLeft > targetLeft) {\r\n            otherRect.width += otherLeft - targetLeft;\r\n            otherRect.x = targetLeft;\r\n          }\r\n          if (otherRight < targetRight) {\r\n            otherRect.width = targetRight - otherLeft;\r\n          }\r\n\r\n          boundingRects.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return boundingRects;\r\n}\r\n\r\nexport function focusWithin(\r\n  hostRoot: Instance,\r\n  selectors: Array<Selector>,\r\n): boolean {\r\n  if (!supportsTestSelectors) {\r\n    throw new Error('Test selector API is not supported by this renderer.');\r\n  }\r\n\r\n  const root = findFiberRootForHostRoot(hostRoot);\r\n  const matchingFibers = findPaths(root, selectors);\r\n\r\n  const stack = Array.from(matchingFibers);\r\n  let index = 0;\r\n  while (index < stack.length) {\r\n    const fiber = ((stack[index++]: any): Fiber);\r\n    if (isHiddenSubtree(fiber)) {\r\n      continue;\r\n    }\r\n    if (fiber.tag === HostComponent) {\r\n      const node = fiber.stateNode;\r\n      if (setFocusIfFocusable(node)) {\r\n        return true;\r\n      }\r\n    }\r\n    let child = fiber.child;\r\n    while (child !== null) {\r\n      stack.push(child);\r\n      child = child.sibling;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nconst commitHooks: Array<Function> = [];\r\n\r\nexport function onCommitRoot(): void {\r\n  if (supportsTestSelectors) {\r\n    commitHooks.forEach(commitHook => commitHook());\r\n  }\r\n}\r\n\r\nexport type IntersectionObserverOptions = Object;\r\n\r\nexport type ObserveVisibleRectsCallback = (\r\n  intersections: Array<{ratio: number, rect: BoundingRect}>,\r\n) => void;\r\n\r\nexport function observeVisibleRects(\r\n  hostRoot: Instance,\r\n  selectors: Array<Selector>,\r\n  callback: (intersections: Array<{ratio: number, rect: BoundingRect}>) => void,\r\n  options?: IntersectionObserverOptions,\r\n): {|disconnect: () => void|} {\r\n  if (!supportsTestSelectors) {\r\n    throw new Error('Test selector API is not supported by this renderer.');\r\n  }\r\n\r\n  const instanceRoots = findAllNodes(hostRoot, selectors);\r\n\r\n  const {disconnect, observe, unobserve} = setupIntersectionObserver(\r\n    instanceRoots,\r\n    callback,\r\n    options,\r\n  );\r\n\r\n  // When React mutates the host environment, we may need to change what we're listening to.\r\n  const commitHook = () => {\r\n    const nextInstanceRoots = findAllNodes(hostRoot, selectors);\r\n\r\n    instanceRoots.forEach(target => {\r\n      if (nextInstanceRoots.indexOf(target) < 0) {\r\n        unobserve(target);\r\n      }\r\n    });\r\n\r\n    nextInstanceRoots.forEach(target => {\r\n      if (instanceRoots.indexOf(target) < 0) {\r\n        observe(target);\r\n      }\r\n    });\r\n  };\r\n\r\n  commitHooks.push(commitHook);\r\n\r\n  return {\r\n    disconnect: () => {\r\n      // Stop listening for React mutations:\r\n      const index = commitHooks.indexOf(commitHook);\r\n      if (index >= 0) {\r\n        commitHooks.splice(index, 1);\r\n      }\r\n\r\n      // Disconnect the host observer:\r\n      disconnect();\r\n    },\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}