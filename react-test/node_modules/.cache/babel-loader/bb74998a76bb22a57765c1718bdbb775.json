{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { allNativeEvents } from '../events/EventRegistry';\nimport { getEventHandlerListeners, setEventHandlerListeners, doesTargetHaveEventHandle, addEventHandleToTarget } from './ReactDOMComponentTree';\nimport { ELEMENT_NODE } from '../shared/HTMLNodeType';\nimport { listenToNativeEventForNonManagedEventTarget } from '../events/DOMPluginEventSystem';\nimport { enableScopeAPI, enableCreateEventHandleAPI } from 'shared/ReactFeatureFlags';\n\nfunction isValidEventTarget(target) {\n  return typeof target.addEventListener === 'function';\n}\n\nfunction isReactScope(target) {\n  return typeof target.getChildContextValues === 'function';\n}\n\nfunction createEventHandleListener(type, isCapturePhaseListener, callback) {\n  return {\n    callback,\n    capture: isCapturePhaseListener,\n    type\n  };\n}\n\nfunction registerReactDOMEvent(target, domEventName, isCapturePhaseListener) {\n  if (target.nodeType === ELEMENT_NODE) {// Do nothing. We already attached all root listeners.\n  } else if (enableScopeAPI && isReactScope(target)) {// Do nothing. We already attached all root listeners.\n  } else if (isValidEventTarget(target)) {\n    const eventTarget = target; // These are valid event targets, but they are also\n    // non-managed React nodes.\n\n    listenToNativeEventForNonManagedEventTarget(domEventName, isCapturePhaseListener, eventTarget);\n  } else {\n    throw new Error('ReactDOM.createEventHandle: setter called on an invalid ' + 'target. Provide a valid EventTarget or an element managed by React.');\n  }\n}\n\nexport function createEventHandle(type, options) {\n  if (enableCreateEventHandleAPI) {\n    const domEventName = type; // We cannot support arbitrary native events with eager root listeners\n    // because the eager strategy relies on knowing the whole list ahead of time.\n    // If we wanted to support this, we'd have to add code to keep track\n    // (or search) for all portal and root containers, and lazily add listeners\n    // to them whenever we see a previously unknown event. This seems like a lot\n    // of complexity for something we don't even have a particular use case for.\n    // Unfortunately, the downside of this invariant is that *removing* a native\n    // event from the list of known events has now become a breaking change for\n    // any code relying on the createEventHandle API.\n\n    if (!allNativeEvents.has(domEventName)) {\n      throw new Error(`Cannot call unstable_createEventHandle with \"${domEventName}\", as it is not an event known to React.`);\n    }\n\n    let isCapturePhaseListener = false;\n\n    if (options != null) {\n      const optionsCapture = options.capture;\n\n      if (typeof optionsCapture === 'boolean') {\n        isCapturePhaseListener = optionsCapture;\n      }\n    }\n\n    const eventHandle = (target, callback) => {\n      if (typeof callback !== 'function') {\n        throw new Error('ReactDOM.createEventHandle: setter called with an invalid ' + 'callback. The callback must be a function.');\n      }\n\n      if (!doesTargetHaveEventHandle(target, eventHandle)) {\n        addEventHandleToTarget(target, eventHandle);\n        registerReactDOMEvent(target, domEventName, isCapturePhaseListener);\n      }\n\n      const listener = createEventHandleListener(domEventName, isCapturePhaseListener, callback);\n      let targetListeners = getEventHandlerListeners(target);\n\n      if (targetListeners === null) {\n        targetListeners = new Set();\n        setEventHandlerListeners(target, targetListeners);\n      }\n\n      targetListeners.add(listener);\n      return () => {\n        targetListeners.delete(listener);\n      };\n    };\n\n    return eventHandle;\n  }\n\n  return null;\n}","map":{"version":3,"names":["allNativeEvents","getEventHandlerListeners","setEventHandlerListeners","doesTargetHaveEventHandle","addEventHandleToTarget","ELEMENT_NODE","listenToNativeEventForNonManagedEventTarget","enableScopeAPI","enableCreateEventHandleAPI","isValidEventTarget","target","addEventListener","isReactScope","getChildContextValues","createEventHandleListener","type","isCapturePhaseListener","callback","capture","registerReactDOMEvent","domEventName","nodeType","eventTarget","Error","createEventHandle","options","has","optionsCapture","eventHandle","listener","targetListeners","Set","add","delete"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-dom/src/client/ReactDOMEventHandle.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {DOMEventName} from '../events/DOMEventNames';\r\nimport type {ReactScopeInstance} from 'shared/ReactTypes';\r\nimport type {\r\n  ReactDOMEventHandle,\r\n  ReactDOMEventHandleListener,\r\n} from '../shared/ReactDOMTypes';\r\n\r\nimport {allNativeEvents} from '../events/EventRegistry';\r\nimport {\r\n  getEventHandlerListeners,\r\n  setEventHandlerListeners,\r\n  doesTargetHaveEventHandle,\r\n  addEventHandleToTarget,\r\n} from './ReactDOMComponentTree';\r\nimport {ELEMENT_NODE} from '../shared/HTMLNodeType';\r\nimport {listenToNativeEventForNonManagedEventTarget} from '../events/DOMPluginEventSystem';\r\n\r\nimport {\r\n  enableScopeAPI,\r\n  enableCreateEventHandleAPI,\r\n} from 'shared/ReactFeatureFlags';\r\n\r\ntype EventHandleOptions = {|\r\n  capture?: boolean,\r\n|};\r\n\r\nfunction isValidEventTarget(target: EventTarget | ReactScopeInstance): boolean {\r\n  return typeof (target: Object).addEventListener === 'function';\r\n}\r\n\r\nfunction isReactScope(target: EventTarget | ReactScopeInstance): boolean {\r\n  return typeof (target: Object).getChildContextValues === 'function';\r\n}\r\n\r\nfunction createEventHandleListener(\r\n  type: DOMEventName,\r\n  isCapturePhaseListener: boolean,\r\n  callback: (SyntheticEvent<EventTarget>) => void,\r\n): ReactDOMEventHandleListener {\r\n  return {\r\n    callback,\r\n    capture: isCapturePhaseListener,\r\n    type,\r\n  };\r\n}\r\n\r\nfunction registerReactDOMEvent(\r\n  target: EventTarget | ReactScopeInstance,\r\n  domEventName: DOMEventName,\r\n  isCapturePhaseListener: boolean,\r\n): void {\r\n  if ((target: any).nodeType === ELEMENT_NODE) {\r\n    // Do nothing. We already attached all root listeners.\r\n  } else if (enableScopeAPI && isReactScope(target)) {\r\n    // Do nothing. We already attached all root listeners.\r\n  } else if (isValidEventTarget(target)) {\r\n    const eventTarget = ((target: any): EventTarget);\r\n    // These are valid event targets, but they are also\r\n    // non-managed React nodes.\r\n    listenToNativeEventForNonManagedEventTarget(\r\n      domEventName,\r\n      isCapturePhaseListener,\r\n      eventTarget,\r\n    );\r\n  } else {\r\n    throw new Error(\r\n      'ReactDOM.createEventHandle: setter called on an invalid ' +\r\n        'target. Provide a valid EventTarget or an element managed by React.',\r\n    );\r\n  }\r\n}\r\n\r\nexport function createEventHandle(\r\n  type: string,\r\n  options?: EventHandleOptions,\r\n): ReactDOMEventHandle {\r\n  if (enableCreateEventHandleAPI) {\r\n    const domEventName = ((type: any): DOMEventName);\r\n\r\n    // We cannot support arbitrary native events with eager root listeners\r\n    // because the eager strategy relies on knowing the whole list ahead of time.\r\n    // If we wanted to support this, we'd have to add code to keep track\r\n    // (or search) for all portal and root containers, and lazily add listeners\r\n    // to them whenever we see a previously unknown event. This seems like a lot\r\n    // of complexity for something we don't even have a particular use case for.\r\n    // Unfortunately, the downside of this invariant is that *removing* a native\r\n    // event from the list of known events has now become a breaking change for\r\n    // any code relying on the createEventHandle API.\r\n    if (!allNativeEvents.has(domEventName)) {\r\n      throw new Error(\r\n        `Cannot call unstable_createEventHandle with \"${domEventName}\", as it is not an event known to React.`,\r\n      );\r\n    }\r\n\r\n    let isCapturePhaseListener = false;\r\n    if (options != null) {\r\n      const optionsCapture = options.capture;\r\n      if (typeof optionsCapture === 'boolean') {\r\n        isCapturePhaseListener = optionsCapture;\r\n      }\r\n    }\r\n\r\n    const eventHandle = (\r\n      target: EventTarget | ReactScopeInstance,\r\n      callback: (SyntheticEvent<EventTarget>) => void,\r\n    ) => {\r\n      if (typeof callback !== 'function') {\r\n        throw new Error(\r\n          'ReactDOM.createEventHandle: setter called with an invalid ' +\r\n            'callback. The callback must be a function.',\r\n        );\r\n      }\r\n\r\n      if (!doesTargetHaveEventHandle(target, eventHandle)) {\r\n        addEventHandleToTarget(target, eventHandle);\r\n        registerReactDOMEvent(target, domEventName, isCapturePhaseListener);\r\n      }\r\n      const listener = createEventHandleListener(\r\n        domEventName,\r\n        isCapturePhaseListener,\r\n        callback,\r\n      );\r\n      let targetListeners = getEventHandlerListeners(target);\r\n      if (targetListeners === null) {\r\n        targetListeners = new Set();\r\n        setEventHandlerListeners(target, targetListeners);\r\n      }\r\n      targetListeners.add(listener);\r\n      return () => {\r\n        ((targetListeners: any): Set<ReactDOMEventHandleListener>).delete(\r\n          listener,\r\n        );\r\n      };\r\n    };\r\n\r\n    return eventHandle;\r\n  }\r\n  return (null: any);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}