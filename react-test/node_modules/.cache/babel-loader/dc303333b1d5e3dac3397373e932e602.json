{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\nimport getActiveElement from './getActiveElement';\nimport { getOffsets, setOffsets } from './ReactDOMSelection';\nimport { ELEMENT_NODE, TEXT_NODE } from '../shared/HTMLNodeType';\n\nfunction isTextNode(node) {\n  return node && node.nodeType === TEXT_NODE;\n}\n\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nfunction isInDocument(node) {\n  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\n}\n\nfunction isSameOriginFrame(iframe) {\n  try {\n    // Accessing the contentDocument of a HTMLIframeElement can cause the browser\n    // to throw, e.g. if it has a cross-origin src attribute.\n    // Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n    // iframe.contentDocument.defaultView;\n    // A safety way is to access one of the cross origin properties: Window or Location\n    // Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\n    return typeof iframe.contentWindow.location.href === 'string';\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction getActiveElementDeep() {\n  let win = window;\n  let element = getActiveElement();\n\n  while (element instanceof win.HTMLIFrameElement) {\n    if (isSameOriginFrame(element)) {\n      win = element.contentWindow;\n    } else {\n      return element;\n    }\n\n    element = getActiveElement(win.document);\n  }\n\n  return element;\n}\n/**\r\n * @ReactInputSelection: React input selection module. Based on Selection.js,\r\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\r\n * assume buttons have range selections allowed).\r\n * Input selection module for React.\r\n */\n\n/**\r\n * @hasSelectionCapabilities: we get the element types that support selection\r\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\r\n * and `selectionEnd` rows.\r\n */\n\n\nexport function hasSelectionCapabilities(elem) {\n  const nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\nexport function getSelectionInformation() {\n  const focusedElem = getActiveElementDeep();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null\n  };\n}\n/**\r\n * @restoreSelection: If any selection information was potentially lost,\r\n * restore it. This is useful when performing operations that could remove dom\r\n * nodes and place them back in, resulting in focus being lost.\r\n */\n\nexport function restoreSelection(priorSelectionInformation) {\n  const curFocusedElem = getActiveElementDeep();\n  const priorFocusedElem = priorSelectionInformation.focusedElem;\n  const priorSelectionRange = priorSelectionInformation.selectionRange;\n\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    } // Focusing a node can change the scroll position, which is undesirable\n\n\n    const ancestors = [];\n    let ancestor = priorFocusedElem;\n\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    if (typeof priorFocusedElem.focus === 'function') {\n      priorFocusedElem.focus();\n    }\n\n    for (let i = 0; i < ancestors.length; i++) {\n      const info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n/**\r\n * @getSelection: Gets the selection bounds of a focused textarea, input or\r\n * contentEditable node.\r\n * -@input: Look up selection bounds of this input\r\n * -@return {start: selectionStart, end: selectionEnd}\r\n */\n\nexport function getSelection(input) {\n  let selection;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || {\n    start: 0,\n    end: 0\n  };\n}\n/**\r\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\r\n * the input.\r\n * -@input     Set selection bounds of this input or textarea\r\n * -@offsets   Object of same form that is returned from get*\r\n */\n\nexport function setSelection(input, offsets) {\n  const start = offsets.start;\n  let end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}","map":{"version":3,"names":["getActiveElement","getOffsets","setOffsets","ELEMENT_NODE","TEXT_NODE","isTextNode","node","nodeType","containsNode","outerNode","innerNode","parentNode","contains","compareDocumentPosition","isInDocument","ownerDocument","documentElement","isSameOriginFrame","iframe","contentWindow","location","href","err","getActiveElementDeep","win","window","element","HTMLIFrameElement","document","hasSelectionCapabilities","elem","nodeName","toLowerCase","type","contentEditable","getSelectionInformation","focusedElem","selectionRange","getSelection","restoreSelection","priorSelectionInformation","curFocusedElem","priorFocusedElem","priorSelectionRange","setSelection","ancestors","ancestor","push","left","scrollLeft","top","scrollTop","focus","i","length","info","input","selection","start","selectionStart","end","selectionEnd","offsets","undefined","Math","min","value"],"sources":["E:/debug-anything/react-test/src/react/packages/react-dom/src/client/ReactInputSelection.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nimport getActiveElement from './getActiveElement';\r\n\r\nimport {getOffsets, setOffsets} from './ReactDOMSelection';\r\nimport {ELEMENT_NODE, TEXT_NODE} from '../shared/HTMLNodeType';\r\n\r\nfunction isTextNode(node) {\r\n  return node && node.nodeType === TEXT_NODE;\r\n}\r\n\r\nfunction containsNode(outerNode, innerNode) {\r\n  if (!outerNode || !innerNode) {\r\n    return false;\r\n  } else if (outerNode === innerNode) {\r\n    return true;\r\n  } else if (isTextNode(outerNode)) {\r\n    return false;\r\n  } else if (isTextNode(innerNode)) {\r\n    return containsNode(outerNode, innerNode.parentNode);\r\n  } else if ('contains' in outerNode) {\r\n    return outerNode.contains(innerNode);\r\n  } else if (outerNode.compareDocumentPosition) {\r\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction isInDocument(node) {\r\n  return (\r\n    node &&\r\n    node.ownerDocument &&\r\n    containsNode(node.ownerDocument.documentElement, node)\r\n  );\r\n}\r\n\r\nfunction isSameOriginFrame(iframe) {\r\n  try {\r\n    // Accessing the contentDocument of a HTMLIframeElement can cause the browser\r\n    // to throw, e.g. if it has a cross-origin src attribute.\r\n    // Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\r\n    // iframe.contentDocument.defaultView;\r\n    // A safety way is to access one of the cross origin properties: Window or Location\r\n    // Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\r\n    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\r\n\r\n    return typeof iframe.contentWindow.location.href === 'string';\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction getActiveElementDeep() {\r\n  let win = window;\r\n  let element = getActiveElement();\r\n  while (element instanceof win.HTMLIFrameElement) {\r\n    if (isSameOriginFrame(element)) {\r\n      win = element.contentWindow;\r\n    } else {\r\n      return element;\r\n    }\r\n    element = getActiveElement(win.document);\r\n  }\r\n  return element;\r\n}\r\n\r\n/**\r\n * @ReactInputSelection: React input selection module. Based on Selection.js,\r\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\r\n * assume buttons have range selections allowed).\r\n * Input selection module for React.\r\n */\r\n\r\n/**\r\n * @hasSelectionCapabilities: we get the element types that support selection\r\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\r\n * and `selectionEnd` rows.\r\n */\r\nexport function hasSelectionCapabilities(elem) {\r\n  const nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\r\n  return (\r\n    nodeName &&\r\n    ((nodeName === 'input' &&\r\n      (elem.type === 'text' ||\r\n        elem.type === 'search' ||\r\n        elem.type === 'tel' ||\r\n        elem.type === 'url' ||\r\n        elem.type === 'password')) ||\r\n      nodeName === 'textarea' ||\r\n      elem.contentEditable === 'true')\r\n  );\r\n}\r\n\r\nexport function getSelectionInformation() {\r\n  const focusedElem = getActiveElementDeep();\r\n  return {\r\n    focusedElem: focusedElem,\r\n    selectionRange: hasSelectionCapabilities(focusedElem)\r\n      ? getSelection(focusedElem)\r\n      : null,\r\n  };\r\n}\r\n\r\n/**\r\n * @restoreSelection: If any selection information was potentially lost,\r\n * restore it. This is useful when performing operations that could remove dom\r\n * nodes and place them back in, resulting in focus being lost.\r\n */\r\nexport function restoreSelection(priorSelectionInformation) {\r\n  const curFocusedElem = getActiveElementDeep();\r\n  const priorFocusedElem = priorSelectionInformation.focusedElem;\r\n  const priorSelectionRange = priorSelectionInformation.selectionRange;\r\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\r\n    if (\r\n      priorSelectionRange !== null &&\r\n      hasSelectionCapabilities(priorFocusedElem)\r\n    ) {\r\n      setSelection(priorFocusedElem, priorSelectionRange);\r\n    }\r\n\r\n    // Focusing a node can change the scroll position, which is undesirable\r\n    const ancestors = [];\r\n    let ancestor = priorFocusedElem;\r\n    while ((ancestor = ancestor.parentNode)) {\r\n      if (ancestor.nodeType === ELEMENT_NODE) {\r\n        ancestors.push({\r\n          element: ancestor,\r\n          left: ancestor.scrollLeft,\r\n          top: ancestor.scrollTop,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (typeof priorFocusedElem.focus === 'function') {\r\n      priorFocusedElem.focus();\r\n    }\r\n\r\n    for (let i = 0; i < ancestors.length; i++) {\r\n      const info = ancestors[i];\r\n      info.element.scrollLeft = info.left;\r\n      info.element.scrollTop = info.top;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @getSelection: Gets the selection bounds of a focused textarea, input or\r\n * contentEditable node.\r\n * -@input: Look up selection bounds of this input\r\n * -@return {start: selectionStart, end: selectionEnd}\r\n */\r\nexport function getSelection(input) {\r\n  let selection;\r\n\r\n  if ('selectionStart' in input) {\r\n    // Modern browser with input or textarea.\r\n    selection = {\r\n      start: input.selectionStart,\r\n      end: input.selectionEnd,\r\n    };\r\n  } else {\r\n    // Content editable or old IE textarea.\r\n    selection = getOffsets(input);\r\n  }\r\n\r\n  return selection || {start: 0, end: 0};\r\n}\r\n\r\n/**\r\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\r\n * the input.\r\n * -@input     Set selection bounds of this input or textarea\r\n * -@offsets   Object of same form that is returned from get*\r\n */\r\nexport function setSelection(input, offsets) {\r\n  const start = offsets.start;\r\n  let end = offsets.end;\r\n  if (end === undefined) {\r\n    end = start;\r\n  }\r\n\r\n  if ('selectionStart' in input) {\r\n    input.selectionStart = start;\r\n    input.selectionEnd = Math.min(end, input.value.length);\r\n  } else {\r\n    setOffsets(input, offsets);\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}