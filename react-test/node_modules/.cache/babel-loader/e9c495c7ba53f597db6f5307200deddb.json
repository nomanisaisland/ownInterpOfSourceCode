{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport { registerTwoPhaseEvent } from '../EventRegistry';\nimport { getData as FallbackCompositionStateGetData, initialize as FallbackCompositionStateInitialize, reset as FallbackCompositionStateReset } from '../FallbackCompositionState';\nimport { SyntheticCompositionEvent, SyntheticInputEvent } from '../SyntheticEvent';\nimport { accumulateTwoPhaseListeners } from '../DOMPluginEventSystem';\nconst END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\n\nconst START_KEYCODE = 229;\nconst canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\nlet documentMode = null;\n\nif (canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n} // Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\n\n\nconst canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\n\nconst useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\nconst SPACEBAR_CODE = 32;\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n_c = SPACEBAR_CHAR;\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);\n  registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\n  registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\n  registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\n} // Track whether we've ever handled a keypress on the space key.\n\n\nlet hasSpaceKeypress = false;\n/**\r\n * Return whether a native keypress event is assumed to be a command.\r\n * This is required because Firefox fires `keypress` events for key commands\r\n * (cut, copy, select-all, etc.) even though no character is inserted.\r\n */\n\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n/**\r\n * Translate native top level events into event types.\r\n */\n\n\nfunction getCompositionEventType(domEventName) {\n  switch (domEventName) {\n    case 'compositionstart':\n      return 'onCompositionStart';\n\n    case 'compositionend':\n      return 'onCompositionEnd';\n\n    case 'compositionupdate':\n      return 'onCompositionUpdate';\n  }\n}\n/**\r\n * Does our fallback best-guess model think this event signifies that\r\n * composition has begun?\r\n */\n\n\nfunction isFallbackCompositionStart(domEventName, nativeEvent) {\n  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;\n}\n/**\r\n * Does our fallback mode think that this event is the end of composition?\r\n */\n\n\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case 'keyup':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n\n    case 'keydown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n\n    case 'keypress':\n    case 'mousedown':\n    case 'focusout':\n      // Events are not possible without cancelling IME.\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\r\n * Google Input Tools provides composition data via a CustomEvent,\r\n * with the `data` property populated in the `detail` object. If this\r\n * is available on the event object, use it. If not, this is a plain\r\n * composition event and we have nothing special to extract.\r\n *\r\n * @param {object} nativeEvent\r\n * @return {?string}\r\n */\n\n\nfunction getDataFromCustomEvent(nativeEvent) {\n  const detail = nativeEvent.detail;\n\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n\n  return null;\n}\n/**\r\n * Check if a composition event was triggered by Korean IME.\r\n * Our fallback mode does not work well with IE's Korean IME,\r\n * so just use native composition events when Korean IME is used.\r\n * Although CompositionEvent.locale property is deprecated,\r\n * it is available in IE, where our fallback mode is enabled.\r\n *\r\n * @param {object} nativeEvent\r\n * @return {boolean}\r\n */\n\n\nfunction isUsingKoreanIME(nativeEvent) {\n  return nativeEvent.locale === 'ko';\n} // Track the current IME composition status, if any.\n\n\nlet isComposing = false;\n/**\r\n * @return {?object} A SyntheticCompositionEvent.\r\n */\n\nfunction extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n  let eventType;\n  let fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(domEventName);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(domEventName, nativeEvent)) {\n      eventType = 'onCompositionStart';\n    }\n  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\n    eventType = 'onCompositionEnd';\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === 'onCompositionStart') {\n      isComposing = FallbackCompositionStateInitialize(nativeEventTarget);\n    } else if (eventType === 'onCompositionEnd') {\n      if (isComposing) {\n        fallbackData = FallbackCompositionStateGetData();\n      }\n    }\n  }\n\n  const listeners = accumulateTwoPhaseListeners(targetInst, eventType);\n\n  if (listeners.length > 0) {\n    const event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n\n    if (fallbackData) {\n      // Inject data generated from fallback path into the synthetic event.\n      // This matches the property of native CompositionEventInterface.\n      event.data = fallbackData;\n    } else {\n      const customData = getDataFromCustomEvent(nativeEvent);\n\n      if (customData !== null) {\n        event.data = customData;\n      }\n    }\n  }\n}\n\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case 'compositionend':\n      return getDataFromCustomEvent(nativeEvent);\n\n    case 'keypress':\n      /**\r\n       * If native `textInput` events are available, our goal is to make\r\n       * use of them. However, there is a special case: the spacebar key.\r\n       * In Webkit, preventing default on a spacebar `textInput` event\r\n       * cancels character insertion, but it *also* causes the browser\r\n       * to fall back to its default spacebar behavior of scrolling the\r\n       * page.\r\n       *\r\n       * Tracking at:\r\n       * https://code.google.com/p/chromium/issues/detail?id=355103\r\n       *\r\n       * To avoid this issue, use the keypress event as if no `textInput`\r\n       * event is available.\r\n       */\n      const which = nativeEvent.which;\n\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'textInput':\n      // Record the characters to be added to the DOM.\n      const chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to ignore it.\n\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n/**\r\n * For browsers that do not provide the `textInput` event, extract the\r\n * appropriate string to use for SyntheticInputEvent.\r\n */\n\n\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {\n      const chars = FallbackCompositionStateGetData();\n      FallbackCompositionStateReset();\n      isComposing = false;\n      return chars;\n    }\n\n    return null;\n  }\n\n  switch (domEventName) {\n    case 'paste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n\n    case 'keypress':\n      /**\r\n       * As of v27, Firefox may fire keypress events even when no character\r\n       * will be inserted. A few possibilities:\r\n       *\r\n       * - `which` is `0`. Arrow keys, Esc key, etc.\r\n       *\r\n       * - `which` is the pressed key code, but no char is available.\r\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\r\n       *   this key combination and no character is inserted into the\r\n       *   document, but FF fires the keypress for char code `100` anyway.\r\n       *   No `input` event will occur.\r\n       *\r\n       * - `which` is the pressed key code, but a command combination is\r\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\r\n       *   `input` event will occur.\r\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n\n      return null;\n\n    case 'compositionend':\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n\n    default:\n      return null;\n  }\n}\n/**\r\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\r\n * `textInput` or fallback behavior.\r\n *\r\n * @return {?object} A SyntheticInputEvent.\r\n */\n\n\nfunction extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n  let chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(domEventName, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\n  } // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n\n\n  if (!chars) {\n    return null;\n  }\n\n  const listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');\n\n  if (listeners.length > 0) {\n    const event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n    event.data = chars;\n  }\n}\n/**\r\n * Create an `onBeforeInput` event to match\r\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\r\n *\r\n * This event plugin is based on the native `textInput` event\r\n * available in Chrome, Safari, Opera, and IE. This event fires after\r\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\r\n *\r\n * `beforeInput` is spec'd but not implemented in any browsers, and\r\n * the `input` event does not provide any useful information about what has\r\n * actually been added, contrary to the spec. Thus, `textInput` is the best\r\n * available event to identify the characters that have actually been inserted\r\n * into the target node.\r\n *\r\n * This plugin is also responsible for emitting `composition` events, thus\r\n * allowing us to share composition fallback code for both `beforeInput` and\r\n * `composition` event types.\r\n */\n\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n  extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n}\n\nexport { registerEvents, extractEvents };\n\nvar _c;\n\n$RefreshReg$(_c, \"SPACEBAR_CHAR\");","map":{"version":3,"names":["canUseDOM","registerTwoPhaseEvent","getData","FallbackCompositionStateGetData","initialize","FallbackCompositionStateInitialize","reset","FallbackCompositionStateReset","SyntheticCompositionEvent","SyntheticInputEvent","accumulateTwoPhaseListeners","END_KEYCODES","START_KEYCODE","canUseCompositionEvent","window","documentMode","document","canUseTextInputEvent","useFallbackCompositionData","SPACEBAR_CODE","SPACEBAR_CHAR","String","fromCharCode","registerEvents","hasSpaceKeypress","isKeypressCommand","nativeEvent","ctrlKey","altKey","metaKey","getCompositionEventType","domEventName","isFallbackCompositionStart","keyCode","isFallbackCompositionEnd","indexOf","getDataFromCustomEvent","detail","data","isUsingKoreanIME","locale","isComposing","extractCompositionEvent","dispatchQueue","targetInst","nativeEventTarget","eventType","fallbackData","listeners","length","event","push","customData","getNativeBeforeInputChars","which","chars","getFallbackBeforeInputChars","char","extractBeforeInputEvent","extractEvents","eventSystemFlags","targetContainer"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-dom/src/events/plugins/BeforeInputEventPlugin.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {DOMEventName} from '../../events/DOMEventNames';\r\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\r\nimport type {AnyNativeEvent} from '../../events/PluginModuleType';\r\nimport type {DispatchQueue} from '../DOMPluginEventSystem';\r\nimport type {EventSystemFlags} from '../EventSystemFlags';\r\n\r\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\r\n\r\nimport {registerTwoPhaseEvent} from '../EventRegistry';\r\nimport {\r\n  getData as FallbackCompositionStateGetData,\r\n  initialize as FallbackCompositionStateInitialize,\r\n  reset as FallbackCompositionStateReset,\r\n} from '../FallbackCompositionState';\r\nimport {\r\n  SyntheticCompositionEvent,\r\n  SyntheticInputEvent,\r\n} from '../SyntheticEvent';\r\nimport {accumulateTwoPhaseListeners} from '../DOMPluginEventSystem';\r\n\r\nconst END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\r\nconst START_KEYCODE = 229;\r\n\r\nconst canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\r\n\r\nlet documentMode = null;\r\nif (canUseDOM && 'documentMode' in document) {\r\n  documentMode = document.documentMode;\r\n}\r\n\r\n// Webkit offers a very useful `textInput` event that can be used to\r\n// directly represent `beforeInput`. The IE `textinput` event is not as\r\n// useful, so we don't use it.\r\nconst canUseTextInputEvent =\r\n  canUseDOM && 'TextEvent' in window && !documentMode;\r\n\r\n// In IE9+, we have access to composition events, but the data supplied\r\n// by the native compositionend event may be incorrect. Japanese ideographic\r\n// spaces, for instance (\\u3000) are not recorded correctly.\r\nconst useFallbackCompositionData =\r\n  canUseDOM &&\r\n  (!canUseCompositionEvent ||\r\n    (documentMode && documentMode > 8 && documentMode <= 11));\r\n\r\nconst SPACEBAR_CODE = 32;\r\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\r\n\r\nfunction registerEvents() {\r\n  registerTwoPhaseEvent('onBeforeInput', [\r\n    'compositionend',\r\n    'keypress',\r\n    'textInput',\r\n    'paste',\r\n  ]);\r\n  registerTwoPhaseEvent('onCompositionEnd', [\r\n    'compositionend',\r\n    'focusout',\r\n    'keydown',\r\n    'keypress',\r\n    'keyup',\r\n    'mousedown',\r\n  ]);\r\n  registerTwoPhaseEvent('onCompositionStart', [\r\n    'compositionstart',\r\n    'focusout',\r\n    'keydown',\r\n    'keypress',\r\n    'keyup',\r\n    'mousedown',\r\n  ]);\r\n  registerTwoPhaseEvent('onCompositionUpdate', [\r\n    'compositionupdate',\r\n    'focusout',\r\n    'keydown',\r\n    'keypress',\r\n    'keyup',\r\n    'mousedown',\r\n  ]);\r\n}\r\n\r\n// Track whether we've ever handled a keypress on the space key.\r\nlet hasSpaceKeypress = false;\r\n\r\n/**\r\n * Return whether a native keypress event is assumed to be a command.\r\n * This is required because Firefox fires `keypress` events for key commands\r\n * (cut, copy, select-all, etc.) even though no character is inserted.\r\n */\r\nfunction isKeypressCommand(nativeEvent: any) {\r\n  return (\r\n    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\r\n    // ctrlKey && altKey is equivalent to AltGr, and is not a command.\r\n    !(nativeEvent.ctrlKey && nativeEvent.altKey)\r\n  );\r\n}\r\n\r\n/**\r\n * Translate native top level events into event types.\r\n */\r\nfunction getCompositionEventType(domEventName: DOMEventName) {\r\n  switch (domEventName) {\r\n    case 'compositionstart':\r\n      return 'onCompositionStart';\r\n    case 'compositionend':\r\n      return 'onCompositionEnd';\r\n    case 'compositionupdate':\r\n      return 'onCompositionUpdate';\r\n  }\r\n}\r\n\r\n/**\r\n * Does our fallback best-guess model think this event signifies that\r\n * composition has begun?\r\n */\r\nfunction isFallbackCompositionStart(\r\n  domEventName: DOMEventName,\r\n  nativeEvent: any,\r\n): boolean {\r\n  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;\r\n}\r\n\r\n/**\r\n * Does our fallback mode think that this event is the end of composition?\r\n */\r\nfunction isFallbackCompositionEnd(\r\n  domEventName: DOMEventName,\r\n  nativeEvent: any,\r\n): boolean {\r\n  switch (domEventName) {\r\n    case 'keyup':\r\n      // Command keys insert or clear IME input.\r\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\r\n    case 'keydown':\r\n      // Expect IME keyCode on each keydown. If we get any other\r\n      // code we must have exited earlier.\r\n      return nativeEvent.keyCode !== START_KEYCODE;\r\n    case 'keypress':\r\n    case 'mousedown':\r\n    case 'focusout':\r\n      // Events are not possible without cancelling IME.\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Google Input Tools provides composition data via a CustomEvent,\r\n * with the `data` property populated in the `detail` object. If this\r\n * is available on the event object, use it. If not, this is a plain\r\n * composition event and we have nothing special to extract.\r\n *\r\n * @param {object} nativeEvent\r\n * @return {?string}\r\n */\r\nfunction getDataFromCustomEvent(nativeEvent: any) {\r\n  const detail = nativeEvent.detail;\r\n  if (typeof detail === 'object' && 'data' in detail) {\r\n    return detail.data;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Check if a composition event was triggered by Korean IME.\r\n * Our fallback mode does not work well with IE's Korean IME,\r\n * so just use native composition events when Korean IME is used.\r\n * Although CompositionEvent.locale property is deprecated,\r\n * it is available in IE, where our fallback mode is enabled.\r\n *\r\n * @param {object} nativeEvent\r\n * @return {boolean}\r\n */\r\nfunction isUsingKoreanIME(nativeEvent: any) {\r\n  return nativeEvent.locale === 'ko';\r\n}\r\n\r\n// Track the current IME composition status, if any.\r\nlet isComposing = false;\r\n\r\n/**\r\n * @return {?object} A SyntheticCompositionEvent.\r\n */\r\nfunction extractCompositionEvent(\r\n  dispatchQueue,\r\n  domEventName,\r\n  targetInst,\r\n  nativeEvent,\r\n  nativeEventTarget,\r\n) {\r\n  let eventType;\r\n  let fallbackData;\r\n\r\n  if (canUseCompositionEvent) {\r\n    eventType = getCompositionEventType(domEventName);\r\n  } else if (!isComposing) {\r\n    if (isFallbackCompositionStart(domEventName, nativeEvent)) {\r\n      eventType = 'onCompositionStart';\r\n    }\r\n  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\r\n    eventType = 'onCompositionEnd';\r\n  }\r\n\r\n  if (!eventType) {\r\n    return null;\r\n  }\r\n\r\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\r\n    // The current composition is stored statically and must not be\r\n    // overwritten while composition continues.\r\n    if (!isComposing && eventType === 'onCompositionStart') {\r\n      isComposing = FallbackCompositionStateInitialize(nativeEventTarget);\r\n    } else if (eventType === 'onCompositionEnd') {\r\n      if (isComposing) {\r\n        fallbackData = FallbackCompositionStateGetData();\r\n      }\r\n    }\r\n  }\r\n\r\n  const listeners = accumulateTwoPhaseListeners(targetInst, eventType);\r\n  if (listeners.length > 0) {\r\n    const event = new SyntheticCompositionEvent(\r\n      eventType,\r\n      domEventName,\r\n      null,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n    );\r\n    dispatchQueue.push({event, listeners});\r\n    if (fallbackData) {\r\n      // Inject data generated from fallback path into the synthetic event.\r\n      // This matches the property of native CompositionEventInterface.\r\n      event.data = fallbackData;\r\n    } else {\r\n      const customData = getDataFromCustomEvent(nativeEvent);\r\n      if (customData !== null) {\r\n        event.data = customData;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNativeBeforeInputChars(\r\n  domEventName: DOMEventName,\r\n  nativeEvent: any,\r\n): ?string {\r\n  switch (domEventName) {\r\n    case 'compositionend':\r\n      return getDataFromCustomEvent(nativeEvent);\r\n    case 'keypress':\r\n      /**\r\n       * If native `textInput` events are available, our goal is to make\r\n       * use of them. However, there is a special case: the spacebar key.\r\n       * In Webkit, preventing default on a spacebar `textInput` event\r\n       * cancels character insertion, but it *also* causes the browser\r\n       * to fall back to its default spacebar behavior of scrolling the\r\n       * page.\r\n       *\r\n       * Tracking at:\r\n       * https://code.google.com/p/chromium/issues/detail?id=355103\r\n       *\r\n       * To avoid this issue, use the keypress event as if no `textInput`\r\n       * event is available.\r\n       */\r\n      const which = nativeEvent.which;\r\n      if (which !== SPACEBAR_CODE) {\r\n        return null;\r\n      }\r\n\r\n      hasSpaceKeypress = true;\r\n      return SPACEBAR_CHAR;\r\n\r\n    case 'textInput':\r\n      // Record the characters to be added to the DOM.\r\n      const chars = nativeEvent.data;\r\n\r\n      // If it's a spacebar character, assume that we have already handled\r\n      // it at the keypress level and bail immediately. Android Chrome\r\n      // doesn't give us keycodes, so we need to ignore it.\r\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\r\n        return null;\r\n      }\r\n\r\n      return chars;\r\n\r\n    default:\r\n      // For other native event types, do nothing.\r\n      return null;\r\n  }\r\n}\r\n\r\n/**\r\n * For browsers that do not provide the `textInput` event, extract the\r\n * appropriate string to use for SyntheticInputEvent.\r\n */\r\nfunction getFallbackBeforeInputChars(\r\n  domEventName: DOMEventName,\r\n  nativeEvent: any,\r\n): ?string {\r\n  // If we are currently composing (IME) and using a fallback to do so,\r\n  // try to extract the composed characters from the fallback object.\r\n  // If composition event is available, we extract a string only at\r\n  // compositionevent, otherwise extract it at fallback events.\r\n  if (isComposing) {\r\n    if (\r\n      domEventName === 'compositionend' ||\r\n      (!canUseCompositionEvent &&\r\n        isFallbackCompositionEnd(domEventName, nativeEvent))\r\n    ) {\r\n      const chars = FallbackCompositionStateGetData();\r\n      FallbackCompositionStateReset();\r\n      isComposing = false;\r\n      return chars;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  switch (domEventName) {\r\n    case 'paste':\r\n      // If a paste event occurs after a keypress, throw out the input\r\n      // chars. Paste events should not lead to BeforeInput events.\r\n      return null;\r\n    case 'keypress':\r\n      /**\r\n       * As of v27, Firefox may fire keypress events even when no character\r\n       * will be inserted. A few possibilities:\r\n       *\r\n       * - `which` is `0`. Arrow keys, Esc key, etc.\r\n       *\r\n       * - `which` is the pressed key code, but no char is available.\r\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\r\n       *   this key combination and no character is inserted into the\r\n       *   document, but FF fires the keypress for char code `100` anyway.\r\n       *   No `input` event will occur.\r\n       *\r\n       * - `which` is the pressed key code, but a command combination is\r\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\r\n       *   `input` event will occur.\r\n       */\r\n      if (!isKeypressCommand(nativeEvent)) {\r\n        // IE fires the `keypress` event when a user types an emoji via\r\n        // Touch keyboard of Windows.  In such a case, the `char` property\r\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\r\n        // is 2, the property `which` does not represent an emoji correctly.\r\n        // In such a case, we directly return the `char` property instead of\r\n        // using `which`.\r\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\r\n          return nativeEvent.char;\r\n        } else if (nativeEvent.which) {\r\n          return String.fromCharCode(nativeEvent.which);\r\n        }\r\n      }\r\n      return null;\r\n    case 'compositionend':\r\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)\r\n        ? null\r\n        : nativeEvent.data;\r\n    default:\r\n      return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\r\n * `textInput` or fallback behavior.\r\n *\r\n * @return {?object} A SyntheticInputEvent.\r\n */\r\nfunction extractBeforeInputEvent(\r\n  dispatchQueue,\r\n  domEventName,\r\n  targetInst,\r\n  nativeEvent,\r\n  nativeEventTarget,\r\n) {\r\n  let chars;\r\n\r\n  if (canUseTextInputEvent) {\r\n    chars = getNativeBeforeInputChars(domEventName, nativeEvent);\r\n  } else {\r\n    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\r\n  }\r\n\r\n  // If no characters are being inserted, no BeforeInput event should\r\n  // be fired.\r\n  if (!chars) {\r\n    return null;\r\n  }\r\n\r\n  const listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');\r\n  if (listeners.length > 0) {\r\n    const event = new SyntheticInputEvent(\r\n      'onBeforeInput',\r\n      'beforeinput',\r\n      null,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n    );\r\n    dispatchQueue.push({event, listeners});\r\n    event.data = chars;\r\n  }\r\n}\r\n\r\n/**\r\n * Create an `onBeforeInput` event to match\r\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\r\n *\r\n * This event plugin is based on the native `textInput` event\r\n * available in Chrome, Safari, Opera, and IE. This event fires after\r\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\r\n *\r\n * `beforeInput` is spec'd but not implemented in any browsers, and\r\n * the `input` event does not provide any useful information about what has\r\n * actually been added, contrary to the spec. Thus, `textInput` is the best\r\n * available event to identify the characters that have actually been inserted\r\n * into the target node.\r\n *\r\n * This plugin is also responsible for emitting `composition` events, thus\r\n * allowing us to share composition fallback code for both `beforeInput` and\r\n * `composition` event types.\r\n */\r\nfunction extractEvents(\r\n  dispatchQueue: DispatchQueue,\r\n  domEventName: DOMEventName,\r\n  targetInst: null | Fiber,\r\n  nativeEvent: AnyNativeEvent,\r\n  nativeEventTarget: null | EventTarget,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n): void {\r\n  extractCompositionEvent(\r\n    dispatchQueue,\r\n    domEventName,\r\n    targetInst,\r\n    nativeEvent,\r\n    nativeEventTarget,\r\n  );\r\n  extractBeforeInputEvent(\r\n    dispatchQueue,\r\n    domEventName,\r\n    targetInst,\r\n    nativeEvent,\r\n    nativeEventTarget,\r\n  );\r\n}\r\n\r\nexport {registerEvents, extractEvents};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}