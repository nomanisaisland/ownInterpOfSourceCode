{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport ReactCurrentActQueue from './ReactCurrentActQueue';\nimport enqueueTask from 'shared/enqueueTask';\nlet actScopeDepth = 0;\nlet didWarnNoAwaitAct = false;\nexport function act(callback) {\n  if (__DEV__) {\n    // `act` calls can be nested, so we track the depth. This represents the\n    // number of `act` scopes on the stack.\n    const prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n\n    if (ReactCurrentActQueue.current === null) {\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\n      // will detect the queue and use it instead of Scheduler.\n      ReactCurrentActQueue.current = [];\n    }\n\n    const prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    let result;\n\n    try {\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n      // set to `true` while the given callback is executed, not for updates\n      // triggered during an async event, because this is how the legacy\n      // implementation of `act` behaved.\n      ReactCurrentActQueue.isBatchingLegacy = true;\n      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n\n      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n        const queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n          flushActQueue(queue);\n        }\n      }\n    } catch (error) {\n      popActScope(prevActScopeDepth);\n      throw error;\n    } finally {\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    }\n\n    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n      const thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n      // for it to resolve before exiting the current scope.\n\n      let wasAwaited = false;\n      const thenable = {\n        then(resolve, reject) {\n          wasAwaited = true;\n          thenableResult.then(returnValue => {\n            popActScope(prevActScopeDepth);\n\n            if (actScopeDepth === 0) {\n              // We've exited the outermost act scope. Recursively flush the\n              // queue until there's no remaining work.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }, error => {\n            // The callback threw an error.\n            popActScope(prevActScopeDepth);\n            reject(error);\n          });\n        }\n\n      };\n\n      if (__DEV__) {\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n          // eslint-disable-next-line no-undef\n          Promise.resolve().then(() => {}).then(() => {\n            if (!wasAwaited) {\n              didWarnNoAwaitAct = true;\n              console.error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n            }\n          });\n        }\n      }\n\n      return thenable;\n    } else {\n      const returnValue = result; // The callback is not an async function. Exit the current scope\n      // immediately, without awaiting.\n\n      popActScope(prevActScopeDepth);\n\n      if (actScopeDepth === 0) {\n        // Exiting the outermost act scope. Flush the queue.\n        const queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          flushActQueue(queue);\n          ReactCurrentActQueue.current = null;\n        } // Return a thenable. If the user awaits it, we'll flush again in\n        // case additional work was scheduled by a microtask.\n\n\n        const thenable = {\n          then(resolve, reject) {\n            // Confirm we haven't re-entered another `act` scope, in case\n            // the user does something weird like await the thenable\n            // multiple times.\n            if (ReactCurrentActQueue.current === null) {\n              // Recursively flush the queue until there's no remaining work.\n              ReactCurrentActQueue.current = [];\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }\n\n        };\n        return thenable;\n      } else {\n        // Since we're inside a nested `act` scope, the returned thenable\n        // immediately resolves. The outer scope will flush the queue.\n        const thenable = {\n          then(resolve, reject) {\n            resolve(returnValue);\n          }\n\n        };\n        return thenable;\n      }\n    }\n  } else {\n    throw new Error('act(...) is not supported in production builds of React.');\n  }\n}\n\nfunction popActScope(prevActScopeDepth) {\n  if (__DEV__) {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      console.error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n    }\n\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n  if (__DEV__) {\n    const queue = ReactCurrentActQueue.current;\n\n    if (queue !== null) {\n      try {\n        flushActQueue(queue);\n        enqueueTask(() => {\n          if (queue.length === 0) {\n            // No additional work was scheduled. Finish.\n            ReactCurrentActQueue.current = null;\n            resolve(returnValue);\n          } else {\n            // Keep flushing work until there's none left.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nlet isFlushing = false;\n\nfunction flushActQueue(queue) {\n  if (__DEV__) {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      let i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          let callback = queue[i];\n\n          do {\n            callback = callback(true);\n          } while (callback !== null);\n        }\n\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue = queue.slice(i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}","map":{"version":3,"names":["ReactCurrentActQueue","enqueueTask","actScopeDepth","didWarnNoAwaitAct","act","callback","__DEV__","prevActScopeDepth","current","prevIsBatchingLegacy","isBatchingLegacy","result","didScheduleLegacyUpdate","queue","flushActQueue","error","popActScope","then","thenableResult","wasAwaited","thenable","resolve","reject","returnValue","recursivelyFlushAsyncActWork","Promise","console","Error","length","isFlushing","i","slice"],"sources":["E:/react-test/src/react/packages/react/src/ReactAct.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Thenable} from 'shared/ReactTypes';\r\nimport ReactCurrentActQueue from './ReactCurrentActQueue';\r\nimport enqueueTask from 'shared/enqueueTask';\r\n\r\nlet actScopeDepth = 0;\r\nlet didWarnNoAwaitAct = false;\r\n\r\nexport function act<T>(callback: () => T | Thenable<T>): Thenable<T> {\r\n  if (__DEV__) {\r\n    // `act` calls can be nested, so we track the depth. This represents the\r\n    // number of `act` scopes on the stack.\r\n    const prevActScopeDepth = actScopeDepth;\r\n    actScopeDepth++;\r\n\r\n    if (ReactCurrentActQueue.current === null) {\r\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\r\n      // will detect the queue and use it instead of Scheduler.\r\n      ReactCurrentActQueue.current = [];\r\n    }\r\n\r\n    const prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\r\n    let result;\r\n    try {\r\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\r\n      // set to `true` while the given callback is executed, not for updates\r\n      // triggered during an async event, because this is how the legacy\r\n      // implementation of `act` behaved.\r\n      ReactCurrentActQueue.isBatchingLegacy = true;\r\n      result = callback();\r\n\r\n      // Replicate behavior of original `act` implementation in legacy mode,\r\n      // which flushed updates immediately after the scope function exits, even\r\n      // if it's an async function.\r\n      if (\r\n        !prevIsBatchingLegacy &&\r\n        ReactCurrentActQueue.didScheduleLegacyUpdate\r\n      ) {\r\n        const queue = ReactCurrentActQueue.current;\r\n        if (queue !== null) {\r\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\r\n          flushActQueue(queue);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      popActScope(prevActScopeDepth);\r\n      throw error;\r\n    } finally {\r\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\r\n    }\r\n\r\n    if (\r\n      result !== null &&\r\n      typeof result === 'object' &&\r\n      typeof result.then === 'function'\r\n    ) {\r\n      const thenableResult: Thenable<T> = (result: any);\r\n      // The callback is an async function (i.e. returned a promise). Wait\r\n      // for it to resolve before exiting the current scope.\r\n      let wasAwaited = false;\r\n      const thenable: Thenable<T> = {\r\n        then(resolve, reject) {\r\n          wasAwaited = true;\r\n          thenableResult.then(\r\n            returnValue => {\r\n              popActScope(prevActScopeDepth);\r\n              if (actScopeDepth === 0) {\r\n                // We've exited the outermost act scope. Recursively flush the\r\n                // queue until there's no remaining work.\r\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\r\n              } else {\r\n                resolve(returnValue);\r\n              }\r\n            },\r\n            error => {\r\n              // The callback threw an error.\r\n              popActScope(prevActScopeDepth);\r\n              reject(error);\r\n            },\r\n          );\r\n        },\r\n      };\r\n\r\n      if (__DEV__) {\r\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\r\n          // eslint-disable-next-line no-undef\r\n          Promise.resolve()\r\n            .then(() => {})\r\n            .then(() => {\r\n              if (!wasAwaited) {\r\n                didWarnNoAwaitAct = true;\r\n                console.error(\r\n                  'You called act(async () => ...) without await. ' +\r\n                    'This could lead to unexpected testing behaviour, ' +\r\n                    'interleaving multiple act calls and mixing their ' +\r\n                    'scopes. ' +\r\n                    'You should - await act(async () => ...);',\r\n                );\r\n              }\r\n            });\r\n        }\r\n      }\r\n      return thenable;\r\n    } else {\r\n      const returnValue: T = (result: any);\r\n      // The callback is not an async function. Exit the current scope\r\n      // immediately, without awaiting.\r\n      popActScope(prevActScopeDepth);\r\n      if (actScopeDepth === 0) {\r\n        // Exiting the outermost act scope. Flush the queue.\r\n        const queue = ReactCurrentActQueue.current;\r\n        if (queue !== null) {\r\n          flushActQueue(queue);\r\n          ReactCurrentActQueue.current = null;\r\n        }\r\n        // Return a thenable. If the user awaits it, we'll flush again in\r\n        // case additional work was scheduled by a microtask.\r\n        const thenable: Thenable<T> = {\r\n          then(resolve, reject) {\r\n            // Confirm we haven't re-entered another `act` scope, in case\r\n            // the user does something weird like await the thenable\r\n            // multiple times.\r\n            if (ReactCurrentActQueue.current === null) {\r\n              // Recursively flush the queue until there's no remaining work.\r\n              ReactCurrentActQueue.current = [];\r\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\r\n            } else {\r\n              resolve(returnValue);\r\n            }\r\n          },\r\n        };\r\n        return thenable;\r\n      } else {\r\n        // Since we're inside a nested `act` scope, the returned thenable\r\n        // immediately resolves. The outer scope will flush the queue.\r\n        const thenable: Thenable<T> = {\r\n          then(resolve, reject) {\r\n            resolve(returnValue);\r\n          },\r\n        };\r\n        return thenable;\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('act(...) is not supported in production builds of React.');\r\n  }\r\n}\r\n\r\nfunction popActScope(prevActScopeDepth) {\r\n  if (__DEV__) {\r\n    if (prevActScopeDepth !== actScopeDepth - 1) {\r\n      console.error(\r\n        'You seem to have overlapping act() calls, this is not supported. ' +\r\n          'Be sure to await previous act() calls before making a new one. ',\r\n      );\r\n    }\r\n    actScopeDepth = prevActScopeDepth;\r\n  }\r\n}\r\n\r\nfunction recursivelyFlushAsyncActWork<T>(\r\n  returnValue: T,\r\n  resolve: T => mixed,\r\n  reject: mixed => mixed,\r\n) {\r\n  if (__DEV__) {\r\n    const queue = ReactCurrentActQueue.current;\r\n    if (queue !== null) {\r\n      try {\r\n        flushActQueue(queue);\r\n        enqueueTask(() => {\r\n          if (queue.length === 0) {\r\n            // No additional work was scheduled. Finish.\r\n            ReactCurrentActQueue.current = null;\r\n            resolve(returnValue);\r\n          } else {\r\n            // Keep flushing work until there's none left.\r\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\r\n          }\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    } else {\r\n      resolve(returnValue);\r\n    }\r\n  }\r\n}\r\n\r\nlet isFlushing = false;\r\nfunction flushActQueue(queue) {\r\n  if (__DEV__) {\r\n    if (!isFlushing) {\r\n      // Prevent re-entrance.\r\n      isFlushing = true;\r\n      let i = 0;\r\n      try {\r\n        for (; i < queue.length; i++) {\r\n          let callback = queue[i];\r\n          do {\r\n            callback = callback(true);\r\n          } while (callback !== null);\r\n        }\r\n        queue.length = 0;\r\n      } catch (error) {\r\n        // If something throws, leave the remaining callbacks on the queue.\r\n        queue = queue.slice(i + 1);\r\n        throw error;\r\n      } finally {\r\n        isFlushing = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}