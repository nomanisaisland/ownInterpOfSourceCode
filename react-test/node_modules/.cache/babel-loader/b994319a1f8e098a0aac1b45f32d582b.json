{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\n\n/* eslint-disable react-internal/prod-error-codes */\nimport { flushSync, scheduleUpdateOnFiber, flushPassiveEffects } from './ReactFiberWorkLoop.new';\nimport { updateContainer } from './ReactFiberReconciler.new';\nimport { emptyContextObject } from './ReactFiberContext.new';\nimport { SyncLane, NoTimestamp } from './ReactFiberLane.new';\nimport { ClassComponent, FunctionComponent, ForwardRef, HostComponent, HostPortal, HostRoot, MemoComponent, SimpleMemoComponent } from './ReactWorkTags';\nimport { REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nlet resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n\nlet failedBoundaries = null;\nexport const setRefreshHandler = handler => {\n  if (__DEV__) {\n    resolveFamily = handler;\n  }\n};\nexport function resolveFunctionForHotReloading(type) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    const family = resolveFamily(type);\n\n    if (family === undefined) {\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  } else {\n    return type;\n  }\n}\nexport function resolveClassForHotReloading(type) {\n  // No implementation differences.\n  return resolveFunctionForHotReloading(type);\n}\nexport function resolveForwardRefForHotReloading(type) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    const family = resolveFamily(type);\n\n    if (family === undefined) {\n      // Check if we're dealing with a real forwardRef. Don't want to crash early.\n      if (type !== null && type !== undefined && typeof type.render === 'function') {\n        // ForwardRef is special because its resolved .type is an object,\n        // but it's possible that we only have its inner render function in the map.\n        // If that inner render function is different, we'll build a new forwardRef type.\n        const currentRender = resolveFunctionForHotReloading(type.render);\n\n        if (type.render !== currentRender) {\n          const syntheticType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: currentRender\n          };\n\n          if (type.displayName !== undefined) {\n            syntheticType.displayName = type.displayName;\n          }\n\n          return syntheticType;\n        }\n      }\n\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  } else {\n    return type;\n  }\n}\nexport function isCompatibleFamilyForHotReloading(fiber, element) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return false;\n    }\n\n    const prevType = fiber.elementType;\n    const nextType = element.type; // If we got here, we know types aren't === equal.\n\n    let needsCompareFamilies = false;\n    const $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n\n    switch (fiber.tag) {\n      case ClassComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case FunctionComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            // We don't know the inner type yet.\n            // We're going to assume that the lazy inner type is stable,\n            // and so it is sufficient to avoid reconciling it away.\n            // We're not going to unwrap or actually use the new lazy type.\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case ForwardRef:\n        {\n          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ($$typeofNextType === REACT_MEMO_TYPE) {\n            // TODO: if it was but can no longer be simple,\n            // we shouldn't set this.\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      default:\n        return false;\n    } // Check if both types have a family and it's the same one.\n\n\n    if (needsCompareFamilies) {\n      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n      // This means both of them need to be registered to preserve state.\n      // If we unwrapped and compared the inner types for wrappers instead,\n      // then we would risk falsely saying two separate memo(Foo)\n      // calls are equivalent because they wrap the same Foo function.\n      const prevFamily = resolveFamily(prevType);\n\n      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return false;\n  }\n}\nexport function markFailedErrorBoundaryForHotReloading(fiber) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    if (typeof WeakSet !== 'function') {\n      return;\n    }\n\n    if (failedBoundaries === null) {\n      failedBoundaries = new WeakSet();\n    }\n\n    failedBoundaries.add(fiber);\n  }\n}\nexport const scheduleRefresh = (root, update) => {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    const {\n      staleFamilies,\n      updatedFamilies\n    } = update;\n    flushPassiveEffects();\n    flushSync(() => {\n      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n    });\n  }\n};\nexport const scheduleRoot = (root, element) => {\n  if (__DEV__) {\n    if (root.context !== emptyContextObject) {\n      // Super edge case: root has a legacy _renderSubtree context\n      // but we don't know the parentComponent so we can't pass it.\n      // Just ignore. We'll delete this with _renderSubtree code path later.\n      return;\n    }\n\n    flushPassiveEffects();\n    flushSync(() => {\n      updateContainer(element, root, null, null);\n    });\n  }\n};\n\nfunction scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n  if (__DEV__) {\n    const {\n      alternate,\n      child,\n      sibling,\n      tag,\n      type\n    } = fiber;\n    let candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n\n      default:\n        break;\n    }\n\n    if (resolveFamily === null) {\n      throw new Error('Expected resolveFamily to be set during hot reload.');\n    }\n\n    let needsRender = false;\n    let needsRemount = false;\n\n    if (candidateType !== null) {\n      const family = resolveFamily(candidateType);\n\n      if (family !== undefined) {\n        if (staleFamilies.has(family)) {\n          needsRemount = true;\n        } else if (updatedFamilies.has(family)) {\n          if (tag === ClassComponent) {\n            needsRemount = true;\n          } else {\n            needsRender = true;\n          }\n        }\n      }\n    }\n\n    if (failedBoundaries !== null) {\n      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n        needsRemount = true;\n      }\n    }\n\n    if (needsRemount) {\n      fiber._debugNeedsRemount = true;\n    }\n\n    if (needsRemount || needsRender) {\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n\n    if (child !== null && !needsRemount) {\n      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n    }\n\n    if (sibling !== null) {\n      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n  }\n}\n\nexport const findHostInstancesForRefresh = (root, families) => {\n  if (__DEV__) {\n    const hostInstances = new Set();\n    const types = new Set(families.map(family => family.current));\n    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n    return hostInstances;\n  } else {\n    throw new Error('Did not expect findHostInstancesForRefresh to be called in production.');\n  }\n};\n\nfunction findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n  if (__DEV__) {\n    const {\n      child,\n      sibling,\n      tag,\n      type\n    } = fiber;\n    let candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n\n      default:\n        break;\n    }\n\n    let didMatch = false;\n\n    if (candidateType !== null) {\n      if (types.has(candidateType)) {\n        didMatch = true;\n      }\n    }\n\n    if (didMatch) {\n      // We have a match. This only drills down to the closest host components.\n      // There's no need to search deeper because for the purpose of giving\n      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n      findHostInstancesForFiberShallowly(fiber, hostInstances);\n    } else {\n      // If there's no match, maybe there will be one further down in the child tree.\n      if (child !== null) {\n        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n      }\n    }\n\n    if (sibling !== null) {\n      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n    }\n  }\n}\n\nfunction findHostInstancesForFiberShallowly(fiber, hostInstances) {\n  if (__DEV__) {\n    const foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n\n    if (foundHostInstances) {\n      return;\n    } // If we didn't find any host children, fallback to closest host parent.\n\n\n    let node = fiber;\n\n    while (true) {\n      switch (node.tag) {\n        case HostComponent:\n          hostInstances.add(node.stateNode);\n          return;\n\n        case HostPortal:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n\n        case HostRoot:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n      }\n\n      if (node.return === null) {\n        throw new Error('Expected to reach root first.');\n      }\n\n      node = node.return;\n    }\n  }\n}\n\nfunction findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n  if (__DEV__) {\n    let node = fiber;\n    let foundHostInstances = false;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        // We got a match.\n        foundHostInstances = true;\n        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return foundHostInstances;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === fiber) {\n          return foundHostInstances;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"names":["flushSync","scheduleUpdateOnFiber","flushPassiveEffects","updateContainer","emptyContextObject","SyncLane","NoTimestamp","ClassComponent","FunctionComponent","ForwardRef","HostComponent","HostPortal","HostRoot","MemoComponent","SimpleMemoComponent","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","resolveFamily","failedBoundaries","setRefreshHandler","handler","__DEV__","resolveFunctionForHotReloading","type","family","undefined","current","resolveClassForHotReloading","resolveForwardRefForHotReloading","render","currentRender","syntheticType","$$typeof","displayName","isCompatibleFamilyForHotReloading","fiber","element","prevType","elementType","nextType","needsCompareFamilies","$$typeofNextType","tag","prevFamily","markFailedErrorBoundaryForHotReloading","WeakSet","add","scheduleRefresh","root","update","staleFamilies","updatedFamilies","scheduleFibersWithFamiliesRecursively","scheduleRoot","context","alternate","child","sibling","candidateType","Error","needsRender","needsRemount","has","_debugNeedsRemount","findHostInstancesForRefresh","families","hostInstances","Set","types","map","findHostInstancesForMatchingFibersRecursively","didMatch","findHostInstancesForFiberShallowly","foundHostInstances","findChildHostInstancesForFiberShallowly","node","stateNode","containerInfo","return"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberHotReloading.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\n/* eslint-disable react-internal/prod-error-codes */\r\n\r\nimport type {ReactElement} from 'shared/ReactElementType';\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {FiberRoot} from './ReactInternalTypes';\r\nimport type {Instance} from './ReactFiberHostConfig';\r\nimport type {ReactNodeList} from 'shared/ReactTypes';\r\n\r\nimport {\r\n  flushSync,\r\n  scheduleUpdateOnFiber,\r\n  flushPassiveEffects,\r\n} from './ReactFiberWorkLoop.new';\r\nimport {updateContainer} from './ReactFiberReconciler.new';\r\nimport {emptyContextObject} from './ReactFiberContext.new';\r\nimport {SyncLane, NoTimestamp} from './ReactFiberLane.new';\r\nimport {\r\n  ClassComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  HostComponent,\r\n  HostPortal,\r\n  HostRoot,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n} from './ReactWorkTags';\r\nimport {\r\n  REACT_FORWARD_REF_TYPE,\r\n  REACT_MEMO_TYPE,\r\n  REACT_LAZY_TYPE,\r\n} from 'shared/ReactSymbols';\r\n\r\nexport type Family = {|\r\n  current: any,\r\n|};\r\n\r\nexport type RefreshUpdate = {|\r\n  staleFamilies: Set<Family>,\r\n  updatedFamilies: Set<Family>,\r\n|};\r\n\r\n// Resolves type to a family.\r\ntype RefreshHandler = any => Family | void;\r\n\r\n// Used by React Refresh runtime through DevTools Global Hook.\r\nexport type SetRefreshHandler = (handler: RefreshHandler | null) => void;\r\nexport type ScheduleRefresh = (root: FiberRoot, update: RefreshUpdate) => void;\r\nexport type ScheduleRoot = (root: FiberRoot, element: ReactNodeList) => void;\r\nexport type FindHostInstancesForRefresh = (\r\n  root: FiberRoot,\r\n  families: Array<Family>,\r\n) => Set<Instance>;\r\n\r\nlet resolveFamily: RefreshHandler | null = null;\r\n// $FlowFixMe Flow gets confused by a WeakSet feature check below.\r\nlet failedBoundaries: WeakSet<Fiber> | null = null;\r\n\r\nexport const setRefreshHandler = (handler: RefreshHandler | null): void => {\r\n  if (__DEV__) {\r\n    resolveFamily = handler;\r\n  }\r\n};\r\n\r\nexport function resolveFunctionForHotReloading(type: any): any {\r\n  if (__DEV__) {\r\n    if (resolveFamily === null) {\r\n      // Hot reloading is disabled.\r\n      return type;\r\n    }\r\n    const family = resolveFamily(type);\r\n    if (family === undefined) {\r\n      return type;\r\n    }\r\n    // Use the latest known implementation.\r\n    return family.current;\r\n  } else {\r\n    return type;\r\n  }\r\n}\r\n\r\nexport function resolveClassForHotReloading(type: any): any {\r\n  // No implementation differences.\r\n  return resolveFunctionForHotReloading(type);\r\n}\r\n\r\nexport function resolveForwardRefForHotReloading(type: any): any {\r\n  if (__DEV__) {\r\n    if (resolveFamily === null) {\r\n      // Hot reloading is disabled.\r\n      return type;\r\n    }\r\n    const family = resolveFamily(type);\r\n    if (family === undefined) {\r\n      // Check if we're dealing with a real forwardRef. Don't want to crash early.\r\n      if (\r\n        type !== null &&\r\n        type !== undefined &&\r\n        typeof type.render === 'function'\r\n      ) {\r\n        // ForwardRef is special because its resolved .type is an object,\r\n        // but it's possible that we only have its inner render function in the map.\r\n        // If that inner render function is different, we'll build a new forwardRef type.\r\n        const currentRender = resolveFunctionForHotReloading(type.render);\r\n        if (type.render !== currentRender) {\r\n          const syntheticType = {\r\n            $$typeof: REACT_FORWARD_REF_TYPE,\r\n            render: currentRender,\r\n          };\r\n          if (type.displayName !== undefined) {\r\n            (syntheticType: any).displayName = type.displayName;\r\n          }\r\n          return syntheticType;\r\n        }\r\n      }\r\n      return type;\r\n    }\r\n    // Use the latest known implementation.\r\n    return family.current;\r\n  } else {\r\n    return type;\r\n  }\r\n}\r\n\r\nexport function isCompatibleFamilyForHotReloading(\r\n  fiber: Fiber,\r\n  element: ReactElement,\r\n): boolean {\r\n  if (__DEV__) {\r\n    if (resolveFamily === null) {\r\n      // Hot reloading is disabled.\r\n      return false;\r\n    }\r\n\r\n    const prevType = fiber.elementType;\r\n    const nextType = element.type;\r\n\r\n    // If we got here, we know types aren't === equal.\r\n    let needsCompareFamilies = false;\r\n\r\n    const $$typeofNextType =\r\n      typeof nextType === 'object' && nextType !== null\r\n        ? nextType.$$typeof\r\n        : null;\r\n\r\n    switch (fiber.tag) {\r\n      case ClassComponent: {\r\n        if (typeof nextType === 'function') {\r\n          needsCompareFamilies = true;\r\n        }\r\n        break;\r\n      }\r\n      case FunctionComponent: {\r\n        if (typeof nextType === 'function') {\r\n          needsCompareFamilies = true;\r\n        } else if ($$typeofNextType === REACT_LAZY_TYPE) {\r\n          // We don't know the inner type yet.\r\n          // We're going to assume that the lazy inner type is stable,\r\n          // and so it is sufficient to avoid reconciling it away.\r\n          // We're not going to unwrap or actually use the new lazy type.\r\n          needsCompareFamilies = true;\r\n        }\r\n        break;\r\n      }\r\n      case ForwardRef: {\r\n        if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\r\n          needsCompareFamilies = true;\r\n        } else if ($$typeofNextType === REACT_LAZY_TYPE) {\r\n          needsCompareFamilies = true;\r\n        }\r\n        break;\r\n      }\r\n      case MemoComponent:\r\n      case SimpleMemoComponent: {\r\n        if ($$typeofNextType === REACT_MEMO_TYPE) {\r\n          // TODO: if it was but can no longer be simple,\r\n          // we shouldn't set this.\r\n          needsCompareFamilies = true;\r\n        } else if ($$typeofNextType === REACT_LAZY_TYPE) {\r\n          needsCompareFamilies = true;\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        return false;\r\n    }\r\n\r\n    // Check if both types have a family and it's the same one.\r\n    if (needsCompareFamilies) {\r\n      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\r\n      // This means both of them need to be registered to preserve state.\r\n      // If we unwrapped and compared the inner types for wrappers instead,\r\n      // then we would risk falsely saying two separate memo(Foo)\r\n      // calls are equivalent because they wrap the same Foo function.\r\n      const prevFamily = resolveFamily(prevType);\r\n      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function markFailedErrorBoundaryForHotReloading(fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (resolveFamily === null) {\r\n      // Hot reloading is disabled.\r\n      return;\r\n    }\r\n    if (typeof WeakSet !== 'function') {\r\n      return;\r\n    }\r\n    if (failedBoundaries === null) {\r\n      failedBoundaries = new WeakSet();\r\n    }\r\n    failedBoundaries.add(fiber);\r\n  }\r\n}\r\n\r\nexport const scheduleRefresh: ScheduleRefresh = (\r\n  root: FiberRoot,\r\n  update: RefreshUpdate,\r\n): void => {\r\n  if (__DEV__) {\r\n    if (resolveFamily === null) {\r\n      // Hot reloading is disabled.\r\n      return;\r\n    }\r\n    const {staleFamilies, updatedFamilies} = update;\r\n    flushPassiveEffects();\r\n    flushSync(() => {\r\n      scheduleFibersWithFamiliesRecursively(\r\n        root.current,\r\n        updatedFamilies,\r\n        staleFamilies,\r\n      );\r\n    });\r\n  }\r\n};\r\n\r\nexport const scheduleRoot: ScheduleRoot = (\r\n  root: FiberRoot,\r\n  element: ReactNodeList,\r\n): void => {\r\n\r\n  if (__DEV__) {\r\n    if (root.context !== emptyContextObject) {\r\n      // Super edge case: root has a legacy _renderSubtree context\r\n      // but we don't know the parentComponent so we can't pass it.\r\n      // Just ignore. We'll delete this with _renderSubtree code path later.\r\n      return;\r\n    }\r\n    flushPassiveEffects();\r\n    flushSync(() => {\r\n      updateContainer(element, root, null, null);\r\n    });\r\n  }\r\n};\r\n\r\nfunction scheduleFibersWithFamiliesRecursively(\r\n  fiber: Fiber,\r\n  updatedFamilies: Set<Family>,\r\n  staleFamilies: Set<Family>,\r\n) {\r\n  if (__DEV__) {\r\n    const {alternate, child, sibling, tag, type} = fiber;\r\n\r\n    let candidateType = null;\r\n    switch (tag) {\r\n      case FunctionComponent:\r\n      case SimpleMemoComponent:\r\n      case ClassComponent:\r\n        candidateType = type;\r\n        break;\r\n      case ForwardRef:\r\n        candidateType = type.render;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    if (resolveFamily === null) {\r\n      throw new Error('Expected resolveFamily to be set during hot reload.');\r\n    }\r\n\r\n    let needsRender = false;\r\n    let needsRemount = false;\r\n    if (candidateType !== null) {\r\n      const family = resolveFamily(candidateType);\r\n      if (family !== undefined) {\r\n        if (staleFamilies.has(family)) {\r\n          needsRemount = true;\r\n        } else if (updatedFamilies.has(family)) {\r\n          if (tag === ClassComponent) {\r\n            needsRemount = true;\r\n          } else {\r\n            needsRender = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (failedBoundaries !== null) {\r\n      if (\r\n        failedBoundaries.has(fiber) ||\r\n        (alternate !== null && failedBoundaries.has(alternate))\r\n      ) {\r\n        needsRemount = true;\r\n      }\r\n    }\r\n\r\n    if (needsRemount) {\r\n      fiber._debugNeedsRemount = true;\r\n    }\r\n    if (needsRemount || needsRender) {\r\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n    }\r\n    if (child !== null && !needsRemount) {\r\n      scheduleFibersWithFamiliesRecursively(\r\n        child,\r\n        updatedFamilies,\r\n        staleFamilies,\r\n      );\r\n    }\r\n    if (sibling !== null) {\r\n      scheduleFibersWithFamiliesRecursively(\r\n        sibling,\r\n        updatedFamilies,\r\n        staleFamilies,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const findHostInstancesForRefresh: FindHostInstancesForRefresh = (\r\n  root: FiberRoot,\r\n  families: Array<Family>,\r\n): Set<Instance> => {\r\n  if (__DEV__) {\r\n    const hostInstances = new Set();\r\n    const types = new Set(families.map(family => family.current));\r\n    findHostInstancesForMatchingFibersRecursively(\r\n      root.current,\r\n      types,\r\n      hostInstances,\r\n    );\r\n    return hostInstances;\r\n  } else {\r\n    throw new Error(\r\n      'Did not expect findHostInstancesForRefresh to be called in production.',\r\n    );\r\n  }\r\n};\r\n\r\nfunction findHostInstancesForMatchingFibersRecursively(\r\n  fiber: Fiber,\r\n  types: Set<any>,\r\n  hostInstances: Set<Instance>,\r\n) {\r\n  if (__DEV__) {\r\n    const {child, sibling, tag, type} = fiber;\r\n\r\n    let candidateType = null;\r\n    switch (tag) {\r\n      case FunctionComponent:\r\n      case SimpleMemoComponent:\r\n      case ClassComponent:\r\n        candidateType = type;\r\n        break;\r\n      case ForwardRef:\r\n        candidateType = type.render;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    let didMatch = false;\r\n    if (candidateType !== null) {\r\n      if (types.has(candidateType)) {\r\n        didMatch = true;\r\n      }\r\n    }\r\n\r\n    if (didMatch) {\r\n      // We have a match. This only drills down to the closest host components.\r\n      // There's no need to search deeper because for the purpose of giving\r\n      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\r\n      findHostInstancesForFiberShallowly(fiber, hostInstances);\r\n    } else {\r\n      // If there's no match, maybe there will be one further down in the child tree.\r\n      if (child !== null) {\r\n        findHostInstancesForMatchingFibersRecursively(\r\n          child,\r\n          types,\r\n          hostInstances,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (sibling !== null) {\r\n      findHostInstancesForMatchingFibersRecursively(\r\n        sibling,\r\n        types,\r\n        hostInstances,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction findHostInstancesForFiberShallowly(\r\n  fiber: Fiber,\r\n  hostInstances: Set<Instance>,\r\n): void {\r\n  if (__DEV__) {\r\n    const foundHostInstances = findChildHostInstancesForFiberShallowly(\r\n      fiber,\r\n      hostInstances,\r\n    );\r\n    if (foundHostInstances) {\r\n      return;\r\n    }\r\n    // If we didn't find any host children, fallback to closest host parent.\r\n    let node = fiber;\r\n    while (true) {\r\n      switch (node.tag) {\r\n        case HostComponent:\r\n          hostInstances.add(node.stateNode);\r\n          return;\r\n        case HostPortal:\r\n          hostInstances.add(node.stateNode.containerInfo);\r\n          return;\r\n        case HostRoot:\r\n          hostInstances.add(node.stateNode.containerInfo);\r\n          return;\r\n      }\r\n      if (node.return === null) {\r\n        throw new Error('Expected to reach root first.');\r\n      }\r\n      node = node.return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction findChildHostInstancesForFiberShallowly(\r\n  fiber: Fiber,\r\n  hostInstances: Set<Instance>,\r\n): boolean {\r\n  if (__DEV__) {\r\n    let node: Fiber = fiber;\r\n    let foundHostInstances = false;\r\n    while (true) {\r\n      if (node.tag === HostComponent) {\r\n        // We got a match.\r\n        foundHostInstances = true;\r\n        hostInstances.add(node.stateNode);\r\n        // There may still be more, so keep searching.\r\n      } else if (node.child !== null) {\r\n        node.child.return = node;\r\n        node = node.child;\r\n        continue;\r\n      }\r\n      if (node === fiber) {\r\n        return foundHostInstances;\r\n      }\r\n      while (node.sibling === null) {\r\n        if (node.return === null || node.return === fiber) {\r\n          return foundHostInstances;\r\n        }\r\n        node = node.return;\r\n      }\r\n      node.sibling.return = node.return;\r\n      node = node.sibling;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}