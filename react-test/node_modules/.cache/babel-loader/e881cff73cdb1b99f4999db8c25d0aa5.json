{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableCreateEventHandleAPI, enableProfilerTimer, enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableSchedulingProfiler, enableSuspenseCallback, enableScopeAPI, enableStrictEffects, deletedTreeCleanUpLevel, enableSuspenseLayoutEffectSemantics, enableUpdaterTracking, enableCache, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { FunctionComponent, ForwardRef, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, Profiler, SuspenseComponent, DehydratedFragment, IncompleteClassComponent, MemoComponent, SimpleMemoComponent, SuspenseListComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent } from './ReactWorkTags';\nimport { detachDeletedInstance } from './ReactFiberHostConfig';\nimport { NoFlags, ContentReset, Placement, ChildDeletion, Snapshot, Update, Ref, Hydrating, Passive, BeforeMutationMask, MutationMask, LayoutMask, PassiveMask, Visibility } from './ReactFiberFlags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV, getCurrentFiber as getCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.new';\nimport { isCurrentUpdateNested, getCommitTime, recordLayoutEffectDuration, startLayoutEffectTimer, recordPassiveEffectDuration, startPassiveEffectTimer } from './ReactProfilerTimer.new';\nimport { ConcurrentMode, NoMode, ProfileMode } from './ReactTypeOfMode';\nimport { commitUpdateQueue } from './ReactUpdateQueue.new';\nimport { getPublicInstance, supportsMutation, supportsPersistence, supportsHydration, commitMount, commitUpdate, resetTextContent, commitTextUpdate, appendChild, appendChildToContainer, insertBefore, insertInContainerBefore, removeChild, removeChildFromContainer, clearSuspenseBoundary, clearSuspenseBoundaryFromContainer, replaceContainerChildren, createContainerChildSet, hideInstance, hideTextInstance, unhideInstance, unhideTextInstance, commitHydratedContainer, commitHydratedSuspenseInstance, clearContainer, prepareScopeUpdate, prepareForCommit, beforeActiveInstanceBlur } from './ReactFiberHostConfig';\nimport { captureCommitPhaseError, resolveRetryWakeable, markCommitTimeOfFallback, enqueuePendingPassiveProfilerEffect, restorePendingUpdaters, addTransitionStartCallbackToPendingTransition, addTransitionCompleteCallbackToPendingTransition, setIsRunningInsertionEffect } from './ReactFiberWorkLoop.new';\nimport { NoFlags as NoHookEffect, HasEffect as HookHasEffect, Layout as HookLayout, Insertion as HookInsertion, Passive as HookPassive } from './ReactHookEffectTags';\nimport { didWarnAboutReassigningProps } from './ReactFiberBeginWork.new';\nimport { doesFiberContain } from './ReactFiberTreeReflection';\nimport { invokeGuardedCallback, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { isDevToolsPresent, markComponentPassiveEffectMountStarted, markComponentPassiveEffectMountStopped, markComponentPassiveEffectUnmountStarted, markComponentPassiveEffectUnmountStopped, markComponentLayoutEffectMountStarted, markComponentLayoutEffectMountStopped, markComponentLayoutEffectUnmountStarted, markComponentLayoutEffectUnmountStopped, onCommitUnmount } from './ReactFiberDevToolsHook.new';\nimport { releaseCache, retainCache } from './ReactFiberCacheComponent.new';\nimport { clearTransitionsForLanes } from './ReactFiberLane.new';\nlet didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n} // Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\n\n\nlet offscreenSubtreeIsHidden = false;\nlet offscreenSubtreeWasHidden = false;\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nlet nextEffect = null; // Used for Profiling builds to track updaters.\n\nlet inProgressLanes = null;\nlet inProgressRoot = null;\nexport function reportUncaughtErrorInDEV(error) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  if (__DEV__) {\n    invokeGuardedCallback(null, () => {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function (current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n\n  if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n}; // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n  try {\n    commitHookEffectListMount(HookLayout, current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n  try {\n    instance.componentDidMount();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  const ref = current.ref;\n\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      let retVal;\n\n      try {\n        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n\n      if (__DEV__) {\n        if (typeof retVal === 'function') {\n          console.error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n  try {\n    destroy();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nlet focusedInstanceHandle = null;\nlet shouldFireAfterActiveInstanceBlur = false;\nexport function commitBeforeMutationEffects(root, firstChild) {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n\n  const shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n    // Let's skip the whole loop if it's off.\n\n    if (enableCreateEventHandleAPI) {\n      // TODO: Should wrap this in flags check, too, as optimization\n      const deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const deletion = deletions[i];\n          commitBeforeMutationEffectsDeletion(deletion);\n        }\n      }\n    }\n\n    const child = fiber.child;\n\n    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    setCurrentDebugFiberInDEV(fiber);\n\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n\n  if (enableCreateEventHandleAPI) {\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // Check to see if the focused element was inside of a hidden (Suspense) subtree.\n      // TODO: Move this out of the hot path using a dedicated effect tag.\n      if (finishedWork.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, finishedWork) && doesFiberContain(finishedWork, focusedInstanceHandle)) {\n        shouldFireAfterActiveInstanceBlur = true;\n        beforeActiveInstanceBlur(finishedWork);\n      }\n    }\n  }\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentDebugFiberInDEV(finishedWork);\n\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          break;\n        }\n\n      case ClassComponent:\n        {\n          if (current !== null) {\n            const prevProps = current.memoizedProps;\n            const prevState = current.memoizedState;\n            const instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            }\n\n            const snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            if (__DEV__) {\n              const didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                console.error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n              }\n            }\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          if (supportsMutation) {\n            const root = finishedWork.stateNode;\n            clearContainer(root.containerInfo);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        // Nothing to do for these component types\n        break;\n\n      default:\n        {\n          throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n        }\n    }\n\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction commitBeforeMutationEffectsDeletion(deletion) {\n  if (enableCreateEventHandleAPI) {\n    // TODO (effects) It would be nice to avoid calling doesFiberContain()\n    // Maybe we can repurpose one of the subtreeFlags positions for this instead?\n    // Use it to store which part of the tree the focused instance is in?\n    // This assumes we can safely determine that instance during the \"render\" phase.\n    if (doesFiberContain(deletion, focusedInstanceHandle)) {\n      shouldFireAfterActiveInstanceBlur = true;\n      beforeActiveInstanceBlur(deletion);\n    }\n  }\n}\n\nfunction commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n  const updateQueue = finishedWork.updateQueue;\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          if (__DEV__) {\n            if ((flags & HookInsertion) !== NoHookEffect) {\n              setIsRunningInsertionEffect(true);\n            }\n          }\n\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n          if (__DEV__) {\n            if ((flags & HookInsertion) !== NoHookEffect) {\n              setIsRunningInsertionEffect(false);\n            }\n          }\n\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags, finishedWork) {\n  const updateQueue = finishedWork.updateQueue;\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        } // Mount\n\n\n        const create = effect.create;\n\n        if (__DEV__) {\n          if ((flags & HookInsertion) !== NoHookEffect) {\n            setIsRunningInsertionEffect(true);\n          }\n        }\n\n        effect.destroy = create();\n\n        if (__DEV__) {\n          if ((flags & HookInsertion) !== NoHookEffect) {\n            setIsRunningInsertionEffect(false);\n          }\n        }\n\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let hookName;\n\n            if ((effect.tag & HookLayout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & HookInsertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n\n            let addendum;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            console.error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nexport function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler:\n          {\n            const {\n              passiveEffectDuration\n            } = finishedWork.stateNode;\n            const {\n              id,\n              onPostCommit\n            } = finishedWork.memoizedProps; // This value will still reflect the previous commit phase.\n            // It does not get reset until the start of the next commit phase.\n\n            const commitTime = getCommitTime();\n            let phase = finishedWork.alternate === null ? 'mount' : 'update';\n\n            if (enableProfilerNestedUpdatePhase) {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onPostCommit === 'function') {\n              onPostCommit(id, phase, passiveEffectDuration, commitTime);\n            } // Bubble times to the next nearest ancestor Profiler.\n            // After we process that Profiler, we'll bubble further up.\n\n\n            let parentFiber = finishedWork.return;\n\n            outer: while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  const root = parentFiber.stateNode;\n                  root.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n\n                case Profiler:\n                  const parentStateNode = parentFiber.stateNode;\n                  parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n              }\n\n              parentFiber = parentFiber.return;\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          if (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n              try {\n                startLayoutEffectTimer();\n                commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n              } finally {\n                recordLayoutEffectDuration(finishedWork);\n              }\n            } else {\n              commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n            }\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = finishedWork.stateNode;\n\n          if (finishedWork.flags & Update) {\n            if (!offscreenSubtreeWasHidden) {\n              if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                if (__DEV__) {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      console.error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      console.error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidMount();\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidMount();\n                }\n              } else {\n                const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                const prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n\n                if (__DEV__) {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      console.error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      console.error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                }\n              }\n            }\n          } // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n\n\n          const updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            } // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n\n            commitUpdateQueue(finishedWork, updateQueue, instance);\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n          const updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            let instance = null;\n\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostComponent:\n                  instance = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n\n                case ClassComponent:\n                  instance = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n\n            commitUpdateQueue(finishedWork, updateQueue, instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          const instance = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n\n          if (current === null && finishedWork.flags & Update) {\n            const type = finishedWork.type;\n            const props = finishedWork.memoizedProps;\n            commitMount(instance, type, props, finishedWork);\n          }\n\n          break;\n        }\n\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          break;\n        }\n\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          break;\n        }\n\n      case Profiler:\n        {\n          if (enableProfilerTimer) {\n            const {\n              onCommit,\n              onRender\n            } = finishedWork.memoizedProps;\n            const {\n              effectDuration\n            } = finishedWork.stateNode;\n            const commitTime = getCommitTime();\n            let phase = current === null ? 'mount' : 'update';\n\n            if (enableProfilerNestedUpdatePhase) {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onRender === 'function') {\n              onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n            }\n\n            if (enableProfilerCommitHooks) {\n              if (typeof onCommit === 'function') {\n                onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n              } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n              // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n              // because the effect is also where times bubble to parent Profilers.\n\n\n              enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n              // Do not reset these values until the next render so DevTools has a chance to read them first.\n\n              let parentFiber = finishedWork.return;\n\n              outer: while (parentFiber !== null) {\n                switch (parentFiber.tag) {\n                  case HostRoot:\n                    const root = parentFiber.stateNode;\n                    root.effectDuration += effectDuration;\n                    break outer;\n\n                  case Profiler:\n                    const parentStateNode = parentFiber.stateNode;\n                    parentStateNode.effectDuration += effectDuration;\n                    break outer;\n                }\n\n                parentFiber = parentFiber.return;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n          break;\n        }\n\n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        {\n          break;\n        }\n\n      default:\n        throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  if (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) {\n    if (enableScopeAPI) {\n      // TODO: This is a temporary solution that allowed us to transition away\n      // from React Flare on www.\n      if (finishedWork.flags & Ref && finishedWork.tag !== ScopeComponent) {\n        commitAttachRef(finishedWork);\n      }\n    } else {\n      if (finishedWork.flags & Ref) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n}\n\nfunction reappearLayoutEffectsOnFiber(node) {\n  // Turn on layout effects in a tree that previously disappeared.\n  // TODO (Offscreen) Check: flags & LayoutStatic\n  switch (node.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && node.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n          } finally {\n            recordLayoutEffectDuration(node);\n          }\n        } else {\n          safelyCallCommitHookLayoutEffectListMount(node, node.return);\n        }\n\n        break;\n      }\n\n    case ClassComponent:\n      {\n        const instance = node.stateNode;\n\n        if (typeof instance.componentDidMount === 'function') {\n          safelyCallComponentDidMount(node, node.return, instance);\n        }\n\n        safelyAttachRef(node, node.return);\n        break;\n      }\n\n    case HostComponent:\n      {\n        safelyAttachRef(node, node.return);\n        break;\n      }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  let hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n\n          try {\n            const instance = node.stateNode;\n\n            if (isHidden) {\n              hideInstance(instance);\n            } else {\n              unhideInstance(node.stateNode, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          try {\n            const instance = node.stateNode;\n\n            if (isHidden) {\n              hideTextInstance(instance);\n            } else {\n              unhideTextInstance(instance, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) {// Found a nested Offscreen component that is hidden.\n        // Don't search any deeper. This tree should remain hidden.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  const ref = finishedWork.ref;\n\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance;\n    }\n\n    if (typeof ref === 'function') {\n      let retVal;\n\n      if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          retVal = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        retVal = ref(instanceToUse);\n      }\n\n      if (__DEV__) {\n        if (typeof retVal === 'function') {\n          console.error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));\n        }\n      }\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          console.error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current) {\n  const currentRef = current.ref;\n\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          currentRef(null);\n        } finally {\n          recordLayoutEffectDuration(current);\n        }\n      } else {\n        currentRef(null);\n      }\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\nfunction detachFiberMutation(fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber) {\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  } // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n\n\n  if (!(deletedTreeCleanUpLevel >= 2)) {\n    // This is the default branch (level 0).\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.dependencies = null;\n    fiber.memoizedProps = null;\n    fiber.memoizedState = null;\n    fiber.pendingProps = null;\n    fiber.sibling = null;\n    fiber.stateNode = null;\n    fiber.updateQueue = null;\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n  } else {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n\n    if (fiber.tag === HostComponent) {\n      const hostInstance = fiber.stateNode;\n\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n\n    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n\n    if (deletedTreeCleanUpLevel >= 3) {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal = current.stateNode;\n  const {\n    containerInfo\n  } = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction getHostParentFiber(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n\n    parent = parent.return;\n  }\n\n  throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  } // Recursively insert all host nodes into the parent.\n\n\n  const parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      {\n        const parent = parentFiber.stateNode;\n\n        if (parentFiber.flags & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.flags &= ~ContentReset;\n        }\n\n        const before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n        // children to find all the terminal nodes.\n\n        insertOrAppendPlacementNode(finishedWork, before, parent);\n        break;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        const parent = parentFiber.stateNode.containerInfo;\n        const before = getHostSibling(finishedWork);\n        insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n        break;\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  const {\n    tag\n  } = node;\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    const stateNode = node.stateNode;\n\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      let sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  const {\n    tag\n  } = node;\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    const stateNode = node.stateNode;\n\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n} // These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\n\n\nlet hostParent = null;\nlet hostParentIsContainer = false;\n\nfunction commitDeletionEffects(root, returnFiber, deletedFiber) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was deleted but we need to recurse down its\n    // children to find all the terminal nodes.\n    // Recursively delete all host nodes from the parent, detach refs, clean\n    // up mounted layout effects, and call componentWillUnmount.\n    // We only need to remove the topmost host child in each branch. But then we\n    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n    // could split this into two separate traversals functions, where the second\n    // one doesn't include any removeChild logic. This is maybe the same\n    // function as \"disappearLayoutEffects\" (or whatever that turns into after\n    // the layout phase is refactored to use recursion).\n    // Before starting, find the nearest host parent on the stack so we know\n    // which instance/container to remove the children from.\n    // TODO: Instead of searching up the fiber return path on every deletion, we\n    // can track the nearest host component on the JS stack as we traverse the\n    // tree during the commit phase. This would make insertions faster, too.\n    let parent = returnFiber;\n\n    findParent: while (parent !== null) {\n      switch (parent.tag) {\n        case HostComponent:\n          {\n            hostParent = parent.stateNode;\n            hostParentIsContainer = false;\n            break findParent;\n          }\n\n        case HostRoot:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n\n        case HostPortal:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n      }\n\n      parent = parent.return;\n    }\n\n    if (hostParent === null) {\n      throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n    }\n\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n    hostParent = null;\n    hostParentIsContainer = false;\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n  }\n\n  detachFiberMutation(deletedFiber);\n}\n\nfunction recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n  // TODO: Use a static flag to skip trees that don't have unmount effects\n  let child = parent.child;\n\n  while (child !== null) {\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n    child = child.sibling;\n  }\n}\n\nfunction commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n  onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n  // into their subtree. There are simpler cases in the inner switch\n  // that don't modify the stack.\n\n  switch (deletedFiber.tag) {\n    case HostComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        } // Intentional fallthrough to next branch\n\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostText:\n      {\n        // We only need to remove the nearest host child. Set the host parent\n        // to `null` on the stack to indicate that nested children don't\n        // need to be removed.\n        if (supportsMutation) {\n          const prevHostParent = hostParent;\n          const prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = prevHostParent;\n          hostParentIsContainer = prevHostParentIsContainer;\n\n          if (hostParent !== null) {\n            // Now that all the child effects have unmounted, we can remove the\n            // node from the tree.\n            if (hostParentIsContainer) {\n              removeChildFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              removeChild(hostParent, deletedFiber.stateNode);\n            }\n          }\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n        if (enableSuspenseCallback) {\n          const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n          if (hydrationCallbacks !== null) {\n            const onDeleted = hydrationCallbacks.onDeleted;\n\n            if (onDeleted) {\n              onDeleted(deletedFiber.stateNode);\n            }\n          }\n        } // Dehydrated fragments don't have any children\n        // Delete the dehydrated suspense boundary and all of its content.\n\n\n        if (supportsMutation) {\n          if (hostParent !== null) {\n            if (hostParentIsContainer) {\n              clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        if (supportsMutation) {\n          // When we go into a portal, it becomes the parent to remove from.\n          const prevHostParent = hostParent;\n          const prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = deletedFiber.stateNode.containerInfo;\n          hostParentIsContainer = true;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = prevHostParent;\n          hostParentIsContainer = prevHostParentIsContainer;\n        } else {\n          emptyPortalContainer(deletedFiber);\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          const updateQueue = deletedFiber.updateQueue;\n\n          if (updateQueue !== null) {\n            const lastEffect = updateQueue.lastEffect;\n\n            if (lastEffect !== null) {\n              const firstEffect = lastEffect.next;\n              let effect = firstEffect;\n\n              do {\n                const {\n                  destroy,\n                  tag\n                } = effect;\n\n                if (destroy !== undefined) {\n                  if ((tag & HookInsertion) !== NoHookEffect) {\n                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                  } else if ((tag & HookLayout) !== NoHookEffect) {\n                    if (enableSchedulingProfiler) {\n                      markComponentLayoutEffectUnmountStarted(deletedFiber);\n                    }\n\n                    if (enableProfilerTimer && enableProfilerCommitHooks && deletedFiber.mode & ProfileMode) {\n                      startLayoutEffectTimer();\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                      recordLayoutEffectDuration(deletedFiber);\n                    } else {\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                    }\n\n                    if (enableSchedulingProfiler) {\n                      markComponentLayoutEffectUnmountStopped();\n                    }\n                  }\n                }\n\n                effect = effect.next;\n              } while (effect !== firstEffect);\n            }\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ClassComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n          const instance = deletedFiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        if ( // TODO: Remove this dead flag\n        enableSuspenseLayoutEffectSemantics && deletedFiber.mode & ConcurrentMode) {\n          // If this offscreen component is hidden, we already unmounted it. Before\n          // deleting the children, track that it's already unmounted so that we\n          // don't attempt to unmount the effects again.\n          // TODO: If the tree is hidden, in most cases we should be able to skip\n          // over the nested children entirely. An exception is we haven't yet found\n          // the topmost host node to delete, which we already track on the stack.\n          // But the other case is portals, which need to be detached no matter how\n          // deeply they are nested. We should use a subtree flag to track whether a\n          // subtree includes a nested portal.\n          const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n  }\n}\n\nfunction commitSuspenseCallback(finishedWork) {\n  // TODO: Move this to passive phase\n  const newState = finishedWork.memoizedState;\n\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n\n    if (typeof suspenseCallback === 'function') {\n      const wakeables = finishedWork.updateQueue;\n\n      if (wakeables !== null) {\n        suspenseCallback(new Set(wakeables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        console.error('Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (!supportsHydration) {\n    return;\n  }\n\n  const newState = finishedWork.memoizedState;\n\n  if (newState === null) {\n    const current = finishedWork.alternate;\n\n    if (current !== null) {\n      const prevState = current.memoizedState;\n\n      if (prevState !== null) {\n        const suspenseInstance = prevState.dehydrated;\n\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n\n          if (enableSuspenseCallback) {\n            const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n            if (hydrationCallbacks !== null) {\n              const onHydrated = hydrationCallbacks.onHydrated;\n\n              if (onHydrated) {\n                onHydrated(suspenseInstance);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const wakeables = finishedWork.updateQueue;\n\n  if (wakeables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n\n    wakeables.forEach(wakeable => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n\n      if (!retryCache.has(wakeable)) {\n        retryCache.add(wakeable);\n\n        if (enableUpdaterTracking) {\n          if (isDevToolsPresent) {\n            if (inProgressLanes !== null && inProgressRoot !== null) {\n              // If we have pending work still, associate the original updaters with it.\n              restorePendingUpdaters(inProgressRoot, inProgressLanes);\n            } else {\n              throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n            }\n          }\n        }\n\n        wakeable.then(retry, retry);\n      }\n    });\n  }\n} // This function detects when a Suspense boundary goes from visible to hidden.\n// It returns false if the boundary is already hidden.\n// TODO: Use an effect tag.\n\n\nexport function isSuspenseBoundaryBeingHidden(current, finishedWork) {\n  if (current !== null) {\n    const oldState = current.memoizedState;\n\n    if (oldState === null || oldState.dehydrated !== null) {\n      const newState = finishedWork.memoizedState;\n      return newState !== null && newState.dehydrated === null;\n    }\n  }\n\n  return false;\n}\nexport function commitMutationEffects(root, finishedWork, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  setCurrentDebugFiberInDEV(finishedWork);\n  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);\n  setCurrentDebugFiberInDEV(finishedWork);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects hae fired.\n  const deletions = parentFiber.deletions;\n\n  if (deletions !== null) {\n    for (let i = 0; i < deletions.length; i++) {\n      const childToDelete = deletions[i];\n\n      try {\n        commitDeletionEffects(root, parentFiber, childToDelete);\n      } catch (error) {\n        captureCommitPhaseError(childToDelete, parentFiber, error);\n      }\n    }\n  }\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n\n  if (parentFiber.subtreeFlags & MutationMask) {\n    let child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitMutationEffectsOnFiber(child, root, lanes);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n  // because the fiber tag is more specific. An exception is any flag related\n  // to reconcilation, because those can be set on all fiber types.\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          try {\n            commitHookEffectListUnmount(HookInsertion | HookHasEffect, finishedWork, finishedWork.return);\n            commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          } // Layout effects are destroyed during the mutation phase so that all\n          // destroy functions for all fibers are called before any create functions.\n          // This prevents sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n\n\n          if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n\n            recordLayoutEffectDuration(finishedWork);\n          } else {\n            try {\n              commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        if (supportsMutation) {\n          // TODO: ContentReset gets cleared by the children during the commit\n          // phase. This is a refactor hazard because it means we must read\n          // flags the flags after `commitReconciliationEffects` has already run;\n          // the order matters. We should refactor so that ContentReset does not\n          // rely on mutating the flag during commit. Like by setting a flag\n          // during the render phase instead.\n          if (finishedWork.flags & ContentReset) {\n            const instance = finishedWork.stateNode;\n\n            try {\n              resetTextContent(instance);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n\n          if (flags & Update) {\n            const instance = finishedWork.stateNode;\n\n            if (instance != null) {\n              // Commit the work prepared earlier.\n              const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              const oldProps = current !== null ? current.memoizedProps : newProps;\n              const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n              const updatePayload = finishedWork.updateQueue;\n              finishedWork.updateQueue = null;\n\n              if (updatePayload !== null) {\n                try {\n                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation) {\n            if (finishedWork.stateNode === null) {\n              throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            }\n\n            const textInstance = finishedWork.stateNode;\n            const newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n\n            const oldText = current !== null ? current.memoizedProps : newText;\n\n            try {\n              commitTextUpdate(textInstance, oldText, newText);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostRoot:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation && supportsHydration) {\n            if (current !== null) {\n              const prevRootState = current.memoizedState;\n\n              if (prevRootState.isDehydrated) {\n                try {\n                  commitHydratedContainer(root.containerInfo);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n\n          if (supportsPersistence) {\n            const containerInfo = root.containerInfo;\n            const pendingChildren = root.pendingChildren;\n\n            try {\n              replaceContainerChildren(containerInfo, pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsPersistence) {\n            const portal = finishedWork.stateNode;\n            const containerInfo = portal.containerInfo;\n            const pendingChildren = portal.pendingChildren;\n\n            try {\n              replaceContainerChildren(containerInfo, pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n        const offscreenFiber = finishedWork.child;\n\n        if (offscreenFiber.flags & Visibility) {\n          const newState = offscreenFiber.memoizedState;\n          const isHidden = newState !== null;\n\n          if (isHidden) {\n            const wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n\n            if (!wasHidden) {\n              // TODO: Move to passive phase\n              markCommitTimeOfFallback();\n            }\n          }\n        }\n\n        if (flags & Update) {\n          try {\n            commitSuspenseCallback(finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n\n          attachSuspenseRetryListeners(finishedWork);\n        }\n\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        const wasHidden = current !== null && current.memoizedState !== null;\n\n        if ( // TODO: Remove this dead flag\n        enableSuspenseLayoutEffectSemantics && finishedWork.mode & ConcurrentMode) {\n          // Before committing the children, track on the stack whether this\n          // offscreen subtree was already hidden, so that we don't unmount the\n          // effects again.\n          const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n          recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        } else {\n          recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        }\n\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Visibility) {\n          const newState = finishedWork.memoizedState;\n          const isHidden = newState !== null;\n          const offscreenBoundary = finishedWork;\n\n          if (supportsMutation) {\n            // TODO: This needs to run whenever there's an insertion or update\n            // inside a hidden Offscreen tree.\n            hideOrUnhideAllChildren(offscreenBoundary, isHidden);\n          }\n\n          if (enableSuspenseLayoutEffectSemantics) {\n            if (isHidden) {\n              if (!wasHidden) {\n                if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                  nextEffect = offscreenBoundary;\n                  let offscreenChild = offscreenBoundary.child;\n\n                  while (offscreenChild !== null) {\n                    nextEffect = offscreenChild;\n                    disappearLayoutEffects_begin(offscreenChild);\n                    offscreenChild = offscreenChild.sibling;\n                  }\n                }\n              }\n            } else {\n              if (wasHidden) {// TODO: Move re-appear call here for symmetry?\n              }\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          attachSuspenseRetryListeners(finishedWork);\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n          commitReconciliationEffects(finishedWork); // TODO: This is a temporary solution that allowed us to transition away\n          // from React Flare on www.\n\n          if (flags & Ref) {\n            if (current !== null) {\n              safelyDetachRef(finishedWork, finishedWork.return);\n            }\n\n            safelyAttachRef(finishedWork, finishedWork.return);\n          }\n\n          if (flags & Update) {\n            const scopeInstance = finishedWork.stateNode;\n            prepareScopeUpdate(scopeInstance, finishedWork);\n          }\n        }\n\n        return;\n      }\n\n    default:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n        return;\n      }\n  }\n}\n\nfunction commitReconciliationEffects(finishedWork) {\n  // Placement effects (insertions, reorders) can be scheduled on any fiber\n  // type. They needs to happen after the children effects have fired, but\n  // before the effects on this fiber have fired.\n  const flags = finishedWork.flags;\n\n  if (flags & Placement) {\n    try {\n      commitPlacement(finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    } // Clear the \"placement\" from effect tag so that we know that this is\n    // inserted, before any life-cycles like componentDidMount gets called.\n    // TODO: findDOMNode doesn't rely on this any more but isMounted does\n    // and isMounted is deprecated anyway so we should be able to kill this.\n\n\n    finishedWork.flags &= ~Placement;\n  }\n\n  if (flags & Hydrating) {\n    finishedWork.flags &= ~Hydrating;\n  }\n}\n\nexport function commitLayoutEffects(finishedWork, root, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = finishedWork;\n  commitLayoutEffects_begin(finishedWork, root, committedLanes);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n  // Suspense layout effects semantics don't change for legacy roots.\n  const isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if (enableSuspenseLayoutEffectSemantics && fiber.tag === OffscreenComponent && isModernRoot) {\n      // Keep track of the current Offscreen stack's state.\n      const isHidden = fiber.memoizedState !== null;\n      const newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n\n      if (newOffscreenSubtreeIsHidden) {\n        // The Offscreen tree is hidden. Skip over its layout effects.\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      } else {\n        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n        const current = fiber.alternate;\n        const wasHidden = current !== null && current.memoizedState !== null;\n        const newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n        const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n\n        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n          // This is the root of a reappearing boundary. Turn its layout effects\n          // back on.\n          nextEffect = fiber;\n          reappearLayoutEffects_begin(fiber);\n        }\n\n        let child = firstChild;\n\n        while (child !== null) {\n          nextEffect = child;\n          commitLayoutEffects_begin(child, // New root; bubble back up to here and stop.\n          root, committedLanes);\n          child = child.sibling;\n        } // Restore Offscreen state and resume in our-progress traversal.\n\n\n        nextEffect = fiber;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      }\n    }\n\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n    }\n  }\n}\n\nfunction commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if ((fiber.flags & LayoutMask) !== NoFlags) {\n      const current = fiber.alternate;\n      setCurrentDebugFiberInDEV(fiber);\n\n      try {\n        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n      } catch (error) {\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction disappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if (enableProfilerTimer && enableProfilerCommitHooks && fiber.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\n            } finally {\n              recordLayoutEffectDuration(fiber);\n            }\n          } else {\n            commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          // TODO (Offscreen) Check: flags & RefStatic\n          safelyDetachRef(fiber, fiber.return);\n          const instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          safelyDetachRef(fiber, fiber.return);\n          break;\n        }\n\n      case OffscreenComponent:\n        {\n          // Check if this is a\n          const isHidden = fiber.memoizedState !== null;\n\n          if (isHidden) {\n            // Nested Offscreen tree is already hidden. Don't disappear\n            // its effects.\n            disappearLayoutEffects_complete(subtreeRoot);\n            continue;\n          }\n\n          break;\n        }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      disappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction disappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction reappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if (fiber.tag === OffscreenComponent) {\n      const isHidden = fiber.memoizedState !== null;\n\n      if (isHidden) {\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n        reappearLayoutEffects_complete(subtreeRoot);\n        continue;\n      }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      reappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction reappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n\n    setCurrentDebugFiberInDEV(fiber);\n\n    try {\n      reappearLayoutEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentDebugFiberInDEV();\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nexport function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n  nextEffect = finishedWork;\n  commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);\n}\n\nfunction commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);\n    }\n  }\n}\n\nfunction commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentDebugFiberInDEV(fiber);\n\n      try {\n        commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);\n      } catch (error) {\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n\n          try {\n            commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n          } finally {\n            recordPassiveEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (finishedWork.alternate !== null) {\n            previousCache = finishedWork.alternate.memoizedState.cache;\n          }\n\n          const nextCache = finishedWork.memoizedState.cache; // Retain/release the root cache.\n          // Note that on initial mount, previousCache and nextCache will be the same\n          // and this retain won't occur. To counter this, we instead retain the HostRoot's\n          // initial cache when creating the root itself (see createFiberRoot() in\n          // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n          // here, such that previous/next caches are retained correctly.\n\n          if (nextCache !== previousCache) {\n            retainCache(nextCache);\n\n            if (previousCache != null) {\n              releaseCache(previousCache);\n            }\n          }\n        }\n\n        if (enableTransitionTracing) {\n          if (committedTransitions !== null) {\n            committedTransitions.forEach(transition => {\n              // TODO(luna) Do we want to log TransitionStart in the startTransition callback instead?\n              addTransitionStartCallbackToPendingTransition({\n                transitionName: transition.name,\n                startTime: transition.startTime\n              });\n              addTransitionCompleteCallbackToPendingTransition({\n                transitionName: transition.name,\n                startTime: transition.startTime\n              });\n            });\n            clearTransitionsForLanes(finishedRoot, committedLanes);\n            finishedWork.memoizedState.transitions = null;\n          }\n        }\n\n        break;\n      }\n\n    case LegacyHiddenComponent:\n    case OffscreenComponent:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (finishedWork.alternate !== null && finishedWork.alternate.memoizedState !== null && finishedWork.alternate.memoizedState.cachePool !== null) {\n            previousCache = finishedWork.alternate.memoizedState.cachePool.pool;\n          }\n\n          let nextCache = null;\n\n          if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {\n            nextCache = finishedWork.memoizedState.cachePool.pool;\n          } // Retain/release the cache used for pending (suspended) nodes.\n          // Note that this is only reached in the non-suspended/visible case:\n          // when the content is suspended/hidden, the retain/release occurs\n          // via the parent Suspense component (see case above).\n\n\n          if (nextCache !== previousCache) {\n            if (nextCache != null) {\n              retainCache(nextCache);\n            }\n\n            if (previousCache != null) {\n              releaseCache(previousCache);\n            }\n          }\n        }\n\n        if (enableTransitionTracing) {\n          // TODO: Add code to actually process the update queue\n          finishedWork.updateQueue = null;\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (finishedWork.alternate !== null) {\n            previousCache = finishedWork.alternate.memoizedState.cache;\n          }\n\n          const nextCache = finishedWork.memoizedState.cache; // Retain/release the cache. In theory the cache component\n          // could be \"borrowing\" a cache instance owned by some parent,\n          // in which case we could avoid retaining/releasing. But it\n          // is non-trivial to determine when that is the case, so we\n          // always retain/release.\n\n          if (nextCache !== previousCache) {\n            retainCache(nextCache);\n\n            if (previousCache != null) {\n              releaseCache(previousCache);\n            }\n          }\n        }\n\n        break;\n      }\n  }\n}\n\nexport function commitPassiveUnmountEffects(firstChild) {\n  nextEffect = firstChild;\n  commitPassiveUnmountEffects_begin();\n}\n\nfunction commitPassiveUnmountEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const child = fiber.child;\n\n    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n      const deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const fiberToDelete = deletions[i];\n          nextEffect = fiberToDelete;\n          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n        }\n\n        if (deletedTreeCleanUpLevel >= 1) {\n          // A fiber was deleted from this parent fiber, but it's still part of\n          // the previous (alternate) parent fiber's list of children. Because\n          // children are a linked list, an earlier sibling that's still alive\n          // will be connected to the deleted fiber via its `alternate`:\n          //\n          //   live fiber\n          //   --alternate--> previous live fiber\n          //   --sibling--> deleted fiber\n          //\n          // We can't disconnect `alternate` on nodes that haven't been deleted\n          // yet, but we can disconnect the `sibling` and `child` pointers.\n          const previousFiber = fiber.alternate;\n\n          if (previousFiber !== null) {\n            let detachedChild = previousFiber.child;\n\n            if (detachedChild !== null) {\n              previousFiber.child = null;\n\n              do {\n                const detachedSibling = detachedChild.sibling;\n                detachedChild.sibling = null;\n                detachedChild = detachedSibling;\n              } while (detachedChild !== null);\n            }\n          }\n        }\n\n        nextEffect = fiber;\n      }\n    }\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffects_complete();\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentDebugFiberInDEV(fiber);\n      commitPassiveUnmountOnFiber(fiber);\n      resetCurrentDebugFiberInDEV();\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(HookPassive | HookHasEffect, finishedWork, finishedWork.return);\n          recordPassiveEffectDuration(finishedWork);\n        } else {\n          commitHookEffectListUnmount(HookPassive | HookHasEffect, finishedWork, finishedWork.return);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n\n    setCurrentDebugFiberInDEV(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentDebugFiberInDEV();\n    const child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\n    if (child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const sibling = fiber.sibling;\n    const returnFiber = fiber.return;\n\n    if (deletedTreeCleanUpLevel >= 2) {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    } else {\n      // This is the default branch (level 0). We do not recursively clear all\n      // the fiber fields. Only the root of the deleted subtree.\n      if (fiber === deletedSubtreeRoot) {\n        detachFiberAfterEffects(fiber);\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      sibling.return = returnFiber;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor);\n          recordPassiveEffectDuration(current);\n        } else {\n          commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor);\n        }\n\n        break;\n      }\n    // TODO: run passive unmount effects when unmounting a root.\n    // Because passive unmount effects are not currently run,\n    // the cache instance owned by the root will never be freed.\n    // When effects are run, the cache should be freed here:\n    // case HostRoot: {\n    //   if (enableCache) {\n    //     const cache = current.memoizedState.cache;\n    //     releaseCache(cache);\n    //   }\n    //   break;\n    // }\n\n    case LegacyHiddenComponent:\n    case OffscreenComponent:\n      {\n        if (enableCache) {\n          if (current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n            const cache = current.memoizedState.cachePool.pool; // Retain/release the cache used for pending (suspended) nodes.\n            // Note that this is only reached in the non-suspended/visible case:\n            // when the content is suspended/hidden, the retain/release occurs\n            // via the parent Suspense component (see case above).\n\n            if (cache != null) {\n              retainCache(cache);\n            }\n          }\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          const cache = current.memoizedState.cache;\n          releaseCache(cache);\n        }\n\n        break;\n      }\n  }\n} // TODO: Reuse reappearLayoutEffects traversal here?\n\n\nfunction invokeLayoutEffectMountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(HookLayout | HookHasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = fiber.stateNode;\n\n          try {\n            instance.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(HookPassive | HookHasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(HookLayout | HookHasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(HookPassive | HookHasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n        }\n    }\n  }\n}\n\nexport { commitPlacement, commitAttachRef, commitDetachRef, invokeLayoutEffectMountInDEV, invokeLayoutEffectUnmountInDEV, invokePassiveEffectMountInDEV, invokePassiveEffectUnmountInDEV };","map":{"version":3,"names":["enableCreateEventHandleAPI","enableProfilerTimer","enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableSchedulingProfiler","enableSuspenseCallback","enableScopeAPI","enableStrictEffects","deletedTreeCleanUpLevel","enableSuspenseLayoutEffectSemantics","enableUpdaterTracking","enableCache","enableTransitionTracing","FunctionComponent","ForwardRef","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","Profiler","SuspenseComponent","DehydratedFragment","IncompleteClassComponent","MemoComponent","SimpleMemoComponent","SuspenseListComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","detachDeletedInstance","NoFlags","ContentReset","Placement","ChildDeletion","Snapshot","Update","Ref","Hydrating","Passive","BeforeMutationMask","MutationMask","LayoutMask","PassiveMask","Visibility","getComponentNameFromFiber","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","getCurrentFiber","getCurrentDebugFiberInDEV","resolveDefaultProps","isCurrentUpdateNested","getCommitTime","recordLayoutEffectDuration","startLayoutEffectTimer","recordPassiveEffectDuration","startPassiveEffectTimer","ConcurrentMode","NoMode","ProfileMode","commitUpdateQueue","getPublicInstance","supportsMutation","supportsPersistence","supportsHydration","commitMount","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","clearSuspenseBoundary","clearSuspenseBoundaryFromContainer","replaceContainerChildren","createContainerChildSet","hideInstance","hideTextInstance","unhideInstance","unhideTextInstance","commitHydratedContainer","commitHydratedSuspenseInstance","clearContainer","prepareScopeUpdate","prepareForCommit","beforeActiveInstanceBlur","captureCommitPhaseError","resolveRetryWakeable","markCommitTimeOfFallback","enqueuePendingPassiveProfilerEffect","restorePendingUpdaters","addTransitionStartCallbackToPendingTransition","addTransitionCompleteCallbackToPendingTransition","setIsRunningInsertionEffect","NoHookEffect","HasEffect","HookHasEffect","Layout","HookLayout","Insertion","HookInsertion","HookPassive","didWarnAboutReassigningProps","doesFiberContain","invokeGuardedCallback","clearCaughtError","isDevToolsPresent","markComponentPassiveEffectMountStarted","markComponentPassiveEffectMountStopped","markComponentPassiveEffectUnmountStarted","markComponentPassiveEffectUnmountStopped","markComponentLayoutEffectMountStarted","markComponentLayoutEffectMountStopped","markComponentLayoutEffectUnmountStarted","markComponentLayoutEffectUnmountStopped","onCommitUnmount","releaseCache","retainCache","clearTransitionsForLanes","didWarnAboutUndefinedSnapshotBeforeUpdate","__DEV__","Set","offscreenSubtreeIsHidden","offscreenSubtreeWasHidden","PossiblyWeakSet","WeakSet","nextEffect","inProgressLanes","inProgressRoot","reportUncaughtErrorInDEV","error","callComponentWillUnmountWithTimer","current","instance","props","memoizedProps","state","memoizedState","mode","componentWillUnmount","safelyCallCommitHookLayoutEffectListMount","nearestMountedAncestor","commitHookEffectListMount","safelyCallComponentWillUnmount","safelyCallComponentDidMount","componentDidMount","safelyAttachRef","commitAttachRef","safelyDetachRef","ref","retVal","console","safelyCallDestroy","destroy","focusedInstanceHandle","shouldFireAfterActiveInstanceBlur","commitBeforeMutationEffects","root","firstChild","containerInfo","commitBeforeMutationEffects_begin","shouldFire","fiber","deletions","i","length","deletion","commitBeforeMutationEffectsDeletion","child","subtreeFlags","return","commitBeforeMutationEffects_complete","commitBeforeMutationEffectsOnFiber","sibling","finishedWork","alternate","flags","tag","isSuspenseBoundaryBeingHidden","prevProps","prevState","stateNode","type","elementType","snapshot","getSnapshotBeforeUpdate","didWarnSet","undefined","has","add","__reactInternalSnapshotBeforeUpdate","Error","commitHookEffectListUnmount","updateQueue","lastEffect","firstEffect","next","effect","create","hookName","addendum","then","commitPassiveEffectDurations","finishedRoot","passiveEffectDuration","id","onPostCommit","commitTime","phase","parentFiber","outer","parentStateNode","commitLayoutEffectOnFiber","committedLanes","componentDidUpdate","onCommit","onRender","effectDuration","actualDuration","treeBaseDuration","actualStartTime","commitSuspenseHydrationCallbacks","reappearLayoutEffectsOnFiber","node","hideOrUnhideAllChildren","isHidden","hostSubtreeRoot","instanceToUse","hasOwnProperty","commitDetachRef","currentRef","detachFiberMutation","detachFiberAfterEffects","dependencies","pendingProps","_debugOwner","hostInstance","emptyPortalContainer","portal","emptyChildSet","getHostParentFiber","parent","isHostParent","getHostSibling","siblings","commitPlacement","before","insertOrAppendPlacementNode","insertOrAppendPlacementNodeIntoContainer","isHost","hostParent","hostParentIsContainer","commitDeletionEffects","returnFiber","deletedFiber","findParent","commitDeletionEffectsOnFiber","recursivelyTraverseDeletionEffects","prevHostParent","prevHostParentIsContainer","hydrationCallbacks","onDeleted","prevOffscreenSubtreeWasHidden","commitSuspenseCallback","newState","suspenseCallback","wakeables","suspenseInstance","dehydrated","onHydrated","attachSuspenseRetryListeners","retryCache","forEach","wakeable","retry","bind","oldState","commitMutationEffects","commitMutationEffectsOnFiber","recursivelyTraverseMutationEffects","lanes","childToDelete","prevDebugFiber","commitReconciliationEffects","newProps","oldProps","updatePayload","textInstance","newText","oldText","prevRootState","isDehydrated","pendingChildren","offscreenFiber","wasHidden","offscreenBoundary","offscreenChild","disappearLayoutEffects_begin","scopeInstance","commitLayoutEffects","commitLayoutEffects_begin","subtreeRoot","isModernRoot","newOffscreenSubtreeIsHidden","commitLayoutMountEffects_complete","newOffscreenSubtreeWasHidden","prevOffscreenSubtreeIsHidden","reappearLayoutEffects_begin","disappearLayoutEffects_complete","reappearLayoutEffects_complete","commitPassiveMountEffects","committedTransitions","commitPassiveMountEffects_begin","commitPassiveMountEffects_complete","commitPassiveMountOnFiber","previousCache","cache","nextCache","transition","transitionName","name","startTime","transitions","cachePool","pool","commitPassiveUnmountEffects","commitPassiveUnmountEffects_begin","fiberToDelete","commitPassiveUnmountEffectsInsideOfDeletedTree_begin","previousFiber","detachedChild","detachedSibling","commitPassiveUnmountEffects_complete","commitPassiveUnmountOnFiber","deletedSubtreeRoot","commitPassiveUnmountInsideDeletedTreeOnFiber","commitPassiveUnmountEffectsInsideOfDeletedTree_complete","invokeLayoutEffectMountInDEV","invokePassiveEffectMountInDEV","invokeLayoutEffectUnmountInDEV","invokePassiveEffectUnmountInDEV"],"sources":["E:/react-test/src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {\r\n  Instance,\r\n  TextInstance,\r\n  SuspenseInstance,\r\n  Container,\r\n  ChildSet,\r\n  UpdatePayload,\r\n} from './ReactFiberHostConfig';\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes} from './ReactFiberLane.new';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.new';\r\nimport type {UpdateQueue} from './ReactUpdateQueue.new';\r\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks.new';\r\nimport type {Wakeable} from 'shared/ReactTypes';\r\nimport type {OffscreenState} from './ReactFiberOffscreenComponent';\r\nimport type {HookFlags} from './ReactHookEffectTags';\r\nimport type {Cache} from './ReactFiberCacheComponent.new';\r\nimport type {RootState} from './ReactFiberRoot.new';\r\nimport type {Transition} from './ReactFiberTracingMarkerComponent.new';\r\n\r\nimport {\r\n  enableCreateEventHandleAPI,\r\n  enableProfilerTimer,\r\n  enableProfilerCommitHooks,\r\n  enableProfilerNestedUpdatePhase,\r\n  enableSchedulingProfiler,\r\n  enableSuspenseCallback,\r\n  enableScopeAPI,\r\n  enableStrictEffects,\r\n  deletedTreeCleanUpLevel,\r\n  enableSuspenseLayoutEffectSemantics,\r\n  enableUpdaterTracking,\r\n  enableCache,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  ClassComponent,\r\n  HostRoot,\r\n  HostComponent,\r\n  HostText,\r\n  HostPortal,\r\n  Profiler,\r\n  SuspenseComponent,\r\n  DehydratedFragment,\r\n  IncompleteClassComponent,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  SuspenseListComponent,\r\n  ScopeComponent,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  CacheComponent,\r\n} from './ReactWorkTags';\r\nimport {detachDeletedInstance} from './ReactFiberHostConfig';\r\nimport {\r\n  NoFlags,\r\n  ContentReset,\r\n  Placement,\r\n  ChildDeletion,\r\n  Snapshot,\r\n  Update,\r\n  Ref,\r\n  Hydrating,\r\n  Passive,\r\n  BeforeMutationMask,\r\n  MutationMask,\r\n  LayoutMask,\r\n  PassiveMask,\r\n  Visibility,\r\n} from './ReactFiberFlags';\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport {\r\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\r\n  setCurrentFiber as setCurrentDebugFiberInDEV,\r\n  getCurrentFiber as getCurrentDebugFiberInDEV,\r\n} from './ReactCurrentFiber';\r\nimport {resolveDefaultProps} from './ReactFiberLazyComponent.new';\r\nimport {\r\n  isCurrentUpdateNested,\r\n  getCommitTime,\r\n  recordLayoutEffectDuration,\r\n  startLayoutEffectTimer,\r\n  recordPassiveEffectDuration,\r\n  startPassiveEffectTimer,\r\n} from './ReactProfilerTimer.new';\r\nimport {ConcurrentMode, NoMode, ProfileMode} from './ReactTypeOfMode';\r\nimport {commitUpdateQueue} from './ReactUpdateQueue.new';\r\nimport {\r\n  getPublicInstance,\r\n  supportsMutation,\r\n  supportsPersistence,\r\n  supportsHydration,\r\n  commitMount,\r\n  commitUpdate,\r\n  resetTextContent,\r\n  commitTextUpdate,\r\n  appendChild,\r\n  appendChildToContainer,\r\n  insertBefore,\r\n  insertInContainerBefore,\r\n  removeChild,\r\n  removeChildFromContainer,\r\n  clearSuspenseBoundary,\r\n  clearSuspenseBoundaryFromContainer,\r\n  replaceContainerChildren,\r\n  createContainerChildSet,\r\n  hideInstance,\r\n  hideTextInstance,\r\n  unhideInstance,\r\n  unhideTextInstance,\r\n  commitHydratedContainer,\r\n  commitHydratedSuspenseInstance,\r\n  clearContainer,\r\n  prepareScopeUpdate,\r\n  prepareForCommit,\r\n  beforeActiveInstanceBlur,\r\n} from './ReactFiberHostConfig';\r\nimport {\r\n  captureCommitPhaseError,\r\n  resolveRetryWakeable,\r\n  markCommitTimeOfFallback,\r\n  enqueuePendingPassiveProfilerEffect,\r\n  restorePendingUpdaters,\r\n  addTransitionStartCallbackToPendingTransition,\r\n  addTransitionCompleteCallbackToPendingTransition,\r\n  setIsRunningInsertionEffect,\r\n} from './ReactFiberWorkLoop.new';\r\nimport {\r\n  NoFlags as NoHookEffect,\r\n  HasEffect as HookHasEffect,\r\n  Layout as HookLayout,\r\n  Insertion as HookInsertion,\r\n  Passive as HookPassive,\r\n} from './ReactHookEffectTags';\r\nimport {didWarnAboutReassigningProps} from './ReactFiberBeginWork.new';\r\nimport {doesFiberContain} from './ReactFiberTreeReflection';\r\nimport {invokeGuardedCallback, clearCaughtError} from 'shared/ReactErrorUtils';\r\nimport {\r\n  isDevToolsPresent,\r\n  markComponentPassiveEffectMountStarted,\r\n  markComponentPassiveEffectMountStopped,\r\n  markComponentPassiveEffectUnmountStarted,\r\n  markComponentPassiveEffectUnmountStopped,\r\n  markComponentLayoutEffectMountStarted,\r\n  markComponentLayoutEffectMountStopped,\r\n  markComponentLayoutEffectUnmountStarted,\r\n  markComponentLayoutEffectUnmountStopped,\r\n  onCommitUnmount,\r\n} from './ReactFiberDevToolsHook.new';\r\nimport {releaseCache, retainCache} from './ReactFiberCacheComponent.new';\r\nimport {clearTransitionsForLanes} from './ReactFiberLane.new';\r\n\r\nlet didWarnAboutUndefinedSnapshotBeforeUpdate: Set<mixed> | null = null;\r\nif (__DEV__) {\r\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\r\n}\r\n\r\n// Used during the commit phase to track the state of the Offscreen component stack.\r\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\r\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\r\nlet offscreenSubtreeIsHidden: boolean = false;\r\nlet offscreenSubtreeWasHidden: boolean = false;\r\n\r\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\r\n\r\nlet nextEffect: Fiber | null = null;\r\n\r\n// Used for Profiling builds to track updaters.\r\nlet inProgressLanes: Lanes | null = null;\r\nlet inProgressRoot: FiberRoot | null = null;\r\n\r\nexport function reportUncaughtErrorInDEV(error: mixed) {\r\n  // Wrapping each small part of the commit phase into a guarded\r\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\r\n  // But we rely on it to surface errors to DEV tools like overlays\r\n  // (https://github.com/facebook/react/issues/21712).\r\n  // As a compromise, rethrow only caught errors in a guard.\r\n  if (__DEV__) {\r\n    invokeGuardedCallback(null, () => {\r\n      throw error;\r\n    });\r\n    clearCaughtError();\r\n  }\r\n}\r\n\r\nconst callComponentWillUnmountWithTimer = function(current, instance) {\r\n  instance.props = current.memoizedProps;\r\n  instance.state = current.memoizedState;\r\n  if (\r\n    enableProfilerTimer &&\r\n    enableProfilerCommitHooks &&\r\n    current.mode & ProfileMode\r\n  ) {\r\n    try {\r\n      startLayoutEffectTimer();\r\n      instance.componentWillUnmount();\r\n    } finally {\r\n      recordLayoutEffectDuration(current);\r\n    }\r\n  } else {\r\n    instance.componentWillUnmount();\r\n  }\r\n};\r\n\r\n// Capture errors so they don't interrupt mounting.\r\nfunction safelyCallCommitHookLayoutEffectListMount(\r\n  current: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n) {\r\n  try {\r\n    commitHookEffectListMount(HookLayout, current);\r\n  } catch (error) {\r\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\r\n  }\r\n}\r\n\r\n// Capture errors so they don't interrupt unmounting.\r\nfunction safelyCallComponentWillUnmount(\r\n  current: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n  instance: any,\r\n) {\r\n  try {\r\n    callComponentWillUnmountWithTimer(current, instance);\r\n  } catch (error) {\r\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\r\n  }\r\n}\r\n\r\n// Capture errors so they don't interrupt mounting.\r\nfunction safelyCallComponentDidMount(\r\n  current: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n  instance: any,\r\n) {\r\n  try {\r\n    instance.componentDidMount();\r\n  } catch (error) {\r\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\r\n  }\r\n}\r\n\r\n// Capture errors so they don't interrupt mounting.\r\nfunction safelyAttachRef(current: Fiber, nearestMountedAncestor: Fiber | null) {\r\n  try {\r\n    commitAttachRef(current);\r\n  } catch (error) {\r\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\r\n  }\r\n}\r\n\r\nfunction safelyDetachRef(current: Fiber, nearestMountedAncestor: Fiber | null) {\r\n  const ref = current.ref;\r\n  if (ref !== null) {\r\n    if (typeof ref === 'function') {\r\n      let retVal;\r\n      try {\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          current.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startLayoutEffectTimer();\r\n            retVal = ref(null);\r\n          } finally {\r\n            recordLayoutEffectDuration(current);\r\n          }\r\n        } else {\r\n          retVal = ref(null);\r\n        }\r\n      } catch (error) {\r\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\r\n      }\r\n      if (__DEV__) {\r\n        if (typeof retVal === 'function') {\r\n          console.error(\r\n            'Unexpected return value from a callback ref in %s. ' +\r\n              'A callback ref should not return a function.',\r\n            getComponentNameFromFiber(current),\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      ref.current = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction safelyCallDestroy(\r\n  current: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n  destroy: () => void,\r\n) {\r\n  try {\r\n    destroy();\r\n  } catch (error) {\r\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\r\n  }\r\n}\r\n\r\nlet focusedInstanceHandle: null | Fiber = null;\r\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\r\n\r\nexport function commitBeforeMutationEffects(\r\n  root: FiberRoot,\r\n  firstChild: Fiber,\r\n) {\r\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n\r\n  nextEffect = firstChild;\r\n  commitBeforeMutationEffects_begin();\r\n\r\n  // We no longer need to track the active instance fiber\r\n  const shouldFire = shouldFireAfterActiveInstanceBlur;\r\n  shouldFireAfterActiveInstanceBlur = false;\r\n  focusedInstanceHandle = null;\r\n\r\n  return shouldFire;\r\n}\r\n\r\nfunction commitBeforeMutationEffects_begin() {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n\r\n    // This phase is only used for beforeActiveInstanceBlur.\r\n    // Let's skip the whole loop if it's off.\r\n    if (enableCreateEventHandleAPI) {\r\n      // TODO: Should wrap this in flags check, too, as optimization\r\n      const deletions = fiber.deletions;\r\n      if (deletions !== null) {\r\n        for (let i = 0; i < deletions.length; i++) {\r\n          const deletion = deletions[i];\r\n          commitBeforeMutationEffectsDeletion(deletion);\r\n        }\r\n      }\r\n    }\r\n\r\n    const child = fiber.child;\r\n    if (\r\n      (fiber.subtreeFlags & BeforeMutationMask) !== NoFlags &&\r\n      child !== null\r\n    ) {\r\n      child.return = fiber;\r\n      nextEffect = child;\r\n    } else {\r\n      commitBeforeMutationEffects_complete();\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitBeforeMutationEffects_complete() {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    setCurrentDebugFiberInDEV(fiber);\r\n    try {\r\n      commitBeforeMutationEffectsOnFiber(fiber);\r\n    } catch (error) {\r\n      captureCommitPhaseError(fiber, fiber.return, error);\r\n    }\r\n    resetCurrentDebugFiberInDEV();\r\n\r\n    const sibling = fiber.sibling;\r\n    if (sibling !== null) {\r\n      sibling.return = fiber.return;\r\n      nextEffect = sibling;\r\n      return;\r\n    }\r\n\r\n    nextEffect = fiber.return;\r\n  }\r\n}\r\n\r\nfunction commitBeforeMutationEffectsOnFiber(finishedWork: Fiber) {\r\n  const current = finishedWork.alternate;\r\n  const flags = finishedWork.flags;\r\n\r\n  if (enableCreateEventHandleAPI) {\r\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n      // Check to see if the focused element was inside of a hidden (Suspense) subtree.\r\n      // TODO: Move this out of the hot path using a dedicated effect tag.\r\n      if (\r\n        finishedWork.tag === SuspenseComponent &&\r\n        isSuspenseBoundaryBeingHidden(current, finishedWork) &&\r\n        doesFiberContain(finishedWork, focusedInstanceHandle)\r\n      ) {\r\n        shouldFireAfterActiveInstanceBlur = true;\r\n        beforeActiveInstanceBlur(finishedWork);\r\n      }\r\n    }\r\n  }\r\n\r\n  if ((flags & Snapshot) !== NoFlags) {\r\n    setCurrentDebugFiberInDEV(finishedWork);\r\n\r\n    switch (finishedWork.tag) {\r\n      case FunctionComponent:\r\n      case ForwardRef:\r\n      case SimpleMemoComponent: {\r\n        break;\r\n      }\r\n      case ClassComponent: {\r\n        if (current !== null) {\r\n          const prevProps = current.memoizedProps;\r\n          const prevState = current.memoizedState;\r\n          const instance = finishedWork.stateNode;\r\n          // We could update instance props and state here,\r\n          // but instead we rely on them being set during last render.\r\n          // TODO: revisit this when we implement resuming.\r\n          if (__DEV__) {\r\n            if (\r\n              finishedWork.type === finishedWork.elementType &&\r\n              !didWarnAboutReassigningProps\r\n            ) {\r\n              if (instance.props !== finishedWork.memoizedProps) {\r\n                console.error(\r\n                  'Expected %s props to match memoized props before ' +\r\n                    'getSnapshotBeforeUpdate. ' +\r\n                    'This might either be because of a bug in React, or because ' +\r\n                    'a component reassigns its own `this.props`. ' +\r\n                    'Please file an issue.',\r\n                  getComponentNameFromFiber(finishedWork) || 'instance',\r\n                );\r\n              }\r\n              if (instance.state !== finishedWork.memoizedState) {\r\n                console.error(\r\n                  'Expected %s state to match memoized state before ' +\r\n                    'getSnapshotBeforeUpdate. ' +\r\n                    'This might either be because of a bug in React, or because ' +\r\n                    'a component reassigns its own `this.state`. ' +\r\n                    'Please file an issue.',\r\n                  getComponentNameFromFiber(finishedWork) || 'instance',\r\n                );\r\n              }\r\n            }\r\n          }\r\n          const snapshot = instance.getSnapshotBeforeUpdate(\r\n            finishedWork.elementType === finishedWork.type\r\n              ? prevProps\r\n              : resolveDefaultProps(finishedWork.type, prevProps),\r\n            prevState,\r\n          );\r\n          if (__DEV__) {\r\n            const didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<mixed>);\r\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\r\n              didWarnSet.add(finishedWork.type);\r\n              console.error(\r\n                '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' +\r\n                  'must be returned. You have returned undefined.',\r\n                getComponentNameFromFiber(finishedWork),\r\n              );\r\n            }\r\n          }\r\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\r\n        }\r\n        break;\r\n      }\r\n      case HostRoot: {\r\n        if (supportsMutation) {\r\n          const root = finishedWork.stateNode;\r\n          clearContainer(root.containerInfo);\r\n        }\r\n        break;\r\n      }\r\n      case HostComponent:\r\n      case HostText:\r\n      case HostPortal:\r\n      case IncompleteClassComponent:\r\n        // Nothing to do for these component types\r\n        break;\r\n      default: {\r\n        throw new Error(\r\n          'This unit of work tag should not have side-effects. This error is ' +\r\n            'likely caused by a bug in React. Please file an issue.',\r\n        );\r\n      }\r\n    }\r\n\r\n    resetCurrentDebugFiberInDEV();\r\n  }\r\n}\r\n\r\nfunction commitBeforeMutationEffectsDeletion(deletion: Fiber) {\r\n  if (enableCreateEventHandleAPI) {\r\n    // TODO (effects) It would be nice to avoid calling doesFiberContain()\r\n    // Maybe we can repurpose one of the subtreeFlags positions for this instead?\r\n    // Use it to store which part of the tree the focused instance is in?\r\n    // This assumes we can safely determine that instance during the \"render\" phase.\r\n    if (doesFiberContain(deletion, ((focusedInstanceHandle: any): Fiber))) {\r\n      shouldFireAfterActiveInstanceBlur = true;\r\n      beforeActiveInstanceBlur(deletion);\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitHookEffectListUnmount(\r\n  flags: HookFlags,\r\n  finishedWork: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n) {\r\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\r\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\r\n  if (lastEffect !== null) {\r\n    const firstEffect = lastEffect.next;\r\n    let effect = firstEffect;\r\n    do {\r\n      if ((effect.tag & flags) === flags) {\r\n        // Unmount\r\n        const destroy = effect.destroy;\r\n        effect.destroy = undefined;\r\n        if (destroy !== undefined) {\r\n          if (enableSchedulingProfiler) {\r\n            if ((flags & HookPassive) !== NoHookEffect) {\r\n              markComponentPassiveEffectUnmountStarted(finishedWork);\r\n            } else if ((flags & HookLayout) !== NoHookEffect) {\r\n              markComponentLayoutEffectUnmountStarted(finishedWork);\r\n            }\r\n          }\r\n\r\n          if (__DEV__) {\r\n            if ((flags & HookInsertion) !== NoHookEffect) {\r\n              setIsRunningInsertionEffect(true);\r\n            }\r\n          }\r\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\r\n          if (__DEV__) {\r\n            if ((flags & HookInsertion) !== NoHookEffect) {\r\n              setIsRunningInsertionEffect(false);\r\n            }\r\n          }\r\n\r\n          if (enableSchedulingProfiler) {\r\n            if ((flags & HookPassive) !== NoHookEffect) {\r\n              markComponentPassiveEffectUnmountStopped();\r\n            } else if ((flags & HookLayout) !== NoHookEffect) {\r\n              markComponentLayoutEffectUnmountStopped();\r\n            }\r\n          }\r\n        }\r\n      }\r\n      effect = effect.next;\r\n    } while (effect !== firstEffect);\r\n  }\r\n}\r\n\r\nfunction commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber) {\r\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\r\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\r\n  if (lastEffect !== null) {\r\n    const firstEffect = lastEffect.next;\r\n    let effect = firstEffect;\r\n    do {\r\n      if ((effect.tag & flags) === flags) {\r\n        if (enableSchedulingProfiler) {\r\n          if ((flags & HookPassive) !== NoHookEffect) {\r\n            markComponentPassiveEffectMountStarted(finishedWork);\r\n          } else if ((flags & HookLayout) !== NoHookEffect) {\r\n            markComponentLayoutEffectMountStarted(finishedWork);\r\n          }\r\n        }\r\n\r\n        // Mount\r\n        const create = effect.create;\r\n        if (__DEV__) {\r\n          if ((flags & HookInsertion) !== NoHookEffect) {\r\n            setIsRunningInsertionEffect(true);\r\n          }\r\n        }\r\n        effect.destroy = create();\r\n        if (__DEV__) {\r\n          if ((flags & HookInsertion) !== NoHookEffect) {\r\n            setIsRunningInsertionEffect(false);\r\n          }\r\n        }\r\n\r\n        if (enableSchedulingProfiler) {\r\n          if ((flags & HookPassive) !== NoHookEffect) {\r\n            markComponentPassiveEffectMountStopped();\r\n          } else if ((flags & HookLayout) !== NoHookEffect) {\r\n            markComponentLayoutEffectMountStopped();\r\n          }\r\n        }\r\n\r\n        if (__DEV__) {\r\n          const destroy = effect.destroy;\r\n          if (destroy !== undefined && typeof destroy !== 'function') {\r\n            let hookName;\r\n            if ((effect.tag & HookLayout) !== NoFlags) {\r\n              hookName = 'useLayoutEffect';\r\n            } else if ((effect.tag & HookInsertion) !== NoFlags) {\r\n              hookName = 'useInsertionEffect';\r\n            } else {\r\n              hookName = 'useEffect';\r\n            }\r\n            let addendum;\r\n            if (destroy === null) {\r\n              addendum =\r\n                ' You returned null. If your effect does not require clean ' +\r\n                'up, return undefined (or nothing).';\r\n            } else if (typeof destroy.then === 'function') {\r\n              addendum =\r\n                '\\n\\nIt looks like you wrote ' +\r\n                hookName +\r\n                '(async () => ...) or returned a Promise. ' +\r\n                'Instead, write the async function inside your effect ' +\r\n                'and call it immediately:\\n\\n' +\r\n                hookName +\r\n                '(() => {\\n' +\r\n                '  async function fetchData() {\\n' +\r\n                '    // You can await here\\n' +\r\n                '    const response = await MyAPI.getData(someId);\\n' +\r\n                '    // ...\\n' +\r\n                '  }\\n' +\r\n                '  fetchData();\\n' +\r\n                `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` +\r\n                'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\r\n            } else {\r\n              addendum = ' You returned: ' + destroy;\r\n            }\r\n            console.error(\r\n              '%s must not return anything besides a function, ' +\r\n                'which is used for clean-up.%s',\r\n              hookName,\r\n              addendum,\r\n            );\r\n          }\r\n        }\r\n      }\r\n      effect = effect.next;\r\n    } while (effect !== firstEffect);\r\n  }\r\n}\r\n\r\nexport function commitPassiveEffectDurations(\r\n  finishedRoot: FiberRoot,\r\n  finishedWork: Fiber,\r\n): void {\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\r\n    if ((finishedWork.flags & Update) !== NoFlags) {\r\n      switch (finishedWork.tag) {\r\n        case Profiler: {\r\n          const {passiveEffectDuration} = finishedWork.stateNode;\r\n          const {id, onPostCommit} = finishedWork.memoizedProps;\r\n\r\n          // This value will still reflect the previous commit phase.\r\n          // It does not get reset until the start of the next commit phase.\r\n          const commitTime = getCommitTime();\r\n\r\n          let phase = finishedWork.alternate === null ? 'mount' : 'update';\r\n          if (enableProfilerNestedUpdatePhase) {\r\n            if (isCurrentUpdateNested()) {\r\n              phase = 'nested-update';\r\n            }\r\n          }\r\n\r\n          if (typeof onPostCommit === 'function') {\r\n            onPostCommit(id, phase, passiveEffectDuration, commitTime);\r\n          }\r\n\r\n          // Bubble times to the next nearest ancestor Profiler.\r\n          // After we process that Profiler, we'll bubble further up.\r\n          let parentFiber = finishedWork.return;\r\n          outer: while (parentFiber !== null) {\r\n            switch (parentFiber.tag) {\r\n              case HostRoot:\r\n                const root = parentFiber.stateNode;\r\n                root.passiveEffectDuration += passiveEffectDuration;\r\n                break outer;\r\n              case Profiler:\r\n                const parentStateNode = parentFiber.stateNode;\r\n                parentStateNode.passiveEffectDuration += passiveEffectDuration;\r\n                break outer;\r\n            }\r\n            parentFiber = parentFiber.return;\r\n          }\r\n          break;\r\n        }\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitLayoutEffectOnFiber(\r\n  finishedRoot: FiberRoot,\r\n  current: Fiber | null,\r\n  finishedWork: Fiber,\r\n  committedLanes: Lanes,\r\n): void {\r\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\r\n    switch (finishedWork.tag) {\r\n      case FunctionComponent:\r\n      case ForwardRef:\r\n      case SimpleMemoComponent: {\r\n        if (\r\n          !enableSuspenseLayoutEffectSemantics ||\r\n          !offscreenSubtreeWasHidden\r\n        ) {\r\n          // At this point layout effects have already been destroyed (during mutation phase).\r\n          // This is done to prevent sibling component effects from interfering with each other,\r\n          // e.g. a destroy function in one component should never override a ref set\r\n          // by a create function in another component during the same commit.\r\n          if (\r\n            enableProfilerTimer &&\r\n            enableProfilerCommitHooks &&\r\n            finishedWork.mode & ProfileMode\r\n          ) {\r\n            try {\r\n              startLayoutEffectTimer();\r\n              commitHookEffectListMount(\r\n                HookLayout | HookHasEffect,\r\n                finishedWork,\r\n              );\r\n            } finally {\r\n              recordLayoutEffectDuration(finishedWork);\r\n            }\r\n          } else {\r\n            commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ClassComponent: {\r\n        const instance = finishedWork.stateNode;\r\n        if (finishedWork.flags & Update) {\r\n          if (!offscreenSubtreeWasHidden) {\r\n            if (current === null) {\r\n              // We could update instance props and state here,\r\n              // but instead we rely on them being set during last render.\r\n              // TODO: revisit this when we implement resuming.\r\n              if (__DEV__) {\r\n                if (\r\n                  finishedWork.type === finishedWork.elementType &&\r\n                  !didWarnAboutReassigningProps\r\n                ) {\r\n                  if (instance.props !== finishedWork.memoizedProps) {\r\n                    console.error(\r\n                      'Expected %s props to match memoized props before ' +\r\n                        'componentDidMount. ' +\r\n                        'This might either be because of a bug in React, or because ' +\r\n                        'a component reassigns its own `this.props`. ' +\r\n                        'Please file an issue.',\r\n                      getComponentNameFromFiber(finishedWork) || 'instance',\r\n                    );\r\n                  }\r\n                  if (instance.state !== finishedWork.memoizedState) {\r\n                    console.error(\r\n                      'Expected %s state to match memoized state before ' +\r\n                        'componentDidMount. ' +\r\n                        'This might either be because of a bug in React, or because ' +\r\n                        'a component reassigns its own `this.state`. ' +\r\n                        'Please file an issue.',\r\n                      getComponentNameFromFiber(finishedWork) || 'instance',\r\n                    );\r\n                  }\r\n                }\r\n              }\r\n              if (\r\n                enableProfilerTimer &&\r\n                enableProfilerCommitHooks &&\r\n                finishedWork.mode & ProfileMode\r\n              ) {\r\n                try {\r\n                  startLayoutEffectTimer();\r\n                  instance.componentDidMount();\r\n                } finally {\r\n                  recordLayoutEffectDuration(finishedWork);\r\n                }\r\n              } else {\r\n                instance.componentDidMount();\r\n              }\r\n            } else {\r\n              const prevProps =\r\n                finishedWork.elementType === finishedWork.type\r\n                  ? current.memoizedProps\r\n                  : resolveDefaultProps(\r\n                      finishedWork.type,\r\n                      current.memoizedProps,\r\n                    );\r\n              const prevState = current.memoizedState;\r\n              // We could update instance props and state here,\r\n              // but instead we rely on them being set during last render.\r\n              // TODO: revisit this when we implement resuming.\r\n              if (__DEV__) {\r\n                if (\r\n                  finishedWork.type === finishedWork.elementType &&\r\n                  !didWarnAboutReassigningProps\r\n                ) {\r\n                  if (instance.props !== finishedWork.memoizedProps) {\r\n                    console.error(\r\n                      'Expected %s props to match memoized props before ' +\r\n                        'componentDidUpdate. ' +\r\n                        'This might either be because of a bug in React, or because ' +\r\n                        'a component reassigns its own `this.props`. ' +\r\n                        'Please file an issue.',\r\n                      getComponentNameFromFiber(finishedWork) || 'instance',\r\n                    );\r\n                  }\r\n                  if (instance.state !== finishedWork.memoizedState) {\r\n                    console.error(\r\n                      'Expected %s state to match memoized state before ' +\r\n                        'componentDidUpdate. ' +\r\n                        'This might either be because of a bug in React, or because ' +\r\n                        'a component reassigns its own `this.state`. ' +\r\n                        'Please file an issue.',\r\n                      getComponentNameFromFiber(finishedWork) || 'instance',\r\n                    );\r\n                  }\r\n                }\r\n              }\r\n              if (\r\n                enableProfilerTimer &&\r\n                enableProfilerCommitHooks &&\r\n                finishedWork.mode & ProfileMode\r\n              ) {\r\n                try {\r\n                  startLayoutEffectTimer();\r\n                  instance.componentDidUpdate(\r\n                    prevProps,\r\n                    prevState,\r\n                    instance.__reactInternalSnapshotBeforeUpdate,\r\n                  );\r\n                } finally {\r\n                  recordLayoutEffectDuration(finishedWork);\r\n                }\r\n              } else {\r\n                instance.componentDidUpdate(\r\n                  prevProps,\r\n                  prevState,\r\n                  instance.__reactInternalSnapshotBeforeUpdate,\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // TODO: I think this is now always non-null by the time it reaches the\r\n        // commit phase. Consider removing the type check.\r\n        const updateQueue: UpdateQueue<\r\n          *,\r\n        > | null = (finishedWork.updateQueue: any);\r\n        if (updateQueue !== null) {\r\n          if (__DEV__) {\r\n            if (\r\n              finishedWork.type === finishedWork.elementType &&\r\n              !didWarnAboutReassigningProps\r\n            ) {\r\n              if (instance.props !== finishedWork.memoizedProps) {\r\n                console.error(\r\n                  'Expected %s props to match memoized props before ' +\r\n                    'processing the update queue. ' +\r\n                    'This might either be because of a bug in React, or because ' +\r\n                    'a component reassigns its own `this.props`. ' +\r\n                    'Please file an issue.',\r\n                  getComponentNameFromFiber(finishedWork) || 'instance',\r\n                );\r\n              }\r\n              if (instance.state !== finishedWork.memoizedState) {\r\n                console.error(\r\n                  'Expected %s state to match memoized state before ' +\r\n                    'processing the update queue. ' +\r\n                    'This might either be because of a bug in React, or because ' +\r\n                    'a component reassigns its own `this.state`. ' +\r\n                    'Please file an issue.',\r\n                  getComponentNameFromFiber(finishedWork) || 'instance',\r\n                );\r\n              }\r\n            }\r\n          }\r\n          // We could update instance props and state here,\r\n          // but instead we rely on them being set during last render.\r\n          // TODO: revisit this when we implement resuming.\r\n          commitUpdateQueue(finishedWork, updateQueue, instance);\r\n        }\r\n        break;\r\n      }\r\n      case HostRoot: {\r\n        // TODO: I think this is now always non-null by the time it reaches the\r\n        // commit phase. Consider removing the type check.\r\n        const updateQueue: UpdateQueue<\r\n          *,\r\n        > | null = (finishedWork.updateQueue: any);\r\n        if (updateQueue !== null) {\r\n          let instance = null;\r\n          if (finishedWork.child !== null) {\r\n            switch (finishedWork.child.tag) {\r\n              case HostComponent:\r\n                instance = getPublicInstance(finishedWork.child.stateNode);\r\n                break;\r\n              case ClassComponent:\r\n                instance = finishedWork.child.stateNode;\r\n                break;\r\n            }\r\n          }\r\n          commitUpdateQueue(finishedWork, updateQueue, instance);\r\n        }\r\n        break;\r\n      }\r\n      case HostComponent: {\r\n        const instance: Instance = finishedWork.stateNode;\r\n\r\n        // Renderers may schedule work to be done after host components are mounted\r\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\r\n        // These effects should only be committed when components are first mounted,\r\n        // aka when there is no current/alternate.\r\n        if (current === null && finishedWork.flags & Update) {\r\n          const type = finishedWork.type;\r\n          const props = finishedWork.memoizedProps;\r\n          commitMount(instance, type, props, finishedWork);\r\n        }\r\n\r\n        break;\r\n      }\r\n      case HostText: {\r\n        // We have no life-cycles associated with text.\r\n        break;\r\n      }\r\n      case HostPortal: {\r\n        // We have no life-cycles associated with portals.\r\n        break;\r\n      }\r\n      case Profiler: {\r\n        if (enableProfilerTimer) {\r\n          const {onCommit, onRender} = finishedWork.memoizedProps;\r\n          const {effectDuration} = finishedWork.stateNode;\r\n\r\n          const commitTime = getCommitTime();\r\n\r\n          let phase = current === null ? 'mount' : 'update';\r\n          if (enableProfilerNestedUpdatePhase) {\r\n            if (isCurrentUpdateNested()) {\r\n              phase = 'nested-update';\r\n            }\r\n          }\r\n\r\n          if (typeof onRender === 'function') {\r\n            onRender(\r\n              finishedWork.memoizedProps.id,\r\n              phase,\r\n              finishedWork.actualDuration,\r\n              finishedWork.treeBaseDuration,\r\n              finishedWork.actualStartTime,\r\n              commitTime,\r\n            );\r\n          }\r\n\r\n          if (enableProfilerCommitHooks) {\r\n            if (typeof onCommit === 'function') {\r\n              onCommit(\r\n                finishedWork.memoizedProps.id,\r\n                phase,\r\n                effectDuration,\r\n                commitTime,\r\n              );\r\n            }\r\n\r\n            // Schedule a passive effect for this Profiler to call onPostCommit hooks.\r\n            // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\r\n            // because the effect is also where times bubble to parent Profilers.\r\n            enqueuePendingPassiveProfilerEffect(finishedWork);\r\n\r\n            // Propagate layout effect durations to the next nearest Profiler ancestor.\r\n            // Do not reset these values until the next render so DevTools has a chance to read them first.\r\n            let parentFiber = finishedWork.return;\r\n            outer: while (parentFiber !== null) {\r\n              switch (parentFiber.tag) {\r\n                case HostRoot:\r\n                  const root = parentFiber.stateNode;\r\n                  root.effectDuration += effectDuration;\r\n                  break outer;\r\n                case Profiler:\r\n                  const parentStateNode = parentFiber.stateNode;\r\n                  parentStateNode.effectDuration += effectDuration;\r\n                  break outer;\r\n              }\r\n              parentFiber = parentFiber.return;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case SuspenseComponent: {\r\n        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\r\n        break;\r\n      }\r\n      case SuspenseListComponent:\r\n      case IncompleteClassComponent:\r\n      case ScopeComponent:\r\n      case OffscreenComponent:\r\n      case LegacyHiddenComponent: {\r\n        break;\r\n      }\r\n\r\n      default:\r\n        throw new Error(\r\n          'This unit of work tag should not have side-effects. This error is ' +\r\n            'likely caused by a bug in React. Please file an issue.',\r\n        );\r\n    }\r\n  }\r\n\r\n  if (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) {\r\n    if (enableScopeAPI) {\r\n      // TODO: This is a temporary solution that allowed us to transition away\r\n      // from React Flare on www.\r\n      if (finishedWork.flags & Ref && finishedWork.tag !== ScopeComponent) {\r\n        commitAttachRef(finishedWork);\r\n      }\r\n    } else {\r\n      if (finishedWork.flags & Ref) {\r\n        commitAttachRef(finishedWork);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction reappearLayoutEffectsOnFiber(node: Fiber) {\r\n  // Turn on layout effects in a tree that previously disappeared.\r\n  // TODO (Offscreen) Check: flags & LayoutStatic\r\n  switch (node.tag) {\r\n    case FunctionComponent:\r\n    case ForwardRef:\r\n    case SimpleMemoComponent: {\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        node.mode & ProfileMode\r\n      ) {\r\n        try {\r\n          startLayoutEffectTimer();\r\n          safelyCallCommitHookLayoutEffectListMount(node, node.return);\r\n        } finally {\r\n          recordLayoutEffectDuration(node);\r\n        }\r\n      } else {\r\n        safelyCallCommitHookLayoutEffectListMount(node, node.return);\r\n      }\r\n      break;\r\n    }\r\n    case ClassComponent: {\r\n      const instance = node.stateNode;\r\n      if (typeof instance.componentDidMount === 'function') {\r\n        safelyCallComponentDidMount(node, node.return, instance);\r\n      }\r\n      safelyAttachRef(node, node.return);\r\n      break;\r\n    }\r\n    case HostComponent: {\r\n      safelyAttachRef(node, node.return);\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\r\n  // Only hide or unhide the top-most host nodes.\r\n  let hostSubtreeRoot = null;\r\n\r\n  if (supportsMutation) {\r\n    // We only have the top Fiber that was inserted but we need to recurse down its\r\n    // children to find all the terminal nodes.\r\n    let node: Fiber = finishedWork;\r\n    while (true) {\r\n      if (node.tag === HostComponent) {\r\n        if (hostSubtreeRoot === null) {\r\n          hostSubtreeRoot = node;\r\n          try {\r\n            const instance = node.stateNode;\r\n            if (isHidden) {\r\n              hideInstance(instance);\r\n            } else {\r\n              unhideInstance(node.stateNode, node.memoizedProps);\r\n            }\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n        }\r\n      } else if (node.tag === HostText) {\r\n        if (hostSubtreeRoot === null) {\r\n          try {\r\n            const instance = node.stateNode;\r\n            if (isHidden) {\r\n              hideTextInstance(instance);\r\n            } else {\r\n              unhideTextInstance(instance, node.memoizedProps);\r\n            }\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n        }\r\n      } else if (\r\n        (node.tag === OffscreenComponent ||\r\n          node.tag === LegacyHiddenComponent) &&\r\n        (node.memoizedState: OffscreenState) !== null &&\r\n        node !== finishedWork\r\n      ) {\r\n        // Found a nested Offscreen component that is hidden.\r\n        // Don't search any deeper. This tree should remain hidden.\r\n      } else if (node.child !== null) {\r\n        node.child.return = node;\r\n        node = node.child;\r\n        continue;\r\n      }\r\n\r\n      if (node === finishedWork) {\r\n        return;\r\n      }\r\n      while (node.sibling === null) {\r\n        if (node.return === null || node.return === finishedWork) {\r\n          return;\r\n        }\r\n\r\n        if (hostSubtreeRoot === node) {\r\n          hostSubtreeRoot = null;\r\n        }\r\n\r\n        node = node.return;\r\n      }\r\n\r\n      if (hostSubtreeRoot === node) {\r\n        hostSubtreeRoot = null;\r\n      }\r\n\r\n      node.sibling.return = node.return;\r\n      node = node.sibling;\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitAttachRef(finishedWork: Fiber) {\r\n  const ref = finishedWork.ref;\r\n  if (ref !== null) {\r\n    const instance = finishedWork.stateNode;\r\n    let instanceToUse;\r\n    switch (finishedWork.tag) {\r\n      case HostComponent:\r\n        instanceToUse = getPublicInstance(instance);\r\n        break;\r\n      default:\r\n        instanceToUse = instance;\r\n    }\r\n    // Moved outside to ensure DCE works with this flag\r\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\r\n      instanceToUse = instance;\r\n    }\r\n    if (typeof ref === 'function') {\r\n      let retVal;\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        finishedWork.mode & ProfileMode\r\n      ) {\r\n        try {\r\n          startLayoutEffectTimer();\r\n          retVal = ref(instanceToUse);\r\n        } finally {\r\n          recordLayoutEffectDuration(finishedWork);\r\n        }\r\n      } else {\r\n        retVal = ref(instanceToUse);\r\n      }\r\n      if (__DEV__) {\r\n        if (typeof retVal === 'function') {\r\n          console.error(\r\n            'Unexpected return value from a callback ref in %s. ' +\r\n              'A callback ref should not return a function.',\r\n            getComponentNameFromFiber(finishedWork),\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      if (__DEV__) {\r\n        if (!ref.hasOwnProperty('current')) {\r\n          console.error(\r\n            'Unexpected ref object provided for %s. ' +\r\n              'Use either a ref-setter function or React.createRef().',\r\n            getComponentNameFromFiber(finishedWork),\r\n          );\r\n        }\r\n      }\r\n\r\n      ref.current = instanceToUse;\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitDetachRef(current: Fiber) {\r\n  const currentRef = current.ref;\r\n  if (currentRef !== null) {\r\n    if (typeof currentRef === 'function') {\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        current.mode & ProfileMode\r\n      ) {\r\n        try {\r\n          startLayoutEffectTimer();\r\n          currentRef(null);\r\n        } finally {\r\n          recordLayoutEffectDuration(current);\r\n        }\r\n      } else {\r\n        currentRef(null);\r\n      }\r\n    } else {\r\n      currentRef.current = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction detachFiberMutation(fiber: Fiber) {\r\n  // Cut off the return pointer to disconnect it from the tree.\r\n  // This enables us to detect and warn against state updates on an unmounted component.\r\n  // It also prevents events from bubbling from within disconnected components.\r\n  //\r\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\r\n  // get GC:ed but we don't know which for sure which parent is the current\r\n  // one so we'll settle for GC:ing the subtree of this child.\r\n  // This child itself will be GC:ed when the parent updates the next time.\r\n  //\r\n  // Note that we can't clear child or sibling pointers yet.\r\n  // They're needed for passive effects and for findDOMNode.\r\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\r\n  //\r\n  // Don't reset the alternate yet, either. We need that so we can detach the\r\n  // alternate's fields in the passive phase. Clearing the return pointer is\r\n  // sufficient for findDOMNode semantics.\r\n  const alternate = fiber.alternate;\r\n  if (alternate !== null) {\r\n    alternate.return = null;\r\n  }\r\n  fiber.return = null;\r\n}\r\n\r\nfunction detachFiberAfterEffects(fiber: Fiber) {\r\n  const alternate = fiber.alternate;\r\n  if (alternate !== null) {\r\n    fiber.alternate = null;\r\n    detachFiberAfterEffects(alternate);\r\n  }\r\n\r\n  // Note: Defensively using negation instead of < in case\r\n  // `deletedTreeCleanUpLevel` is undefined.\r\n  if (!(deletedTreeCleanUpLevel >= 2)) {\r\n    // This is the default branch (level 0).\r\n    fiber.child = null;\r\n    fiber.deletions = null;\r\n    fiber.dependencies = null;\r\n    fiber.memoizedProps = null;\r\n    fiber.memoizedState = null;\r\n    fiber.pendingProps = null;\r\n    fiber.sibling = null;\r\n    fiber.stateNode = null;\r\n    fiber.updateQueue = null;\r\n\r\n    if (__DEV__) {\r\n      fiber._debugOwner = null;\r\n    }\r\n  } else {\r\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\r\n    // approximate the planned Fiber refactor. In that world, `setState` will be\r\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\r\n    // object will not have any of these fields. It will only be connected to\r\n    // the fiber tree via a single link at the root. So if this level alone is\r\n    // sufficient to fix memory issues, that bodes well for our plans.\r\n    fiber.child = null;\r\n    fiber.deletions = null;\r\n    fiber.sibling = null;\r\n\r\n    // The `stateNode` is cyclical because on host nodes it points to the host\r\n    // tree, which has its own pointers to children, parents, and siblings.\r\n    // The other host nodes also point back to fibers, so we should detach that\r\n    // one, too.\r\n    if (fiber.tag === HostComponent) {\r\n      const hostInstance: Instance = fiber.stateNode;\r\n      if (hostInstance !== null) {\r\n        detachDeletedInstance(hostInstance);\r\n      }\r\n    }\r\n    fiber.stateNode = null;\r\n\r\n    // I'm intentionally not clearing the `return` field in this level. We\r\n    // already disconnect the `return` pointer at the root of the deleted\r\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\r\n    // cyclical — it's only cyclical when combined with `child`, `sibling`, and\r\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\r\n\r\n    if (__DEV__) {\r\n      fiber._debugOwner = null;\r\n    }\r\n\r\n    if (deletedTreeCleanUpLevel >= 3) {\r\n      // Theoretically, nothing in here should be necessary, because we already\r\n      // disconnected the fiber from the tree. So even if something leaks this\r\n      // particular fiber, it won't leak anything else\r\n      //\r\n      // The purpose of this branch is to be super aggressive so we can measure\r\n      // if there's any difference in memory impact. If there is, that could\r\n      // indicate a React leak we don't know about.\r\n      fiber.return = null;\r\n      fiber.dependencies = null;\r\n      fiber.memoizedProps = null;\r\n      fiber.memoizedState = null;\r\n      fiber.pendingProps = null;\r\n      fiber.stateNode = null;\r\n      // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\r\n      fiber.updateQueue = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction emptyPortalContainer(current: Fiber) {\r\n  if (!supportsPersistence) {\r\n    return;\r\n  }\r\n\r\n  const portal: {\r\n    containerInfo: Container,\r\n    pendingChildren: ChildSet,\r\n    ...\r\n  } = current.stateNode;\r\n  const {containerInfo} = portal;\r\n  const emptyChildSet = createContainerChildSet(containerInfo);\r\n  replaceContainerChildren(containerInfo, emptyChildSet);\r\n}\r\n\r\nfunction getHostParentFiber(fiber: Fiber): Fiber {\r\n  let parent = fiber.return;\r\n  while (parent !== null) {\r\n    if (isHostParent(parent)) {\r\n      return parent;\r\n    }\r\n    parent = parent.return;\r\n  }\r\n\r\n  throw new Error(\r\n    'Expected to find a host parent. This error is likely caused by a bug ' +\r\n      'in React. Please file an issue.',\r\n  );\r\n}\r\n\r\nfunction isHostParent(fiber: Fiber): boolean {\r\n  return (\r\n    fiber.tag === HostComponent ||\r\n    fiber.tag === HostRoot ||\r\n    fiber.tag === HostPortal\r\n  );\r\n}\r\n\r\nfunction getHostSibling(fiber: Fiber): ?Instance {\r\n  // We're going to search forward into the tree until we find a sibling host\r\n  // node. Unfortunately, if multiple insertions are done in a row we have to\r\n  // search past them. This leads to exponential search for the next sibling.\r\n  // TODO: Find a more efficient way to do this.\r\n  let node: Fiber = fiber;\r\n  siblings: while (true) {\r\n    // If we didn't find anything, let's try the next sibling.\r\n    while (node.sibling === null) {\r\n      if (node.return === null || isHostParent(node.return)) {\r\n        // If we pop out of the root or hit the parent the fiber we are the\r\n        // last sibling.\r\n        return null;\r\n      }\r\n      node = node.return;\r\n    }\r\n    node.sibling.return = node.return;\r\n    node = node.sibling;\r\n    while (\r\n      node.tag !== HostComponent &&\r\n      node.tag !== HostText &&\r\n      node.tag !== DehydratedFragment\r\n    ) {\r\n      // If it is not host node and, we might have a host node inside it.\r\n      // Try to search down until we find one.\r\n      if (node.flags & Placement) {\r\n        // If we don't have a child, try the siblings instead.\r\n        continue siblings;\r\n      }\r\n      // If we don't have a child, try the siblings instead.\r\n      // We also skip portals because they are not part of this host tree.\r\n      if (node.child === null || node.tag === HostPortal) {\r\n        continue siblings;\r\n      } else {\r\n        node.child.return = node;\r\n        node = node.child;\r\n      }\r\n    }\r\n    // Check if this host node is stable or about to be placed.\r\n    if (!(node.flags & Placement)) {\r\n      // Found it!\r\n      return node.stateNode;\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitPlacement(finishedWork: Fiber): void {\r\n  if (!supportsMutation) {\r\n    return;\r\n  }\r\n\r\n  // Recursively insert all host nodes into the parent.\r\n  const parentFiber = getHostParentFiber(finishedWork);\r\n\r\n  // Note: these two variables *must* always be updated together.\r\n  switch (parentFiber.tag) {\r\n    case HostComponent: {\r\n      const parent: Instance = parentFiber.stateNode;\r\n      if (parentFiber.flags & ContentReset) {\r\n        // Reset the text content of the parent before doing any insertions\r\n        resetTextContent(parent);\r\n        // Clear ContentReset from the effect tag\r\n        parentFiber.flags &= ~ContentReset;\r\n      }\r\n\r\n      const before = getHostSibling(finishedWork);\r\n      // We only have the top Fiber that was inserted but we need to recurse down its\r\n      // children to find all the terminal nodes.\r\n      insertOrAppendPlacementNode(finishedWork, before, parent);\r\n      break;\r\n    }\r\n    case HostRoot:\r\n    case HostPortal: {\r\n      const parent: Container = parentFiber.stateNode.containerInfo;\r\n      const before = getHostSibling(finishedWork);\r\n      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\r\n      break;\r\n    }\r\n    // eslint-disable-next-line-no-fallthrough\r\n    default:\r\n      throw new Error(\r\n        'Invalid host parent fiber. This error is likely caused by a bug ' +\r\n          'in React. Please file an issue.',\r\n      );\r\n  }\r\n}\r\n\r\nfunction insertOrAppendPlacementNodeIntoContainer(\r\n  node: Fiber,\r\n  before: ?Instance,\r\n  parent: Container,\r\n): void {\r\n  const {tag} = node;\r\n  const isHost = tag === HostComponent || tag === HostText;\r\n  if (isHost) {\r\n    const stateNode = node.stateNode;\r\n    if (before) {\r\n      insertInContainerBefore(parent, stateNode, before);\r\n    } else {\r\n      appendChildToContainer(parent, stateNode);\r\n    }\r\n  } else if (tag === HostPortal) {\r\n    // If the insertion itself is a portal, then we don't want to traverse\r\n    // down its children. Instead, we'll get insertions from each child in\r\n    // the portal directly.\r\n  } else {\r\n    const child = node.child;\r\n    if (child !== null) {\r\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\r\n      let sibling = child.sibling;\r\n      while (sibling !== null) {\r\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\r\n        sibling = sibling.sibling;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction insertOrAppendPlacementNode(\r\n  node: Fiber,\r\n  before: ?Instance,\r\n  parent: Instance,\r\n): void {\r\n  const {tag} = node;\r\n  const isHost = tag === HostComponent || tag === HostText;\r\n  if (isHost) {\r\n    const stateNode = node.stateNode;\r\n    if (before) {\r\n      insertBefore(parent, stateNode, before);\r\n    } else {\r\n      appendChild(parent, stateNode);\r\n    }\r\n  } else if (tag === HostPortal) {\r\n    // If the insertion itself is a portal, then we don't want to traverse\r\n    // down its children. Instead, we'll get insertions from each child in\r\n    // the portal directly.\r\n  } else {\r\n    const child = node.child;\r\n    if (child !== null) {\r\n      insertOrAppendPlacementNode(child, before, parent);\r\n      let sibling = child.sibling;\r\n      while (sibling !== null) {\r\n        insertOrAppendPlacementNode(sibling, before, parent);\r\n        sibling = sibling.sibling;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// These are tracked on the stack as we recursively traverse a\r\n// deleted subtree.\r\n// TODO: Update these during the whole mutation phase, not just during\r\n// a deletion.\r\nlet hostParent: Instance | Container | null = null;\r\nlet hostParentIsContainer: boolean = false;\r\n\r\nfunction commitDeletionEffects(\r\n  root: FiberRoot,\r\n  returnFiber: Fiber,\r\n  deletedFiber: Fiber,\r\n) {\r\n  if (supportsMutation) {\r\n    // We only have the top Fiber that was deleted but we need to recurse down its\r\n    // children to find all the terminal nodes.\r\n\r\n    // Recursively delete all host nodes from the parent, detach refs, clean\r\n    // up mounted layout effects, and call componentWillUnmount.\r\n\r\n    // We only need to remove the topmost host child in each branch. But then we\r\n    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\r\n    // could split this into two separate traversals functions, where the second\r\n    // one doesn't include any removeChild logic. This is maybe the same\r\n    // function as \"disappearLayoutEffects\" (or whatever that turns into after\r\n    // the layout phase is refactored to use recursion).\r\n\r\n    // Before starting, find the nearest host parent on the stack so we know\r\n    // which instance/container to remove the children from.\r\n    // TODO: Instead of searching up the fiber return path on every deletion, we\r\n    // can track the nearest host component on the JS stack as we traverse the\r\n    // tree during the commit phase. This would make insertions faster, too.\r\n    let parent = returnFiber;\r\n    findParent: while (parent !== null) {\r\n      switch (parent.tag) {\r\n        case HostComponent: {\r\n          hostParent = parent.stateNode;\r\n          hostParentIsContainer = false;\r\n          break findParent;\r\n        }\r\n        case HostRoot: {\r\n          hostParent = parent.stateNode.containerInfo;\r\n          hostParentIsContainer = true;\r\n          break findParent;\r\n        }\r\n        case HostPortal: {\r\n          hostParent = parent.stateNode.containerInfo;\r\n          hostParentIsContainer = true;\r\n          break findParent;\r\n        }\r\n      }\r\n      parent = parent.return;\r\n    }\r\n    if (hostParent === null) {\r\n      throw new Error(\r\n        'Expected to find a host parent. This error is likely caused by ' +\r\n          'a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\r\n    hostParent = null;\r\n    hostParentIsContainer = false;\r\n  } else {\r\n    // Detach refs and call componentWillUnmount() on the whole subtree.\r\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\r\n  }\r\n\r\n  detachFiberMutation(deletedFiber);\r\n}\r\n\r\nfunction recursivelyTraverseDeletionEffects(\r\n  finishedRoot,\r\n  nearestMountedAncestor,\r\n  parent,\r\n) {\r\n  // TODO: Use a static flag to skip trees that don't have unmount effects\r\n  let child = parent.child;\r\n  while (child !== null) {\r\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\r\n    child = child.sibling;\r\n  }\r\n}\r\n\r\nfunction commitDeletionEffectsOnFiber(\r\n  finishedRoot: FiberRoot,\r\n  nearestMountedAncestor: Fiber,\r\n  deletedFiber: Fiber,\r\n) {\r\n  onCommitUnmount(deletedFiber);\r\n\r\n  // The cases in this outer switch modify the stack before they traverse\r\n  // into their subtree. There are simpler cases in the inner switch\r\n  // that don't modify the stack.\r\n  switch (deletedFiber.tag) {\r\n    case HostComponent: {\r\n      if (!offscreenSubtreeWasHidden) {\r\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\r\n      }\r\n      // Intentional fallthrough to next branch\r\n    }\r\n    // eslint-disable-next-line-no-fallthrough\r\n    case HostText: {\r\n      // We only need to remove the nearest host child. Set the host parent\r\n      // to `null` on the stack to indicate that nested children don't\r\n      // need to be removed.\r\n      if (supportsMutation) {\r\n        const prevHostParent = hostParent;\r\n        const prevHostParentIsContainer = hostParentIsContainer;\r\n        hostParent = null;\r\n        recursivelyTraverseDeletionEffects(\r\n          finishedRoot,\r\n          nearestMountedAncestor,\r\n          deletedFiber,\r\n        );\r\n        hostParent = prevHostParent;\r\n        hostParentIsContainer = prevHostParentIsContainer;\r\n\r\n        if (hostParent !== null) {\r\n          // Now that all the child effects have unmounted, we can remove the\r\n          // node from the tree.\r\n          if (hostParentIsContainer) {\r\n            removeChildFromContainer(\r\n              ((hostParent: any): Container),\r\n              (deletedFiber.stateNode: Instance | TextInstance),\r\n            );\r\n          } else {\r\n            removeChild(\r\n              ((hostParent: any): Instance),\r\n              (deletedFiber.stateNode: Instance | TextInstance),\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        recursivelyTraverseDeletionEffects(\r\n          finishedRoot,\r\n          nearestMountedAncestor,\r\n          deletedFiber,\r\n        );\r\n      }\r\n      return;\r\n    }\r\n    case DehydratedFragment: {\r\n      if (enableSuspenseCallback) {\r\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\r\n        if (hydrationCallbacks !== null) {\r\n          const onDeleted = hydrationCallbacks.onDeleted;\r\n          if (onDeleted) {\r\n            onDeleted((deletedFiber.stateNode: SuspenseInstance));\r\n          }\r\n        }\r\n      }\r\n\r\n      // Dehydrated fragments don't have any children\r\n\r\n      // Delete the dehydrated suspense boundary and all of its content.\r\n      if (supportsMutation) {\r\n        if (hostParent !== null) {\r\n          if (hostParentIsContainer) {\r\n            clearSuspenseBoundaryFromContainer(\r\n              ((hostParent: any): Container),\r\n              (deletedFiber.stateNode: SuspenseInstance),\r\n            );\r\n          } else {\r\n            clearSuspenseBoundary(\r\n              ((hostParent: any): Instance),\r\n              (deletedFiber.stateNode: SuspenseInstance),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case HostPortal: {\r\n      if (supportsMutation) {\r\n        // When we go into a portal, it becomes the parent to remove from.\r\n        const prevHostParent = hostParent;\r\n        const prevHostParentIsContainer = hostParentIsContainer;\r\n        hostParent = deletedFiber.stateNode.containerInfo;\r\n        hostParentIsContainer = true;\r\n        recursivelyTraverseDeletionEffects(\r\n          finishedRoot,\r\n          nearestMountedAncestor,\r\n          deletedFiber,\r\n        );\r\n        hostParent = prevHostParent;\r\n        hostParentIsContainer = prevHostParentIsContainer;\r\n      } else {\r\n        emptyPortalContainer(deletedFiber);\r\n\r\n        recursivelyTraverseDeletionEffects(\r\n          finishedRoot,\r\n          nearestMountedAncestor,\r\n          deletedFiber,\r\n        );\r\n      }\r\n      return;\r\n    }\r\n    case FunctionComponent:\r\n    case ForwardRef:\r\n    case MemoComponent:\r\n    case SimpleMemoComponent: {\r\n      if (!offscreenSubtreeWasHidden) {\r\n        const updateQueue: FunctionComponentUpdateQueue | null = (deletedFiber.updateQueue: any);\r\n        if (updateQueue !== null) {\r\n          const lastEffect = updateQueue.lastEffect;\r\n          if (lastEffect !== null) {\r\n            const firstEffect = lastEffect.next;\r\n\r\n            let effect = firstEffect;\r\n            do {\r\n              const {destroy, tag} = effect;\r\n              if (destroy !== undefined) {\r\n                if ((tag & HookInsertion) !== NoHookEffect) {\r\n                  safelyCallDestroy(\r\n                    deletedFiber,\r\n                    nearestMountedAncestor,\r\n                    destroy,\r\n                  );\r\n                } else if ((tag & HookLayout) !== NoHookEffect) {\r\n                  if (enableSchedulingProfiler) {\r\n                    markComponentLayoutEffectUnmountStarted(deletedFiber);\r\n                  }\r\n\r\n                  if (\r\n                    enableProfilerTimer &&\r\n                    enableProfilerCommitHooks &&\r\n                    deletedFiber.mode & ProfileMode\r\n                  ) {\r\n                    startLayoutEffectTimer();\r\n                    safelyCallDestroy(\r\n                      deletedFiber,\r\n                      nearestMountedAncestor,\r\n                      destroy,\r\n                    );\r\n                    recordLayoutEffectDuration(deletedFiber);\r\n                  } else {\r\n                    safelyCallDestroy(\r\n                      deletedFiber,\r\n                      nearestMountedAncestor,\r\n                      destroy,\r\n                    );\r\n                  }\r\n\r\n                  if (enableSchedulingProfiler) {\r\n                    markComponentLayoutEffectUnmountStopped();\r\n                  }\r\n                }\r\n              }\r\n              effect = effect.next;\r\n            } while (effect !== firstEffect);\r\n          }\r\n        }\r\n      }\r\n\r\n      recursivelyTraverseDeletionEffects(\r\n        finishedRoot,\r\n        nearestMountedAncestor,\r\n        deletedFiber,\r\n      );\r\n      return;\r\n    }\r\n    case ClassComponent: {\r\n      if (!offscreenSubtreeWasHidden) {\r\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\r\n        const instance = deletedFiber.stateNode;\r\n        if (typeof instance.componentWillUnmount === 'function') {\r\n          safelyCallComponentWillUnmount(\r\n            deletedFiber,\r\n            nearestMountedAncestor,\r\n            instance,\r\n          );\r\n        }\r\n      }\r\n      recursivelyTraverseDeletionEffects(\r\n        finishedRoot,\r\n        nearestMountedAncestor,\r\n        deletedFiber,\r\n      );\r\n      return;\r\n    }\r\n    case ScopeComponent: {\r\n      if (enableScopeAPI) {\r\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\r\n      }\r\n      recursivelyTraverseDeletionEffects(\r\n        finishedRoot,\r\n        nearestMountedAncestor,\r\n        deletedFiber,\r\n      );\r\n      return;\r\n    }\r\n    case OffscreenComponent: {\r\n      if (\r\n        // TODO: Remove this dead flag\r\n        enableSuspenseLayoutEffectSemantics &&\r\n        deletedFiber.mode & ConcurrentMode\r\n      ) {\r\n        // If this offscreen component is hidden, we already unmounted it. Before\r\n        // deleting the children, track that it's already unmounted so that we\r\n        // don't attempt to unmount the effects again.\r\n        // TODO: If the tree is hidden, in most cases we should be able to skip\r\n        // over the nested children entirely. An exception is we haven't yet found\r\n        // the topmost host node to delete, which we already track on the stack.\r\n        // But the other case is portals, which need to be detached no matter how\r\n        // deeply they are nested. We should use a subtree flag to track whether a\r\n        // subtree includes a nested portal.\r\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\r\n        offscreenSubtreeWasHidden =\r\n          prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\r\n        recursivelyTraverseDeletionEffects(\r\n          finishedRoot,\r\n          nearestMountedAncestor,\r\n          deletedFiber,\r\n        );\r\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\r\n      } else {\r\n        recursivelyTraverseDeletionEffects(\r\n          finishedRoot,\r\n          nearestMountedAncestor,\r\n          deletedFiber,\r\n        );\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      recursivelyTraverseDeletionEffects(\r\n        finishedRoot,\r\n        nearestMountedAncestor,\r\n        deletedFiber,\r\n      );\r\n      return;\r\n    }\r\n  }\r\n}\r\nfunction commitSuspenseCallback(finishedWork: Fiber) {\r\n  // TODO: Move this to passive phase\r\n  const newState: SuspenseState | null = finishedWork.memoizedState;\r\n  if (enableSuspenseCallback && newState !== null) {\r\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\r\n    if (typeof suspenseCallback === 'function') {\r\n      const wakeables: Set<Wakeable> | null = (finishedWork.updateQueue: any);\r\n      if (wakeables !== null) {\r\n        suspenseCallback(new Set(wakeables));\r\n      }\r\n    } else if (__DEV__) {\r\n      if (suspenseCallback !== undefined) {\r\n        console.error('Unexpected type for suspenseCallback.');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitSuspenseHydrationCallbacks(\r\n  finishedRoot: FiberRoot,\r\n  finishedWork: Fiber,\r\n) {\r\n  if (!supportsHydration) {\r\n    return;\r\n  }\r\n  const newState: SuspenseState | null = finishedWork.memoizedState;\r\n  if (newState === null) {\r\n    const current = finishedWork.alternate;\r\n    if (current !== null) {\r\n      const prevState: SuspenseState | null = current.memoizedState;\r\n      if (prevState !== null) {\r\n        const suspenseInstance = prevState.dehydrated;\r\n        if (suspenseInstance !== null) {\r\n          commitHydratedSuspenseInstance(suspenseInstance);\r\n          if (enableSuspenseCallback) {\r\n            const hydrationCallbacks = finishedRoot.hydrationCallbacks;\r\n            if (hydrationCallbacks !== null) {\r\n              const onHydrated = hydrationCallbacks.onHydrated;\r\n              if (onHydrated) {\r\n                onHydrated(suspenseInstance);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction attachSuspenseRetryListeners(finishedWork: Fiber) {\r\n  // If this boundary just timed out, then it will have a set of wakeables.\r\n  // For each wakeable, attach a listener so that when it resolves, React\r\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\r\n  const wakeables: Set<Wakeable> | null = (finishedWork.updateQueue: any);\r\n  if (wakeables !== null) {\r\n    finishedWork.updateQueue = null;\r\n    let retryCache = finishedWork.stateNode;\r\n    if (retryCache === null) {\r\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\r\n    }\r\n    wakeables.forEach(wakeable => {\r\n      // Memoize using the boundary fiber to prevent redundant listeners.\r\n      const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\r\n      if (!retryCache.has(wakeable)) {\r\n        retryCache.add(wakeable);\r\n\r\n        if (enableUpdaterTracking) {\r\n          if (isDevToolsPresent) {\r\n            if (inProgressLanes !== null && inProgressRoot !== null) {\r\n              // If we have pending work still, associate the original updaters with it.\r\n              restorePendingUpdaters(inProgressRoot, inProgressLanes);\r\n            } else {\r\n              throw Error(\r\n                'Expected finished root and lanes to be set. This is a bug in React.',\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        wakeable.then(retry, retry);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// This function detects when a Suspense boundary goes from visible to hidden.\r\n// It returns false if the boundary is already hidden.\r\n// TODO: Use an effect tag.\r\nexport function isSuspenseBoundaryBeingHidden(\r\n  current: Fiber | null,\r\n  finishedWork: Fiber,\r\n): boolean {\r\n  if (current !== null) {\r\n    const oldState: SuspenseState | null = current.memoizedState;\r\n    if (oldState === null || oldState.dehydrated !== null) {\r\n      const newState: SuspenseState | null = finishedWork.memoizedState;\r\n      return newState !== null && newState.dehydrated === null;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function commitMutationEffects(\r\n  root: FiberRoot,\r\n  finishedWork: Fiber,\r\n  committedLanes: Lanes,\r\n) {\r\n  inProgressLanes = committedLanes;\r\n  inProgressRoot = root;\r\n\r\n  setCurrentDebugFiberInDEV(finishedWork);\r\n  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);\r\n  setCurrentDebugFiberInDEV(finishedWork);\r\n\r\n  inProgressLanes = null;\r\n  inProgressRoot = null;\r\n}\r\n\r\nfunction recursivelyTraverseMutationEffects(\r\n  root: FiberRoot,\r\n  parentFiber: Fiber,\r\n  lanes: Lanes,\r\n) {\r\n  // Deletions effects can be scheduled on any fiber type. They need to happen\r\n  // before the children effects hae fired.\r\n  const deletions = parentFiber.deletions;\r\n  if (deletions !== null) {\r\n    for (let i = 0; i < deletions.length; i++) {\r\n      const childToDelete = deletions[i];\r\n      try {\r\n        commitDeletionEffects(root, parentFiber, childToDelete);\r\n      } catch (error) {\r\n        captureCommitPhaseError(childToDelete, parentFiber, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\r\n  if (parentFiber.subtreeFlags & MutationMask) {\r\n    let child = parentFiber.child;\r\n    while (child !== null) {\r\n      setCurrentDebugFiberInDEV(child);\r\n      commitMutationEffectsOnFiber(child, root, lanes);\r\n      child = child.sibling;\r\n    }\r\n  }\r\n  setCurrentDebugFiberInDEV(prevDebugFiber);\r\n}\r\n\r\nfunction commitMutationEffectsOnFiber(\r\n  finishedWork: Fiber,\r\n  root: FiberRoot,\r\n  lanes: Lanes,\r\n) {\r\n  const current = finishedWork.alternate;\r\n  const flags = finishedWork.flags;\r\n\r\n  // The effect flag should be checked *after* we refine the type of fiber,\r\n  // because the fiber tag is more specific. An exception is any flag related\r\n  // to reconcilation, because those can be set on all fiber types.\r\n  switch (finishedWork.tag) {\r\n    case FunctionComponent:\r\n    case ForwardRef:\r\n    case MemoComponent:\r\n    case SimpleMemoComponent: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Update) {\r\n        try {\r\n          commitHookEffectListUnmount(\r\n            HookInsertion | HookHasEffect,\r\n            finishedWork,\r\n            finishedWork.return,\r\n          );\r\n          commitHookEffectListMount(\r\n            HookInsertion | HookHasEffect,\r\n            finishedWork,\r\n          );\r\n        } catch (error) {\r\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n        }\r\n        // Layout effects are destroyed during the mutation phase so that all\r\n        // destroy functions for all fibers are called before any create functions.\r\n        // This prevents sibling component effects from interfering with each other,\r\n        // e.g. a destroy function in one component should never override a ref set\r\n        // by a create function in another component during the same commit.\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          finishedWork.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startLayoutEffectTimer();\r\n            commitHookEffectListUnmount(\r\n              HookLayout | HookHasEffect,\r\n              finishedWork,\r\n              finishedWork.return,\r\n            );\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n          recordLayoutEffectDuration(finishedWork);\r\n        } else {\r\n          try {\r\n            commitHookEffectListUnmount(\r\n              HookLayout | HookHasEffect,\r\n              finishedWork,\r\n              finishedWork.return,\r\n            );\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case ClassComponent: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Ref) {\r\n        if (current !== null) {\r\n          safelyDetachRef(current, current.return);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case HostComponent: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Ref) {\r\n        if (current !== null) {\r\n          safelyDetachRef(current, current.return);\r\n        }\r\n      }\r\n      if (supportsMutation) {\r\n        // TODO: ContentReset gets cleared by the children during the commit\r\n        // phase. This is a refactor hazard because it means we must read\r\n        // flags the flags after `commitReconciliationEffects` has already run;\r\n        // the order matters. We should refactor so that ContentReset does not\r\n        // rely on mutating the flag during commit. Like by setting a flag\r\n        // during the render phase instead.\r\n        if (finishedWork.flags & ContentReset) {\r\n          const instance: Instance = finishedWork.stateNode;\r\n          try {\r\n            resetTextContent(instance);\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n        }\r\n\r\n        if (flags & Update) {\r\n          const instance: Instance = finishedWork.stateNode;\r\n          if (instance != null) {\r\n            // Commit the work prepared earlier.\r\n            const newProps = finishedWork.memoizedProps;\r\n            // For hydration we reuse the update path but we treat the oldProps\r\n            // as the newProps. The updatePayload will contain the real change in\r\n            // this case.\r\n            const oldProps =\r\n              current !== null ? current.memoizedProps : newProps;\r\n            const type = finishedWork.type;\r\n            // TODO: Type the updateQueue to be specific to host components.\r\n            const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\r\n            finishedWork.updateQueue = null;\r\n            if (updatePayload !== null) {\r\n              try {\r\n                commitUpdate(\r\n                  instance,\r\n                  updatePayload,\r\n                  type,\r\n                  oldProps,\r\n                  newProps,\r\n                  finishedWork,\r\n                );\r\n              } catch (error) {\r\n                captureCommitPhaseError(\r\n                  finishedWork,\r\n                  finishedWork.return,\r\n                  error,\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case HostText: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Update) {\r\n        if (supportsMutation) {\r\n          if (finishedWork.stateNode === null) {\r\n            throw new Error(\r\n              'This should have a text node initialized. This error is likely ' +\r\n                'caused by a bug in React. Please file an issue.',\r\n            );\r\n          }\r\n\r\n          const textInstance: TextInstance = finishedWork.stateNode;\r\n          const newText: string = finishedWork.memoizedProps;\r\n          // For hydration we reuse the update path but we treat the oldProps\r\n          // as the newProps. The updatePayload will contain the real change in\r\n          // this case.\r\n          const oldText: string =\r\n            current !== null ? current.memoizedProps : newText;\r\n\r\n          try {\r\n            commitTextUpdate(textInstance, oldText, newText);\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case HostRoot: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Update) {\r\n        if (supportsMutation && supportsHydration) {\r\n          if (current !== null) {\r\n            const prevRootState: RootState = current.memoizedState;\r\n            if (prevRootState.isDehydrated) {\r\n              try {\r\n                commitHydratedContainer(root.containerInfo);\r\n              } catch (error) {\r\n                captureCommitPhaseError(\r\n                  finishedWork,\r\n                  finishedWork.return,\r\n                  error,\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (supportsPersistence) {\r\n          const containerInfo = root.containerInfo;\r\n          const pendingChildren = root.pendingChildren;\r\n          try {\r\n            replaceContainerChildren(containerInfo, pendingChildren);\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case HostPortal: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Update) {\r\n        if (supportsPersistence) {\r\n          const portal = finishedWork.stateNode;\r\n          const containerInfo = portal.containerInfo;\r\n          const pendingChildren = portal.pendingChildren;\r\n          try {\r\n            replaceContainerChildren(containerInfo, pendingChildren);\r\n          } catch (error) {\r\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n          }\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case SuspenseComponent: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      const offscreenFiber: Fiber = (finishedWork.child: any);\r\n\r\n      if (offscreenFiber.flags & Visibility) {\r\n        const newState: OffscreenState | null = offscreenFiber.memoizedState;\r\n        const isHidden = newState !== null;\r\n        if (isHidden) {\r\n          const wasHidden =\r\n            offscreenFiber.alternate !== null &&\r\n            offscreenFiber.alternate.memoizedState !== null;\r\n          if (!wasHidden) {\r\n            // TODO: Move to passive phase\r\n            markCommitTimeOfFallback();\r\n          }\r\n        }\r\n      }\r\n\r\n      if (flags & Update) {\r\n        try {\r\n          commitSuspenseCallback(finishedWork);\r\n        } catch (error) {\r\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n        }\r\n        attachSuspenseRetryListeners(finishedWork);\r\n      }\r\n      return;\r\n    }\r\n    case OffscreenComponent: {\r\n      const wasHidden = current !== null && current.memoizedState !== null;\r\n\r\n      if (\r\n        // TODO: Remove this dead flag\r\n        enableSuspenseLayoutEffectSemantics &&\r\n        finishedWork.mode & ConcurrentMode\r\n      ) {\r\n        // Before committing the children, track on the stack whether this\r\n        // offscreen subtree was already hidden, so that we don't unmount the\r\n        // effects again.\r\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\r\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\r\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\r\n      } else {\r\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      }\r\n\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Visibility) {\r\n        const newState: OffscreenState | null = finishedWork.memoizedState;\r\n        const isHidden = newState !== null;\r\n        const offscreenBoundary: Fiber = finishedWork;\r\n\r\n        if (supportsMutation) {\r\n          // TODO: This needs to run whenever there's an insertion or update\r\n          // inside a hidden Offscreen tree.\r\n          hideOrUnhideAllChildren(offscreenBoundary, isHidden);\r\n        }\r\n\r\n        if (enableSuspenseLayoutEffectSemantics) {\r\n          if (isHidden) {\r\n            if (!wasHidden) {\r\n              if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\r\n                nextEffect = offscreenBoundary;\r\n                let offscreenChild = offscreenBoundary.child;\r\n                while (offscreenChild !== null) {\r\n                  nextEffect = offscreenChild;\r\n                  disappearLayoutEffects_begin(offscreenChild);\r\n                  offscreenChild = offscreenChild.sibling;\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            if (wasHidden) {\r\n              // TODO: Move re-appear call here for symmetry?\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    case SuspenseListComponent: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      if (flags & Update) {\r\n        attachSuspenseRetryListeners(finishedWork);\r\n      }\r\n      return;\r\n    }\r\n    case ScopeComponent: {\r\n      if (enableScopeAPI) {\r\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n        commitReconciliationEffects(finishedWork);\r\n\r\n        // TODO: This is a temporary solution that allowed us to transition away\r\n        // from React Flare on www.\r\n        if (flags & Ref) {\r\n          if (current !== null) {\r\n            safelyDetachRef(finishedWork, finishedWork.return);\r\n          }\r\n          safelyAttachRef(finishedWork, finishedWork.return);\r\n        }\r\n        if (flags & Update) {\r\n          const scopeInstance = finishedWork.stateNode;\r\n          prepareScopeUpdate(scopeInstance, finishedWork);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n    default: {\r\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\r\n      commitReconciliationEffects(finishedWork);\r\n\r\n      return;\r\n    }\r\n  }\r\n}\r\nfunction commitReconciliationEffects(finishedWork: Fiber) {\r\n  // Placement effects (insertions, reorders) can be scheduled on any fiber\r\n  // type. They needs to happen after the children effects have fired, but\r\n  // before the effects on this fiber have fired.\r\n  const flags = finishedWork.flags;\r\n  if (flags & Placement) {\r\n    try {\r\n      commitPlacement(finishedWork);\r\n    } catch (error) {\r\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\r\n    }\r\n    // Clear the \"placement\" from effect tag so that we know that this is\r\n    // inserted, before any life-cycles like componentDidMount gets called.\r\n    // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n    // and isMounted is deprecated anyway so we should be able to kill this.\r\n    finishedWork.flags &= ~Placement;\r\n  }\r\n  if (flags & Hydrating) {\r\n    finishedWork.flags &= ~Hydrating;\r\n  }\r\n}\r\n\r\nexport function commitLayoutEffects(\r\n  finishedWork: Fiber,\r\n  root: FiberRoot,\r\n  committedLanes: Lanes,\r\n): void {\r\n  inProgressLanes = committedLanes;\r\n  inProgressRoot = root;\r\n  nextEffect = finishedWork;\r\n\r\n  commitLayoutEffects_begin(finishedWork, root, committedLanes);\r\n\r\n  inProgressLanes = null;\r\n  inProgressRoot = null;\r\n}\r\n\r\nfunction commitLayoutEffects_begin(\r\n  subtreeRoot: Fiber,\r\n  root: FiberRoot,\r\n  committedLanes: Lanes,\r\n) {\r\n  // Suspense layout effects semantics don't change for legacy roots.\r\n  const isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\r\n\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    const firstChild = fiber.child;\r\n\r\n    if (\r\n      enableSuspenseLayoutEffectSemantics &&\r\n      fiber.tag === OffscreenComponent &&\r\n      isModernRoot\r\n    ) {\r\n      // Keep track of the current Offscreen stack's state.\r\n      const isHidden = fiber.memoizedState !== null;\r\n      const newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\r\n      if (newOffscreenSubtreeIsHidden) {\r\n        // The Offscreen tree is hidden. Skip over its layout effects.\r\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\r\n        continue;\r\n      } else {\r\n        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\r\n        const current = fiber.alternate;\r\n        const wasHidden = current !== null && current.memoizedState !== null;\r\n        const newOffscreenSubtreeWasHidden =\r\n          wasHidden || offscreenSubtreeWasHidden;\r\n        const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\r\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\r\n\r\n        // Traverse the Offscreen subtree with the current Offscreen as the root.\r\n        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\r\n        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\r\n\r\n        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\r\n          // This is the root of a reappearing boundary. Turn its layout effects\r\n          // back on.\r\n          nextEffect = fiber;\r\n          reappearLayoutEffects_begin(fiber);\r\n        }\r\n\r\n        let child = firstChild;\r\n        while (child !== null) {\r\n          nextEffect = child;\r\n          commitLayoutEffects_begin(\r\n            child, // New root; bubble back up to here and stop.\r\n            root,\r\n            committedLanes,\r\n          );\r\n          child = child.sibling;\r\n        }\r\n\r\n        // Restore Offscreen state and resume in our-progress traversal.\r\n        nextEffect = fiber;\r\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\r\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\r\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\r\n\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\r\n      firstChild.return = fiber;\r\n      nextEffect = firstChild;\r\n    } else {\r\n      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitLayoutMountEffects_complete(\r\n  subtreeRoot: Fiber,\r\n  root: FiberRoot,\r\n  committedLanes: Lanes,\r\n) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    if ((fiber.flags & LayoutMask) !== NoFlags) {\r\n      const current = fiber.alternate;\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      try {\r\n        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\r\n      } catch (error) {\r\n        captureCommitPhaseError(fiber, fiber.return, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n\r\n    if (fiber === subtreeRoot) {\r\n      nextEffect = null;\r\n      return;\r\n    }\r\n\r\n    const sibling = fiber.sibling;\r\n    if (sibling !== null) {\r\n      sibling.return = fiber.return;\r\n      nextEffect = sibling;\r\n      return;\r\n    }\r\n\r\n    nextEffect = fiber.return;\r\n  }\r\n}\r\n\r\nfunction disappearLayoutEffects_begin(subtreeRoot: Fiber) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    const firstChild = fiber.child;\r\n\r\n    // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\r\n    switch (fiber.tag) {\r\n      case FunctionComponent:\r\n      case ForwardRef:\r\n      case MemoComponent:\r\n      case SimpleMemoComponent: {\r\n        if (\r\n          enableProfilerTimer &&\r\n          enableProfilerCommitHooks &&\r\n          fiber.mode & ProfileMode\r\n        ) {\r\n          try {\r\n            startLayoutEffectTimer();\r\n            commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\r\n          } finally {\r\n            recordLayoutEffectDuration(fiber);\r\n          }\r\n        } else {\r\n          commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\r\n        }\r\n        break;\r\n      }\r\n      case ClassComponent: {\r\n        // TODO (Offscreen) Check: flags & RefStatic\r\n        safelyDetachRef(fiber, fiber.return);\r\n\r\n        const instance = fiber.stateNode;\r\n        if (typeof instance.componentWillUnmount === 'function') {\r\n          safelyCallComponentWillUnmount(fiber, fiber.return, instance);\r\n        }\r\n        break;\r\n      }\r\n      case HostComponent: {\r\n        safelyDetachRef(fiber, fiber.return);\r\n        break;\r\n      }\r\n      case OffscreenComponent: {\r\n        // Check if this is a\r\n        const isHidden = fiber.memoizedState !== null;\r\n        if (isHidden) {\r\n          // Nested Offscreen tree is already hidden. Don't disappear\r\n          // its effects.\r\n          disappearLayoutEffects_complete(subtreeRoot);\r\n          continue;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\r\n    if (firstChild !== null) {\r\n      firstChild.return = fiber;\r\n      nextEffect = firstChild;\r\n    } else {\r\n      disappearLayoutEffects_complete(subtreeRoot);\r\n    }\r\n  }\r\n}\r\n\r\nfunction disappearLayoutEffects_complete(subtreeRoot: Fiber) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n\r\n    if (fiber === subtreeRoot) {\r\n      nextEffect = null;\r\n      return;\r\n    }\r\n\r\n    const sibling = fiber.sibling;\r\n    if (sibling !== null) {\r\n      sibling.return = fiber.return;\r\n      nextEffect = sibling;\r\n      return;\r\n    }\r\n\r\n    nextEffect = fiber.return;\r\n  }\r\n}\r\n\r\nfunction reappearLayoutEffects_begin(subtreeRoot: Fiber) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    const firstChild = fiber.child;\r\n\r\n    if (fiber.tag === OffscreenComponent) {\r\n      const isHidden = fiber.memoizedState !== null;\r\n      if (isHidden) {\r\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\r\n        reappearLayoutEffects_complete(subtreeRoot);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\r\n    if (firstChild !== null) {\r\n      // This node may have been reused from a previous render, so we can't\r\n      // assume its return pointer is correct.\r\n      firstChild.return = fiber;\r\n      nextEffect = firstChild;\r\n    } else {\r\n      reappearLayoutEffects_complete(subtreeRoot);\r\n    }\r\n  }\r\n}\r\n\r\nfunction reappearLayoutEffects_complete(subtreeRoot: Fiber) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n\r\n    // TODO (Offscreen) Check: flags & LayoutStatic\r\n    setCurrentDebugFiberInDEV(fiber);\r\n    try {\r\n      reappearLayoutEffectsOnFiber(fiber);\r\n    } catch (error) {\r\n      captureCommitPhaseError(fiber, fiber.return, error);\r\n    }\r\n    resetCurrentDebugFiberInDEV();\r\n\r\n    if (fiber === subtreeRoot) {\r\n      nextEffect = null;\r\n      return;\r\n    }\r\n\r\n    const sibling = fiber.sibling;\r\n    if (sibling !== null) {\r\n      // This node may have been reused from a previous render, so we can't\r\n      // assume its return pointer is correct.\r\n      sibling.return = fiber.return;\r\n      nextEffect = sibling;\r\n      return;\r\n    }\r\n\r\n    nextEffect = fiber.return;\r\n  }\r\n}\r\n\r\nexport function commitPassiveMountEffects(\r\n  root: FiberRoot,\r\n  finishedWork: Fiber,\r\n  committedLanes: Lanes,\r\n  committedTransitions: Array<Transition> | null,\r\n): void {\r\n  nextEffect = finishedWork;\r\n  commitPassiveMountEffects_begin(\r\n    finishedWork,\r\n    root,\r\n    committedLanes,\r\n    committedTransitions,\r\n  );\r\n}\r\n\r\nfunction commitPassiveMountEffects_begin(\r\n  subtreeRoot: Fiber,\r\n  root: FiberRoot,\r\n  committedLanes: Lanes,\r\n  committedTransitions: Array<Transition> | null,\r\n) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    const firstChild = fiber.child;\r\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\r\n      firstChild.return = fiber;\r\n      nextEffect = firstChild;\r\n    } else {\r\n      commitPassiveMountEffects_complete(\r\n        subtreeRoot,\r\n        root,\r\n        committedLanes,\r\n        committedTransitions,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitPassiveMountEffects_complete(\r\n  subtreeRoot: Fiber,\r\n  root: FiberRoot,\r\n  committedLanes: Lanes,\r\n  committedTransitions: Array<Transition> | null,\r\n) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n\r\n    if ((fiber.flags & Passive) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      try {\r\n        commitPassiveMountOnFiber(\r\n          root,\r\n          fiber,\r\n          committedLanes,\r\n          committedTransitions,\r\n        );\r\n      } catch (error) {\r\n        captureCommitPhaseError(fiber, fiber.return, error);\r\n      }\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n\r\n    if (fiber === subtreeRoot) {\r\n      nextEffect = null;\r\n      return;\r\n    }\r\n\r\n    const sibling = fiber.sibling;\r\n    if (sibling !== null) {\r\n      sibling.return = fiber.return;\r\n      nextEffect = sibling;\r\n      return;\r\n    }\r\n\r\n    nextEffect = fiber.return;\r\n  }\r\n}\r\n\r\nfunction commitPassiveMountOnFiber(\r\n  finishedRoot: FiberRoot,\r\n  finishedWork: Fiber,\r\n  committedLanes: Lanes,\r\n  committedTransitions: Array<Transition> | null,\r\n): void {\r\n  switch (finishedWork.tag) {\r\n    case FunctionComponent:\r\n    case ForwardRef:\r\n    case SimpleMemoComponent: {\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        finishedWork.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        try {\r\n          commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\r\n        } finally {\r\n          recordPassiveEffectDuration(finishedWork);\r\n        }\r\n      } else {\r\n        commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\r\n      }\r\n      break;\r\n    }\r\n    case HostRoot: {\r\n      if (enableCache) {\r\n        let previousCache: Cache | null = null;\r\n        if (finishedWork.alternate !== null) {\r\n          previousCache = finishedWork.alternate.memoizedState.cache;\r\n        }\r\n        const nextCache = finishedWork.memoizedState.cache;\r\n        // Retain/release the root cache.\r\n        // Note that on initial mount, previousCache and nextCache will be the same\r\n        // and this retain won't occur. To counter this, we instead retain the HostRoot's\r\n        // initial cache when creating the root itself (see createFiberRoot() in\r\n        // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\r\n        // here, such that previous/next caches are retained correctly.\r\n        if (nextCache !== previousCache) {\r\n          retainCache(nextCache);\r\n          if (previousCache != null) {\r\n            releaseCache(previousCache);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (enableTransitionTracing) {\r\n        if (committedTransitions !== null) {\r\n          committedTransitions.forEach(transition => {\r\n            // TODO(luna) Do we want to log TransitionStart in the startTransition callback instead?\r\n            addTransitionStartCallbackToPendingTransition({\r\n              transitionName: transition.name,\r\n              startTime: transition.startTime,\r\n            });\r\n\r\n            addTransitionCompleteCallbackToPendingTransition({\r\n              transitionName: transition.name,\r\n              startTime: transition.startTime,\r\n            });\r\n          });\r\n\r\n          clearTransitionsForLanes(finishedRoot, committedLanes);\r\n          finishedWork.memoizedState.transitions = null;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case LegacyHiddenComponent:\r\n    case OffscreenComponent: {\r\n      if (enableCache) {\r\n        let previousCache: Cache | null = null;\r\n        if (\r\n          finishedWork.alternate !== null &&\r\n          finishedWork.alternate.memoizedState !== null &&\r\n          finishedWork.alternate.memoizedState.cachePool !== null\r\n        ) {\r\n          previousCache = finishedWork.alternate.memoizedState.cachePool.pool;\r\n        }\r\n        let nextCache: Cache | null = null;\r\n        if (\r\n          finishedWork.memoizedState !== null &&\r\n          finishedWork.memoizedState.cachePool !== null\r\n        ) {\r\n          nextCache = finishedWork.memoizedState.cachePool.pool;\r\n        }\r\n        // Retain/release the cache used for pending (suspended) nodes.\r\n        // Note that this is only reached in the non-suspended/visible case:\r\n        // when the content is suspended/hidden, the retain/release occurs\r\n        // via the parent Suspense component (see case above).\r\n        if (nextCache !== previousCache) {\r\n          if (nextCache != null) {\r\n            retainCache(nextCache);\r\n          }\r\n          if (previousCache != null) {\r\n            releaseCache(previousCache);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (enableTransitionTracing) {\r\n        // TODO: Add code to actually process the update queue\r\n        finishedWork.updateQueue = null;\r\n      }\r\n      break;\r\n    }\r\n    case CacheComponent: {\r\n      if (enableCache) {\r\n        let previousCache: Cache | null = null;\r\n        if (finishedWork.alternate !== null) {\r\n          previousCache = finishedWork.alternate.memoizedState.cache;\r\n        }\r\n        const nextCache = finishedWork.memoizedState.cache;\r\n        // Retain/release the cache. In theory the cache component\r\n        // could be \"borrowing\" a cache instance owned by some parent,\r\n        // in which case we could avoid retaining/releasing. But it\r\n        // is non-trivial to determine when that is the case, so we\r\n        // always retain/release.\r\n        if (nextCache !== previousCache) {\r\n          retainCache(nextCache);\r\n          if (previousCache != null) {\r\n            releaseCache(previousCache);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nexport function commitPassiveUnmountEffects(firstChild: Fiber): void {\r\n  nextEffect = firstChild;\r\n  commitPassiveUnmountEffects_begin();\r\n}\r\n\r\nfunction commitPassiveUnmountEffects_begin() {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    const child = fiber.child;\r\n\r\n    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\r\n      const deletions = fiber.deletions;\r\n      if (deletions !== null) {\r\n        for (let i = 0; i < deletions.length; i++) {\r\n          const fiberToDelete = deletions[i];\r\n          nextEffect = fiberToDelete;\r\n          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\r\n            fiberToDelete,\r\n            fiber,\r\n          );\r\n        }\r\n\r\n        if (deletedTreeCleanUpLevel >= 1) {\r\n          // A fiber was deleted from this parent fiber, but it's still part of\r\n          // the previous (alternate) parent fiber's list of children. Because\r\n          // children are a linked list, an earlier sibling that's still alive\r\n          // will be connected to the deleted fiber via its `alternate`:\r\n          //\r\n          //   live fiber\r\n          //   --alternate--> previous live fiber\r\n          //   --sibling--> deleted fiber\r\n          //\r\n          // We can't disconnect `alternate` on nodes that haven't been deleted\r\n          // yet, but we can disconnect the `sibling` and `child` pointers.\r\n          const previousFiber = fiber.alternate;\r\n          if (previousFiber !== null) {\r\n            let detachedChild = previousFiber.child;\r\n            if (detachedChild !== null) {\r\n              previousFiber.child = null;\r\n              do {\r\n                const detachedSibling = detachedChild.sibling;\r\n                detachedChild.sibling = null;\r\n                detachedChild = detachedSibling;\r\n              } while (detachedChild !== null);\r\n            }\r\n          }\r\n        }\r\n\r\n        nextEffect = fiber;\r\n      }\r\n    }\r\n\r\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\r\n      child.return = fiber;\r\n      nextEffect = child;\r\n    } else {\r\n      commitPassiveUnmountEffects_complete();\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitPassiveUnmountEffects_complete() {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    if ((fiber.flags & Passive) !== NoFlags) {\r\n      setCurrentDebugFiberInDEV(fiber);\r\n      commitPassiveUnmountOnFiber(fiber);\r\n      resetCurrentDebugFiberInDEV();\r\n    }\r\n\r\n    const sibling = fiber.sibling;\r\n    if (sibling !== null) {\r\n      sibling.return = fiber.return;\r\n      nextEffect = sibling;\r\n      return;\r\n    }\r\n\r\n    nextEffect = fiber.return;\r\n  }\r\n}\r\n\r\nfunction commitPassiveUnmountOnFiber(finishedWork: Fiber): void {\r\n  switch (finishedWork.tag) {\r\n    case FunctionComponent:\r\n    case ForwardRef:\r\n    case SimpleMemoComponent: {\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        finishedWork.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        commitHookEffectListUnmount(\r\n          HookPassive | HookHasEffect,\r\n          finishedWork,\r\n          finishedWork.return,\r\n        );\r\n        recordPassiveEffectDuration(finishedWork);\r\n      } else {\r\n        commitHookEffectListUnmount(\r\n          HookPassive | HookHasEffect,\r\n          finishedWork,\r\n          finishedWork.return,\r\n        );\r\n      }\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\r\n  deletedSubtreeRoot: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n\r\n    // Deletion effects fire in parent -> child order\r\n    // TODO: Check if fiber has a PassiveStatic flag\r\n    setCurrentDebugFiberInDEV(fiber);\r\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\r\n    resetCurrentDebugFiberInDEV();\r\n\r\n    const child = fiber.child;\r\n    // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\r\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\r\n    if (child !== null) {\r\n      child.return = fiber;\r\n      nextEffect = child;\r\n    } else {\r\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(\r\n        deletedSubtreeRoot,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(\r\n  deletedSubtreeRoot: Fiber,\r\n) {\r\n  while (nextEffect !== null) {\r\n    const fiber = nextEffect;\r\n    const sibling = fiber.sibling;\r\n    const returnFiber = fiber.return;\r\n\r\n    if (deletedTreeCleanUpLevel >= 2) {\r\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\r\n      // This is more aggressive than ideal, and the long term goal is to only\r\n      // have to detach the deleted tree at the root.\r\n      detachFiberAfterEffects(fiber);\r\n      if (fiber === deletedSubtreeRoot) {\r\n        nextEffect = null;\r\n        return;\r\n      }\r\n    } else {\r\n      // This is the default branch (level 0). We do not recursively clear all\r\n      // the fiber fields. Only the root of the deleted subtree.\r\n      if (fiber === deletedSubtreeRoot) {\r\n        detachFiberAfterEffects(fiber);\r\n        nextEffect = null;\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (sibling !== null) {\r\n      sibling.return = returnFiber;\r\n      nextEffect = sibling;\r\n      return;\r\n    }\r\n\r\n    nextEffect = returnFiber;\r\n  }\r\n}\r\n\r\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(\r\n  current: Fiber,\r\n  nearestMountedAncestor: Fiber | null,\r\n): void {\r\n  switch (current.tag) {\r\n    case FunctionComponent:\r\n    case ForwardRef:\r\n    case SimpleMemoComponent: {\r\n      if (\r\n        enableProfilerTimer &&\r\n        enableProfilerCommitHooks &&\r\n        current.mode & ProfileMode\r\n      ) {\r\n        startPassiveEffectTimer();\r\n        commitHookEffectListUnmount(\r\n          HookPassive,\r\n          current,\r\n          nearestMountedAncestor,\r\n        );\r\n        recordPassiveEffectDuration(current);\r\n      } else {\r\n        commitHookEffectListUnmount(\r\n          HookPassive,\r\n          current,\r\n          nearestMountedAncestor,\r\n        );\r\n      }\r\n      break;\r\n    }\r\n    // TODO: run passive unmount effects when unmounting a root.\r\n    // Because passive unmount effects are not currently run,\r\n    // the cache instance owned by the root will never be freed.\r\n    // When effects are run, the cache should be freed here:\r\n    // case HostRoot: {\r\n    //   if (enableCache) {\r\n    //     const cache = current.memoizedState.cache;\r\n    //     releaseCache(cache);\r\n    //   }\r\n    //   break;\r\n    // }\r\n    case LegacyHiddenComponent:\r\n    case OffscreenComponent: {\r\n      if (enableCache) {\r\n        if (\r\n          current.memoizedState !== null &&\r\n          current.memoizedState.cachePool !== null\r\n        ) {\r\n          const cache: Cache = current.memoizedState.cachePool.pool;\r\n          // Retain/release the cache used for pending (suspended) nodes.\r\n          // Note that this is only reached in the non-suspended/visible case:\r\n          // when the content is suspended/hidden, the retain/release occurs\r\n          // via the parent Suspense component (see case above).\r\n          if (cache != null) {\r\n            retainCache(cache);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case CacheComponent: {\r\n      if (enableCache) {\r\n        const cache = current.memoizedState.cache;\r\n        releaseCache(cache);\r\n      }\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\n// TODO: Reuse reappearLayoutEffects traversal here?\r\nfunction invokeLayoutEffectMountInDEV(fiber: Fiber): void {\r\n  if (__DEV__ && enableStrictEffects) {\r\n    // We don't need to re-check StrictEffectsMode here.\r\n    // This function is only called if that check has already passed.\r\n    switch (fiber.tag) {\r\n      case FunctionComponent:\r\n      case ForwardRef:\r\n      case SimpleMemoComponent: {\r\n        try {\r\n          commitHookEffectListMount(HookLayout | HookHasEffect, fiber);\r\n        } catch (error) {\r\n          captureCommitPhaseError(fiber, fiber.return, error);\r\n        }\r\n        break;\r\n      }\r\n      case ClassComponent: {\r\n        const instance = fiber.stateNode;\r\n        try {\r\n          instance.componentDidMount();\r\n        } catch (error) {\r\n          captureCommitPhaseError(fiber, fiber.return, error);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectMountInDEV(fiber: Fiber): void {\r\n  if (__DEV__ && enableStrictEffects) {\r\n    // We don't need to re-check StrictEffectsMode here.\r\n    // This function is only called if that check has already passed.\r\n    switch (fiber.tag) {\r\n      case FunctionComponent:\r\n      case ForwardRef:\r\n      case SimpleMemoComponent: {\r\n        try {\r\n          commitHookEffectListMount(HookPassive | HookHasEffect, fiber);\r\n        } catch (error) {\r\n          captureCommitPhaseError(fiber, fiber.return, error);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction invokeLayoutEffectUnmountInDEV(fiber: Fiber): void {\r\n  if (__DEV__ && enableStrictEffects) {\r\n    // We don't need to re-check StrictEffectsMode here.\r\n    // This function is only called if that check has already passed.\r\n    switch (fiber.tag) {\r\n      case FunctionComponent:\r\n      case ForwardRef:\r\n      case SimpleMemoComponent: {\r\n        try {\r\n          commitHookEffectListUnmount(\r\n            HookLayout | HookHasEffect,\r\n            fiber,\r\n            fiber.return,\r\n          );\r\n        } catch (error) {\r\n          captureCommitPhaseError(fiber, fiber.return, error);\r\n        }\r\n        break;\r\n      }\r\n      case ClassComponent: {\r\n        const instance = fiber.stateNode;\r\n        if (typeof instance.componentWillUnmount === 'function') {\r\n          safelyCallComponentWillUnmount(fiber, fiber.return, instance);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction invokePassiveEffectUnmountInDEV(fiber: Fiber): void {\r\n  if (__DEV__ && enableStrictEffects) {\r\n    // We don't need to re-check StrictEffectsMode here.\r\n    // This function is only called if that check has already passed.\r\n    switch (fiber.tag) {\r\n      case FunctionComponent:\r\n      case ForwardRef:\r\n      case SimpleMemoComponent: {\r\n        try {\r\n          commitHookEffectListUnmount(\r\n            HookPassive | HookHasEffect,\r\n            fiber,\r\n            fiber.return,\r\n          );\r\n        } catch (error) {\r\n          captureCommitPhaseError(fiber, fiber.return, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  commitPlacement,\r\n  commitAttachRef,\r\n  commitDetachRef,\r\n  invokeLayoutEffectMountInDEV,\r\n  invokeLayoutEffectUnmountInDEV,\r\n  invokePassiveEffectMountInDEV,\r\n  invokePassiveEffectUnmountInDEV,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}