{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay } from 'shared/ReactFeatureFlags';\nimport { unstable_scheduleCallback as scheduleCallback, unstable_NormalPriority as NormalPriority } from 'scheduler';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/src/ReactFiberTreeReflection';\nimport { findInstanceBlockingEvent, return_targetInst } from './ReactDOMEventListener';\nimport { setReplayingEvent, resetReplayingEvent } from './CurrentReplayingEvent';\nimport { dispatchEventForPluginEventSystem } from './DOMPluginEventSystem';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { isHigherEventPriority } from 'react-reconciler/src/ReactEventPriorities';\nimport { isRootDehydrated } from 'react-reconciler/src/ReactFiberShellHydration';\n\nlet _attemptSynchronousHydration;\n\nexport function setAttemptSynchronousHydration(fn) {\n  _attemptSynchronousHydration = fn;\n}\nexport function attemptSynchronousHydration(fiber) {\n  _attemptSynchronousHydration(fiber);\n}\nlet attemptDiscreteHydration;\nexport function setAttemptDiscreteHydration(fn) {\n  attemptDiscreteHydration = fn;\n}\nlet attemptContinuousHydration;\nexport function setAttemptContinuousHydration(fn) {\n  attemptContinuousHydration = fn;\n}\nlet attemptHydrationAtCurrentPriority;\nexport function setAttemptHydrationAtCurrentPriority(fn) {\n  attemptHydrationAtCurrentPriority = fn;\n}\nlet getCurrentUpdatePriority;\nexport function setGetCurrentUpdatePriority(fn) {\n  getCurrentUpdatePriority = fn;\n}\nlet attemptHydrationAtPriority;\nexport function setAttemptHydrationAtPriority(fn) {\n  attemptHydrationAtPriority = fn;\n} // TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\n\nlet hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.\n\nconst queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.\n\nconst hasAnyQueuedContinuousEvents = false; // The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\n\nlet queuedFocus = null;\nlet queuedDrag = null;\nlet queuedMouse = null; // For pointer events there can be one latest event per pointerId.\n\nconst queuedPointers = new Map();\nconst queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.\n\nconst queuedExplicitHydrationTargets = [];\nexport function hasQueuedDiscreteEvents() {\n  return queuedDiscreteEvents.length > 0;\n}\nexport function hasQueuedContinuousEvents() {\n  return hasAnyQueuedContinuousEvents;\n}\nconst discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput', // Intentionally camelCase\n'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];\nexport function isDiscreteEventThatRequiresHydration(eventType) {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  return {\n    blockedOn,\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    targetContainers: [targetContainer]\n  };\n}\n\nexport function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    return;\n  }\n\n  const queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n  queuedDiscreteEvents.push(queuedEvent);\n\n  if (queuedDiscreteEvents.length === 1) {\n    // If this was the first discrete event, we might be able to\n    // synchronously unblock it so that preventDefault still works.\n    while (queuedEvent.blockedOn !== null) {\n      const fiber = getInstanceFromNode(queuedEvent.blockedOn);\n\n      if (fiber === null) {\n        break;\n      }\n\n      attemptSynchronousHydration(fiber);\n\n      if (queuedEvent.blockedOn === null) {\n        // We got unblocked by hydration. Let's try again.\n        replayUnblockedEvents(); // If we're reblocked, on an inner boundary, we might need\n        // to attempt hydrating that one.\n\n        continue;\n      } else {\n        // We're still blocked from hydration, we have to give up\n        // and replay later.\n        break;\n      }\n    }\n  }\n} // Resets the replaying for this type of continuous event to no event.\n\nexport function clearIfContinuousEvent(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case 'focusin':\n    case 'focusout':\n      queuedFocus = null;\n      break;\n\n    case 'dragenter':\n    case 'dragleave':\n      queuedDrag = null;\n      break;\n\n    case 'mouseover':\n    case 'mouseout':\n      queuedMouse = null;\n      break;\n\n    case 'pointerover':\n    case 'pointerout':\n      {\n        const pointerId = nativeEvent.pointerId;\n        queuedPointers.delete(pointerId);\n        break;\n      }\n\n    case 'gotpointercapture':\n    case 'lostpointercapture':\n      {\n        const pointerId = nativeEvent.pointerId;\n        queuedPointerCaptures.delete(pointerId);\n        break;\n      }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n    const queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n    if (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n\n    return queuedEvent;\n  } // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags, and the targetContainers, and\n  // store a single event to be replayed.\n\n\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  const targetContainers = existingQueuedEvent.targetContainers;\n\n  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\n    targetContainers.push(targetContainer);\n  }\n\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (domEventName) {\n    case 'focusin':\n      {\n        const focusEvent = nativeEvent;\n        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\n        return true;\n      }\n\n    case 'dragenter':\n      {\n        const dragEvent = nativeEvent;\n        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\n        return true;\n      }\n\n    case 'mouseover':\n      {\n        const mouseEvent = nativeEvent;\n        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\n        return true;\n      }\n\n    case 'pointerover':\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n        return true;\n      }\n\n    case 'gotpointercapture':\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n        return true;\n      }\n  }\n\n  return false;\n} // Check if this target is unblocked. Returns true if it's unblocked.\n\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  // TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  const targetInst = getClosestInstanceFromNode(queuedTarget.target);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          attemptHydrationAtPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (isRootDehydrated(root)) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of\n          // a root other than sync.\n\n          return;\n        }\n      }\n    }\n  }\n\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target) {\n  // TODO: This will read the priority if it's dispatched by the React\n  // event system but not native events. Should read window.event.type, like\n  // we do for updates (getCurrentEventPriority).\n  const updatePriority = getCurrentUpdatePriority();\n  const queuedTarget = {\n    blockedOn: null,\n    target: target,\n    priority: updatePriority\n  };\n  let i = 0;\n\n  for (; i < queuedExplicitHydrationTargets.length; i++) {\n    // Stop once we hit the first target with lower priority than\n    if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {\n      break;\n    }\n  }\n\n  queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n\n  if (i === 0) {\n    attemptExplicitHydrationTarget(queuedTarget);\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n\n  const targetContainers = queuedEvent.targetContainers;\n\n  while (targetContainers.length > 0) {\n    const targetContainer = targetContainers[0];\n    const nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\n\n    if (nextBlockedOn === null) {\n      if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n        const nativeEvent = queuedEvent.nativeEvent;\n        const nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\n        setReplayingEvent(nativeEventClone);\n        nativeEvent.target.dispatchEvent(nativeEventClone);\n        resetReplayingEvent();\n      } else {\n        setReplayingEvent(queuedEvent.nativeEvent);\n        dispatchEventForPluginEventSystem(queuedEvent.domEventName, queuedEvent.eventSystemFlags, queuedEvent.nativeEvent, return_targetInst, targetContainer);\n        resetReplayingEvent();\n      }\n    } else {\n      // We're still blocked. Try again later.\n      const fiber = getInstanceFromNode(nextBlockedOn);\n\n      if (fiber !== null) {\n        attemptContinuousHydration(fiber);\n      }\n\n      queuedEvent.blockedOn = nextBlockedOn;\n      return false;\n    } // This target container was successfully dispatched. Try the next.\n\n\n    targetContainers.shift();\n  }\n\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false;\n\n  if (!enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    // First replay discrete events.\n    while (queuedDiscreteEvents.length > 0) {\n      const nextDiscreteEvent = queuedDiscreteEvents[0];\n\n      if (nextDiscreteEvent.blockedOn !== null) {\n        // We're still blocked.\n        // Increase the priority of this boundary to unblock\n        // the next discrete event.\n        const fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n\n        if (fiber !== null) {\n          attemptDiscreteHydration(fiber);\n        }\n\n        break;\n      }\n\n      const targetContainers = nextDiscreteEvent.targetContainers;\n\n      while (targetContainers.length > 0) {\n        const targetContainer = targetContainers[0];\n        const nextBlockedOn = findInstanceBlockingEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);\n\n        if (nextBlockedOn === null) {\n          // This whole function is in !enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay,\n          // so we don't need the new replay behavior code branch.\n          setReplayingEvent(nextDiscreteEvent.nativeEvent);\n          dispatchEventForPluginEventSystem(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, nextDiscreteEvent.nativeEvent, return_targetInst, targetContainer);\n          resetReplayingEvent();\n        } else {\n          // We're still blocked. Try again later.\n          nextDiscreteEvent.blockedOn = nextBlockedOn;\n          break;\n        } // This target container was successfully dispatched. Try the next.\n\n\n        targetContainers.shift();\n      }\n\n      if (nextDiscreteEvent.blockedOn === null) {\n        // We've successfully replayed the first event. Let's try the next one.\n        queuedDiscreteEvents.shift();\n      }\n    }\n  } // Next replay any continuous events.\n\n\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(unblocked) {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      const queuedEvent = queuedDiscreteEvents[i];\n\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n\n  const unblock = queuedEvent => scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    const queuedTarget = queuedExplicitHydrationTargets[i];\n\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    const nextExplicitTarget = queuedExplicitHydrationTargets[0];\n\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}","map":{"version":3,"names":["enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","unstable_scheduleCallback","scheduleCallback","unstable_NormalPriority","NormalPriority","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","findInstanceBlockingEvent","return_targetInst","setReplayingEvent","resetReplayingEvent","dispatchEventForPluginEventSystem","getInstanceFromNode","getClosestInstanceFromNode","HostRoot","SuspenseComponent","isHigherEventPriority","isRootDehydrated","_attemptSynchronousHydration","setAttemptSynchronousHydration","fn","attemptSynchronousHydration","fiber","attemptDiscreteHydration","setAttemptDiscreteHydration","attemptContinuousHydration","setAttemptContinuousHydration","attemptHydrationAtCurrentPriority","setAttemptHydrationAtCurrentPriority","getCurrentUpdatePriority","setGetCurrentUpdatePriority","attemptHydrationAtPriority","setAttemptHydrationAtPriority","hasScheduledReplayAttempt","queuedDiscreteEvents","hasAnyQueuedContinuousEvents","queuedFocus","queuedDrag","queuedMouse","queuedPointers","Map","queuedPointerCaptures","queuedExplicitHydrationTargets","hasQueuedDiscreteEvents","length","hasQueuedContinuousEvents","discreteReplayableEvents","isDiscreteEventThatRequiresHydration","eventType","indexOf","createQueuedReplayableEvent","blockedOn","domEventName","eventSystemFlags","targetContainer","nativeEvent","targetContainers","queueDiscreteEvent","queuedEvent","push","replayUnblockedEvents","clearIfContinuousEvent","pointerId","delete","accumulateOrCreateContinuousQueuedReplayableEvent","existingQueuedEvent","queueIfContinuousEvent","focusEvent","dragEvent","mouseEvent","pointerEvent","set","get","attemptExplicitHydrationTarget","queuedTarget","targetInst","target","nearestMounted","tag","instance","priority","root","stateNode","queueExplicitHydrationTarget","updatePriority","i","splice","attemptReplayContinuousQueuedEvent","nextBlockedOn","nativeEventClone","constructor","type","dispatchEvent","shift","attemptReplayContinuousQueuedEventInMap","key","map","nextDiscreteEvent","forEach","scheduleCallbackIfUnblocked","unblocked","retryIfBlockedOn","unblock","nextExplicitTarget"],"sources":["E:/debug-anything/react-test/src/react/packages/react-dom/src/events/ReactDOMEventReplaying.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {AnyNativeEvent} from '../events/PluginModuleType';\r\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\r\nimport type {DOMEventName} from '../events/DOMEventNames';\r\nimport type {EventSystemFlags} from './EventSystemFlags';\r\nimport type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\r\nimport type {EventPriority} from 'react-reconciler/src/ReactEventPriorities';\r\n\r\nimport {enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay} from 'shared/ReactFeatureFlags';\r\nimport {\r\n  unstable_scheduleCallback as scheduleCallback,\r\n  unstable_NormalPriority as NormalPriority,\r\n} from 'scheduler';\r\nimport {\r\n  getNearestMountedFiber,\r\n  getContainerFromFiber,\r\n  getSuspenseInstanceFromFiber,\r\n} from 'react-reconciler/src/ReactFiberTreeReflection';\r\nimport {\r\n  findInstanceBlockingEvent,\r\n  return_targetInst,\r\n} from './ReactDOMEventListener';\r\nimport {setReplayingEvent, resetReplayingEvent} from './CurrentReplayingEvent';\r\nimport {dispatchEventForPluginEventSystem} from './DOMPluginEventSystem';\r\nimport {\r\n  getInstanceFromNode,\r\n  getClosestInstanceFromNode,\r\n} from '../client/ReactDOMComponentTree';\r\nimport {HostRoot, SuspenseComponent} from 'react-reconciler/src/ReactWorkTags';\r\nimport {isHigherEventPriority} from 'react-reconciler/src/ReactEventPriorities';\r\nimport {isRootDehydrated} from 'react-reconciler/src/ReactFiberShellHydration';\r\n\r\nlet _attemptSynchronousHydration: (fiber: Object) => void;\r\n\r\nexport function setAttemptSynchronousHydration(fn: (fiber: Object) => void) {\r\n  _attemptSynchronousHydration = fn;\r\n}\r\n\r\nexport function attemptSynchronousHydration(fiber: Object) {\r\n  _attemptSynchronousHydration(fiber);\r\n}\r\n\r\nlet attemptDiscreteHydration: (fiber: Object) => void;\r\n\r\nexport function setAttemptDiscreteHydration(fn: (fiber: Object) => void) {\r\n  attemptDiscreteHydration = fn;\r\n}\r\n\r\nlet attemptContinuousHydration: (fiber: Object) => void;\r\n\r\nexport function setAttemptContinuousHydration(fn: (fiber: Object) => void) {\r\n  attemptContinuousHydration = fn;\r\n}\r\n\r\nlet attemptHydrationAtCurrentPriority: (fiber: Object) => void;\r\n\r\nexport function setAttemptHydrationAtCurrentPriority(\r\n  fn: (fiber: Object) => void,\r\n) {\r\n  attemptHydrationAtCurrentPriority = fn;\r\n}\r\n\r\nlet getCurrentUpdatePriority: () => EventPriority;\r\n\r\nexport function setGetCurrentUpdatePriority(fn: () => EventPriority) {\r\n  getCurrentUpdatePriority = fn;\r\n}\r\n\r\nlet attemptHydrationAtPriority: <T>(priority: EventPriority, fn: () => T) => T;\r\n\r\nexport function setAttemptHydrationAtPriority(\r\n  fn: <T>(priority: EventPriority, fn: () => T) => T,\r\n) {\r\n  attemptHydrationAtPriority = fn;\r\n}\r\n\r\n// TODO: Upgrade this definition once we're on a newer version of Flow that\r\n// has this definition built-in.\r\ntype PointerEvent = Event & {\r\n  pointerId: number,\r\n  relatedTarget: EventTarget | null,\r\n  ...\r\n};\r\n\r\ntype QueuedReplayableEvent = {|\r\n  blockedOn: null | Container | SuspenseInstance,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  nativeEvent: AnyNativeEvent,\r\n  targetContainers: Array<EventTarget>,\r\n|};\r\n\r\nlet hasScheduledReplayAttempt = false;\r\n\r\n// The queue of discrete events to be replayed.\r\nconst queuedDiscreteEvents: Array<QueuedReplayableEvent> = [];\r\n\r\n// Indicates if any continuous event targets are non-null for early bailout.\r\nconst hasAnyQueuedContinuousEvents: boolean = false;\r\n// The last of each continuous event type. We only need to replay the last one\r\n// if the last target was dehydrated.\r\nlet queuedFocus: null | QueuedReplayableEvent = null;\r\nlet queuedDrag: null | QueuedReplayableEvent = null;\r\nlet queuedMouse: null | QueuedReplayableEvent = null;\r\n// For pointer events there can be one latest event per pointerId.\r\nconst queuedPointers: Map<number, QueuedReplayableEvent> = new Map();\r\nconst queuedPointerCaptures: Map<number, QueuedReplayableEvent> = new Map();\r\n// We could consider replaying selectionchange and touchmoves too.\r\n\r\ntype QueuedHydrationTarget = {|\r\n  blockedOn: null | Container | SuspenseInstance,\r\n  target: Node,\r\n  priority: EventPriority,\r\n|};\r\nconst queuedExplicitHydrationTargets: Array<QueuedHydrationTarget> = [];\r\n\r\nexport function hasQueuedDiscreteEvents(): boolean {\r\n  return queuedDiscreteEvents.length > 0;\r\n}\r\n\r\nexport function hasQueuedContinuousEvents(): boolean {\r\n  return hasAnyQueuedContinuousEvents;\r\n}\r\n\r\nconst discreteReplayableEvents: Array<DOMEventName> = [\r\n  'mousedown',\r\n  'mouseup',\r\n  'touchcancel',\r\n  'touchend',\r\n  'touchstart',\r\n  'auxclick',\r\n  'dblclick',\r\n  'pointercancel',\r\n  'pointerdown',\r\n  'pointerup',\r\n  'dragend',\r\n  'dragstart',\r\n  'drop',\r\n  'compositionend',\r\n  'compositionstart',\r\n  'keydown',\r\n  'keypress',\r\n  'keyup',\r\n  'input',\r\n  'textInput', // Intentionally camelCase\r\n  'copy',\r\n  'cut',\r\n  'paste',\r\n  'click',\r\n  'change',\r\n  'contextmenu',\r\n  'reset',\r\n  'submit',\r\n];\r\n\r\nexport function isDiscreteEventThatRequiresHydration(\r\n  eventType: DOMEventName,\r\n): boolean {\r\n  return discreteReplayableEvents.indexOf(eventType) > -1;\r\n}\r\n\r\nfunction createQueuedReplayableEvent(\r\n  blockedOn: null | Container | SuspenseInstance,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n): QueuedReplayableEvent {\r\n  return {\r\n    blockedOn,\r\n    domEventName,\r\n    eventSystemFlags,\r\n    nativeEvent,\r\n    targetContainers: [targetContainer],\r\n  };\r\n}\r\n\r\nexport function queueDiscreteEvent(\r\n  blockedOn: null | Container | SuspenseInstance,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n): void {\r\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\r\n    return;\r\n  }\r\n  const queuedEvent = createQueuedReplayableEvent(\r\n    blockedOn,\r\n    domEventName,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n    nativeEvent,\r\n  );\r\n  queuedDiscreteEvents.push(queuedEvent);\r\n  if (queuedDiscreteEvents.length === 1) {\r\n    // If this was the first discrete event, we might be able to\r\n    // synchronously unblock it so that preventDefault still works.\r\n    while (queuedEvent.blockedOn !== null) {\r\n      const fiber = getInstanceFromNode(queuedEvent.blockedOn);\r\n      if (fiber === null) {\r\n        break;\r\n      }\r\n      attemptSynchronousHydration(fiber);\r\n      if (queuedEvent.blockedOn === null) {\r\n        // We got unblocked by hydration. Let's try again.\r\n        replayUnblockedEvents();\r\n        // If we're reblocked, on an inner boundary, we might need\r\n        // to attempt hydrating that one.\r\n        continue;\r\n      } else {\r\n        // We're still blocked from hydration, we have to give up\r\n        // and replay later.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Resets the replaying for this type of continuous event to no event.\r\nexport function clearIfContinuousEvent(\r\n  domEventName: DOMEventName,\r\n  nativeEvent: AnyNativeEvent,\r\n): void {\r\n  switch (domEventName) {\r\n    case 'focusin':\r\n    case 'focusout':\r\n      queuedFocus = null;\r\n      break;\r\n    case 'dragenter':\r\n    case 'dragleave':\r\n      queuedDrag = null;\r\n      break;\r\n    case 'mouseover':\r\n    case 'mouseout':\r\n      queuedMouse = null;\r\n      break;\r\n    case 'pointerover':\r\n    case 'pointerout': {\r\n      const pointerId = ((nativeEvent: any): PointerEvent).pointerId;\r\n      queuedPointers.delete(pointerId);\r\n      break;\r\n    }\r\n    case 'gotpointercapture':\r\n    case 'lostpointercapture': {\r\n      const pointerId = ((nativeEvent: any): PointerEvent).pointerId;\r\n      queuedPointerCaptures.delete(pointerId);\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\r\n  existingQueuedEvent: null | QueuedReplayableEvent,\r\n  blockedOn: null | Container | SuspenseInstance,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n): QueuedReplayableEvent {\r\n  if (\r\n    existingQueuedEvent === null ||\r\n    existingQueuedEvent.nativeEvent !== nativeEvent\r\n  ) {\r\n    const queuedEvent = createQueuedReplayableEvent(\r\n      blockedOn,\r\n      domEventName,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n      nativeEvent,\r\n    );\r\n    if (blockedOn !== null) {\r\n      const fiber = getInstanceFromNode(blockedOn);\r\n      if (fiber !== null) {\r\n        // Attempt to increase the priority of this target.\r\n        attemptContinuousHydration(fiber);\r\n      }\r\n    }\r\n    return queuedEvent;\r\n  }\r\n  // If we have already queued this exact event, then it's because\r\n  // the different event systems have different DOM event listeners.\r\n  // We can accumulate the flags, and the targetContainers, and\r\n  // store a single event to be replayed.\r\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\r\n  const targetContainers = existingQueuedEvent.targetContainers;\r\n  if (\r\n    targetContainer !== null &&\r\n    targetContainers.indexOf(targetContainer) === -1\r\n  ) {\r\n    targetContainers.push(targetContainer);\r\n  }\r\n  return existingQueuedEvent;\r\n}\r\n\r\nexport function queueIfContinuousEvent(\r\n  blockedOn: null | Container | SuspenseInstance,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n  nativeEvent: AnyNativeEvent,\r\n): boolean {\r\n  // These set relatedTarget to null because the replayed event will be treated as if we\r\n  // moved from outside the window (no target) onto the target once it hydrates.\r\n  // Instead of mutating we could clone the event.\r\n  switch (domEventName) {\r\n    case 'focusin': {\r\n      const focusEvent = ((nativeEvent: any): FocusEvent);\r\n      queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\r\n        queuedFocus,\r\n        blockedOn,\r\n        domEventName,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n        focusEvent,\r\n      );\r\n      return true;\r\n    }\r\n    case 'dragenter': {\r\n      const dragEvent = ((nativeEvent: any): DragEvent);\r\n      queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\r\n        queuedDrag,\r\n        blockedOn,\r\n        domEventName,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n        dragEvent,\r\n      );\r\n      return true;\r\n    }\r\n    case 'mouseover': {\r\n      const mouseEvent = ((nativeEvent: any): MouseEvent);\r\n      queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\r\n        queuedMouse,\r\n        blockedOn,\r\n        domEventName,\r\n        eventSystemFlags,\r\n        targetContainer,\r\n        mouseEvent,\r\n      );\r\n      return true;\r\n    }\r\n    case 'pointerover': {\r\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\r\n      const pointerId = pointerEvent.pointerId;\r\n      queuedPointers.set(\r\n        pointerId,\r\n        accumulateOrCreateContinuousQueuedReplayableEvent(\r\n          queuedPointers.get(pointerId) || null,\r\n          blockedOn,\r\n          domEventName,\r\n          eventSystemFlags,\r\n          targetContainer,\r\n          pointerEvent,\r\n        ),\r\n      );\r\n      return true;\r\n    }\r\n    case 'gotpointercapture': {\r\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\r\n      const pointerId = pointerEvent.pointerId;\r\n      queuedPointerCaptures.set(\r\n        pointerId,\r\n        accumulateOrCreateContinuousQueuedReplayableEvent(\r\n          queuedPointerCaptures.get(pointerId) || null,\r\n          blockedOn,\r\n          domEventName,\r\n          eventSystemFlags,\r\n          targetContainer,\r\n          pointerEvent,\r\n        ),\r\n      );\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Check if this target is unblocked. Returns true if it's unblocked.\r\nfunction attemptExplicitHydrationTarget(\r\n  queuedTarget: QueuedHydrationTarget,\r\n): void {\r\n  // TODO: This function shares a lot of logic with findInstanceBlockingEvent.\r\n  // Try to unify them. It's a bit tricky since it would require two return\r\n  // values.\r\n  const targetInst = getClosestInstanceFromNode(queuedTarget.target);\r\n  if (targetInst !== null) {\r\n    const nearestMounted = getNearestMountedFiber(targetInst);\r\n    if (nearestMounted !== null) {\r\n      const tag = nearestMounted.tag;\r\n      if (tag === SuspenseComponent) {\r\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\r\n        if (instance !== null) {\r\n          // We're blocked on hydrating this boundary.\r\n          // Increase its priority.\r\n          queuedTarget.blockedOn = instance;\r\n          attemptHydrationAtPriority(queuedTarget.priority, () => {\r\n            attemptHydrationAtCurrentPriority(nearestMounted);\r\n          });\r\n\r\n          return;\r\n        }\r\n      } else if (tag === HostRoot) {\r\n        const root: FiberRoot = nearestMounted.stateNode;\r\n        if (isRootDehydrated(root)) {\r\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\r\n          // We don't currently have a way to increase the priority of\r\n          // a root other than sync.\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  queuedTarget.blockedOn = null;\r\n}\r\n\r\nexport function queueExplicitHydrationTarget(target: Node): void {\r\n  // TODO: This will read the priority if it's dispatched by the React\r\n  // event system but not native events. Should read window.event.type, like\r\n  // we do for updates (getCurrentEventPriority).\r\n  const updatePriority = getCurrentUpdatePriority();\r\n  const queuedTarget: QueuedHydrationTarget = {\r\n    blockedOn: null,\r\n    target: target,\r\n    priority: updatePriority,\r\n  };\r\n  let i = 0;\r\n  for (; i < queuedExplicitHydrationTargets.length; i++) {\r\n    // Stop once we hit the first target with lower priority than\r\n    if (\r\n      !isHigherEventPriority(\r\n        updatePriority,\r\n        queuedExplicitHydrationTargets[i].priority,\r\n      )\r\n    ) {\r\n      break;\r\n    }\r\n  }\r\n  queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\r\n  if (i === 0) {\r\n    attemptExplicitHydrationTarget(queuedTarget);\r\n  }\r\n}\r\n\r\nfunction attemptReplayContinuousQueuedEvent(\r\n  queuedEvent: QueuedReplayableEvent,\r\n): boolean {\r\n  if (queuedEvent.blockedOn !== null) {\r\n    return false;\r\n  }\r\n  const targetContainers = queuedEvent.targetContainers;\r\n  while (targetContainers.length > 0) {\r\n    const targetContainer = targetContainers[0];\r\n    const nextBlockedOn = findInstanceBlockingEvent(\r\n      queuedEvent.domEventName,\r\n      queuedEvent.eventSystemFlags,\r\n      targetContainer,\r\n      queuedEvent.nativeEvent,\r\n    );\r\n    if (nextBlockedOn === null) {\r\n      if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\r\n        const nativeEvent = queuedEvent.nativeEvent;\r\n        const nativeEventClone = new nativeEvent.constructor(\r\n          nativeEvent.type,\r\n          (nativeEvent: any),\r\n        );\r\n        setReplayingEvent(nativeEventClone);\r\n        nativeEvent.target.dispatchEvent(nativeEventClone);\r\n        resetReplayingEvent();\r\n      } else {\r\n        setReplayingEvent(queuedEvent.nativeEvent);\r\n        dispatchEventForPluginEventSystem(\r\n          queuedEvent.domEventName,\r\n          queuedEvent.eventSystemFlags,\r\n          queuedEvent.nativeEvent,\r\n          return_targetInst,\r\n          targetContainer,\r\n        );\r\n        resetReplayingEvent();\r\n      }\r\n    } else {\r\n      // We're still blocked. Try again later.\r\n      const fiber = getInstanceFromNode(nextBlockedOn);\r\n      if (fiber !== null) {\r\n        attemptContinuousHydration(fiber);\r\n      }\r\n      queuedEvent.blockedOn = nextBlockedOn;\r\n      return false;\r\n    }\r\n    // This target container was successfully dispatched. Try the next.\r\n    targetContainers.shift();\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction attemptReplayContinuousQueuedEventInMap(\r\n  queuedEvent: QueuedReplayableEvent,\r\n  key: number,\r\n  map: Map<number, QueuedReplayableEvent>,\r\n): void {\r\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\r\n    map.delete(key);\r\n  }\r\n}\r\n\r\nfunction replayUnblockedEvents() {\r\n  hasScheduledReplayAttempt = false;\r\n  if (!enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\r\n    // First replay discrete events.\r\n    while (queuedDiscreteEvents.length > 0) {\r\n      const nextDiscreteEvent = queuedDiscreteEvents[0];\r\n      if (nextDiscreteEvent.blockedOn !== null) {\r\n        // We're still blocked.\r\n        // Increase the priority of this boundary to unblock\r\n        // the next discrete event.\r\n        const fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\r\n        if (fiber !== null) {\r\n          attemptDiscreteHydration(fiber);\r\n        }\r\n        break;\r\n      }\r\n      const targetContainers = nextDiscreteEvent.targetContainers;\r\n      while (targetContainers.length > 0) {\r\n        const targetContainer = targetContainers[0];\r\n        const nextBlockedOn = findInstanceBlockingEvent(\r\n          nextDiscreteEvent.domEventName,\r\n          nextDiscreteEvent.eventSystemFlags,\r\n          targetContainer,\r\n          nextDiscreteEvent.nativeEvent,\r\n        );\r\n        if (nextBlockedOn === null) {\r\n          // This whole function is in !enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay,\r\n          // so we don't need the new replay behavior code branch.\r\n          setReplayingEvent(nextDiscreteEvent.nativeEvent);\r\n          dispatchEventForPluginEventSystem(\r\n            nextDiscreteEvent.domEventName,\r\n            nextDiscreteEvent.eventSystemFlags,\r\n            nextDiscreteEvent.nativeEvent,\r\n            return_targetInst,\r\n            targetContainer,\r\n          );\r\n          resetReplayingEvent();\r\n        } else {\r\n          // We're still blocked. Try again later.\r\n          nextDiscreteEvent.blockedOn = nextBlockedOn;\r\n          break;\r\n        }\r\n        // This target container was successfully dispatched. Try the next.\r\n        targetContainers.shift();\r\n      }\r\n      if (nextDiscreteEvent.blockedOn === null) {\r\n        // We've successfully replayed the first event. Let's try the next one.\r\n        queuedDiscreteEvents.shift();\r\n      }\r\n    }\r\n  }\r\n  // Next replay any continuous events.\r\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\r\n    queuedFocus = null;\r\n  }\r\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\r\n    queuedDrag = null;\r\n  }\r\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\r\n    queuedMouse = null;\r\n  }\r\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\r\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\r\n}\r\n\r\nfunction scheduleCallbackIfUnblocked(\r\n  queuedEvent: QueuedReplayableEvent,\r\n  unblocked: Container | SuspenseInstance,\r\n) {\r\n  if (queuedEvent.blockedOn === unblocked) {\r\n    queuedEvent.blockedOn = null;\r\n    if (!hasScheduledReplayAttempt) {\r\n      hasScheduledReplayAttempt = true;\r\n      // Schedule a callback to attempt replaying as many events as are\r\n      // now unblocked. This first might not actually be unblocked yet.\r\n      // We could check it early to avoid scheduling an unnecessary callback.\r\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\r\n    }\r\n  }\r\n}\r\n\r\nexport function retryIfBlockedOn(\r\n  unblocked: Container | SuspenseInstance,\r\n): void {\r\n  // Mark anything that was blocked on this as no longer blocked\r\n  // and eligible for a replay.\r\n  if (queuedDiscreteEvents.length > 0) {\r\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\r\n    // This is a exponential search for each boundary that commits. I think it's\r\n    // worth it because we expect very few discrete events to queue up and once\r\n    // we are actually fully unblocked it will be fast to replay them.\r\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\r\n      const queuedEvent = queuedDiscreteEvents[i];\r\n      if (queuedEvent.blockedOn === unblocked) {\r\n        queuedEvent.blockedOn = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (queuedFocus !== null) {\r\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\r\n  }\r\n  if (queuedDrag !== null) {\r\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\r\n  }\r\n  if (queuedMouse !== null) {\r\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\r\n  }\r\n  const unblock = queuedEvent =>\r\n    scheduleCallbackIfUnblocked(queuedEvent, unblocked);\r\n  queuedPointers.forEach(unblock);\r\n  queuedPointerCaptures.forEach(unblock);\r\n\r\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\r\n    const queuedTarget = queuedExplicitHydrationTargets[i];\r\n    if (queuedTarget.blockedOn === unblocked) {\r\n      queuedTarget.blockedOn = null;\r\n    }\r\n  }\r\n\r\n  while (queuedExplicitHydrationTargets.length > 0) {\r\n    const nextExplicitTarget = queuedExplicitHydrationTargets[0];\r\n    if (nextExplicitTarget.blockedOn !== null) {\r\n      // We're still blocked.\r\n      break;\r\n    } else {\r\n      attemptExplicitHydrationTarget(nextExplicitTarget);\r\n      if (nextExplicitTarget.blockedOn === null) {\r\n        // We're unblocked.\r\n        queuedExplicitHydrationTargets.shift();\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}