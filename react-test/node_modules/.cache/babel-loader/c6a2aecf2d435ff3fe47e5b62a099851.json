{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableSuspenseAvoidThisFallback } from 'shared/ReactFeatureFlags';\nimport { SuspenseComponent, SuspenseListComponent } from './ReactWorkTags';\nimport { NoFlags, DidCapture } from './ReactFiberFlags';\nimport { isSuspenseInstancePending, isSuspenseInstanceFallback } from './ReactFiberHostConfig';\nexport function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  const nextState = workInProgress.memoizedState;\n\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n\n    return false;\n  }\n\n  const props = workInProgress.memoizedProps; // Regular boundaries always capture.\n\n  if (!enableSuspenseAvoidThisFallback || props.unstable_avoidThisFallback !== true) {\n    return true;\n  } // If it's a boundary we should avoid, then we prefer to bubble up to the\n  // parent boundary if it is currently invisible.\n\n\n  if (hasInvisibleParent) {\n    return false;\n  } // If the parent is not able to handle it, we must handle it.\n\n\n  return true;\n}\nexport function findFirstSuspended(row) {\n  let node = row;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        const dehydrated = state.dehydrated;\n\n        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n          return node;\n        }\n      }\n    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n    // keep track of whether it suspended or not.\n    node.memoizedProps.revealOrder !== undefined) {\n      const didSuspend = (node.flags & DidCapture) !== NoFlags;\n\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === row) {\n      return null;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n\n  return null;\n}","map":{"version":3,"names":["enableSuspenseAvoidThisFallback","SuspenseComponent","SuspenseListComponent","NoFlags","DidCapture","isSuspenseInstancePending","isSuspenseInstanceFallback","shouldCaptureSuspense","workInProgress","hasInvisibleParent","nextState","memoizedState","dehydrated","props","memoizedProps","unstable_avoidThisFallback","findFirstSuspended","row","node","tag","state","revealOrder","undefined","didSuspend","flags","child","return","sibling"],"sources":["E:/react-test/src/react/packages/react-reconciler/src/ReactFiberSuspenseComponent.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {ReactNodeList, Wakeable} from 'shared/ReactTypes';\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\r\nimport type {Lane} from './ReactFiberLane.new';\r\nimport type {TreeContext} from './ReactFiberTreeContext.new';\r\n\r\nimport {enableSuspenseAvoidThisFallback} from 'shared/ReactFeatureFlags';\r\nimport {SuspenseComponent, SuspenseListComponent} from './ReactWorkTags';\r\nimport {NoFlags, DidCapture} from './ReactFiberFlags';\r\nimport {\r\n  isSuspenseInstancePending,\r\n  isSuspenseInstanceFallback,\r\n} from './ReactFiberHostConfig';\r\n\r\nexport type SuspenseProps = {|\r\n  children?: ReactNodeList,\r\n  fallback?: ReactNodeList,\r\n\r\n  // TODO: Add \"unstable_\" prefix?\r\n  suspenseCallback?: (Set<Wakeable> | null) => mixed,\r\n\r\n  unstable_expectedLoadTime?: number,\r\n  unstable_name?: string,\r\n|};\r\n\r\n// A null SuspenseState represents an unsuspended normal Suspense boundary.\r\n// A non-null SuspenseState means that it is blocked for one reason or another.\r\n// - A non-null dehydrated field means it's blocked pending hydration.\r\n//   - A non-null dehydrated field can use isSuspenseInstancePending or\r\n//     isSuspenseInstanceFallback to query the reason for being dehydrated.\r\n// - A null dehydrated field means it's blocked by something suspending and\r\n//   we're currently showing a fallback instead.\r\nexport type SuspenseState = {|\r\n  // If this boundary is still dehydrated, we store the SuspenseInstance\r\n  // here to indicate that it is dehydrated (flag) and for quick access\r\n  // to check things like isSuspenseInstancePending.\r\n  dehydrated: null | SuspenseInstance,\r\n  treeContext: null | TreeContext,\r\n  // Represents the lane we should attempt to hydrate a dehydrated boundary at.\r\n  // OffscreenLane is the default for dehydrated boundaries.\r\n  // NoLane is the default for normal boundaries, which turns into \"normal\" pri.\r\n  retryLane: Lane,\r\n|};\r\n\r\nexport type SuspenseListTailMode = 'collapsed' | 'hidden' | void;\r\n\r\nexport type SuspenseListRenderState = {|\r\n  isBackwards: boolean,\r\n  // The currently rendering tail row.\r\n  rendering: null | Fiber,\r\n  // The absolute time when we started rendering the most recent tail row.\r\n  renderingStartTime: number,\r\n  // The last of the already rendered children.\r\n  last: null | Fiber,\r\n  // Remaining rows on the tail of the list.\r\n  tail: null | Fiber,\r\n  // Tail insertions setting.\r\n  tailMode: SuspenseListTailMode,\r\n|};\r\n\r\nexport function shouldCaptureSuspense(\r\n  workInProgress: Fiber,\r\n  hasInvisibleParent: boolean,\r\n): boolean {\r\n  // If it was the primary children that just suspended, capture and render the\r\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\r\n  const nextState: SuspenseState | null = workInProgress.memoizedState;\r\n  if (nextState !== null) {\r\n    if (nextState.dehydrated !== null) {\r\n      // A dehydrated boundary always captures.\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  const props = workInProgress.memoizedProps;\r\n  // Regular boundaries always capture.\r\n  if (\r\n    !enableSuspenseAvoidThisFallback ||\r\n    props.unstable_avoidThisFallback !== true\r\n  ) {\r\n    return true;\r\n  }\r\n  // If it's a boundary we should avoid, then we prefer to bubble up to the\r\n  // parent boundary if it is currently invisible.\r\n  if (hasInvisibleParent) {\r\n    return false;\r\n  }\r\n  // If the parent is not able to handle it, we must handle it.\r\n  return true;\r\n}\r\n\r\nexport function findFirstSuspended(row: Fiber): null | Fiber {\r\n  let node = row;\r\n  while (node !== null) {\r\n    if (node.tag === SuspenseComponent) {\r\n      const state: SuspenseState | null = node.memoizedState;\r\n      if (state !== null) {\r\n        const dehydrated: null | SuspenseInstance = state.dehydrated;\r\n        if (\r\n          dehydrated === null ||\r\n          isSuspenseInstancePending(dehydrated) ||\r\n          isSuspenseInstanceFallback(dehydrated)\r\n        ) {\r\n          return node;\r\n        }\r\n      }\r\n    } else if (\r\n      node.tag === SuspenseListComponent &&\r\n      // revealOrder undefined can't be trusted because it don't\r\n      // keep track of whether it suspended or not.\r\n      node.memoizedProps.revealOrder !== undefined\r\n    ) {\r\n      const didSuspend = (node.flags & DidCapture) !== NoFlags;\r\n      if (didSuspend) {\r\n        return node;\r\n      }\r\n    } else if (node.child !== null) {\r\n      node.child.return = node;\r\n      node = node.child;\r\n      continue;\r\n    }\r\n    if (node === row) {\r\n      return null;\r\n    }\r\n    while (node.sibling === null) {\r\n      if (node.return === null || node.return === row) {\r\n        return null;\r\n      }\r\n      node = node.return;\r\n    }\r\n    node.sibling.return = node.return;\r\n    node = node.sibling;\r\n  }\r\n  return null;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA,SAAQA,+BAAR,QAA8C,0BAA9C;AACA,SAAQC,iBAAR,EAA2BC,qBAA3B,QAAuD,iBAAvD;AACA,SAAQC,OAAR,EAAiBC,UAAjB,QAAkC,mBAAlC;AACA,SACEC,yBADF,EAEEC,0BAFF,QAGO,wBAHP;AAmDA,OAAO,SAASC,qBAAT,CACLC,cADK,EAELC,kBAFK,EAGI;EACT;EACA;EACA,MAAMC,SAA+B,GAAGF,cAAc,CAACG,aAAvD;;EACA,IAAID,SAAS,KAAK,IAAlB,EAAwB;IACtB,IAAIA,SAAS,CAACE,UAAV,KAAyB,IAA7B,EAAmC;MACjC;MACA,OAAO,IAAP;IACD;;IACD,OAAO,KAAP;EACD;;EACD,MAAMC,KAAK,GAAGL,cAAc,CAACM,aAA7B,CAXS,CAYT;;EACA,IACE,CAACd,+BAAD,IACAa,KAAK,CAACE,0BAAN,KAAqC,IAFvC,EAGE;IACA,OAAO,IAAP;EACD,CAlBQ,CAmBT;EACA;;;EACA,IAAIN,kBAAJ,EAAwB;IACtB,OAAO,KAAP;EACD,CAvBQ,CAwBT;;;EACA,OAAO,IAAP;AACD;AAED,OAAO,SAASO,kBAAT,CAA4BC,GAA5B,EAAsD;EAC3D,IAAIC,IAAI,GAAGD,GAAX;;EACA,OAAOC,IAAI,KAAK,IAAhB,EAAsB;IACpB,IAAIA,IAAI,CAACC,GAAL,KAAalB,iBAAjB,EAAoC;MAClC,MAAMmB,KAA2B,GAAGF,IAAI,CAACP,aAAzC;;MACA,IAAIS,KAAK,KAAK,IAAd,EAAoB;QAClB,MAAMR,UAAmC,GAAGQ,KAAK,CAACR,UAAlD;;QACA,IACEA,UAAU,KAAK,IAAf,IACAP,yBAAyB,CAACO,UAAD,CADzB,IAEAN,0BAA0B,CAACM,UAAD,CAH5B,EAIE;UACA,OAAOM,IAAP;QACD;MACF;IACF,CAZD,MAYO,IACLA,IAAI,CAACC,GAAL,KAAajB,qBAAb,IACA;IACA;IACAgB,IAAI,CAACJ,aAAL,CAAmBO,WAAnB,KAAmCC,SAJ9B,EAKL;MACA,MAAMC,UAAU,GAAG,CAACL,IAAI,CAACM,KAAL,GAAapB,UAAd,MAA8BD,OAAjD;;MACA,IAAIoB,UAAJ,EAAgB;QACd,OAAOL,IAAP;MACD;IACF,CAVM,MAUA,IAAIA,IAAI,CAACO,KAAL,KAAe,IAAnB,EAAyB;MAC9BP,IAAI,CAACO,KAAL,CAAWC,MAAX,GAAoBR,IAApB;MACAA,IAAI,GAAGA,IAAI,CAACO,KAAZ;MACA;IACD;;IACD,IAAIP,IAAI,KAAKD,GAAb,EAAkB;MAChB,OAAO,IAAP;IACD;;IACD,OAAOC,IAAI,CAACS,OAAL,KAAiB,IAAxB,EAA8B;MAC5B,IAAIT,IAAI,CAACQ,MAAL,KAAgB,IAAhB,IAAwBR,IAAI,CAACQ,MAAL,KAAgBT,GAA5C,EAAiD;QAC/C,OAAO,IAAP;MACD;;MACDC,IAAI,GAAGA,IAAI,CAACQ,MAAZ;IACD;;IACDR,IAAI,CAACS,OAAL,CAAaD,MAAb,GAAsBR,IAAI,CAACQ,MAA3B;IACAR,IAAI,GAAGA,IAAI,CAACS,OAAZ;EACD;;EACD,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}