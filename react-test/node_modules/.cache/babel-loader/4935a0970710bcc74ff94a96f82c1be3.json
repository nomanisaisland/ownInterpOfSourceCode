{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\nconst didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  if (__DEV__) {\n    const constructor = publicInstance.constructor;\n    const componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';\n    const warningKey = `${componentName}.${callerName}`;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    console.error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\r\n * This is the abstract API for an update queue.\r\n */\n\n\nconst ReactNoopUpdateQueue = {\n  /**\r\n   * Checks whether or not this composite component is mounted.\r\n   * @param {ReactClass} publicInstance The instance we want to test.\r\n   * @return {boolean} True if mounted, false otherwise.\r\n   * @protected\r\n   * @final\r\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\r\n   * Forces an update. This should only be invoked when it is known with\r\n   * certainty that we are **not** in a DOM transaction.\r\n   *\r\n   * You may want to call this when you know that some deeper aspect of the\r\n   * component's state has changed but `setState` was not called.\r\n   *\r\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\r\n   * `componentWillUpdate` and `componentDidUpdate`.\r\n   *\r\n   * @param {ReactClass} publicInstance The instance that should rerender.\r\n   * @param {?function} callback Called after component is updated.\r\n   * @param {?string} callerName name of the calling function in the public API.\r\n   * @internal\r\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\r\n   * Replaces all of the state. Always use this or `setState` to mutate state.\r\n   * You should treat `this.state` as immutable.\r\n   *\r\n   * There is no guarantee that `this.state` will be immediately updated, so\r\n   * accessing `this.state` after calling this method may return the old value.\r\n   *\r\n   * @param {ReactClass} publicInstance The instance that should rerender.\r\n   * @param {object} completeState Next state.\r\n   * @param {?function} callback Called after component is updated.\r\n   * @param {?string} callerName name of the calling function in the public API.\r\n   * @internal\r\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\r\n   * Sets a subset of the state. This only exists because _pendingState is\r\n   * internal. This provides a merging strategy that is not available to deep\r\n   * properties which is confusing. TODO: Expose pendingState or don't use it\r\n   * during the merge.\r\n   *\r\n   * @param {ReactClass} publicInstance The instance that should rerender.\r\n   * @param {object} partialState Next partial state to be merged with state.\r\n   * @param {?function} callback Called after component is updated.\r\n   * @param {?string} Name of the calling function in the public API.\r\n   * @internal\r\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\nexport default ReactNoopUpdateQueue;","map":{"version":3,"names":["didWarnStateUpdateForUnmountedComponent","warnNoop","publicInstance","callerName","__DEV__","constructor","componentName","displayName","name","warningKey","console","error","ReactNoopUpdateQueue","isMounted","enqueueForceUpdate","callback","enqueueReplaceState","completeState","enqueueSetState","partialState"],"sources":["E:/react-test/src/react/packages/react/src/ReactNoopUpdateQueue.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nconst didWarnStateUpdateForUnmountedComponent = {};\r\n\r\nfunction warnNoop(publicInstance, callerName) {\r\n  if (__DEV__) {\r\n    const constructor = publicInstance.constructor;\r\n    const componentName =\r\n      (constructor && (constructor.displayName || constructor.name)) ||\r\n      'ReactClass';\r\n    const warningKey = `${componentName}.${callerName}`;\r\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\r\n      return;\r\n    }\r\n    console.error(\r\n      \"Can't call %s on a component that is not yet mounted. \" +\r\n        'This is a no-op, but it might indicate a bug in your application. ' +\r\n        'Instead, assign to `this.state` directly or define a `state = {};` ' +\r\n        'class property with the desired state in the %s component.',\r\n      callerName,\r\n      componentName,\r\n    );\r\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\r\n  }\r\n}\r\n\r\n/**\r\n * This is the abstract API for an update queue.\r\n */\r\nconst ReactNoopUpdateQueue = {\r\n  /**\r\n   * Checks whether or not this composite component is mounted.\r\n   * @param {ReactClass} publicInstance The instance we want to test.\r\n   * @return {boolean} True if mounted, false otherwise.\r\n   * @protected\r\n   * @final\r\n   */\r\n  isMounted: function(publicInstance) {\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Forces an update. This should only be invoked when it is known with\r\n   * certainty that we are **not** in a DOM transaction.\r\n   *\r\n   * You may want to call this when you know that some deeper aspect of the\r\n   * component's state has changed but `setState` was not called.\r\n   *\r\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\r\n   * `componentWillUpdate` and `componentDidUpdate`.\r\n   *\r\n   * @param {ReactClass} publicInstance The instance that should rerender.\r\n   * @param {?function} callback Called after component is updated.\r\n   * @param {?string} callerName name of the calling function in the public API.\r\n   * @internal\r\n   */\r\n  enqueueForceUpdate: function(publicInstance, callback, callerName) {\r\n    warnNoop(publicInstance, 'forceUpdate');\r\n  },\r\n\r\n  /**\r\n   * Replaces all of the state. Always use this or `setState` to mutate state.\r\n   * You should treat `this.state` as immutable.\r\n   *\r\n   * There is no guarantee that `this.state` will be immediately updated, so\r\n   * accessing `this.state` after calling this method may return the old value.\r\n   *\r\n   * @param {ReactClass} publicInstance The instance that should rerender.\r\n   * @param {object} completeState Next state.\r\n   * @param {?function} callback Called after component is updated.\r\n   * @param {?string} callerName name of the calling function in the public API.\r\n   * @internal\r\n   */\r\n  enqueueReplaceState: function(\r\n    publicInstance,\r\n    completeState,\r\n    callback,\r\n    callerName,\r\n  ) {\r\n    warnNoop(publicInstance, 'replaceState');\r\n  },\r\n\r\n  /**\r\n   * Sets a subset of the state. This only exists because _pendingState is\r\n   * internal. This provides a merging strategy that is not available to deep\r\n   * properties which is confusing. TODO: Expose pendingState or don't use it\r\n   * during the merge.\r\n   *\r\n   * @param {ReactClass} publicInstance The instance that should rerender.\r\n   * @param {object} partialState Next partial state to be merged with state.\r\n   * @param {?function} callback Called after component is updated.\r\n   * @param {?string} Name of the calling function in the public API.\r\n   * @internal\r\n   */\r\n  enqueueSetState: function(\r\n    publicInstance,\r\n    partialState,\r\n    callback,\r\n    callerName,\r\n  ) {\r\n    warnNoop(publicInstance, 'setState');\r\n  },\r\n};\r\n\r\nexport default ReactNoopUpdateQueue;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,uCAAuC,GAAG,EAAhD;;AAEA,SAASC,QAAT,CAAkBC,cAAlB,EAAkCC,UAAlC,EAA8C;EAC5C,IAAIC,OAAJ,EAAa;IACX,MAAMC,WAAW,GAAGH,cAAc,CAACG,WAAnC;IACA,MAAMC,aAAa,GAChBD,WAAW,KAAKA,WAAW,CAACE,WAAZ,IAA2BF,WAAW,CAACG,IAA5C,CAAZ,IACA,YAFF;IAGA,MAAMC,UAAU,GAAI,GAAEH,aAAc,IAAGH,UAAW,EAAlD;;IACA,IAAIH,uCAAuC,CAACS,UAAD,CAA3C,EAAyD;MACvD;IACD;;IACDC,OAAO,CAACC,KAAR,CACE,2DACE,oEADF,GAEE,qEAFF,GAGE,4DAJJ,EAKER,UALF,EAMEG,aANF;IAQAN,uCAAuC,CAACS,UAAD,CAAvC,GAAsD,IAAtD;EACD;AACF;AAED;AACA;AACA;;;AACA,MAAMG,oBAAoB,GAAG;EAC3B;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,SAAS,EAAE,UAASX,cAAT,EAAyB;IAClC,OAAO,KAAP;EACD,CAV0B;;EAY3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEY,kBAAkB,EAAE,UAASZ,cAAT,EAAyBa,QAAzB,EAAmCZ,UAAnC,EAA+C;IACjEF,QAAQ,CAACC,cAAD,EAAiB,aAAjB,CAAR;EACD,CA7B0B;;EA+B3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,mBAAmB,EAAE,UACnBd,cADmB,EAEnBe,aAFmB,EAGnBF,QAHmB,EAInBZ,UAJmB,EAKnB;IACAF,QAAQ,CAACC,cAAD,EAAiB,cAAjB,CAAR;EACD,CAnD0B;;EAqD3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgB,eAAe,EAAE,UACfhB,cADe,EAEfiB,YAFe,EAGfJ,QAHe,EAIfZ,UAJe,EAKf;IACAF,QAAQ,CAACC,cAAD,EAAiB,UAAjB,CAAR;EACD;AAxE0B,CAA7B;AA2EA,eAAeU,oBAAf"},"metadata":{},"sourceType":"module"}