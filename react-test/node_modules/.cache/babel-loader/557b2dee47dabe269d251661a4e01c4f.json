{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { Placement, ChildDeletion, Forked } from './ReactFiberFlags';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_FRAGMENT_TYPE, REACT_PORTAL_TYPE, REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nimport { ClassComponent, HostText, HostPortal, Fragment } from './ReactWorkTags';\nimport isArray from 'shared/isArray';\nimport { warnAboutStringRefs } from 'shared/ReactFeatureFlags';\nimport { checkPropStringCoercion } from 'shared/CheckStringCoercion';\nimport { createWorkInProgress, resetWorkInProgress, createFiberFromElement, createFiberFromFragment, createFiberFromText, createFiberFromPortal } from './ReactFiber.old';\nimport { emptyRefsObject } from './ReactFiberClassComponent.old';\nimport { isCompatibleFamilyForHotReloading } from './ReactFiberHotReloading.old';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { getIsHydrating } from './ReactFiberHydrationContext.old';\nimport { pushTreeFork } from './ReactFiberTreeContext.old';\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\n\nlet warnForMissingKey = (child, returnFiber) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\r\n   * Warn if there's no key explicitly set on dynamic arrays of children or\r\n   * object keys are not valid. This allows us to keep track of children between\r\n   * updates.\r\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child, returnFiber) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    child._store.validated = true;\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[componentName] = true;\n    console.error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\n  };\n}\n\nfunction coerceRef(returnFiber, current, element) {\n  const mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n      // because these cannot be automatically converted to an arrow function\n      // using a codemod. Therefore, we don't have to warn about string refs again.\n      !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n        const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            console.error('Component \"%s\" contains the string ref \"%s\". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);\n          } else {\n            console.error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner = element._owner;\n      let inst;\n\n      if (owner) {\n        const ownerFiber = owner;\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(`Missing owner for string ref ${mixedRef}. This error is likely caused by a ` + 'bug in React. Please file an issue.');\n      } // Assigning this to a const so Flow knows it won't change in the closure\n\n\n      const resolvedInst = inst;\n\n      if (__DEV__) {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n\n      const stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      const ref = function (value) {\n        let refs = resolvedInst.refs;\n\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = resolvedInst.refs = {};\n        }\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      }\n\n      if (!element._owner) {\n        throw new Error(`Element ref was specified as a string (${mixedRef}) but no owner was set. This could happen for one of` + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');\n      }\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  const childString = Object.prototype.toString.call(newChild);\n  throw new Error(`Objects are not valid as a React child (found: ${childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString}). ` + 'If you meant to render a collection of children, use an array ' + 'instead.');\n}\n\nfunction warnOnFunctionType(returnFiber) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n\n    ownerHasFunctionTypeWarning[componentName] = true;\n    console.error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  const payload = lazyType._payload;\n  const init = lazyType._init;\n  return init(payload);\n} // This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\n\n\nfunction ChildReconciler(shouldTrackSideEffects) {\n  var _s = $RefreshSig$(),\n      _s2 = $RefreshSig$(),\n      _s3 = $RefreshSig$(),\n      _s4 = $RefreshSig$(),\n      _s5 = $RefreshSig$(),\n      _s6 = $RefreshSig$(),\n      _s7 = $RefreshSig$();\n\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n\n    const deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    let childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren = new Map();\n    let existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n\n    const current = newFiber.alternate;\n\n    if (current !== null) {\n      const oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    _s();\n\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  _s(updateTextNode, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function updateElement(returnFiber, current, element, lanes) {\n    _s2();\n\n    const elementType = element.type;\n\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n    }\n\n    if (current !== null) {\n      if (current.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n      __DEV__ ? isCompatibleFamilyForHotReloading(current, element) : false) || // Lazy types should reconcile their resolved type.\n      // We need to do this after the Hot Reloading check above,\n      // because hot reloading has different semantics than prod because\n      // it doesn't resuspend. So we can't let the call below suspend.\n      typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n        // Move based on index\n        const existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      }\n    } // Insert\n\n\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  _s2(updateElement, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function updatePortal(returnFiber, current, portal, lanes) {\n    _s3();\n\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  _s3(updatePortal, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    _s4();\n\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  _s4(updateFragment, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function createChild(returnFiber, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n            created.ref = coerceRef(returnFiber, null, newChild);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const created = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return createChild(returnFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    // Update the fiber if the keys match, otherwise return null.\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateElement(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateElement(returnFiber, matchedFiber, newChild, lanes);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, matchedFiber, newChild, lanes);\n          }\n\n        case REACT_LAZY_TYPE:\n          const payload = newChild._payload;\n          const init = newChild._init;\n          return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * Warns if there is a duplicate or missing key\r\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys, returnFiber) {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          const key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          console.error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n          break;\n\n        case REACT_LAZY_TYPE:\n          const payload = child._payload;\n          const init = child._init;\n          warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n    }\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        if (!didWarnAboutGenerators) {\n          console.error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        }\n\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          console.error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n        }\n\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      const newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    let step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, lanes);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n    _s5();\n\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    } // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  } // 单点diff有如下几种情况：\n  // key和type相同表示可以复用节点\n  // key不同直接标记删除节点，然后新建节点\n  // key相同type不同，标记删除该节点和兄弟节点，然后新创建节点\n\n\n  _s5(reconcileSingleTextNode, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n    _s6();\n\n    const key = element.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        const elementType = element.type;\n\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } else {\n          if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n          __DEV__ ? isCompatibleFamilyForHotReloading(child, element) : false) || // Lazy types should reconcile their resolved type.\n          // We need to do this after the Hot Reloading check above,\n          // because hot reloading has different semantics than prod because\n          // it doesn't resuspend. So we can't let the call below suspend.\n          typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } // Didn't match.\n\n\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      } //key不同直接标记删除该节点\n\n\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(element, returnFiber.mode, lanes);\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  _s6(reconcileSingleElement, \"YD9wqb/AD6BbMBjrepuEiWevtjU=\", false, function () {\n    return [useFiber, useFiber];\n  });\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n    _s7();\n\n    const key = portal.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  // 开始react diff算法\n\n\n  _s7(reconcileSinglePortal, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    console.log({\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      lanes\n    }); // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n\n    const isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n    // 根据newChild的类型来进入单节点的diff或者多节点diff\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          //单一节点diff\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          const payload = newChild._payload;\n          const init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n          return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n      }\n\n      if (isArray(newChild)) {\n        //多节点diff\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n    // 删除节点\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\n_c = ChildReconciler;\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\nexport function cloneChildFibers(current, workInProgress) {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nexport function resetChildFibers(workInProgress, lanes) {\n  let child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"ChildReconciler\");","map":{"version":3,"names":["getComponentNameFromFiber","Placement","ChildDeletion","Forked","getIteratorFn","REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","REACT_PORTAL_TYPE","REACT_LAZY_TYPE","ClassComponent","HostText","HostPortal","Fragment","isArray","warnAboutStringRefs","checkPropStringCoercion","createWorkInProgress","resetWorkInProgress","createFiberFromElement","createFiberFromFragment","createFiberFromText","createFiberFromPortal","emptyRefsObject","isCompatibleFamilyForHotReloading","StrictLegacyMode","getIsHydrating","pushTreeFork","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefs","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","child","returnFiber","__DEV__","_store","validated","key","Error","componentName","console","error","coerceRef","current","element","mixedRef","ref","mode","_owner","_self","stateNode","owner","inst","ownerFiber","tag","resolvedInst","stringRef","_stringRef","value","refs","throwOnInvalidObjectType","newChild","childString","Object","prototype","toString","call","keys","join","warnOnFunctionType","resolveLazy","lazyType","payload","_payload","init","_init","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deletions","flags","push","deleteRemainingChildren","currentFirstChild","sibling","mapRemainingChildren","existingChildren","Map","existingChild","set","index","useFiber","fiber","pendingProps","clone","placeChild","newFiber","lastPlacedIndex","newIndex","alternate","oldIndex","placeSingleChild","updateTextNode","textContent","lanes","created","return","existing","updateElement","elementType","type","updateFragment","props","children","$$typeof","_debugSource","_source","_debugOwner","updatePortal","portal","containerInfo","implementation","fragment","createChild","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","get","warnOnInvalidKey","knownKeys","Set","add","has","reconcileChildrenArray","newChildren","i","length","resultingFirstChild","previousNewFiber","nextOldFiber","numberOfForks","delete","forEach","reconcileChildrenIterator","newChildrenIterable","iteratorFn","Symbol","toStringTag","entries","step","next","done","reconcileSingleTextNode","reconcileSingleElement","reconcileSinglePortal","reconcileChildFibers","log","isUnkeyedTopLevelFragment","mountChildFibers","cloneChildFibers","workInProgress","currentChild","resetChildFibers"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactChildFiber.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { ReactElement } from 'shared/ReactElementType';\r\nimport type { ReactPortal } from 'shared/ReactTypes';\r\nimport type { Fiber } from './ReactInternalTypes';\r\nimport type { Lanes } from './ReactFiberLane.old';\r\n\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport { Placement, ChildDeletion, Forked } from './ReactFiberFlags';\r\nimport {\r\n  getIteratorFn,\r\n  REACT_ELEMENT_TYPE,\r\n  REACT_FRAGMENT_TYPE,\r\n  REACT_PORTAL_TYPE,\r\n  REACT_LAZY_TYPE,\r\n} from 'shared/ReactSymbols';\r\nimport { ClassComponent, HostText, HostPortal, Fragment } from './ReactWorkTags';\r\nimport isArray from 'shared/isArray';\r\nimport { warnAboutStringRefs } from 'shared/ReactFeatureFlags';\r\nimport { checkPropStringCoercion } from 'shared/CheckStringCoercion';\r\n\r\nimport {\r\n  createWorkInProgress,\r\n  resetWorkInProgress,\r\n  createFiberFromElement,\r\n  createFiberFromFragment,\r\n  createFiberFromText,\r\n  createFiberFromPortal,\r\n} from './ReactFiber.old';\r\nimport { emptyRefsObject } from './ReactFiberClassComponent.old';\r\nimport { isCompatibleFamilyForHotReloading } from './ReactFiberHotReloading.old';\r\nimport { StrictLegacyMode } from './ReactTypeOfMode';\r\nimport { getIsHydrating } from './ReactFiberHydrationContext.old';\r\nimport { pushTreeFork } from './ReactFiberTreeContext.old';\r\n\r\nlet didWarnAboutMaps;\r\nlet didWarnAboutGenerators;\r\nlet didWarnAboutStringRefs;\r\nlet ownerHasKeyUseWarning;\r\nlet ownerHasFunctionTypeWarning;\r\nlet warnForMissingKey = (child: mixed, returnFiber: Fiber) => { };\r\n\r\nif (__DEV__) {\r\n  didWarnAboutMaps = false;\r\n  didWarnAboutGenerators = false;\r\n  didWarnAboutStringRefs = {};\r\n\r\n  /**\r\n   * Warn if there's no key explicitly set on dynamic arrays of children or\r\n   * object keys are not valid. This allows us to keep track of children between\r\n   * updates.\r\n   */\r\n  ownerHasKeyUseWarning = {};\r\n  ownerHasFunctionTypeWarning = {};\r\n\r\n  warnForMissingKey = (child: mixed, returnFiber: Fiber) => {\r\n    if (child === null || typeof child !== 'object') {\r\n      return;\r\n    }\r\n    if (!child._store || child._store.validated || child.key != null) {\r\n      return;\r\n    }\r\n\r\n    if (typeof child._store !== 'object') {\r\n      throw new Error(\r\n        'React Component in warnForMissingKey should have a _store. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n\r\n    child._store.validated = true;\r\n\r\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\r\n\r\n    if (ownerHasKeyUseWarning[componentName]) {\r\n      return;\r\n    }\r\n    ownerHasKeyUseWarning[componentName] = true;\r\n\r\n    console.error(\r\n      'Each child in a list should have a unique ' +\r\n      '\"key\" prop. See https://reactjs.org/link/warning-keys for ' +\r\n      'more information.',\r\n    );\r\n  };\r\n}\r\n\r\nfunction coerceRef (\r\n  returnFiber: Fiber,\r\n  current: Fiber | null,\r\n  element: ReactElement,\r\n) {\r\n  const mixedRef = element.ref;\r\n  if (\r\n    mixedRef !== null &&\r\n    typeof mixedRef !== 'function' &&\r\n    typeof mixedRef !== 'object'\r\n  ) {\r\n    if (__DEV__) {\r\n      // TODO: Clean this up once we turn on the string ref warning for\r\n      // everyone, because the strict mode case will no longer be relevant\r\n      if (\r\n        (returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) &&\r\n        // We warn in ReactElement.js if owner and self are equal for string refs\r\n        // because these cannot be automatically converted to an arrow function\r\n        // using a codemod. Therefore, we don't have to warn about string refs again.\r\n        !(\r\n          element._owner &&\r\n          element._self &&\r\n          element._owner.stateNode !== element._self\r\n        )\r\n      ) {\r\n        const componentName =\r\n          getComponentNameFromFiber(returnFiber) || 'Component';\r\n        if (!didWarnAboutStringRefs[componentName]) {\r\n          if (warnAboutStringRefs) {\r\n            console.error(\r\n              'Component \"%s\" contains the string ref \"%s\". Support for string refs ' +\r\n              'will be removed in a future major release. We recommend using ' +\r\n              'useRef() or createRef() instead. ' +\r\n              'Learn more about using refs safely here: ' +\r\n              'https://reactjs.org/link/strict-mode-string-ref',\r\n              componentName,\r\n              mixedRef,\r\n            );\r\n          } else {\r\n            console.error(\r\n              'A string ref, \"%s\", has been found within a strict mode tree. ' +\r\n              'String refs are a source of potential bugs and should be avoided. ' +\r\n              'We recommend using useRef() or createRef() instead. ' +\r\n              'Learn more about using refs safely here: ' +\r\n              'https://reactjs.org/link/strict-mode-string-ref',\r\n              mixedRef,\r\n            );\r\n          }\r\n          didWarnAboutStringRefs[componentName] = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (element._owner) {\r\n      const owner: ?Fiber = (element._owner: any);\r\n      let inst;\r\n      if (owner) {\r\n        const ownerFiber = ((owner: any): Fiber);\r\n\r\n        if (ownerFiber.tag !== ClassComponent) {\r\n          throw new Error(\r\n            'Function components cannot have string refs. ' +\r\n            'We recommend using useRef() instead. ' +\r\n            'Learn more about using refs safely here: ' +\r\n            'https://reactjs.org/link/strict-mode-string-ref',\r\n          );\r\n        }\r\n\r\n        inst = ownerFiber.stateNode;\r\n      }\r\n\r\n      if (!inst) {\r\n        throw new Error(\r\n          `Missing owner for string ref ${mixedRef}. This error is likely caused by a ` +\r\n          'bug in React. Please file an issue.',\r\n        );\r\n      }\r\n      // Assigning this to a const so Flow knows it won't change in the closure\r\n      const resolvedInst = inst;\r\n\r\n      if (__DEV__) {\r\n        checkPropStringCoercion(mixedRef, 'ref');\r\n      }\r\n      const stringRef = '' + mixedRef;\r\n      // Check if previous string ref matches new string ref\r\n      if (\r\n        current !== null &&\r\n        current.ref !== null &&\r\n        typeof current.ref === 'function' &&\r\n        current.ref._stringRef === stringRef\r\n      ) {\r\n        return current.ref;\r\n      }\r\n      const ref = function (value) {\r\n        let refs = resolvedInst.refs;\r\n        if (refs === emptyRefsObject) {\r\n          // This is a lazy pooled frozen object, so we need to initialize.\r\n          refs = resolvedInst.refs = {};\r\n        }\r\n        if (value === null) {\r\n          delete refs[stringRef];\r\n        } else {\r\n          refs[stringRef] = value;\r\n        }\r\n      };\r\n      ref._stringRef = stringRef;\r\n      return ref;\r\n    } else {\r\n      if (typeof mixedRef !== 'string') {\r\n        throw new Error(\r\n          'Expected ref to be a function, a string, an object returned by React.createRef(), or null.',\r\n        );\r\n      }\r\n\r\n      if (!element._owner) {\r\n        throw new Error(\r\n          `Element ref was specified as a string (${mixedRef}) but no owner was set. This could happen for one of` +\r\n          ' the following reasons:\\n' +\r\n          '1. You may be adding a ref to a function component\\n' +\r\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\r\n          '3. You have multiple copies of React loaded\\n' +\r\n          'See https://reactjs.org/link/refs-must-have-owner for more information.',\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return mixedRef;\r\n}\r\n\r\nfunction throwOnInvalidObjectType (returnFiber: Fiber, newChild: Object) {\r\n  const childString = Object.prototype.toString.call(newChild);\r\n\r\n  throw new Error(\r\n    `Objects are not valid as a React child (found: ${childString === '[object Object]'\r\n      ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'\r\n      : childString\r\n    }). ` +\r\n    'If you meant to render a collection of children, use an array ' +\r\n    'instead.',\r\n  );\r\n}\r\n\r\nfunction warnOnFunctionType (returnFiber: Fiber) {\r\n  if (__DEV__) {\r\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\r\n\r\n    if (ownerHasFunctionTypeWarning[componentName]) {\r\n      return;\r\n    }\r\n    ownerHasFunctionTypeWarning[componentName] = true;\r\n\r\n    console.error(\r\n      'Functions are not valid as a React child. This may happen if ' +\r\n      'you return a Component instead of <Component /> from render. ' +\r\n      'Or maybe you meant to call this function rather than return it.',\r\n    );\r\n  }\r\n}\r\n\r\nfunction resolveLazy (lazyType) {\r\n  const payload = lazyType._payload;\r\n  const init = lazyType._init;\r\n  return init(payload);\r\n}\r\n\r\n// This wrapper function exists because I expect to clone the code in each path\r\n// to be able to optimize each path individually by branching early. This needs\r\n// a compiler or we can do it manually. Helpers that don't need this branching\r\n// live outside of this function.\r\nfunction ChildReconciler (shouldTrackSideEffects) {\r\n  function deleteChild (returnFiber: Fiber, childToDelete: Fiber): void {\r\n    if (!shouldTrackSideEffects) {\r\n      // Noop.\r\n      return;\r\n    }\r\n    const deletions = returnFiber.deletions;\r\n    if (deletions === null) {\r\n      returnFiber.deletions = [childToDelete];\r\n      returnFiber.flags |= ChildDeletion;\r\n    } else {\r\n      deletions.push(childToDelete);\r\n    }\r\n  }\r\n\r\n  function deleteRemainingChildren (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber | null,\r\n  ): null {\r\n    if (!shouldTrackSideEffects) {\r\n      // Noop.\r\n      return null;\r\n    }\r\n\r\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\r\n    // assuming that after the first child we've already added everything.\r\n    let childToDelete = currentFirstChild;\r\n    while (childToDelete !== null) {\r\n      deleteChild(returnFiber, childToDelete);\r\n      childToDelete = childToDelete.sibling;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  function mapRemainingChildren (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber,\r\n  ): Map<string | number, Fiber> {\r\n    // Add the remaining children to a temporary map so that we can find them by\r\n    // keys quickly. Implicit (null) keys get added to this set with their index\r\n    // instead.\r\n    const existingChildren: Map<string | number, Fiber> = new Map();\r\n\r\n    let existingChild = currentFirstChild;\r\n    while (existingChild !== null) {\r\n      if (existingChild.key !== null) {\r\n        existingChildren.set(existingChild.key, existingChild);\r\n      } else {\r\n        existingChildren.set(existingChild.index, existingChild);\r\n      }\r\n      existingChild = existingChild.sibling;\r\n    }\r\n    return existingChildren;\r\n  }\r\n\r\n  function useFiber (fiber: Fiber, pendingProps: mixed): Fiber {\r\n    // We currently set sibling to null and index to 0 here because it is easy\r\n    // to forget to do before returning it. E.g. for the single child case.\r\n    const clone = createWorkInProgress(fiber, pendingProps);\r\n    clone.index = 0;\r\n    clone.sibling = null;\r\n    return clone;\r\n  }\r\n\r\n  function placeChild (\r\n    newFiber: Fiber,\r\n    lastPlacedIndex: number,\r\n    newIndex: number,\r\n  ): number {\r\n    newFiber.index = newIndex;\r\n    if (!shouldTrackSideEffects) {\r\n      // During hydration, the useId algorithm needs to know which fibers are\r\n      // part of a list of children (arrays, iterators).\r\n      newFiber.flags |= Forked;\r\n      return lastPlacedIndex;\r\n    }\r\n    const current = newFiber.alternate;\r\n    if (current !== null) {\r\n      const oldIndex = current.index;\r\n      if (oldIndex < lastPlacedIndex) {\r\n        // This is a move.\r\n        newFiber.flags |= Placement;\r\n        return lastPlacedIndex;\r\n      } else {\r\n        // This item can stay in place.\r\n        return oldIndex;\r\n      }\r\n    } else {\r\n      // This is an insertion.\r\n      newFiber.flags |= Placement;\r\n      return lastPlacedIndex;\r\n    }\r\n  }\r\n\r\n  function placeSingleChild (newFiber: Fiber): Fiber {\r\n    // This is simpler for the single child case. We only need to do a\r\n    // placement for inserting new children.\r\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\r\n      newFiber.flags |= Placement;\r\n    }\r\n    return newFiber;\r\n  }\r\n\r\n  function updateTextNode (\r\n    returnFiber: Fiber,\r\n    current: Fiber | null,\r\n    textContent: string,\r\n    lanes: Lanes,\r\n  ) {\r\n    if (current === null || current.tag !== HostText) {\r\n      // Insert\r\n      const created = createFiberFromText(textContent, returnFiber.mode, lanes);\r\n      created.return = returnFiber;\r\n      return created;\r\n    } else {\r\n      // Update\r\n      const existing = useFiber(current, textContent);\r\n      existing.return = returnFiber;\r\n      return existing;\r\n    }\r\n  }\r\n\r\n  function updateElement (\r\n    returnFiber: Fiber,\r\n    current: Fiber | null,\r\n    element: ReactElement,\r\n    lanes: Lanes,\r\n  ): Fiber {\r\n    const elementType = element.type;\r\n    if (elementType === REACT_FRAGMENT_TYPE) {\r\n      return updateFragment(\r\n        returnFiber,\r\n        current,\r\n        element.props.children,\r\n        lanes,\r\n        element.key,\r\n      );\r\n    }\r\n    if (current !== null) {\r\n      if (\r\n        current.elementType === elementType ||\r\n        // Keep this check inline so it only runs on the false path:\r\n        (__DEV__\r\n          ? isCompatibleFamilyForHotReloading(current, element)\r\n          : false) ||\r\n        // Lazy types should reconcile their resolved type.\r\n        // We need to do this after the Hot Reloading check above,\r\n        // because hot reloading has different semantics than prod because\r\n        // it doesn't resuspend. So we can't let the call below suspend.\r\n        (typeof elementType === 'object' &&\r\n          elementType !== null &&\r\n          elementType.$$typeof === REACT_LAZY_TYPE &&\r\n          resolveLazy(elementType) === current.type)\r\n      ) {\r\n        // Move based on index\r\n        const existing = useFiber(current, element.props);\r\n        existing.ref = coerceRef(returnFiber, current, element);\r\n        existing.return = returnFiber;\r\n        if (__DEV__) {\r\n          existing._debugSource = element._source;\r\n          existing._debugOwner = element._owner;\r\n        }\r\n        return existing;\r\n      }\r\n    }\r\n    // Insert\r\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\r\n    created.ref = coerceRef(returnFiber, current, element);\r\n    created.return = returnFiber;\r\n    return created;\r\n  }\r\n\r\n  function updatePortal (\r\n    returnFiber: Fiber,\r\n    current: Fiber | null,\r\n    portal: ReactPortal,\r\n    lanes: Lanes,\r\n  ): Fiber {\r\n    if (\r\n      current === null ||\r\n      current.tag !== HostPortal ||\r\n      current.stateNode.containerInfo !== portal.containerInfo ||\r\n      current.stateNode.implementation !== portal.implementation\r\n    ) {\r\n      // Insert\r\n      const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\r\n      created.return = returnFiber;\r\n      return created;\r\n    } else {\r\n      // Update\r\n      const existing = useFiber(current, portal.children || []);\r\n      existing.return = returnFiber;\r\n      return existing;\r\n    }\r\n  }\r\n\r\n  function updateFragment (\r\n    returnFiber: Fiber,\r\n    current: Fiber | null,\r\n    fragment: Iterable<*>,\r\n    lanes: Lanes,\r\n    key: null | string,\r\n  ): Fiber {\r\n    if (current === null || current.tag !== Fragment) {\r\n      // Insert\r\n      const created = createFiberFromFragment(\r\n        fragment,\r\n        returnFiber.mode,\r\n        lanes,\r\n        key,\r\n      );\r\n      created.return = returnFiber;\r\n      return created;\r\n    } else {\r\n      // Update\r\n      const existing = useFiber(current, fragment);\r\n      existing.return = returnFiber;\r\n      return existing;\r\n    }\r\n  }\r\n\r\n  function createChild (\r\n    returnFiber: Fiber,\r\n    newChild: any,\r\n    lanes: Lanes,\r\n  ): Fiber | null {\r\n    if (\r\n      (typeof newChild === 'string' && newChild !== '') ||\r\n      typeof newChild === 'number'\r\n    ) {\r\n      // Text nodes don't have keys. If the previous node is implicitly keyed\r\n      // we can continue to replace it without aborting even if it is not a text\r\n      // node.\r\n      const created = createFiberFromText(\r\n        '' + newChild,\r\n        returnFiber.mode,\r\n        lanes,\r\n      );\r\n      created.return = returnFiber;\r\n      return created;\r\n    }\r\n\r\n    if (typeof newChild === 'object' && newChild !== null) {\r\n      switch (newChild.$$typeof) {\r\n        case REACT_ELEMENT_TYPE: {\r\n          const created = createFiberFromElement(\r\n            newChild,\r\n            returnFiber.mode,\r\n            lanes,\r\n          );\r\n          created.ref = coerceRef(returnFiber, null, newChild);\r\n          created.return = returnFiber;\r\n          return created;\r\n        }\r\n        case REACT_PORTAL_TYPE: {\r\n          const created = createFiberFromPortal(\r\n            newChild,\r\n            returnFiber.mode,\r\n            lanes,\r\n          );\r\n          created.return = returnFiber;\r\n          return created;\r\n        }\r\n        case REACT_LAZY_TYPE: {\r\n          const payload = newChild._payload;\r\n          const init = newChild._init;\r\n          return createChild(returnFiber, init(payload), lanes);\r\n        }\r\n      }\r\n\r\n      if (isArray(newChild) || getIteratorFn(newChild)) {\r\n        const created = createFiberFromFragment(\r\n          newChild,\r\n          returnFiber.mode,\r\n          lanes,\r\n          null,\r\n        );\r\n        created.return = returnFiber;\r\n        return created;\r\n      }\r\n\r\n      throwOnInvalidObjectType(returnFiber, newChild);\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (typeof newChild === 'function') {\r\n        warnOnFunctionType(returnFiber);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  function updateSlot (\r\n    returnFiber: Fiber,\r\n    oldFiber: Fiber | null,\r\n    newChild: any,\r\n    lanes: Lanes,\r\n  ): Fiber | null {\r\n    // Update the fiber if the keys match, otherwise return null.\r\n\r\n    const key = oldFiber !== null ? oldFiber.key : null;\r\n\r\n    if (\r\n      (typeof newChild === 'string' && newChild !== '') ||\r\n      typeof newChild === 'number'\r\n    ) {\r\n      // Text nodes don't have keys. If the previous node is implicitly keyed\r\n      // we can continue to replace it without aborting even if it is not a text\r\n      // node.\r\n      if (key !== null) {\r\n        return null;\r\n      }\r\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\r\n    }\r\n\r\n    if (typeof newChild === 'object' && newChild !== null) {\r\n      switch (newChild.$$typeof) {\r\n        case REACT_ELEMENT_TYPE: {\r\n          if (newChild.key === key) {\r\n            return updateElement(returnFiber, oldFiber, newChild, lanes);\r\n          } else {\r\n            return null;\r\n          }\r\n        }\r\n        case REACT_PORTAL_TYPE: {\r\n          if (newChild.key === key) {\r\n            return updatePortal(returnFiber, oldFiber, newChild, lanes);\r\n          } else {\r\n            return null;\r\n          }\r\n        }\r\n        case REACT_LAZY_TYPE: {\r\n          const payload = newChild._payload;\r\n          const init = newChild._init;\r\n          return updateSlot(returnFiber, oldFiber, init(payload), lanes);\r\n        }\r\n      }\r\n\r\n      if (isArray(newChild) || getIteratorFn(newChild)) {\r\n        if (key !== null) {\r\n          return null;\r\n        }\r\n\r\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\r\n      }\r\n\r\n      throwOnInvalidObjectType(returnFiber, newChild);\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (typeof newChild === 'function') {\r\n        warnOnFunctionType(returnFiber);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  function updateFromMap (\r\n    existingChildren: Map<string | number, Fiber>,\r\n    returnFiber: Fiber,\r\n    newIdx: number,\r\n    newChild: any,\r\n    lanes: Lanes,\r\n  ): Fiber | null {\r\n    if (\r\n      (typeof newChild === 'string' && newChild !== '') ||\r\n      typeof newChild === 'number'\r\n    ) {\r\n      // Text nodes don't have keys, so we neither have to check the old nor\r\n      // new node for the key. If both are text nodes, they match.\r\n      const matchedFiber = existingChildren.get(newIdx) || null;\r\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\r\n    }\r\n\r\n    if (typeof newChild === 'object' && newChild !== null) {\r\n      switch (newChild.$$typeof) {\r\n        case REACT_ELEMENT_TYPE: {\r\n          const matchedFiber =\r\n            existingChildren.get(\r\n              newChild.key === null ? newIdx : newChild.key,\r\n            ) || null;\r\n          return updateElement(returnFiber, matchedFiber, newChild, lanes);\r\n        }\r\n        case REACT_PORTAL_TYPE: {\r\n          const matchedFiber =\r\n            existingChildren.get(\r\n              newChild.key === null ? newIdx : newChild.key,\r\n            ) || null;\r\n          return updatePortal(returnFiber, matchedFiber, newChild, lanes);\r\n        }\r\n        case REACT_LAZY_TYPE:\r\n          const payload = newChild._payload;\r\n          const init = newChild._init;\r\n          return updateFromMap(\r\n            existingChildren,\r\n            returnFiber,\r\n            newIdx,\r\n            init(payload),\r\n            lanes,\r\n          );\r\n      }\r\n\r\n      if (isArray(newChild) || getIteratorFn(newChild)) {\r\n        const matchedFiber = existingChildren.get(newIdx) || null;\r\n        return updateFragment(returnFiber, matchedFiber, newChild, lanes, null);\r\n      }\r\n\r\n      throwOnInvalidObjectType(returnFiber, newChild);\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (typeof newChild === 'function') {\r\n        warnOnFunctionType(returnFiber);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Warns if there is a duplicate or missing key\r\n   */\r\n  function warnOnInvalidKey (\r\n    child: mixed,\r\n    knownKeys: Set<string> | null,\r\n    returnFiber: Fiber,\r\n  ): Set<string> | null {\r\n    if (__DEV__) {\r\n      if (typeof child !== 'object' || child === null) {\r\n        return knownKeys;\r\n      }\r\n      switch (child.$$typeof) {\r\n        case REACT_ELEMENT_TYPE:\r\n        case REACT_PORTAL_TYPE:\r\n          warnForMissingKey(child, returnFiber);\r\n          const key = child.key;\r\n          if (typeof key !== 'string') {\r\n            break;\r\n          }\r\n          if (knownKeys === null) {\r\n            knownKeys = new Set();\r\n            knownKeys.add(key);\r\n            break;\r\n          }\r\n          if (!knownKeys.has(key)) {\r\n            knownKeys.add(key);\r\n            break;\r\n          }\r\n          console.error(\r\n            'Encountered two children with the same key, `%s`. ' +\r\n            'Keys should be unique so that components maintain their identity ' +\r\n            'across updates. Non-unique keys may cause children to be ' +\r\n            'duplicated and/or omitted — the behavior is unsupported and ' +\r\n            'could change in a future version.',\r\n            key,\r\n          );\r\n          break;\r\n        case REACT_LAZY_TYPE:\r\n          const payload = child._payload;\r\n          const init = (child._init: any);\r\n          warnOnInvalidKey(init(payload), knownKeys, returnFiber);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    return knownKeys;\r\n  }\r\n\r\n  function reconcileChildrenArray (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber | null,\r\n    newChildren: Array<*>,\r\n    lanes: Lanes,\r\n  ): Fiber | null {\r\n    // This algorithm can't optimize by searching from both ends since we\r\n    // don't have backpointers on fibers. I'm trying to see how far we can get\r\n    // with that model. If it ends up not being worth the tradeoffs, we can\r\n    // add it later.\r\n\r\n    // Even with a two ended optimization, we'd want to optimize for the case\r\n    // where there are few changes and brute force the comparison instead of\r\n    // going for the Map. It'd like to explore hitting that path first in\r\n    // forward-only mode and only go for the Map once we notice that we need\r\n    // lots of look ahead. This doesn't handle reversal as well as two ended\r\n    // search but that's unusual. Besides, for the two ended optimization to\r\n    // work on Iterables, we'd need to copy the whole set.\r\n\r\n    // In this first iteration, we'll just live with hitting the bad case\r\n    // (adding everything to a Map) in for every insert/move.\r\n\r\n    // If you change this code, also update reconcileChildrenIterator() which\r\n    // uses the same algorithm.\r\n\r\n    if (__DEV__) {\r\n      // First, validate keys.\r\n      let knownKeys = null;\r\n      for (let i = 0; i < newChildren.length; i++) {\r\n        const child = newChildren[i];\r\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\r\n      }\r\n    }\r\n\r\n    let resultingFirstChild: Fiber | null = null;\r\n    let previousNewFiber: Fiber | null = null;\r\n\r\n    let oldFiber = currentFirstChild;\r\n    let lastPlacedIndex = 0;\r\n    let newIdx = 0;\r\n    let nextOldFiber = null;\r\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\r\n      if (oldFiber.index > newIdx) {\r\n        nextOldFiber = oldFiber;\r\n        oldFiber = null;\r\n      } else {\r\n        nextOldFiber = oldFiber.sibling;\r\n      }\r\n      const newFiber = updateSlot(\r\n        returnFiber,\r\n        oldFiber,\r\n        newChildren[newIdx],\r\n        lanes,\r\n      );\r\n      if (newFiber === null) {\r\n        // TODO: This breaks on empty slots like null children. That's\r\n        // unfortunate because it triggers the slow path all the time. We need\r\n        // a better way to communicate whether this was a miss or null,\r\n        // boolean, undefined, etc.\r\n        if (oldFiber === null) {\r\n          oldFiber = nextOldFiber;\r\n        }\r\n        break;\r\n      }\r\n      if (shouldTrackSideEffects) {\r\n        if (oldFiber && newFiber.alternate === null) {\r\n          // We matched the slot, but we didn't reuse the existing fiber, so we\r\n          // need to delete the existing child.\r\n          deleteChild(returnFiber, oldFiber);\r\n        }\r\n      }\r\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n      if (previousNewFiber === null) {\r\n        // TODO: Move out of the loop. This only happens for the first run.\r\n        resultingFirstChild = newFiber;\r\n      } else {\r\n        // TODO: Defer siblings if we're not at the right index for this slot.\r\n        // I.e. if we had null values before, then we want to defer this\r\n        // for each null value. However, we also don't want to call updateSlot\r\n        // with the previous one.\r\n        previousNewFiber.sibling = newFiber;\r\n      }\r\n      previousNewFiber = newFiber;\r\n      oldFiber = nextOldFiber;\r\n    }\r\n\r\n    if (newIdx === newChildren.length) {\r\n      // We've reached the end of the new children. We can delete the rest.\r\n      deleteRemainingChildren(returnFiber, oldFiber);\r\n      if (getIsHydrating()) {\r\n        const numberOfForks = newIdx;\r\n        pushTreeFork(returnFiber, numberOfForks);\r\n      }\r\n      return resultingFirstChild;\r\n    }\r\n\r\n    if (oldFiber === null) {\r\n      // If we don't have any more existing children we can choose a fast path\r\n      // since the rest will all be insertions.\r\n      for (; newIdx < newChildren.length; newIdx++) {\r\n        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\r\n        if (newFiber === null) {\r\n          continue;\r\n        }\r\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n        if (previousNewFiber === null) {\r\n          // TODO: Move out of the loop. This only happens for the first run.\r\n          resultingFirstChild = newFiber;\r\n        } else {\r\n          previousNewFiber.sibling = newFiber;\r\n        }\r\n        previousNewFiber = newFiber;\r\n      }\r\n      if (getIsHydrating()) {\r\n        const numberOfForks = newIdx;\r\n        pushTreeFork(returnFiber, numberOfForks);\r\n      }\r\n      return resultingFirstChild;\r\n    }\r\n\r\n    // Add all children to a key map for quick lookups.\r\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\r\n\r\n    // Keep scanning and use the map to restore deleted items as moves.\r\n    for (; newIdx < newChildren.length; newIdx++) {\r\n      const newFiber = updateFromMap(\r\n        existingChildren,\r\n        returnFiber,\r\n        newIdx,\r\n        newChildren[newIdx],\r\n        lanes,\r\n      );\r\n      if (newFiber !== null) {\r\n        if (shouldTrackSideEffects) {\r\n          if (newFiber.alternate !== null) {\r\n            // The new fiber is a work in progress, but if there exists a\r\n            // current, that means that we reused the fiber. We need to delete\r\n            // it from the child list so that we don't add it to the deletion\r\n            // list.\r\n            existingChildren.delete(\r\n              newFiber.key === null ? newIdx : newFiber.key,\r\n            );\r\n          }\r\n        }\r\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n        if (previousNewFiber === null) {\r\n          resultingFirstChild = newFiber;\r\n        } else {\r\n          previousNewFiber.sibling = newFiber;\r\n        }\r\n        previousNewFiber = newFiber;\r\n      }\r\n    }\r\n\r\n    if (shouldTrackSideEffects) {\r\n      // Any existing children that weren't consumed above were deleted. We need\r\n      // to add them to the deletion list.\r\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\r\n    }\r\n\r\n    if (getIsHydrating()) {\r\n      const numberOfForks = newIdx;\r\n      pushTreeFork(returnFiber, numberOfForks);\r\n    }\r\n    return resultingFirstChild;\r\n  }\r\n\r\n  function reconcileChildrenIterator (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber | null,\r\n    newChildrenIterable: Iterable<*>,\r\n    lanes: Lanes,\r\n  ): Fiber | null {\r\n    // This is the same implementation as reconcileChildrenArray(),\r\n    // but using the iterator instead.\r\n\r\n    const iteratorFn = getIteratorFn(newChildrenIterable);\r\n\r\n    if (typeof iteratorFn !== 'function') {\r\n      throw new Error(\r\n        'An object is not an iterable. This error is likely caused by a bug in ' +\r\n        'React. Please file an issue.',\r\n      );\r\n    }\r\n\r\n    if (__DEV__) {\r\n      // We don't support rendering Generators because it's a mutation.\r\n      // See https://github.com/facebook/react/issues/12995\r\n      if (\r\n        typeof Symbol === 'function' &&\r\n        // $FlowFixMe Flow doesn't know about toStringTag\r\n        newChildrenIterable[Symbol.toStringTag] === 'Generator'\r\n      ) {\r\n        if (!didWarnAboutGenerators) {\r\n          console.error(\r\n            'Using Generators as children is unsupported and will likely yield ' +\r\n            'unexpected results because enumerating a generator mutates it. ' +\r\n            'You may convert it to an array with `Array.from()` or the ' +\r\n            '`[...spread]` operator before rendering. Keep in mind ' +\r\n            'you might need to polyfill these features for older browsers.',\r\n          );\r\n        }\r\n        didWarnAboutGenerators = true;\r\n      }\r\n\r\n      // Warn about using Maps as children\r\n      if ((newChildrenIterable: any).entries === iteratorFn) {\r\n        if (!didWarnAboutMaps) {\r\n          console.error(\r\n            'Using Maps as children is not supported. ' +\r\n            'Use an array of keyed ReactElements instead.',\r\n          );\r\n        }\r\n        didWarnAboutMaps = true;\r\n      }\r\n\r\n      // First, validate keys.\r\n      // We'll get a different iterator later for the main pass.\r\n      const newChildren = iteratorFn.call(newChildrenIterable);\r\n      if (newChildren) {\r\n        let knownKeys = null;\r\n        let step = newChildren.next();\r\n        for (; !step.done; step = newChildren.next()) {\r\n          const child = step.value;\r\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\r\n        }\r\n      }\r\n    }\r\n\r\n    const newChildren = iteratorFn.call(newChildrenIterable);\r\n\r\n    if (newChildren == null) {\r\n      throw new Error('An iterable object provided no iterator.');\r\n    }\r\n\r\n    let resultingFirstChild: Fiber | null = null;\r\n    let previousNewFiber: Fiber | null = null;\r\n\r\n    let oldFiber = currentFirstChild;\r\n    let lastPlacedIndex = 0;\r\n    let newIdx = 0;\r\n    let nextOldFiber = null;\r\n\r\n    let step = newChildren.next();\r\n    for (\r\n      ;\r\n      oldFiber !== null && !step.done;\r\n      newIdx++, step = newChildren.next()\r\n    ) {\r\n      if (oldFiber.index > newIdx) {\r\n        nextOldFiber = oldFiber;\r\n        oldFiber = null;\r\n      } else {\r\n        nextOldFiber = oldFiber.sibling;\r\n      }\r\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\r\n      if (newFiber === null) {\r\n        // TODO: This breaks on empty slots like null children. That's\r\n        // unfortunate because it triggers the slow path all the time. We need\r\n        // a better way to communicate whether this was a miss or null,\r\n        // boolean, undefined, etc.\r\n        if (oldFiber === null) {\r\n          oldFiber = nextOldFiber;\r\n        }\r\n        break;\r\n      }\r\n      if (shouldTrackSideEffects) {\r\n        if (oldFiber && newFiber.alternate === null) {\r\n          // We matched the slot, but we didn't reuse the existing fiber, so we\r\n          // need to delete the existing child.\r\n          deleteChild(returnFiber, oldFiber);\r\n        }\r\n      }\r\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n      if (previousNewFiber === null) {\r\n        // TODO: Move out of the loop. This only happens for the first run.\r\n        resultingFirstChild = newFiber;\r\n      } else {\r\n        // TODO: Defer siblings if we're not at the right index for this slot.\r\n        // I.e. if we had null values before, then we want to defer this\r\n        // for each null value. However, we also don't want to call updateSlot\r\n        // with the previous one.\r\n        previousNewFiber.sibling = newFiber;\r\n      }\r\n      previousNewFiber = newFiber;\r\n      oldFiber = nextOldFiber;\r\n    }\r\n\r\n    if (step.done) {\r\n      // We've reached the end of the new children. We can delete the rest.\r\n      deleteRemainingChildren(returnFiber, oldFiber);\r\n      if (getIsHydrating()) {\r\n        const numberOfForks = newIdx;\r\n        pushTreeFork(returnFiber, numberOfForks);\r\n      }\r\n      return resultingFirstChild;\r\n    }\r\n\r\n    if (oldFiber === null) {\r\n      // If we don't have any more existing children we can choose a fast path\r\n      // since the rest will all be insertions.\r\n      for (; !step.done; newIdx++, step = newChildren.next()) {\r\n        const newFiber = createChild(returnFiber, step.value, lanes);\r\n        if (newFiber === null) {\r\n          continue;\r\n        }\r\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n        if (previousNewFiber === null) {\r\n          // TODO: Move out of the loop. This only happens for the first run.\r\n          resultingFirstChild = newFiber;\r\n        } else {\r\n          previousNewFiber.sibling = newFiber;\r\n        }\r\n        previousNewFiber = newFiber;\r\n      }\r\n      if (getIsHydrating()) {\r\n        const numberOfForks = newIdx;\r\n        pushTreeFork(returnFiber, numberOfForks);\r\n      }\r\n      return resultingFirstChild;\r\n    }\r\n\r\n    // Add all children to a key map for quick lookups.\r\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\r\n\r\n    // Keep scanning and use the map to restore deleted items as moves.\r\n    for (; !step.done; newIdx++, step = newChildren.next()) {\r\n      const newFiber = updateFromMap(\r\n        existingChildren,\r\n        returnFiber,\r\n        newIdx,\r\n        step.value,\r\n        lanes,\r\n      );\r\n      if (newFiber !== null) {\r\n        if (shouldTrackSideEffects) {\r\n          if (newFiber.alternate !== null) {\r\n            // The new fiber is a work in progress, but if there exists a\r\n            // current, that means that we reused the fiber. We need to delete\r\n            // it from the child list so that we don't add it to the deletion\r\n            // list.\r\n            existingChildren.delete(\r\n              newFiber.key === null ? newIdx : newFiber.key,\r\n            );\r\n          }\r\n        }\r\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n        if (previousNewFiber === null) {\r\n          resultingFirstChild = newFiber;\r\n        } else {\r\n          previousNewFiber.sibling = newFiber;\r\n        }\r\n        previousNewFiber = newFiber;\r\n      }\r\n    }\r\n\r\n    if (shouldTrackSideEffects) {\r\n      // Any existing children that weren't consumed above were deleted. We need\r\n      // to add them to the deletion list.\r\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\r\n    }\r\n\r\n    if (getIsHydrating()) {\r\n      const numberOfForks = newIdx;\r\n      pushTreeFork(returnFiber, numberOfForks);\r\n    }\r\n    return resultingFirstChild;\r\n  }\r\n\r\n  function reconcileSingleTextNode (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber | null,\r\n    textContent: string,\r\n    lanes: Lanes,\r\n  ): Fiber {\r\n    // There's no need to check for keys on text nodes since we don't have a\r\n    // way to define them.\r\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\r\n      // We already have an existing node so let's just update it and delete\r\n      // the rest.\r\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\r\n      const existing = useFiber(currentFirstChild, textContent);\r\n      existing.return = returnFiber;\r\n      return existing;\r\n    }\r\n    // The existing first child is not a text node so we need to create one\r\n    // and delete the existing ones.\r\n    deleteRemainingChildren(returnFiber, currentFirstChild);\r\n    const created = createFiberFromText(textContent, returnFiber.mode, lanes);\r\n    created.return = returnFiber;\r\n    return created;\r\n  }\r\n\r\n\r\n  // 单点diff有如下几种情况：\r\n  // key和type相同表示可以复用节点\r\n  // key不同直接标记删除节点，然后新建节点\r\n  // key相同type不同，标记删除该节点和兄弟节点，然后新创建节点\r\n  function reconcileSingleElement (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber | null,\r\n    element: ReactElement,\r\n    lanes: Lanes,\r\n  ): Fiber {\r\n    const key = element.key;\r\n    let child = currentFirstChild;\r\n    while (child !== null) {\r\n      // TODO: If key === null and child.key === null, then this only applies to\r\n      // the first item in the list.\r\n      if (child.key === key) {\r\n        const elementType = element.type;\r\n        if (elementType === REACT_FRAGMENT_TYPE) {\r\n          if (child.tag === Fragment) {\r\n            deleteRemainingChildren(returnFiber, child.sibling);\r\n            const existing = useFiber(child, element.props.children);\r\n            existing.return = returnFiber;\r\n            if (__DEV__) {\r\n              existing._debugSource = element._source;\r\n              existing._debugOwner = element._owner;\r\n            }\r\n            return existing;\r\n          }\r\n        } else {\r\n          if (\r\n            child.elementType === elementType ||\r\n            // Keep this check inline so it only runs on the false path:\r\n            (__DEV__\r\n              ? isCompatibleFamilyForHotReloading(child, element)\r\n              : false) ||\r\n            // Lazy types should reconcile their resolved type.\r\n            // We need to do this after the Hot Reloading check above,\r\n            // because hot reloading has different semantics than prod because\r\n            // it doesn't resuspend. So we can't let the call below suspend.\r\n            (typeof elementType === 'object' &&\r\n              elementType !== null &&\r\n              elementType.$$typeof === REACT_LAZY_TYPE &&\r\n              resolveLazy(elementType) === child.type)\r\n          ) {\r\n            deleteRemainingChildren(returnFiber, child.sibling);\r\n            const existing = useFiber(child, element.props);\r\n            existing.ref = coerceRef(returnFiber, child, element);\r\n            existing.return = returnFiber;\r\n            if (__DEV__) {\r\n              existing._debugSource = element._source;\r\n              existing._debugOwner = element._owner;\r\n            }\r\n            return existing;\r\n          }\r\n        }\r\n        // Didn't match.\r\n        deleteRemainingChildren(returnFiber, child);\r\n        break;\r\n      } else {\r\n        deleteChild(returnFiber, child);\r\n      }\r\n      //key不同直接标记删除该节点\r\n      child = child.sibling;\r\n    }\r\n\r\n    if (element.type === REACT_FRAGMENT_TYPE) {\r\n      const created = createFiberFromFragment(\r\n        element.props.children,\r\n        returnFiber.mode,\r\n        lanes,\r\n        element.key,\r\n      );\r\n      created.return = returnFiber;\r\n      return created;\r\n    } else {\r\n      const created = createFiberFromElement(element, returnFiber.mode, lanes);\r\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\r\n      created.return = returnFiber;\r\n      return created;\r\n    }\r\n  }\r\n\r\n  function reconcileSinglePortal (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber | null,\r\n    portal: ReactPortal,\r\n    lanes: Lanes,\r\n  ): Fiber {\r\n    const key = portal.key;\r\n    let child = currentFirstChild;\r\n    while (child !== null) {\r\n      // TODO: If key === null and child.key === null, then this only applies to\r\n      // the first item in the list.\r\n      if (child.key === key) {\r\n        if (\r\n          child.tag === HostPortal &&\r\n          child.stateNode.containerInfo === portal.containerInfo &&\r\n          child.stateNode.implementation === portal.implementation\r\n        ) {\r\n          deleteRemainingChildren(returnFiber, child.sibling);\r\n          const existing = useFiber(child, portal.children || []);\r\n          existing.return = returnFiber;\r\n          return existing;\r\n        } else {\r\n          deleteRemainingChildren(returnFiber, child);\r\n          break;\r\n        }\r\n      } else {\r\n        deleteChild(returnFiber, child);\r\n      }\r\n      child = child.sibling;\r\n    }\r\n\r\n    const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\r\n    created.return = returnFiber;\r\n    return created;\r\n  }\r\n\r\n  // This API will tag the children with the side-effect of the reconciliation\r\n  // itself. They will be added to the side-effect list as we pass through the\r\n  // children and the parent.\r\n\r\n  // 开始react diff算法\r\n  function reconcileChildFibers (\r\n    returnFiber: Fiber,\r\n    currentFirstChild: Fiber | null,\r\n    newChild: any,\r\n    lanes: Lanes,\r\n  ): Fiber | null {\r\n    console.log({\r\n      returnFiber,\r\n      currentFirstChild,\r\n      newChild,\r\n      lanes\r\n    })\r\n    // This function is not recursive.\r\n    // If the top level item is an array, we treat it as a set of children,\r\n    // not as a fragment. Nested arrays on the other hand will be treated as\r\n    // fragment nodes. Recursion happens at the normal flow.\r\n\r\n    // Handle top level unkeyed fragments as if they were arrays.\r\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\r\n    // We treat the ambiguous cases above the same.\r\n    const isUnkeyedTopLevelFragment =\r\n      typeof newChild === 'object' &&\r\n      newChild !== null &&\r\n      newChild.type === REACT_FRAGMENT_TYPE &&\r\n      newChild.key === null;\r\n    if (isUnkeyedTopLevelFragment) {\r\n      newChild = newChild.props.children;\r\n    }\r\n\r\n    // Handle object types\r\n    // 根据newChild的类型来进入单节点的diff或者多节点diff\r\n    if (typeof newChild === 'object' && newChild !== null) {\r\n      switch (newChild.$$typeof) {\r\n        case REACT_ELEMENT_TYPE:\r\n          //单一节点diff\r\n          return placeSingleChild(\r\n            reconcileSingleElement(\r\n              returnFiber,\r\n              currentFirstChild,\r\n              newChild,\r\n              lanes,\r\n            ),\r\n          );\r\n        case REACT_PORTAL_TYPE:\r\n          return placeSingleChild(\r\n            reconcileSinglePortal(\r\n              returnFiber,\r\n              currentFirstChild,\r\n              newChild,\r\n              lanes,\r\n            ),\r\n          );\r\n        case REACT_LAZY_TYPE:\r\n          const payload = newChild._payload;\r\n          const init = newChild._init;\r\n          // TODO: This function is supposed to be non-recursive.\r\n          return reconcileChildFibers(\r\n            returnFiber,\r\n            currentFirstChild,\r\n            init(payload),\r\n            lanes,\r\n          );\r\n      }\r\n\r\n      if (isArray(newChild)) {\r\n        //多节点diff\r\n        return reconcileChildrenArray(\r\n          returnFiber,\r\n          currentFirstChild,\r\n          newChild,\r\n          lanes,\r\n        );\r\n      }\r\n\r\n      if (getIteratorFn(newChild)) {\r\n        return reconcileChildrenIterator(\r\n          returnFiber,\r\n          currentFirstChild,\r\n          newChild,\r\n          lanes,\r\n        );\r\n      }\r\n\r\n      throwOnInvalidObjectType(returnFiber, newChild);\r\n    }\r\n\r\n    if (\r\n      (typeof newChild === 'string' && newChild !== '') ||\r\n      typeof newChild === 'number'\r\n    ) {\r\n      return placeSingleChild(\r\n        reconcileSingleTextNode(\r\n          returnFiber,\r\n          currentFirstChild,\r\n          '' + newChild,\r\n          lanes,\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (typeof newChild === 'function') {\r\n        warnOnFunctionType(returnFiber);\r\n      }\r\n    }\r\n\r\n    // Remaining cases are all treated as empty.\r\n\r\n    // 删除节点\r\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\r\n  }\r\n\r\n  return reconcileChildFibers;\r\n}\r\n\r\nexport const reconcileChildFibers = ChildReconciler(true);\r\nexport const mountChildFibers = ChildReconciler(false);\r\n\r\nexport function cloneChildFibers (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n): void {\r\n  if (current !== null && workInProgress.child !== current.child) {\r\n    throw new Error('Resuming work not yet implemented.');\r\n  }\r\n\r\n  if (workInProgress.child === null) {\r\n    return;\r\n  }\r\n\r\n  let currentChild = workInProgress.child;\r\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\r\n  workInProgress.child = newChild;\r\n\r\n  newChild.return = workInProgress;\r\n  while (currentChild.sibling !== null) {\r\n    currentChild = currentChild.sibling;\r\n    newChild = newChild.sibling = createWorkInProgress(\r\n      currentChild,\r\n      currentChild.pendingProps,\r\n    );\r\n    newChild.return = workInProgress;\r\n  }\r\n  newChild.sibling = null;\r\n}\r\n\r\n// Reset a workInProgress child set to prepare it for a second pass.\r\nexport function resetChildFibers (workInProgress: Fiber, lanes: Lanes): void {\r\n  let child = workInProgress.child;\r\n  while (child !== null) {\r\n    resetWorkInProgress(child, lanes);\r\n    child = child.sibling;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}