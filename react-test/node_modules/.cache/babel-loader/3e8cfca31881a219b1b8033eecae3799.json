{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nfunction invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n  const funcArgs = Array.prototype.slice.call(arguments, 3);\n\n  try {// func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n}\n\nlet invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n\nif (__DEV__) {\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    const fakeNode = document.createElement('react');\n\n    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebook/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      if (typeof document === 'undefined' || document === null) {\n        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');\n      }\n      /**\r\n       * 创建一个事件对象，名字为newEvent，类型为HTMLEvent\r\n       * var newEvent = document.createEvent(\"HTMLEvents\");\r\n       * 实例化创建好的事件对象\r\n       *  第一个参数：事件类型（就好像是click还是submit）\r\n       * 第二个参数：是否冒泡\r\n       * 第三个参数：是否阻止浏览器默认行为（例如阻止submit事件提交表单）\r\n       * newEvent.initEvent(\"myEvent\",true,true);\r\n       * 给自定义事件对象的属性赋值。这个属性一开始不存在，我们这里将其实例化了\r\n       *  newEvent.name = \"THis is Name\";\r\n       * 将自定义事件绑定在document上，你也可以绑定到指定元素上。\r\n       * 这里要注意：第一个参数要和上面initEvent()的第一个参数一致，否则无法触发这个事件以及获取newEvent中的一些属性（比如这里的newEvent.name）。\r\n       * document.addEventListener(\"myEvent\",function() {\r\n      21         alert(\"自定义事件的name属性：\" + newEvent.name);\r\n      22     },false);\r\n       * 触发自定义事件\r\n       * document.dispatchEvent(newEvent);  \r\n       */\n\n\n      const evt = document.createEvent('Event');\n      let didCall = false; // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n\n      let didError = true; // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n\n      const windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event\n      // dispatching: https://github.com/facebook/react/issues/13688\n      // 获取window对象中event的描述符（value writable  get set configurable enumerable）\n\n      const windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');\n\n      function restoreAfterDispatch() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n\n        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\n          window.event = windowEvent;\n        }\n      } // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      // 获取react所有的事件参数\n\n\n      const funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      function callCallback() {\n        didCall = true; // 移除事件监听\n\n        restoreAfterDispatch(); // 触发用户事件，并且将react自定义事件参数传入\n\n        func.apply(context, funcArgs);\n        didError = false;\n      } // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n\n\n      let error; // Use this to track whether the error event is ever called.\n\n      let didSetError = false;\n      let isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === 'object') {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {// Ignore.\n            }\n          }\n        }\n      } // Create a fake event type.\n\n\n      const evtType = `react-${name ? name : 'invokeguardedcallback'}`; // Attach our event handlers\n      // 当资源加载失败或无法使用时，会在Window对象触发error事件\n\n      window.addEventListener('error', handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (windowEventDescriptor) {\n        Object.defineProperty(window, 'event', windowEventDescriptor);\n      }\n\n      if (didCall && didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');\n        }\n\n        this.onError(error);\n      } // Remove our event listeners\n\n\n      window.removeEventListener('error', handleWindowError);\n\n      if (!didCall) {\n        // Something went really wrong, and our event was not dispatched.\n        // https://github.com/facebook/react/issues/16734\n        // https://github.com/facebook/react/issues/16585\n        // Fall back to the production implementation.\n        restoreAfterDispatch();\n        return invokeGuardedCallbackProd.apply(this, arguments);\n      }\n    };\n  }\n}\n\nexport default invokeGuardedCallbackImpl;","map":{"version":3,"names":["invokeGuardedCallbackProd","name","func","context","a","b","c","d","e","f","funcArgs","Array","prototype","slice","call","arguments","error","onError","invokeGuardedCallbackImpl","__DEV__","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","Error","evt","didCall","didError","windowEvent","event","windowEventDescriptor","Object","getOwnPropertyDescriptor","restoreAfterDispatch","removeEventListener","evtType","callCallback","hasOwnProperty","apply","didSetError","isCrossOriginError","handleWindowError","colno","lineno","defaultPrevented","_suppressLogging","inner","addEventListener","initEvent","defineProperty"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/shared/invokeGuardedCallbackImpl.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nfunction invokeGuardedCallbackProd<A, B, C, D, E, F, Context>(\r\n  name: string | null,\r\n  func: (a: A, b: B, c: C, d: D, e: E, f: F) => mixed,\r\n  context: Context,\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n  e: E,\r\n  f: F,\r\n) {\r\n  const funcArgs = Array.prototype.slice.call(arguments, 3);\r\n  try {\r\n    // func.apply(context, funcArgs);\r\n  } catch (error) {\r\n    this.onError(error);\r\n  }\r\n}\r\n\r\nlet invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\r\n\r\nif (__DEV__) {\r\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\r\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\r\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\r\n  // functions in invokeGuardedCallback, and the production version of\r\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\r\n  // like caught exceptions, and the DevTools won't pause unless the developer\r\n  // takes the extra step of enabling pause on caught exceptions. This is\r\n  // unintuitive, though, because even though React has caught the error, from\r\n  // the developer's perspective, the error is uncaught.\r\n  //\r\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\r\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\r\n  // DOM node, and call the user-provided callback from inside an event handler\r\n  // for that fake event. If the callback throws, the error is \"captured\" using\r\n  // a global event handler. But because the error happens in a different\r\n  // event loop context, it does not interrupt the normal program flow.\r\n  // Effectively, this gives us try-catch behavior without actually using\r\n  // try-catch. Neat!\r\n\r\n  // Check that the browser supports the APIs we need to implement our special\r\n  // DEV version of invokeGuardedCallback\r\n  if (\r\n    typeof window !== 'undefined' &&\r\n    typeof window.dispatchEvent === 'function' &&\r\n    typeof document !== 'undefined' &&\r\n    typeof document.createEvent === 'function'\r\n  ) {\r\n    const fakeNode = document.createElement('react');\r\n    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev<\r\n      A,\r\n      B,\r\n      C,\r\n      D,\r\n      E,\r\n      F,\r\n      Context,\r\n    >(\r\n      name: string | null,\r\n      func: (a: A, b: B, c: C, d: D, e: E, f: F) => mixed,\r\n      context: Context,\r\n      a: A,\r\n      b: B,\r\n      c: C,\r\n      d: D,\r\n      e: E,\r\n      f: F,\r\n    ) {\r\n      // If document doesn't exist we know for sure we will crash in this method\r\n      // when we call document.createEvent(). However this can cause confusing\r\n      // errors: https://github.com/facebook/create-react-app/issues/3482\r\n      // So we preemptively throw with a better message instead.\r\n      if (typeof document === 'undefined' || document === null) {\r\n        throw new Error(\r\n          'The `document` global was defined when React was initialized, but is not ' +\r\n            'defined anymore. This can happen in a test environment if a component ' +\r\n            'schedules an update from an asynchronous callback, but the test has already ' +\r\n            'finished running. To solve this, you can either unmount the component at ' +\r\n            'the end of your test (and ensure that any asynchronous operations get ' +\r\n            'canceled in `componentWillUnmount`), or you can change the test itself ' +\r\n            'to be asynchronous.',\r\n        );\r\n      }\r\n\r\n      /**\r\n       * 创建一个事件对象，名字为newEvent，类型为HTMLEvent\r\n       * var newEvent = document.createEvent(\"HTMLEvents\");\r\n       * 实例化创建好的事件对象\r\n       *  第一个参数：事件类型（就好像是click还是submit）\r\n       * 第二个参数：是否冒泡\r\n       * 第三个参数：是否阻止浏览器默认行为（例如阻止submit事件提交表单）\r\n       * newEvent.initEvent(\"myEvent\",true,true);\r\n       * 给自定义事件对象的属性赋值。这个属性一开始不存在，我们这里将其实例化了\r\n       *  newEvent.name = \"THis is Name\";\r\n       * 将自定义事件绑定在document上，你也可以绑定到指定元素上。\r\n       * 这里要注意：第一个参数要和上面initEvent()的第一个参数一致，否则无法触发这个事件以及获取newEvent中的一些属性（比如这里的newEvent.name）。\r\n       * document.addEventListener(\"myEvent\",function() {\r\n21         alert(\"自定义事件的name属性：\" + newEvent.name);\r\n22     },false);\r\n       * 触发自定义事件\r\n       * document.dispatchEvent(newEvent);  \r\n       */\r\n      const evt = document.createEvent('Event');\r\n\r\n      let didCall = false;\r\n      // Keeps track of whether the user-provided callback threw an error. We\r\n      // set this to true at the beginning, then set it to false right after\r\n      // calling the function. If the function errors, `didError` will never be\r\n      // set to false. This strategy works even if the browser is flaky and\r\n      // fails to call our global error handler, because it doesn't rely on\r\n      // the error event at all.\r\n      let didError = true;\r\n\r\n      // Keeps track of the value of window.event so that we can reset it\r\n      // during the callback to let user code access window.event in the\r\n      // browsers that support it.\r\n      const windowEvent = window.event;\r\n\r\n      // Keeps track of the descriptor of window.event to restore it after event\r\n      // dispatching: https://github.com/facebook/react/issues/13688\r\n\r\n      // 获取window对象中event的描述符（value writable  get set configurable enumerable）\r\n      const windowEventDescriptor = Object.getOwnPropertyDescriptor(\r\n        window,\r\n        'event',\r\n      );\r\n\r\n      function restoreAfterDispatch() {\r\n        // We immediately remove the callback from event listeners so that\r\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\r\n        // nested call would trigger the fake event handlers of any call higher\r\n        // in the stack.\r\n        fakeNode.removeEventListener(evtType, callCallback, false);\r\n\r\n        // We check for window.hasOwnProperty('event') to prevent the\r\n        // window.event assignment in both IE <= 10 as they throw an error\r\n        // \"Member not found\" in strict mode, and in Firefox which does not\r\n        // support window.event.\r\n        if (\r\n          typeof window.event !== 'undefined' &&\r\n          window.hasOwnProperty('event')\r\n        ) {\r\n          window.event = windowEvent;\r\n        }\r\n      }\r\n\r\n      // Create an event handler for our fake event. We will synchronously\r\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\r\n      // call the user-provided callback.\r\n      // 获取react所有的事件参数\r\n      const funcArgs = Array.prototype.slice.call(arguments, 3);\r\n      function callCallback() {\r\n        didCall = true;\r\n        // 移除事件监听\r\n        restoreAfterDispatch();\r\n        // 触发用户事件，并且将react自定义事件参数传入\r\n        func.apply(context, funcArgs);\r\n        didError = false;\r\n      }\r\n\r\n      // Create a global error event handler. We use this to capture the value\r\n      // that was thrown. It's possible that this error handler will fire more\r\n      // than once; for example, if non-React code also calls `dispatchEvent`\r\n      // and a handler for that event throws. We should be resilient to most of\r\n      // those cases. Even if our error event handler fires more than once, the\r\n      // last error event is always used. If the callback actually does error,\r\n      // we know that the last error event is the correct one, because it's not\r\n      // possible for anything else to have happened in between our callback\r\n      // erroring and the code that follows the `dispatchEvent` call below. If\r\n      // the callback doesn't error, but the error event was fired, we know to\r\n      // ignore it because `didError` will be false, as described above.\r\n      let error;\r\n      // Use this to track whether the error event is ever called.\r\n      let didSetError = false;\r\n      let isCrossOriginError = false;\r\n\r\n      function handleWindowError(event) {\r\n        error = event.error;\r\n        didSetError = true;\r\n        if (error === null && event.colno === 0 && event.lineno === 0) {\r\n          isCrossOriginError = true;\r\n        }\r\n        if (event.defaultPrevented) {\r\n          // Some other error handler has prevented default.\r\n          // Browsers silence the error report if this happens.\r\n          // We'll remember this to later decide whether to log it or not.\r\n          if (error != null && typeof error === 'object') {\r\n            try {\r\n              error._suppressLogging = true;\r\n            } catch (inner) {\r\n              // Ignore.\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Create a fake event type.\r\n      const evtType = `react-${name ? name : 'invokeguardedcallback'}`;\r\n\r\n      // Attach our event handlers\r\n      // 当资源加载失败或无法使用时，会在Window对象触发error事件\r\n      window.addEventListener('error', handleWindowError);\r\n      fakeNode.addEventListener(evtType, callCallback, false);\r\n\r\n      // Synchronously dispatch our fake event. If the user-provided function\r\n      // errors, it will trigger our global error handler.\r\n      evt.initEvent(evtType, false, false);\r\n      fakeNode.dispatchEvent(evt);\r\n\r\n      if (windowEventDescriptor) {\r\n        Object.defineProperty(window, 'event', windowEventDescriptor);\r\n      }\r\n\r\n      if (didCall && didError) {\r\n        if (!didSetError) {\r\n          // The callback errored, but the error event never fired.\r\n          // eslint-disable-next-line react-internal/prod-error-codes\r\n          error = new Error(\r\n            'An error was thrown inside one of your components, but React ' +\r\n              \"doesn't know what it was. This is likely due to browser \" +\r\n              'flakiness. React does its best to preserve the \"Pause on ' +\r\n              'exceptions\" behavior of the DevTools, which requires some ' +\r\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\r\n              'your browser. Try triggering the error in production mode, ' +\r\n              'or switching to a modern browser. If you suspect that this is ' +\r\n              'actually an issue with React, please file an issue.',\r\n          );\r\n        } else if (isCrossOriginError) {\r\n          // eslint-disable-next-line react-internal/prod-error-codes\r\n          error = new Error(\r\n            \"A cross-origin error was thrown. React doesn't have access to \" +\r\n              'the actual error object in development. ' +\r\n              'See https://reactjs.org/link/crossorigin-error for more information.',\r\n          );\r\n        }\r\n        this.onError(error);\r\n      }\r\n\r\n      // Remove our event listeners\r\n      window.removeEventListener('error', handleWindowError);\r\n      if (!didCall) {\r\n        // Something went really wrong, and our event was not dispatched.\r\n        // https://github.com/facebook/react/issues/16734\r\n        // https://github.com/facebook/react/issues/16585\r\n        // Fall back to the production implementation.\r\n        restoreAfterDispatch();\r\n        return invokeGuardedCallbackProd.apply(this, arguments);\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\nexport default invokeGuardedCallbackImpl;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,yBAAT,CACEC,IADF,EAEEC,IAFF,EAGEC,OAHF,EAIEC,CAJF,EAKEC,CALF,EAMEC,CANF,EAOEC,CAPF,EAQEC,CARF,EASEC,CATF,EAUE;EACA,MAAMC,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAjB;;EACA,IAAI,CACF;EACD,CAFD,CAEE,OAAOC,KAAP,EAAc;IACd,KAAKC,OAAL,CAAaD,KAAb;EACD;AACF;;AAED,IAAIE,yBAAyB,GAAGlB,yBAAhC;;AAEA,IAAImB,OAAJ,EAAa;EACX;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA,IACE,OAAOC,MAAP,KAAkB,WAAlB,IACA,OAAOA,MAAM,CAACC,aAAd,KAAgC,UADhC,IAEA,OAAOC,QAAP,KAAoB,WAFpB,IAGA,OAAOA,QAAQ,CAACC,WAAhB,KAAgC,UAJlC,EAKE;IACA,MAAMC,QAAQ,GAAGF,QAAQ,CAACG,aAAT,CAAuB,OAAvB,CAAjB;;IACAP,yBAAyB,GAAG,SAASQ,wBAAT,CAS1BzB,IAT0B,EAU1BC,IAV0B,EAW1BC,OAX0B,EAY1BC,CAZ0B,EAa1BC,CAb0B,EAc1BC,CAd0B,EAe1BC,CAf0B,EAgB1BC,CAhB0B,EAiB1BC,CAjB0B,EAkB1B;MACA;MACA;MACA;MACA;MACA,IAAI,OAAOa,QAAP,KAAoB,WAApB,IAAmCA,QAAQ,KAAK,IAApD,EAA0D;QACxD,MAAM,IAAIK,KAAJ,CACJ,8EACE,wEADF,GAEE,8EAFF,GAGE,2EAHF,GAIE,wEAJF,GAKE,yEALF,GAME,qBAPE,CAAN;MASD;MAED;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;MACM,MAAMC,GAAG,GAAGN,QAAQ,CAACC,WAAT,CAAqB,OAArB,CAAZ;MAEA,IAAIM,OAAO,GAAG,KAAd,CArCA,CAsCA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAIC,QAAQ,GAAG,IAAf,CA5CA,CA8CA;MACA;MACA;;MACA,MAAMC,WAAW,GAAGX,MAAM,CAACY,KAA3B,CAjDA,CAmDA;MACA;MAEA;;MACA,MAAMC,qBAAqB,GAAGC,MAAM,CAACC,wBAAP,CAC5Bf,MAD4B,EAE5B,OAF4B,CAA9B;;MAKA,SAASgB,oBAAT,GAAgC;QAC9B;QACA;QACA;QACA;QACAZ,QAAQ,CAACa,mBAAT,CAA6BC,OAA7B,EAAsCC,YAAtC,EAAoD,KAApD,EAL8B,CAO9B;QACA;QACA;QACA;;QACA,IACE,OAAOnB,MAAM,CAACY,KAAd,KAAwB,WAAxB,IACAZ,MAAM,CAACoB,cAAP,CAAsB,OAAtB,CAFF,EAGE;UACApB,MAAM,CAACY,KAAP,GAAeD,WAAf;QACD;MACF,CA7ED,CA+EA;MACA;MACA;MACA;;;MACA,MAAMrB,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAjB;;MACA,SAASwB,YAAT,GAAwB;QACtBV,OAAO,GAAG,IAAV,CADsB,CAEtB;;QACAO,oBAAoB,GAHE,CAItB;;QACAlC,IAAI,CAACuC,KAAL,CAAWtC,OAAX,EAAoBO,QAApB;QACAoB,QAAQ,GAAG,KAAX;MACD,CA3FD,CA6FA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;;MACA,IAAId,KAAJ,CAxGA,CAyGA;;MACA,IAAI0B,WAAW,GAAG,KAAlB;MACA,IAAIC,kBAAkB,GAAG,KAAzB;;MAEA,SAASC,iBAAT,CAA2BZ,KAA3B,EAAkC;QAChChB,KAAK,GAAGgB,KAAK,CAAChB,KAAd;QACA0B,WAAW,GAAG,IAAd;;QACA,IAAI1B,KAAK,KAAK,IAAV,IAAkBgB,KAAK,CAACa,KAAN,KAAgB,CAAlC,IAAuCb,KAAK,CAACc,MAAN,KAAiB,CAA5D,EAA+D;UAC7DH,kBAAkB,GAAG,IAArB;QACD;;QACD,IAAIX,KAAK,CAACe,gBAAV,EAA4B;UAC1B;UACA;UACA;UACA,IAAI/B,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,KAAiB,QAAtC,EAAgD;YAC9C,IAAI;cACFA,KAAK,CAACgC,gBAAN,GAAyB,IAAzB;YACD,CAFD,CAEE,OAAOC,KAAP,EAAc,CACd;YACD;UACF;QACF;MACF,CA/HD,CAiIA;;;MACA,MAAMX,OAAO,GAAI,SAAQrC,IAAI,GAAGA,IAAH,GAAU,uBAAwB,EAA/D,CAlIA,CAoIA;MACA;;MACAmB,MAAM,CAAC8B,gBAAP,CAAwB,OAAxB,EAAiCN,iBAAjC;MACApB,QAAQ,CAAC0B,gBAAT,CAA0BZ,OAA1B,EAAmCC,YAAnC,EAAiD,KAAjD,EAvIA,CAyIA;MACA;;MACAX,GAAG,CAACuB,SAAJ,CAAcb,OAAd,EAAuB,KAAvB,EAA8B,KAA9B;MACAd,QAAQ,CAACH,aAAT,CAAuBO,GAAvB;;MAEA,IAAIK,qBAAJ,EAA2B;QACzBC,MAAM,CAACkB,cAAP,CAAsBhC,MAAtB,EAA8B,OAA9B,EAAuCa,qBAAvC;MACD;;MAED,IAAIJ,OAAO,IAAIC,QAAf,EAAyB;QACvB,IAAI,CAACY,WAAL,EAAkB;UAChB;UACA;UACA1B,KAAK,GAAG,IAAIW,KAAJ,CACN,kEACE,0DADF,GAEE,2DAFF,GAGE,4DAHF,GAIE,+DAJF,GAKE,6DALF,GAME,gEANF,GAOE,qDARI,CAAR;QAUD,CAbD,MAaO,IAAIgB,kBAAJ,EAAwB;UAC7B;UACA3B,KAAK,GAAG,IAAIW,KAAJ,CACN,mEACE,0CADF,GAEE,sEAHI,CAAR;QAKD;;QACD,KAAKV,OAAL,CAAaD,KAAb;MACD,CAzKD,CA2KA;;;MACAI,MAAM,CAACiB,mBAAP,CAA2B,OAA3B,EAAoCO,iBAApC;;MACA,IAAI,CAACf,OAAL,EAAc;QACZ;QACA;QACA;QACA;QACAO,oBAAoB;QACpB,OAAOpC,yBAAyB,CAACyC,KAA1B,CAAgC,IAAhC,EAAsC1B,SAAtC,CAAP;MACD;IACF,CAvMD;EAwMD;AACF;;AAED,eAAeG,yBAAf"},"metadata":{},"sourceType":"module"}