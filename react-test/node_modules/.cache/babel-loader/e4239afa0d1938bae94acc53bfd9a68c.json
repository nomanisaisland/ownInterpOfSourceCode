{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { ClassComponent, HostRoot, SuspenseComponent, IncompleteClassComponent, FunctionComponent, ForwardRef, SimpleMemoComponent } from './ReactWorkTags';\nimport { DidCapture, Incomplete, NoFlags, ShouldCapture, LifecycleEffectMask, ForceUpdateForLegacySuspense, ForceClientRender } from './ReactFiberFlags';\nimport { supportsPersistence, getOffscreenContainerProps } from './ReactFiberHostConfig';\nimport { shouldCaptureSuspense } from './ReactFiberSuspenseComponent.old';\nimport { NoMode, ConcurrentMode, DebugTracingMode } from './ReactTypeOfMode';\nimport { enableDebugTracing, enableLazyContextPropagation, enableUpdaterTracking, enablePersistentOffscreenHostContainer } from 'shared/ReactFeatureFlags';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { enqueueCapturedUpdate, createUpdate, CaptureUpdate, ForceUpdate, enqueueUpdate } from './ReactUpdateQueue.old';\nimport { markFailedErrorBoundaryForHotReloading } from './ReactFiberHotReloading.old';\nimport { suspenseStackCursor, InvisibleParentSuspenseContext, hasSuspenseContext } from './ReactFiberSuspenseContext.old';\nimport { renderDidError, renderDidSuspendDelayIfPossible, onUncaughtError, markLegacyErrorBoundaryAsFailed, isAlreadyFailedLegacyErrorBoundary, pingSuspendedRoot, restorePendingUpdaters } from './ReactFiberWorkLoop.old';\nimport { propagateParentContextChangesToDeferredTree } from './ReactFiberNewContext.old';\nimport { logCapturedError } from './ReactFiberErrorLogger';\nimport { logComponentSuspended } from './DebugTracing';\nimport { isDevToolsPresent } from './ReactFiberDevToolsHook.old';\nimport { SyncLane, NoTimestamp, includesSomeLane, mergeLanes, pickArbitraryLane, includesSyncLane } from './ReactFiberLane.old';\nimport { getIsHydrating, markDidThrowWhileHydratingDEV, queueHydrationError } from './ReactFiberHydrationContext.old';\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(fiber, errorInfo, lane) {\n  const update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n\n  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: null\n  };\n  const error = errorInfo.value;\n\n  update.callback = () => {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, lane) {\n  const update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n\n    update.payload = () => {\n      return getDerivedStateFromError(error);\n    };\n\n    update.callback = () => {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  const inst = fiber.stateNode;\n\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : ''\n      });\n\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, SyncLane)) {\n            console.error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n          }\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\nfunction attachPingListener(root, wakeable, lanes) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  let pingCache = root.pingCache;\n  let threadIDs;\n\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(wakeable);\n\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    }\n  }\n\n  if (!threadIDs.has(lanes)) {\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(lanes);\n    const ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        // If we have pending work still, restore the original updaters\n        restorePendingUpdaters(root, lanes);\n      }\n    }\n\n    wakeable.then(ping, ping);\n  }\n}\n\nfunction attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n  // Retry listener\n  //\n  // If the fallback does commit, we need to attach a different type of\n  // listener. This one schedules an update on the Suspense boundary to turn\n  // the fallback state off.\n  //\n  // Stash the wakeable on the boundary fiber so we can access it in the\n  // commit phase.\n  //\n  // When the wakeable resolves, we'll attempt to render the boundary\n  // again (\"retry\").\n  const wakeables = suspenseBoundary.updateQueue;\n\n  if (wakeables === null) {\n    const updateQueue = new Set();\n    updateQueue.add(wakeable);\n    suspenseBoundary.updateQueue = updateQueue;\n  } else {\n    wakeables.add(wakeable);\n  }\n}\n\nfunction resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n  if (enableLazyContextPropagation) {\n    const currentSourceFiber = sourceFiber.alternate;\n\n    if (currentSourceFiber !== null) {\n      // Since we never visited the children of the suspended component, we\n      // need to propagate the context change now, to ensure that we visit\n      // them during the retry.\n      //\n      // We don't have to do this for errors because we retry errors without\n      // committing in between. So this is specific to Suspense.\n      propagateParentContextChangesToDeferredTree(currentSourceFiber, sourceFiber, rootRenderLanes);\n    }\n  } // Reset the memoizedState to what it was before we attempted to render it.\n  // A legacy mode Suspense quirk, only relevant to hook components.\n\n\n  const tag = sourceFiber.tag;\n\n  if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n    const currentSource = sourceFiber.alternate;\n\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction getNearestSuspenseBoundaryToCapture(returnFiber) {\n  let node = returnFiber;\n  const hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext);\n\n  do {\n    if (node.tag === SuspenseComponent && shouldCaptureSuspense(node, hasInvisibleParentBoundary)) {\n      return node;\n    } // This boundary already captured during this render. Continue to the next\n    // boundary.\n\n\n    node = node.return;\n  } while (node !== null);\n\n  return null;\n}\n\nfunction markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (supportsPersistence && enablePersistentOffscreenHostContainer) {\n        // Another legacy Suspense quirk. In persistent mode, if this is the\n        // initial mount, override the props of the host container to hide\n        // its contents.\n        const currentSuspenseBoundary = suspenseBoundary.alternate;\n\n        if (currentSuspenseBoundary === null) {\n          const offscreenFiber = suspenseBoundary.child;\n          const offscreenContainer = offscreenFiber.child;\n\n          if (offscreenContainer !== null) {\n            const children = offscreenContainer.memoizedProps.children;\n            const containerProps = getOffscreenContainerProps('hidden', children);\n            offscreenContainer.pendingProps = containerProps;\n            offscreenContainer.memoizedProps = containerProps;\n          }\n        }\n      }\n\n      if (sourceFiber.tag === ClassComponent) {\n        const currentSourceFiber = sourceFiber.alternate;\n\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          const update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update, SyncLane);\n        }\n      } // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n\n\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n\n    return suspenseBoundary;\n  } // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n\n\n  suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a wakeable. The component suspended.\n    const wakeable = value;\n    resetSuspendedComponent(sourceFiber, rootRenderLanes);\n\n    if (__DEV__) {\n      if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n        markDidThrowWhileHydratingDEV();\n      }\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (sourceFiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(sourceFiber) || 'Unknown';\n          logComponentSuspended(name, wakeable);\n        }\n      }\n    } // Schedule the nearest Suspense to re-render the timed out view.\n\n\n    const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n\n    if (suspenseBoundary !== null) {\n      suspenseBoundary.flags &= ~ForceClientRender;\n      markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n      // commits fallbacks synchronously, so there are no pings.\n\n      if (suspenseBoundary.mode & ConcurrentMode) {\n        attachPingListener(root, wakeable, rootRenderLanes);\n      }\n\n      attachRetryListener(suspenseBoundary, root, wakeable, rootRenderLanes);\n      return;\n    } else {\n      // No boundary was found. Unless this is a sync update, this is OK.\n      // We can suspend and wait for more data to arrive.\n      if (!includesSyncLane(rootRenderLanes)) {\n        // This is not a sync update. Suspend. Since we're not activating a\n        // Suspense boundary, this will unwind all the way to the root without\n        // performing a second pass to render a fallback. (This is arguably how\n        // refresh transitions should work, too, since we're not going to commit\n        // the fallbacks anyway.)\n        //\n        // This case also applies to initial hydration.\n        attachPingListener(root, wakeable, rootRenderLanes);\n        renderDidSuspendDelayIfPossible();\n        return;\n      } // This is a sync/discrete update. We treat this case like an error\n      // because discrete renders are expected to produce a complete tree\n      // synchronously to maintain consistency with external state.\n\n\n      const uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.'); // If we're outside a transition, fall through to the regular error path.\n      // The error will be caught by the nearest suspense boundary.\n\n      value = uncaughtSuspenseError;\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      markDidThrowWhileHydratingDEV();\n      const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n\n      if (suspenseBoundary !== null) {\n        if ((suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          suspenseBoundary.flags |= ForceClientRender;\n        }\n\n        markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n        // still log it so it can be fixed.\n\n        queueHydrationError(value);\n        return;\n      }\n    } else {// Otherwise, fall through to the error path.\n    }\n  } // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n\n\n  renderDidError(value);\n  value = createCapturedValue(value, sourceFiber);\n  let workInProgress = returnFiber;\n\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          const errorInfo = value;\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          const update = createRootErrorUpdate(workInProgress, errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n\n        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          const update = createClassErrorUpdate(workInProgress, errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nexport { throwException, createRootErrorUpdate, createClassErrorUpdate };","map":{"version":3,"names":["getComponentNameFromFiber","ClassComponent","HostRoot","SuspenseComponent","IncompleteClassComponent","FunctionComponent","ForwardRef","SimpleMemoComponent","DidCapture","Incomplete","NoFlags","ShouldCapture","LifecycleEffectMask","ForceUpdateForLegacySuspense","ForceClientRender","supportsPersistence","getOffscreenContainerProps","shouldCaptureSuspense","NoMode","ConcurrentMode","DebugTracingMode","enableDebugTracing","enableLazyContextPropagation","enableUpdaterTracking","enablePersistentOffscreenHostContainer","createCapturedValue","enqueueCapturedUpdate","createUpdate","CaptureUpdate","ForceUpdate","enqueueUpdate","markFailedErrorBoundaryForHotReloading","suspenseStackCursor","InvisibleParentSuspenseContext","hasSuspenseContext","renderDidError","renderDidSuspendDelayIfPossible","onUncaughtError","markLegacyErrorBoundaryAsFailed","isAlreadyFailedLegacyErrorBoundary","pingSuspendedRoot","restorePendingUpdaters","propagateParentContextChangesToDeferredTree","logCapturedError","logComponentSuspended","isDevToolsPresent","SyncLane","NoTimestamp","includesSomeLane","mergeLanes","pickArbitraryLane","includesSyncLane","getIsHydrating","markDidThrowWhileHydratingDEV","queueHydrationError","PossiblyWeakMap","WeakMap","Map","createRootErrorUpdate","fiber","errorInfo","lane","update","tag","payload","element","error","value","callback","createClassErrorUpdate","getDerivedStateFromError","type","__DEV__","inst","stateNode","componentDidCatch","stack","componentStack","lanes","console","attachPingListener","root","wakeable","pingCache","threadIDs","Set","set","get","undefined","has","add","ping","bind","then","attachRetryListener","suspenseBoundary","wakeables","updateQueue","resetSuspendedComponent","sourceFiber","rootRenderLanes","currentSourceFiber","alternate","mode","currentSource","memoizedState","getNearestSuspenseBoundaryToCapture","returnFiber","node","hasInvisibleParentBoundary","current","return","markSuspenseBoundaryShouldCapture","flags","currentSuspenseBoundary","offscreenFiber","child","offscreenContainer","children","memoizedProps","containerProps","pendingProps","throwException","name","uncaughtSuspenseError","Error","workInProgress","ctor","instance"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberThrow.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {FiberRoot} from './ReactInternalTypes';\r\nimport type {Lane, Lanes} from './ReactFiberLane.old';\r\nimport type {CapturedValue} from './ReactCapturedValue';\r\nimport type {Update} from './ReactUpdateQueue.old';\r\nimport type {Wakeable} from 'shared/ReactTypes';\r\nimport type {SuspenseContext} from './ReactFiberSuspenseContext.old';\r\n\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport {\r\n  ClassComponent,\r\n  HostRoot,\r\n  SuspenseComponent,\r\n  IncompleteClassComponent,\r\n  FunctionComponent,\r\n  ForwardRef,\r\n  SimpleMemoComponent,\r\n} from './ReactWorkTags';\r\nimport {\r\n  DidCapture,\r\n  Incomplete,\r\n  NoFlags,\r\n  ShouldCapture,\r\n  LifecycleEffectMask,\r\n  ForceUpdateForLegacySuspense,\r\n  ForceClientRender,\r\n} from './ReactFiberFlags';\r\nimport {\r\n  supportsPersistence,\r\n  getOffscreenContainerProps,\r\n} from './ReactFiberHostConfig';\r\nimport {shouldCaptureSuspense} from './ReactFiberSuspenseComponent.old';\r\nimport {NoMode, ConcurrentMode, DebugTracingMode} from './ReactTypeOfMode';\r\nimport {\r\n  enableDebugTracing,\r\n  enableLazyContextPropagation,\r\n  enableUpdaterTracking,\r\n  enablePersistentOffscreenHostContainer,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {createCapturedValue} from './ReactCapturedValue';\r\nimport {\r\n  enqueueCapturedUpdate,\r\n  createUpdate,\r\n  CaptureUpdate,\r\n  ForceUpdate,\r\n  enqueueUpdate,\r\n} from './ReactUpdateQueue.old';\r\nimport {markFailedErrorBoundaryForHotReloading} from './ReactFiberHotReloading.old';\r\nimport {\r\n  suspenseStackCursor,\r\n  InvisibleParentSuspenseContext,\r\n  hasSuspenseContext,\r\n} from './ReactFiberSuspenseContext.old';\r\nimport {\r\n  renderDidError,\r\n  renderDidSuspendDelayIfPossible,\r\n  onUncaughtError,\r\n  markLegacyErrorBoundaryAsFailed,\r\n  isAlreadyFailedLegacyErrorBoundary,\r\n  pingSuspendedRoot,\r\n  restorePendingUpdaters,\r\n} from './ReactFiberWorkLoop.old';\r\nimport {propagateParentContextChangesToDeferredTree} from './ReactFiberNewContext.old';\r\nimport {logCapturedError} from './ReactFiberErrorLogger';\r\nimport {logComponentSuspended} from './DebugTracing';\r\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook.old';\r\nimport {\r\n  SyncLane,\r\n  NoTimestamp,\r\n  includesSomeLane,\r\n  mergeLanes,\r\n  pickArbitraryLane,\r\n  includesSyncLane,\r\n} from './ReactFiberLane.old';\r\nimport {\r\n  getIsHydrating,\r\n  markDidThrowWhileHydratingDEV,\r\n  queueHydrationError,\r\n} from './ReactFiberHydrationContext.old';\r\n\r\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n\r\nfunction createRootErrorUpdate(\r\n  fiber: Fiber,\r\n  errorInfo: CapturedValue<mixed>,\r\n  lane: Lane,\r\n): Update<mixed> {\r\n  const update = createUpdate(NoTimestamp, lane);\r\n  // Unmount the root by rendering null.\r\n  update.tag = CaptureUpdate;\r\n  // Caution: React DevTools currently depends on this property\r\n  // being called \"element\".\r\n  update.payload = {element: null};\r\n  const error = errorInfo.value;\r\n  update.callback = () => {\r\n    onUncaughtError(error);\r\n    logCapturedError(fiber, errorInfo);\r\n  };\r\n  return update;\r\n}\r\n\r\nfunction createClassErrorUpdate(\r\n  fiber: Fiber,\r\n  errorInfo: CapturedValue<mixed>,\r\n  lane: Lane,\r\n): Update<mixed> {\r\n  const update = createUpdate(NoTimestamp, lane);\r\n  update.tag = CaptureUpdate;\r\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\r\n  if (typeof getDerivedStateFromError === 'function') {\r\n    const error = errorInfo.value;\r\n    update.payload = () => {\r\n      return getDerivedStateFromError(error);\r\n    };\r\n    update.callback = () => {\r\n      if (__DEV__) {\r\n        markFailedErrorBoundaryForHotReloading(fiber);\r\n      }\r\n      logCapturedError(fiber, errorInfo);\r\n    };\r\n  }\r\n\r\n  const inst = fiber.stateNode;\r\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\r\n    update.callback = function callback() {\r\n      if (__DEV__) {\r\n        markFailedErrorBoundaryForHotReloading(fiber);\r\n      }\r\n      logCapturedError(fiber, errorInfo);\r\n      if (typeof getDerivedStateFromError !== 'function') {\r\n        // To preserve the preexisting retry behavior of error boundaries,\r\n        // we keep track of which ones already failed during this batch.\r\n        // This gets reset before we yield back to the browser.\r\n        // TODO: Warn in strict mode if getDerivedStateFromError is\r\n        // not defined.\r\n        markLegacyErrorBoundaryAsFailed(this);\r\n      }\r\n      const error = errorInfo.value;\r\n      const stack = errorInfo.stack;\r\n      this.componentDidCatch(error, {\r\n        componentStack: stack !== null ? stack : '',\r\n      });\r\n      if (__DEV__) {\r\n        if (typeof getDerivedStateFromError !== 'function') {\r\n          // If componentDidCatch is the only error boundary method defined,\r\n          // then it needs to call setState to recover from errors.\r\n          // If no state update is scheduled then the boundary will swallow the error.\r\n          if (!includesSomeLane(fiber.lanes, (SyncLane: Lane))) {\r\n            console.error(\r\n              '%s: Error boundaries should implement getDerivedStateFromError(). ' +\r\n                'In that method, return a state update to display an error message or fallback UI.',\r\n              getComponentNameFromFiber(fiber) || 'Unknown',\r\n            );\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n  return update;\r\n}\r\n\r\nfunction attachPingListener(root: FiberRoot, wakeable: Wakeable, lanes: Lanes) {\r\n  // Attach a ping listener\r\n  //\r\n  // The data might resolve before we have a chance to commit the fallback. Or,\r\n  // in the case of a refresh, we'll never commit a fallback. So we need to\r\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\r\n  // try rendering the tree again.\r\n  //\r\n  // Only attach a listener if one does not already exist for the lanes\r\n  // we're currently rendering (which acts like a \"thread ID\" here).\r\n  //\r\n  // We only need to do this in concurrent mode. Legacy Suspense always\r\n  // commits fallbacks synchronously, so there are no pings.\r\n  let pingCache = root.pingCache;\r\n  let threadIDs;\r\n  if (pingCache === null) {\r\n    pingCache = root.pingCache = new PossiblyWeakMap();\r\n    threadIDs = new Set();\r\n    pingCache.set(wakeable, threadIDs);\r\n  } else {\r\n    threadIDs = pingCache.get(wakeable);\r\n    if (threadIDs === undefined) {\r\n      threadIDs = new Set();\r\n      pingCache.set(wakeable, threadIDs);\r\n    }\r\n  }\r\n  if (!threadIDs.has(lanes)) {\r\n    // Memoize using the thread ID to prevent redundant listeners.\r\n    threadIDs.add(lanes);\r\n    const ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\r\n    if (enableUpdaterTracking) {\r\n      if (isDevToolsPresent) {\r\n        // If we have pending work still, restore the original updaters\r\n        restorePendingUpdaters(root, lanes);\r\n      }\r\n    }\r\n    wakeable.then(ping, ping);\r\n  }\r\n}\r\n\r\nfunction attachRetryListener(\r\n  suspenseBoundary: Fiber,\r\n  root: FiberRoot,\r\n  wakeable: Wakeable,\r\n  lanes: Lanes,\r\n) {\r\n  // Retry listener\r\n  //\r\n  // If the fallback does commit, we need to attach a different type of\r\n  // listener. This one schedules an update on the Suspense boundary to turn\r\n  // the fallback state off.\r\n  //\r\n  // Stash the wakeable on the boundary fiber so we can access it in the\r\n  // commit phase.\r\n  //\r\n  // When the wakeable resolves, we'll attempt to render the boundary\r\n  // again (\"retry\").\r\n  const wakeables: Set<Wakeable> | null = (suspenseBoundary.updateQueue: any);\r\n  if (wakeables === null) {\r\n    const updateQueue = (new Set(): any);\r\n    updateQueue.add(wakeable);\r\n    suspenseBoundary.updateQueue = updateQueue;\r\n  } else {\r\n    wakeables.add(wakeable);\r\n  }\r\n}\r\n\r\nfunction resetSuspendedComponent(sourceFiber: Fiber, rootRenderLanes: Lanes) {\r\n  if (enableLazyContextPropagation) {\r\n    const currentSourceFiber = sourceFiber.alternate;\r\n    if (currentSourceFiber !== null) {\r\n      // Since we never visited the children of the suspended component, we\r\n      // need to propagate the context change now, to ensure that we visit\r\n      // them during the retry.\r\n      //\r\n      // We don't have to do this for errors because we retry errors without\r\n      // committing in between. So this is specific to Suspense.\r\n      propagateParentContextChangesToDeferredTree(\r\n        currentSourceFiber,\r\n        sourceFiber,\r\n        rootRenderLanes,\r\n      );\r\n    }\r\n  }\r\n\r\n  // Reset the memoizedState to what it was before we attempted to render it.\r\n  // A legacy mode Suspense quirk, only relevant to hook components.\r\n  const tag = sourceFiber.tag;\r\n  if (\r\n    (sourceFiber.mode & ConcurrentMode) === NoMode &&\r\n    (tag === FunctionComponent ||\r\n      tag === ForwardRef ||\r\n      tag === SimpleMemoComponent)\r\n  ) {\r\n    const currentSource = sourceFiber.alternate;\r\n    if (currentSource) {\r\n      sourceFiber.updateQueue = currentSource.updateQueue;\r\n      sourceFiber.memoizedState = currentSource.memoizedState;\r\n      sourceFiber.lanes = currentSource.lanes;\r\n    } else {\r\n      sourceFiber.updateQueue = null;\r\n      sourceFiber.memoizedState = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNearestSuspenseBoundaryToCapture(returnFiber: Fiber) {\r\n  let node = returnFiber;\r\n  const hasInvisibleParentBoundary = hasSuspenseContext(\r\n    suspenseStackCursor.current,\r\n    (InvisibleParentSuspenseContext: SuspenseContext),\r\n  );\r\n  do {\r\n    if (\r\n      node.tag === SuspenseComponent &&\r\n      shouldCaptureSuspense(node, hasInvisibleParentBoundary)\r\n    ) {\r\n      return node;\r\n    }\r\n    // This boundary already captured during this render. Continue to the next\r\n    // boundary.\r\n    node = node.return;\r\n  } while (node !== null);\r\n  return null;\r\n}\r\n\r\nfunction markSuspenseBoundaryShouldCapture(\r\n  suspenseBoundary: Fiber,\r\n  returnFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  root: FiberRoot,\r\n  rootRenderLanes: Lanes,\r\n): Fiber | null {\r\n  // This marks a Suspense boundary so that when we're unwinding the stack,\r\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\r\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\r\n    // Legacy Mode Suspense\r\n    //\r\n    // If the boundary is in legacy mode, we should *not*\r\n    // suspend the commit. Pretend as if the suspended component rendered\r\n    // null and keep rendering. When the Suspense boundary completes,\r\n    // we'll do a second pass to render the fallback.\r\n    if (suspenseBoundary === returnFiber) {\r\n      // Special case where we suspended while reconciling the children of\r\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\r\n      // when a React.lazy component is a direct child of a\r\n      // Suspense boundary.\r\n      //\r\n      // Suspense boundaries are implemented as multiple fibers, but they\r\n      // are a single conceptual unit. The legacy mode behavior where we\r\n      // pretend the suspended fiber committed as `null` won't work,\r\n      // because in this case the \"suspended\" fiber is the inner\r\n      // Offscreen wrapper.\r\n      //\r\n      // Because the contents of the boundary haven't started rendering\r\n      // yet (i.e. nothing in the tree has partially rendered) we can\r\n      // switch to the regular, concurrent mode behavior: mark the\r\n      // boundary with ShouldCapture and enter the unwind phase.\r\n      suspenseBoundary.flags |= ShouldCapture;\r\n    } else {\r\n      suspenseBoundary.flags |= DidCapture;\r\n      sourceFiber.flags |= ForceUpdateForLegacySuspense;\r\n\r\n      // We're going to commit this fiber even though it didn't complete.\r\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\r\n      // all lifecycle effect tags.\r\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\r\n\r\n      if (supportsPersistence && enablePersistentOffscreenHostContainer) {\r\n        // Another legacy Suspense quirk. In persistent mode, if this is the\r\n        // initial mount, override the props of the host container to hide\r\n        // its contents.\r\n        const currentSuspenseBoundary = suspenseBoundary.alternate;\r\n        if (currentSuspenseBoundary === null) {\r\n          const offscreenFiber: Fiber = (suspenseBoundary.child: any);\r\n          const offscreenContainer = offscreenFiber.child;\r\n          if (offscreenContainer !== null) {\r\n            const children = offscreenContainer.memoizedProps.children;\r\n            const containerProps = getOffscreenContainerProps(\r\n              'hidden',\r\n              children,\r\n            );\r\n            offscreenContainer.pendingProps = containerProps;\r\n            offscreenContainer.memoizedProps = containerProps;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (sourceFiber.tag === ClassComponent) {\r\n        const currentSourceFiber = sourceFiber.alternate;\r\n        if (currentSourceFiber === null) {\r\n          // This is a new mount. Change the tag so it's not mistaken for a\r\n          // completed class component. For example, we should not call\r\n          // componentWillUnmount if it is deleted.\r\n          sourceFiber.tag = IncompleteClassComponent;\r\n        } else {\r\n          // When we try rendering again, we should not reuse the current fiber,\r\n          // since it's known to be in an inconsistent state. Use a force update to\r\n          // prevent a bail out.\r\n          const update = createUpdate(NoTimestamp, SyncLane);\r\n          update.tag = ForceUpdate;\r\n          enqueueUpdate(sourceFiber, update, SyncLane);\r\n        }\r\n      }\r\n\r\n      // The source fiber did not complete. Mark it with Sync priority to\r\n      // indicate that it still has pending work.\r\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\r\n    }\r\n    return suspenseBoundary;\r\n  }\r\n  // Confirmed that the boundary is in a concurrent mode tree. Continue\r\n  // with the normal suspend path.\r\n  //\r\n  // After this we'll use a set of heuristics to determine whether this\r\n  // render pass will run to completion or restart or \"suspend\" the commit.\r\n  // The actual logic for this is spread out in different places.\r\n  //\r\n  // This first principle is that if we're going to suspend when we complete\r\n  // a root, then we should also restart if we get an update or ping that\r\n  // might unsuspend it, and vice versa. The only reason to suspend is\r\n  // because you think you might want to restart before committing. However,\r\n  // it doesn't make sense to restart only while in the period we're suspended.\r\n  //\r\n  // Restarting too aggressively is also not good because it starves out any\r\n  // intermediate loading state. So we use heuristics to determine when.\r\n\r\n  // Suspense Heuristics\r\n  //\r\n  // If nothing threw a Promise or all the same fallbacks are already showing,\r\n  // then don't suspend/restart.\r\n  //\r\n  // If this is an initial render of a new tree of Suspense boundaries and\r\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\r\n  // that we can show the initial loading state as quickly as possible.\r\n  //\r\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\r\n  // a fallback, then we should always suspend/restart. Transitions apply\r\n  // to this case. If none is defined, JND is used instead.\r\n  //\r\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\r\n  // another level, but there's still an inner boundary that would show a fallback,\r\n  // then we suspend/restart for 500ms since the last time we showed a fallback\r\n  // anywhere in the tree. This effectively throttles progressive loading into a\r\n  // consistent train of commits. This also gives us an opportunity to restart to\r\n  // get to the completed state slightly earlier.\r\n  //\r\n  // If there's ambiguity due to batching it's resolved in preference of:\r\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\r\n  //\r\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\r\n  // ensure that new initial loading states can commit as soon as possible.\r\n  suspenseBoundary.flags |= ShouldCapture;\r\n  // TODO: I think we can remove this, since we now use `DidCapture` in\r\n  // the begin phase to prevent an early bailout.\r\n  suspenseBoundary.lanes = rootRenderLanes;\r\n  return suspenseBoundary;\r\n}\r\n\r\nfunction throwException(\r\n  root: FiberRoot,\r\n  returnFiber: Fiber,\r\n  sourceFiber: Fiber,\r\n  value: mixed,\r\n  rootRenderLanes: Lanes,\r\n) {\r\n  // The source fiber did not complete.\r\n  sourceFiber.flags |= Incomplete;\r\n\r\n  if (enableUpdaterTracking) {\r\n    if (isDevToolsPresent) {\r\n      // If we have pending work still, restore the original updaters\r\n      restorePendingUpdaters(root, rootRenderLanes);\r\n    }\r\n  }\r\n\r\n  if (\r\n    value !== null &&\r\n    typeof value === 'object' &&\r\n    typeof value.then === 'function'\r\n  ) {\r\n    // This is a wakeable. The component suspended.\r\n    const wakeable: Wakeable = (value: any);\r\n    resetSuspendedComponent(sourceFiber, rootRenderLanes);\r\n\r\n    if (__DEV__) {\r\n      if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\r\n        markDidThrowWhileHydratingDEV();\r\n      }\r\n    }\r\n\r\n    if (__DEV__) {\r\n      if (enableDebugTracing) {\r\n        if (sourceFiber.mode & DebugTracingMode) {\r\n          const name = getComponentNameFromFiber(sourceFiber) || 'Unknown';\r\n          logComponentSuspended(name, wakeable);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Schedule the nearest Suspense to re-render the timed out view.\r\n    const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\r\n    if (suspenseBoundary !== null) {\r\n      suspenseBoundary.flags &= ~ForceClientRender;\r\n      markSuspenseBoundaryShouldCapture(\r\n        suspenseBoundary,\r\n        returnFiber,\r\n        sourceFiber,\r\n        root,\r\n        rootRenderLanes,\r\n      );\r\n      // We only attach ping listeners in concurrent mode. Legacy Suspense always\r\n      // commits fallbacks synchronously, so there are no pings.\r\n      if (suspenseBoundary.mode & ConcurrentMode) {\r\n        attachPingListener(root, wakeable, rootRenderLanes);\r\n      }\r\n      attachRetryListener(suspenseBoundary, root, wakeable, rootRenderLanes);\r\n      return;\r\n    } else {\r\n      // No boundary was found. Unless this is a sync update, this is OK.\r\n      // We can suspend and wait for more data to arrive.\r\n\r\n      if (!includesSyncLane(rootRenderLanes)) {\r\n        // This is not a sync update. Suspend. Since we're not activating a\r\n        // Suspense boundary, this will unwind all the way to the root without\r\n        // performing a second pass to render a fallback. (This is arguably how\r\n        // refresh transitions should work, too, since we're not going to commit\r\n        // the fallbacks anyway.)\r\n        //\r\n        // This case also applies to initial hydration.\r\n        attachPingListener(root, wakeable, rootRenderLanes);\r\n        renderDidSuspendDelayIfPossible();\r\n        return;\r\n      }\r\n\r\n      // This is a sync/discrete update. We treat this case like an error\r\n      // because discrete renders are expected to produce a complete tree\r\n      // synchronously to maintain consistency with external state.\r\n      const uncaughtSuspenseError = new Error(\r\n        'A component suspended while responding to synchronous input. This ' +\r\n          'will cause the UI to be replaced with a loading indicator. To ' +\r\n          'fix, updates that suspend should be wrapped ' +\r\n          'with startTransition.',\r\n      );\r\n\r\n      // If we're outside a transition, fall through to the regular error path.\r\n      // The error will be caught by the nearest suspense boundary.\r\n      value = uncaughtSuspenseError;\r\n    }\r\n  } else {\r\n    // This is a regular error, not a Suspense wakeable.\r\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\r\n      markDidThrowWhileHydratingDEV();\r\n      const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\r\n      // If the error was thrown during hydration, we may be able to recover by\r\n      // discarding the dehydrated content and switching to a client render.\r\n      // Instead of surfacing the error, find the nearest Suspense boundary\r\n      // and render it again without hydration.\r\n      if (suspenseBoundary !== null) {\r\n        if ((suspenseBoundary.flags & ShouldCapture) === NoFlags) {\r\n          // Set a flag to indicate that we should try rendering the normal\r\n          // children again, not the fallback.\r\n          suspenseBoundary.flags |= ForceClientRender;\r\n        }\r\n        markSuspenseBoundaryShouldCapture(\r\n          suspenseBoundary,\r\n          returnFiber,\r\n          sourceFiber,\r\n          root,\r\n          rootRenderLanes,\r\n        );\r\n\r\n        // Even though the user may not be affected by this error, we should\r\n        // still log it so it can be fixed.\r\n        queueHydrationError(value);\r\n        return;\r\n      }\r\n    } else {\r\n      // Otherwise, fall through to the error path.\r\n    }\r\n  }\r\n\r\n  // We didn't find a boundary that could handle this type of exception. Start\r\n  // over and traverse parent path again, this time treating the exception\r\n  // as an error.\r\n  renderDidError(value);\r\n\r\n  value = createCapturedValue(value, sourceFiber);\r\n  let workInProgress = returnFiber;\r\n  do {\r\n    switch (workInProgress.tag) {\r\n      case HostRoot: {\r\n        const errorInfo = value;\r\n        workInProgress.flags |= ShouldCapture;\r\n        const lane = pickArbitraryLane(rootRenderLanes);\r\n        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\r\n        const update = createRootErrorUpdate(workInProgress, errorInfo, lane);\r\n        enqueueCapturedUpdate(workInProgress, update);\r\n        return;\r\n      }\r\n      case ClassComponent:\r\n        // Capture and retry\r\n        const errorInfo = value;\r\n        const ctor = workInProgress.type;\r\n        const instance = workInProgress.stateNode;\r\n        if (\r\n          (workInProgress.flags & DidCapture) === NoFlags &&\r\n          (typeof ctor.getDerivedStateFromError === 'function' ||\r\n            (instance !== null &&\r\n              typeof instance.componentDidCatch === 'function' &&\r\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\r\n        ) {\r\n          workInProgress.flags |= ShouldCapture;\r\n          const lane = pickArbitraryLane(rootRenderLanes);\r\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\r\n          // Schedule the error boundary to re-render using updated state\r\n          const update = createClassErrorUpdate(\r\n            workInProgress,\r\n            errorInfo,\r\n            lane,\r\n          );\r\n          enqueueCapturedUpdate(workInProgress, update);\r\n          return;\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    workInProgress = workInProgress.return;\r\n  } while (workInProgress !== null);\r\n}\r\n\r\nexport {throwException, createRootErrorUpdate, createClassErrorUpdate};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}