{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { NoMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostComponent, HostText, HostRoot, SuspenseComponent } from './ReactWorkTags';\nimport { ChildDeletion, Placement, Hydrating, NoFlags, DidCapture } from './ReactFiberFlags';\nimport { createFiberFromHostInstanceForDeletion, createFiberFromDehydratedFragment } from './ReactFiber.old';\nimport { shouldSetTextContent, supportsHydration, canHydrateInstance, canHydrateTextInstance, canHydrateSuspenseInstance, getNextHydratableSibling, getFirstHydratableChild, getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance, hydrateInstance, hydrateTextInstance, hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance, shouldDeleteUnhydratedTailInstances, didNotMatchHydratedContainerTextInstance, didNotMatchHydratedTextInstance, didNotHydrateInstanceWithinContainer, didNotHydrateInstanceWithinSuspenseInstance, didNotHydrateInstance, didNotFindHydratableInstanceWithinContainer, didNotFindHydratableTextInstanceWithinContainer, didNotFindHydratableSuspenseInstanceWithinContainer, didNotFindHydratableInstanceWithinSuspenseInstance, didNotFindHydratableTextInstanceWithinSuspenseInstance, didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, didNotFindHydratableInstance, didNotFindHydratableTextInstance, didNotFindHydratableSuspenseInstance } from './ReactFiberHostConfig';\nimport { OffscreenLane } from './ReactFiberLane.old';\nimport { getSuspendedTreeContext, restoreSuspendedTreeContext } from './ReactFiberTreeContext.old';\nimport { queueRecoverableErrors } from './ReactFiberWorkLoop.old'; // The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\n\nlet hydrationParentFiber = null;\nlet nextHydratableInstance = null;\nlet isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\n\nlet didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary\n\nlet hydrationErrors = null;\n\nfunction warnIfHydrating() {\n  if (__DEV__) {\n    if (isHydrating) {\n      console.error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n    }\n  }\n}\n\nexport function markDidThrowWhileHydratingDEV() {\n  if (__DEV__) {\n    didSuspendOrErrorDEV = true;\n  }\n}\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n\n  return true;\n}\n\nfunction warnUnhydratedInstance(returnFiber, instance) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n          break;\n        }\n\n      case HostComponent:\n        {\n          const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, // TODO: Delete this argument when we remove the legacy root API.\n          isConcurrentMode);\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          const suspenseState = returnFiber.memoizedState;\n          if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n          break;\n        }\n    }\n  }\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  warnUnhydratedInstance(returnFiber, instance);\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  const deletions = returnFiber.deletions;\n\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction warnNonhydratedInstance(returnFiber, fiber) {\n  if (__DEV__) {\n    if (didSuspendOrErrorDEV) {\n      // Inside a boundary that already suspended. We're currently rendering the\n      // siblings of a suspended node. The mismatch may be due to the missing\n      // data, so it's probably a false positive.\n      return;\n    }\n\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          const parentContainer = returnFiber.stateNode.containerInfo;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n              break;\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          const parentType = returnFiber.type;\n          const parentProps = returnFiber.memoizedProps;\n          const parentInstance = returnFiber.stateNode;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              {\n                const type = fiber.type;\n                const props = fiber.pendingProps;\n                const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, // TODO: Delete this argument when we remove the legacy root API.\n                isConcurrentMode);\n                break;\n              }\n\n            case HostText:\n              {\n                const text = fiber.pendingProps;\n                const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, // TODO: Delete this argument when we remove the legacy root API.\n                isConcurrentMode);\n                break;\n              }\n\n            case SuspenseComponent:\n              {\n                didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n                break;\n              }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          const suspenseState = returnFiber.memoizedState;\n          const parentInstance = suspenseState.dehydrated;\n          if (parentInstance !== null) switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(parentInstance);\n              break;\n          }\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.flags = fiber.flags & ~Hydrating | Placement;\n  warnNonhydratedInstance(returnFiber, fiber);\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        const type = fiber.type;\n        const props = fiber.pendingProps;\n        const instance = canHydrateInstance(nextInstance, type, props);\n\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          hydrationParentFiber = fiber;\n          nextHydratableInstance = getFirstHydratableChild(instance);\n          return true;\n        }\n\n        return false;\n      }\n\n    case HostText:\n      {\n        const text = fiber.pendingProps;\n        const textInstance = canHydrateTextInstance(nextInstance, text);\n\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    case SuspenseComponent:\n      {\n        const suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n        if (suspenseInstance !== null) {\n          const suspenseState = {\n            dehydrated: suspenseInstance,\n            treeContext: getSuspendedTreeContext(),\n            retryLane: OffscreenLane\n          };\n          fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n          // This simplifies the code for getHostSibling and deleting nodes,\n          // since it doesn't have to consider all Suspense boundaries and\n          // check if they're dehydrated ones or not.\n\n          const dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n          dehydratedFragment.return = fiber;\n          fiber.child = dehydratedFragment;\n          hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n          // it during the first pass. Instead, we'll reenter it later.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nfunction shouldClientRenderOnMismatch(fiber) {\n  return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n}\n\nfunction throwOnHydrationMismatch(fiber) {\n  throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n\n  let nextInstance = nextHydratableInstance;\n\n  if (!nextInstance) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch(fiber);\n    } // Nothing to hydrate. Make it an insertion.\n\n\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  const firstAttemptedInstance = nextInstance;\n\n  if (!tryHydrate(fiber, nextInstance)) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch(fiber);\n    } // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n\n\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    const prevHydrationParentFiber = hydrationParentFiber;\n\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    } // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n\n\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const instance = fiber.stateNode;\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  const updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n\n  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n\n  if (updatePayload !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const textInstance = fiber.stateNode;\n  const textContent = fiber.memoizedProps;\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n\n  if (shouldUpdate) {\n    // We assume that prepareToHydrateHostTextInstance is called in a context where the\n    // hydration parent is the parent host component of this host text.\n    const returnFiber = hydrationParentFiber;\n\n    if (returnFiber !== null) {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            const parentContainer = returnFiber.stateNode.containerInfo;\n            const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode);\n            break;\n          }\n\n        case HostComponent:\n          {\n            const parentType = returnFiber.type;\n            const parentProps = returnFiber.memoizedProps;\n            const parentInstance = returnFiber.stateNode;\n            const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode);\n            break;\n          }\n      }\n    }\n  }\n\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const suspenseState = fiber.memoizedState;\n  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const suspenseState = fiber.memoizedState;\n  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n    parent = parent.return;\n  }\n\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  } // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them. We also don't delete anything inside the root container.\n\n\n  if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n    let nextInstance = nextHydratableInstance;\n\n    if (nextInstance) {\n      if (shouldClientRenderOnMismatch(fiber)) {\n        warnIfUnhydratedTailNodes(fiber);\n        throwOnHydrationMismatch(fiber);\n      } else {\n        while (nextInstance) {\n          deleteHydratableInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n    }\n  }\n\n  popToNextHostParent(fiber);\n\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  }\n\n  return true;\n}\n\nfunction hasUnhydratedTailNodes() {\n  return isHydrating && nextHydratableInstance !== null;\n}\n\nfunction warnIfUnhydratedTailNodes(fiber) {\n  let nextInstance = nextHydratableInstance;\n\n  while (nextInstance) {\n    warnUnhydratedInstance(fiber, nextInstance);\n    nextInstance = getNextHydratableSibling(nextInstance);\n  }\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n  didSuspendOrErrorDEV = false;\n}\n\nexport function upgradeHydrationErrorsToRecoverable() {\n  if (hydrationErrors !== null) {\n    // Successfully completed a forced client render. The errors that occurred\n    // during the hydration attempt are now recovered. We will log them in\n    // commit phase, once the entire tree has finished.\n    queueRecoverableErrors(hydrationErrors);\n    hydrationErrors = null;\n  }\n}\n\nfunction getIsHydrating() {\n  return isHydrating;\n}\n\nexport function queueHydrationError(error) {\n  if (hydrationErrors === null) {\n    hydrationErrors = [error];\n  } else {\n    hydrationErrors.push(error);\n  }\n}\nexport { warnIfHydrating, enterHydrationState, getIsHydrating, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, tryToClaimNextHydratableInstance, prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, popHydrationState, hasUnhydratedTailNodes, warnIfUnhydratedTailNodes };","map":{"version":3,"names":["NoMode","ConcurrentMode","HostComponent","HostText","HostRoot","SuspenseComponent","ChildDeletion","Placement","Hydrating","NoFlags","DidCapture","createFiberFromHostInstanceForDeletion","createFiberFromDehydratedFragment","shouldSetTextContent","supportsHydration","canHydrateInstance","canHydrateTextInstance","canHydrateSuspenseInstance","getNextHydratableSibling","getFirstHydratableChild","getFirstHydratableChildWithinContainer","getFirstHydratableChildWithinSuspenseInstance","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","shouldDeleteUnhydratedTailInstances","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateInstanceWithinContainer","didNotHydrateInstanceWithinSuspenseInstance","didNotHydrateInstance","didNotFindHydratableInstanceWithinContainer","didNotFindHydratableTextInstanceWithinContainer","didNotFindHydratableSuspenseInstanceWithinContainer","didNotFindHydratableInstanceWithinSuspenseInstance","didNotFindHydratableTextInstanceWithinSuspenseInstance","didNotFindHydratableSuspenseInstanceWithinSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","OffscreenLane","getSuspendedTreeContext","restoreSuspendedTreeContext","queueRecoverableErrors","hydrationParentFiber","nextHydratableInstance","isHydrating","didSuspendOrErrorDEV","hydrationErrors","warnIfHydrating","__DEV__","console","error","markDidThrowWhileHydratingDEV","enterHydrationState","fiber","parentInstance","stateNode","containerInfo","reenterHydrationStateFromDehydratedSuspenseInstance","suspenseInstance","treeContext","warnUnhydratedInstance","returnFiber","instance","tag","isConcurrentMode","mode","type","memoizedProps","suspenseState","memoizedState","dehydrated","deleteHydratableInstance","childToDelete","return","deletions","flags","push","warnNonhydratedInstance","parentContainer","props","pendingProps","text","parentType","parentProps","insertNonHydratedInstance","tryHydrate","nextInstance","textInstance","retryLane","dehydratedFragment","child","shouldClientRenderOnMismatch","throwOnHydrationMismatch","Error","tryToClaimNextHydratableInstance","firstAttemptedInstance","prevHydrationParentFiber","prepareToHydrateHostInstance","rootContainerInstance","hostContext","shouldWarnIfMismatchDev","updatePayload","updateQueue","prepareToHydrateHostTextInstance","textContent","shouldUpdate","prepareToHydrateHostSuspenseInstance","skipPastDehydratedSuspenseInstance","popToNextHostParent","parent","popHydrationState","warnIfUnhydratedTailNodes","hasUnhydratedTailNodes","resetHydrationState","upgradeHydrationErrorsToRecoverable","getIsHydrating","queueHydrationError"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberHydrationContext.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport {NoMode, ConcurrentMode} from './ReactTypeOfMode';\r\nimport type {\r\n  Instance,\r\n  TextInstance,\r\n  HydratableInstance,\r\n  SuspenseInstance,\r\n  Container,\r\n  HostContext,\r\n} from './ReactFiberHostConfig';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\nimport type {TreeContext} from './ReactFiberTreeContext.old';\r\n\r\nimport {\r\n  HostComponent,\r\n  HostText,\r\n  HostRoot,\r\n  SuspenseComponent,\r\n} from './ReactWorkTags';\r\nimport {\r\n  ChildDeletion,\r\n  Placement,\r\n  Hydrating,\r\n  NoFlags,\r\n  DidCapture,\r\n} from './ReactFiberFlags';\r\n\r\nimport {\r\n  createFiberFromHostInstanceForDeletion,\r\n  createFiberFromDehydratedFragment,\r\n} from './ReactFiber.old';\r\nimport {\r\n  shouldSetTextContent,\r\n  supportsHydration,\r\n  canHydrateInstance,\r\n  canHydrateTextInstance,\r\n  canHydrateSuspenseInstance,\r\n  getNextHydratableSibling,\r\n  getFirstHydratableChild,\r\n  getFirstHydratableChildWithinContainer,\r\n  getFirstHydratableChildWithinSuspenseInstance,\r\n  hydrateInstance,\r\n  hydrateTextInstance,\r\n  hydrateSuspenseInstance,\r\n  getNextHydratableInstanceAfterSuspenseInstance,\r\n  shouldDeleteUnhydratedTailInstances,\r\n  didNotMatchHydratedContainerTextInstance,\r\n  didNotMatchHydratedTextInstance,\r\n  didNotHydrateInstanceWithinContainer,\r\n  didNotHydrateInstanceWithinSuspenseInstance,\r\n  didNotHydrateInstance,\r\n  didNotFindHydratableInstanceWithinContainer,\r\n  didNotFindHydratableTextInstanceWithinContainer,\r\n  didNotFindHydratableSuspenseInstanceWithinContainer,\r\n  didNotFindHydratableInstanceWithinSuspenseInstance,\r\n  didNotFindHydratableTextInstanceWithinSuspenseInstance,\r\n  didNotFindHydratableSuspenseInstanceWithinSuspenseInstance,\r\n  didNotFindHydratableInstance,\r\n  didNotFindHydratableTextInstance,\r\n  didNotFindHydratableSuspenseInstance,\r\n} from './ReactFiberHostConfig';\r\nimport {OffscreenLane} from './ReactFiberLane.old';\r\nimport {\r\n  getSuspendedTreeContext,\r\n  restoreSuspendedTreeContext,\r\n} from './ReactFiberTreeContext.old';\r\nimport {queueRecoverableErrors} from './ReactFiberWorkLoop.old';\r\n\r\n// The deepest Fiber on the stack involved in a hydration context.\r\n// This may have been an insertion or a hydration.\r\nlet hydrationParentFiber: null | Fiber = null;\r\nlet nextHydratableInstance: null | HydratableInstance = null;\r\nlet isHydrating: boolean = false;\r\n\r\n// This flag allows for warning supression when we expect there to be mismatches\r\n// due to earlier mismatches or a suspended fiber.\r\nlet didSuspendOrErrorDEV: boolean = false;\r\n\r\n// Hydration errors that were thrown inside this boundary\r\nlet hydrationErrors: Array<mixed> | null = null;\r\n\r\nfunction warnIfHydrating() {\r\n  if (__DEV__) {\r\n    if (isHydrating) {\r\n      console.error(\r\n        'We should not be hydrating here. This is a bug in React. Please file a bug.',\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function markDidThrowWhileHydratingDEV() {\r\n  if (__DEV__) {\r\n    didSuspendOrErrorDEV = true;\r\n  }\r\n}\r\n\r\nfunction enterHydrationState(fiber: Fiber): boolean {\r\n  if (!supportsHydration) {\r\n    return false;\r\n  }\r\n\r\n  const parentInstance: Container = fiber.stateNode.containerInfo;\r\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(\r\n    parentInstance,\r\n  );\r\n  hydrationParentFiber = fiber;\r\n  isHydrating = true;\r\n  hydrationErrors = null;\r\n  didSuspendOrErrorDEV = false;\r\n  return true;\r\n}\r\n\r\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(\r\n  fiber: Fiber,\r\n  suspenseInstance: SuspenseInstance,\r\n  treeContext: TreeContext | null,\r\n): boolean {\r\n  if (!supportsHydration) {\r\n    return false;\r\n  }\r\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(\r\n    suspenseInstance,\r\n  );\r\n  hydrationParentFiber = fiber;\r\n  isHydrating = true;\r\n  hydrationErrors = null;\r\n  didSuspendOrErrorDEV = false;\r\n  if (treeContext !== null) {\r\n    restoreSuspendedTreeContext(fiber, treeContext);\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction warnUnhydratedInstance(\r\n  returnFiber: Fiber,\r\n  instance: HydratableInstance,\r\n) {\r\n  if (__DEV__) {\r\n    switch (returnFiber.tag) {\r\n      case HostRoot: {\r\n        didNotHydrateInstanceWithinContainer(\r\n          returnFiber.stateNode.containerInfo,\r\n          instance,\r\n        );\r\n        break;\r\n      }\r\n      case HostComponent: {\r\n        const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\r\n        didNotHydrateInstance(\r\n          returnFiber.type,\r\n          returnFiber.memoizedProps,\r\n          returnFiber.stateNode,\r\n          instance,\r\n          // TODO: Delete this argument when we remove the legacy root API.\r\n          isConcurrentMode,\r\n        );\r\n        break;\r\n      }\r\n      case SuspenseComponent: {\r\n        const suspenseState: SuspenseState = returnFiber.memoizedState;\r\n        if (suspenseState.dehydrated !== null)\r\n          didNotHydrateInstanceWithinSuspenseInstance(\r\n            suspenseState.dehydrated,\r\n            instance,\r\n          );\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteHydratableInstance(\r\n  returnFiber: Fiber,\r\n  instance: HydratableInstance,\r\n) {\r\n  warnUnhydratedInstance(returnFiber, instance);\r\n  const childToDelete = createFiberFromHostInstanceForDeletion();\r\n  childToDelete.stateNode = instance;\r\n  childToDelete.return = returnFiber;\r\n\r\n  const deletions = returnFiber.deletions;\r\n  if (deletions === null) {\r\n    returnFiber.deletions = [childToDelete];\r\n    returnFiber.flags |= ChildDeletion;\r\n  } else {\r\n    deletions.push(childToDelete);\r\n  }\r\n}\r\n\r\nfunction warnNonhydratedInstance(returnFiber: Fiber, fiber: Fiber) {\r\n  if (__DEV__) {\r\n    if (didSuspendOrErrorDEV) {\r\n      // Inside a boundary that already suspended. We're currently rendering the\r\n      // siblings of a suspended node. The mismatch may be due to the missing\r\n      // data, so it's probably a false positive.\r\n      return;\r\n    }\r\n\r\n    switch (returnFiber.tag) {\r\n      case HostRoot: {\r\n        const parentContainer = returnFiber.stateNode.containerInfo;\r\n        switch (fiber.tag) {\r\n          case HostComponent:\r\n            const type = fiber.type;\r\n            const props = fiber.pendingProps;\r\n            didNotFindHydratableInstanceWithinContainer(\r\n              parentContainer,\r\n              type,\r\n              props,\r\n            );\r\n            break;\r\n          case HostText:\r\n            const text = fiber.pendingProps;\r\n            didNotFindHydratableTextInstanceWithinContainer(\r\n              parentContainer,\r\n              text,\r\n            );\r\n            break;\r\n          case SuspenseComponent:\r\n            didNotFindHydratableSuspenseInstanceWithinContainer(\r\n              parentContainer,\r\n            );\r\n            break;\r\n        }\r\n        break;\r\n      }\r\n      case HostComponent: {\r\n        const parentType = returnFiber.type;\r\n        const parentProps = returnFiber.memoizedProps;\r\n        const parentInstance = returnFiber.stateNode;\r\n        switch (fiber.tag) {\r\n          case HostComponent: {\r\n            const type = fiber.type;\r\n            const props = fiber.pendingProps;\r\n            const isConcurrentMode =\r\n              (returnFiber.mode & ConcurrentMode) !== NoMode;\r\n            didNotFindHydratableInstance(\r\n              parentType,\r\n              parentProps,\r\n              parentInstance,\r\n              type,\r\n              props,\r\n              // TODO: Delete this argument when we remove the legacy root API.\r\n              isConcurrentMode,\r\n            );\r\n            break;\r\n          }\r\n          case HostText: {\r\n            const text = fiber.pendingProps;\r\n            const isConcurrentMode =\r\n              (returnFiber.mode & ConcurrentMode) !== NoMode;\r\n            didNotFindHydratableTextInstance(\r\n              parentType,\r\n              parentProps,\r\n              parentInstance,\r\n              text,\r\n              // TODO: Delete this argument when we remove the legacy root API.\r\n              isConcurrentMode,\r\n            );\r\n            break;\r\n          }\r\n          case SuspenseComponent: {\r\n            didNotFindHydratableSuspenseInstance(\r\n              parentType,\r\n              parentProps,\r\n              parentInstance,\r\n            );\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case SuspenseComponent: {\r\n        const suspenseState: SuspenseState = returnFiber.memoizedState;\r\n        const parentInstance = suspenseState.dehydrated;\r\n        if (parentInstance !== null)\r\n          switch (fiber.tag) {\r\n            case HostComponent:\r\n              const type = fiber.type;\r\n              const props = fiber.pendingProps;\r\n              didNotFindHydratableInstanceWithinSuspenseInstance(\r\n                parentInstance,\r\n                type,\r\n                props,\r\n              );\r\n              break;\r\n            case HostText:\r\n              const text = fiber.pendingProps;\r\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(\r\n                parentInstance,\r\n                text,\r\n              );\r\n              break;\r\n            case SuspenseComponent:\r\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(\r\n                parentInstance,\r\n              );\r\n              break;\r\n          }\r\n        break;\r\n      }\r\n      default:\r\n        return;\r\n    }\r\n  }\r\n}\r\nfunction insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {\r\n  fiber.flags = (fiber.flags & ~Hydrating) | Placement;\r\n  warnNonhydratedInstance(returnFiber, fiber);\r\n}\r\n\r\nfunction tryHydrate(fiber, nextInstance) {\r\n  switch (fiber.tag) {\r\n    case HostComponent: {\r\n      const type = fiber.type;\r\n      const props = fiber.pendingProps;\r\n      const instance = canHydrateInstance(nextInstance, type, props);\r\n      if (instance !== null) {\r\n        fiber.stateNode = (instance: Instance);\r\n        hydrationParentFiber = fiber;\r\n        nextHydratableInstance = getFirstHydratableChild(instance);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    case HostText: {\r\n      const text = fiber.pendingProps;\r\n      const textInstance = canHydrateTextInstance(nextInstance, text);\r\n      if (textInstance !== null) {\r\n        fiber.stateNode = (textInstance: TextInstance);\r\n        hydrationParentFiber = fiber;\r\n        // Text Instances don't have children so there's nothing to hydrate.\r\n        nextHydratableInstance = null;\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    case SuspenseComponent: {\r\n      const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(\r\n        nextInstance,\r\n      );\r\n      if (suspenseInstance !== null) {\r\n        const suspenseState: SuspenseState = {\r\n          dehydrated: suspenseInstance,\r\n          treeContext: getSuspendedTreeContext(),\r\n          retryLane: OffscreenLane,\r\n        };\r\n        fiber.memoizedState = suspenseState;\r\n        // Store the dehydrated fragment as a child fiber.\r\n        // This simplifies the code for getHostSibling and deleting nodes,\r\n        // since it doesn't have to consider all Suspense boundaries and\r\n        // check if they're dehydrated ones or not.\r\n        const dehydratedFragment = createFiberFromDehydratedFragment(\r\n          suspenseInstance,\r\n        );\r\n        dehydratedFragment.return = fiber;\r\n        fiber.child = dehydratedFragment;\r\n        hydrationParentFiber = fiber;\r\n        // While a Suspense Instance does have children, we won't step into\r\n        // it during the first pass. Instead, we'll reenter it later.\r\n        nextHydratableInstance = null;\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nfunction shouldClientRenderOnMismatch(fiber: Fiber) {\r\n  return (\r\n    (fiber.mode & ConcurrentMode) !== NoMode &&\r\n    (fiber.flags & DidCapture) === NoFlags\r\n  );\r\n}\r\n\r\nfunction throwOnHydrationMismatch(fiber: Fiber) {\r\n  throw new Error(\r\n    'Hydration failed because the initial UI does not match what was ' +\r\n      'rendered on the server.',\r\n  );\r\n}\r\n\r\nfunction tryToClaimNextHydratableInstance(fiber: Fiber): void {\r\n  if (!isHydrating) {\r\n    return;\r\n  }\r\n  let nextInstance = nextHydratableInstance;\r\n  if (!nextInstance) {\r\n    if (shouldClientRenderOnMismatch(fiber)) {\r\n      warnNonhydratedInstance((hydrationParentFiber: any), fiber);\r\n      throwOnHydrationMismatch(fiber);\r\n    }\r\n    // Nothing to hydrate. Make it an insertion.\r\n    insertNonHydratedInstance((hydrationParentFiber: any), fiber);\r\n    isHydrating = false;\r\n    hydrationParentFiber = fiber;\r\n    return;\r\n  }\r\n  const firstAttemptedInstance = nextInstance;\r\n  if (!tryHydrate(fiber, nextInstance)) {\r\n    if (shouldClientRenderOnMismatch(fiber)) {\r\n      warnNonhydratedInstance((hydrationParentFiber: any), fiber);\r\n      throwOnHydrationMismatch(fiber);\r\n    }\r\n    // If we can't hydrate this instance let's try the next one.\r\n    // We use this as a heuristic. It's based on intuition and not data so it\r\n    // might be flawed or unnecessary.\r\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\r\n    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);\r\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\r\n      // Nothing to hydrate. Make it an insertion.\r\n      insertNonHydratedInstance((hydrationParentFiber: any), fiber);\r\n      isHydrating = false;\r\n      hydrationParentFiber = fiber;\r\n      return;\r\n    }\r\n    // We matched the next one, we'll now assume that the first one was\r\n    // superfluous and we'll delete it. Since we can't eagerly delete it\r\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\r\n    // fiber associated with it.\r\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\r\n  }\r\n}\r\n\r\nfunction prepareToHydrateHostInstance(\r\n  fiber: Fiber,\r\n  rootContainerInstance: Container,\r\n  hostContext: HostContext,\r\n): boolean {\r\n  if (!supportsHydration) {\r\n    throw new Error(\r\n      'Expected prepareToHydrateHostInstance() to never be called. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  const instance: Instance = fiber.stateNode;\r\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\r\n  const updatePayload = hydrateInstance(\r\n    instance,\r\n    fiber.type,\r\n    fiber.memoizedProps,\r\n    rootContainerInstance,\r\n    hostContext,\r\n    fiber,\r\n    shouldWarnIfMismatchDev,\r\n  );\r\n  // TODO: Type this specific to this type of component.\r\n  fiber.updateQueue = (updatePayload: any);\r\n  // If the update payload indicates that there is a change or if there\r\n  // is a new ref we mark this as an update.\r\n  if (updatePayload !== null) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction prepareToHydrateHostTextInstance(fiber: Fiber): boolean {\r\n  if (!supportsHydration) {\r\n    throw new Error(\r\n      'Expected prepareToHydrateHostTextInstance() to never be called. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  const textInstance: TextInstance = fiber.stateNode;\r\n  const textContent: string = fiber.memoizedProps;\r\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\r\n  const shouldUpdate = hydrateTextInstance(\r\n    textInstance,\r\n    textContent,\r\n    fiber,\r\n    shouldWarnIfMismatchDev,\r\n  );\r\n  if (shouldUpdate) {\r\n    // We assume that prepareToHydrateHostTextInstance is called in a context where the\r\n    // hydration parent is the parent host component of this host text.\r\n    const returnFiber = hydrationParentFiber;\r\n    if (returnFiber !== null) {\r\n      switch (returnFiber.tag) {\r\n        case HostRoot: {\r\n          const parentContainer = returnFiber.stateNode.containerInfo;\r\n          const isConcurrentMode =\r\n            (returnFiber.mode & ConcurrentMode) !== NoMode;\r\n          didNotMatchHydratedContainerTextInstance(\r\n            parentContainer,\r\n            textInstance,\r\n            textContent,\r\n            // TODO: Delete this argument when we remove the legacy root API.\r\n            isConcurrentMode,\r\n          );\r\n          break;\r\n        }\r\n        case HostComponent: {\r\n          const parentType = returnFiber.type;\r\n          const parentProps = returnFiber.memoizedProps;\r\n          const parentInstance = returnFiber.stateNode;\r\n          const isConcurrentMode =\r\n            (returnFiber.mode & ConcurrentMode) !== NoMode;\r\n          didNotMatchHydratedTextInstance(\r\n            parentType,\r\n            parentProps,\r\n            parentInstance,\r\n            textInstance,\r\n            textContent,\r\n            // TODO: Delete this argument when we remove the legacy root API.\r\n            isConcurrentMode,\r\n          );\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return shouldUpdate;\r\n}\r\n\r\nfunction prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {\r\n  if (!supportsHydration) {\r\n    throw new Error(\r\n      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\r\n  const suspenseInstance: null | SuspenseInstance =\r\n    suspenseState !== null ? suspenseState.dehydrated : null;\r\n\r\n  if (!suspenseInstance) {\r\n    throw new Error(\r\n      'Expected to have a hydrated suspense instance. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  hydrateSuspenseInstance(suspenseInstance, fiber);\r\n}\r\n\r\nfunction skipPastDehydratedSuspenseInstance(\r\n  fiber: Fiber,\r\n): null | HydratableInstance {\r\n  if (!supportsHydration) {\r\n    throw new Error(\r\n      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\r\n  const suspenseInstance: null | SuspenseInstance =\r\n    suspenseState !== null ? suspenseState.dehydrated : null;\r\n\r\n  if (!suspenseInstance) {\r\n    throw new Error(\r\n      'Expected to have a hydrated suspense instance. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n\r\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\r\n}\r\n\r\nfunction popToNextHostParent(fiber: Fiber): void {\r\n  let parent = fiber.return;\r\n  while (\r\n    parent !== null &&\r\n    parent.tag !== HostComponent &&\r\n    parent.tag !== HostRoot &&\r\n    parent.tag !== SuspenseComponent\r\n  ) {\r\n    parent = parent.return;\r\n  }\r\n  hydrationParentFiber = parent;\r\n}\r\n\r\nfunction popHydrationState(fiber: Fiber): boolean {\r\n  if (!supportsHydration) {\r\n    return false;\r\n  }\r\n  if (fiber !== hydrationParentFiber) {\r\n    // We're deeper than the current hydration context, inside an inserted\r\n    // tree.\r\n    return false;\r\n  }\r\n  if (!isHydrating) {\r\n    // If we're not currently hydrating but we're in a hydration context, then\r\n    // we were an insertion and now need to pop up reenter hydration of our\r\n    // siblings.\r\n    popToNextHostParent(fiber);\r\n    isHydrating = true;\r\n    return false;\r\n  }\r\n\r\n  // If we have any remaining hydratable nodes, we need to delete them now.\r\n  // We only do this deeper than head and body since they tend to have random\r\n  // other nodes in them. We also ignore components with pure text content in\r\n  // side of them. We also don't delete anything inside the root container.\r\n  if (\r\n    fiber.tag !== HostRoot &&\r\n    (fiber.tag !== HostComponent ||\r\n      (shouldDeleteUnhydratedTailInstances(fiber.type) &&\r\n        !shouldSetTextContent(fiber.type, fiber.memoizedProps)))\r\n  ) {\r\n    let nextInstance = nextHydratableInstance;\r\n    if (nextInstance) {\r\n      if (shouldClientRenderOnMismatch(fiber)) {\r\n        warnIfUnhydratedTailNodes(fiber);\r\n        throwOnHydrationMismatch(fiber);\r\n      } else {\r\n        while (nextInstance) {\r\n          deleteHydratableInstance(fiber, nextInstance);\r\n          nextInstance = getNextHydratableSibling(nextInstance);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  popToNextHostParent(fiber);\r\n  if (fiber.tag === SuspenseComponent) {\r\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\r\n  } else {\r\n    nextHydratableInstance = hydrationParentFiber\r\n      ? getNextHydratableSibling(fiber.stateNode)\r\n      : null;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction hasUnhydratedTailNodes() {\r\n  return isHydrating && nextHydratableInstance !== null;\r\n}\r\n\r\nfunction warnIfUnhydratedTailNodes(fiber: Fiber) {\r\n  let nextInstance = nextHydratableInstance;\r\n  while (nextInstance) {\r\n    warnUnhydratedInstance(fiber, nextInstance);\r\n    nextInstance = getNextHydratableSibling(nextInstance);\r\n  }\r\n}\r\n\r\nfunction resetHydrationState(): void {\r\n  if (!supportsHydration) {\r\n    return;\r\n  }\r\n\r\n  hydrationParentFiber = null;\r\n  nextHydratableInstance = null;\r\n  isHydrating = false;\r\n  didSuspendOrErrorDEV = false;\r\n}\r\n\r\nexport function upgradeHydrationErrorsToRecoverable(): void {\r\n  if (hydrationErrors !== null) {\r\n    // Successfully completed a forced client render. The errors that occurred\r\n    // during the hydration attempt are now recovered. We will log them in\r\n    // commit phase, once the entire tree has finished.\r\n    queueRecoverableErrors(hydrationErrors);\r\n    hydrationErrors = null;\r\n  }\r\n}\r\n\r\nfunction getIsHydrating(): boolean {\r\n  return isHydrating;\r\n}\r\n\r\nexport function queueHydrationError(error: mixed): void {\r\n  if (hydrationErrors === null) {\r\n    hydrationErrors = [error];\r\n  } else {\r\n    hydrationErrors.push(error);\r\n  }\r\n}\r\n\r\nexport {\r\n  warnIfHydrating,\r\n  enterHydrationState,\r\n  getIsHydrating,\r\n  reenterHydrationStateFromDehydratedSuspenseInstance,\r\n  resetHydrationState,\r\n  tryToClaimNextHydratableInstance,\r\n  prepareToHydrateHostInstance,\r\n  prepareToHydrateHostTextInstance,\r\n  prepareToHydrateHostSuspenseInstance,\r\n  popHydrationState,\r\n  hasUnhydratedTailNodes,\r\n  warnIfUnhydratedTailNodes,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}