{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableCache, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { isPrimaryRenderer } from './ReactFiberHostConfig';\nimport { createCursor, push, pop } from './ReactFiberStack.new';\nimport { getWorkInProgressRoot, getWorkInProgressTransitions } from './ReactFiberWorkLoop.new';\nimport { createCache, retainCache, CacheContext } from './ReactFiberCacheComponent.new'; // When retrying a Suspense/Offscreen boundary, we restore the cache that was\n// used during the previous render by placing it here, on the stack.\n\nconst resumedCache = createCursor(null); // During the render/synchronous commit phase, we don't actually process the\n// transitions. Therefore, we want to lazily combine transitions. Instead of\n// comparing the arrays of transitions when we combine them and storing them\n// and filtering out the duplicates, we will instead store the unprocessed transitions\n// in an array and actually filter them in the passive phase.\n\nconst transitionStack = createCursor(null);\n\nfunction peekCacheFromPool() {\n  if (!enableCache) {\n    return null;\n  } // Check if the cache pool already has a cache we can use.\n  // If we're rendering inside a Suspense boundary that is currently hidden,\n  // we should use the same cache that we used during the previous render, if\n  // one exists.\n\n\n  const cacheResumedFromPreviousRender = resumedCache.current;\n\n  if (cacheResumedFromPreviousRender !== null) {\n    return cacheResumedFromPreviousRender;\n  } // Otherwise, check the root's cache pool.\n\n\n  const root = getWorkInProgressRoot();\n  const cacheFromRootCachePool = root.pooledCache;\n  return cacheFromRootCachePool;\n}\n\nexport function requestCacheFromPool(renderLanes) {\n  // Similar to previous function, except if there's not already a cache in the\n  // pool, we allocate a new one.\n  const cacheFromPool = peekCacheFromPool();\n\n  if (cacheFromPool !== null) {\n    return cacheFromPool;\n  } // Create a fresh cache and add it to the root cache pool. A cache can have\n  // multiple owners:\n  // - A cache pool that lives on the FiberRoot. This is where all fresh caches\n  //   are originally created (TODO: except during refreshes, until we implement\n  //   this correctly). The root takes ownership immediately when the cache is\n  //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\n  //   and the return value of this function is a &Arc<Cache> (borrowed).\n  // - One of several fiber types: host root, cache boundary, suspense\n  //   component. These retain and release in the commit phase.\n\n\n  const root = getWorkInProgressRoot();\n  const freshCache = createCache();\n  root.pooledCache = freshCache;\n  retainCache(freshCache);\n\n  if (freshCache !== null) {\n    root.pooledCacheLanes |= renderLanes;\n  }\n\n  return freshCache;\n}\nexport function pushRootTransition(workInProgress, root, renderLanes) {\n  if (enableTransitionTracing) {\n    const rootTransitions = getWorkInProgressTransitions();\n    push(transitionStack, rootTransitions, workInProgress);\n  }\n}\nexport function popRootTransition(workInProgress, root, renderLanes) {\n  if (enableTransitionTracing) {\n    pop(transitionStack, workInProgress);\n  }\n}\nexport function pushTransition(offscreenWorkInProgress, prevCachePool, newTransitions) {\n  if (enableCache) {\n    if (prevCachePool === null) {\n      push(resumedCache, resumedCache.current, offscreenWorkInProgress);\n    } else {\n      push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n  }\n\n  if (enableTransitionTracing) {\n    if (transitionStack.current === null) {\n      push(transitionStack, newTransitions, offscreenWorkInProgress);\n    } else if (newTransitions === null) {\n      push(transitionStack, transitionStack.current, offscreenWorkInProgress);\n    } else {\n      push(transitionStack, transitionStack.current.concat(newTransitions), offscreenWorkInProgress);\n    }\n  }\n}\nexport function popTransition(workInProgress, current) {\n  if (current !== null) {\n    if (enableCache) {\n      pop(resumedCache, workInProgress);\n    }\n\n    if (enableTransitionTracing) {\n      pop(transitionStack, workInProgress);\n    }\n  }\n}\nexport function getSuspendedTransitions() {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  return transitionStack.current;\n}\nexport function getSuspendedCache() {\n  if (!enableCache) {\n    return null;\n  } // This function is called when a Suspense boundary suspends. It returns the\n  // cache that would have been used to render fresh data during this render,\n  // if there was any, so that we can resume rendering with the same cache when\n  // we receive more data.\n\n\n  const cacheFromPool = peekCacheFromPool();\n\n  if (cacheFromPool === null) {\n    return null;\n  }\n\n  return {\n    // We must also save the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n    pool: cacheFromPool\n  };\n}\nexport function getOffscreenDeferredCache() {\n  if (!enableCache) {\n    return null;\n  }\n\n  const cacheFromPool = peekCacheFromPool();\n\n  if (cacheFromPool === null) {\n    return null;\n  }\n\n  return {\n    // We must also store the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n    pool: cacheFromPool\n  };\n}","map":{"version":3,"names":["enableCache","enableTransitionTracing","isPrimaryRenderer","createCursor","push","pop","getWorkInProgressRoot","getWorkInProgressTransitions","createCache","retainCache","CacheContext","resumedCache","transitionStack","peekCacheFromPool","cacheResumedFromPreviousRender","current","root","cacheFromRootCachePool","pooledCache","requestCacheFromPool","renderLanes","cacheFromPool","freshCache","pooledCacheLanes","pushRootTransition","workInProgress","rootTransitions","popRootTransition","pushTransition","offscreenWorkInProgress","prevCachePool","newTransitions","pool","concat","popTransition","getSuspendedTransitions","getSuspendedCache","parent","_currentValue","_currentValue2","getOffscreenDeferredCache"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberTransition.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\nimport type {FiberRoot} from './ReactInternalTypes';\r\nimport type {Lanes} from './ReactFiberLane.new';\r\nimport type {StackCursor} from './ReactFiberStack.new';\r\nimport type {Cache, SpawnedCachePool} from './ReactFiberCacheComponent.new';\r\nimport type {Transition} from './ReactFiberTracingMarkerComponent.new';\r\n\r\nimport {enableCache, enableTransitionTracing} from 'shared/ReactFeatureFlags';\r\nimport {isPrimaryRenderer} from './ReactFiberHostConfig';\r\nimport {createCursor, push, pop} from './ReactFiberStack.new';\r\nimport {\r\n  getWorkInProgressRoot,\r\n  getWorkInProgressTransitions,\r\n} from './ReactFiberWorkLoop.new';\r\nimport {\r\n  createCache,\r\n  retainCache,\r\n  CacheContext,\r\n} from './ReactFiberCacheComponent.new';\r\n\r\n// When retrying a Suspense/Offscreen boundary, we restore the cache that was\r\n// used during the previous render by placing it here, on the stack.\r\nconst resumedCache: StackCursor<Cache | null> = createCursor(null);\r\n\r\n// During the render/synchronous commit phase, we don't actually process the\r\n// transitions. Therefore, we want to lazily combine transitions. Instead of\r\n// comparing the arrays of transitions when we combine them and storing them\r\n// and filtering out the duplicates, we will instead store the unprocessed transitions\r\n// in an array and actually filter them in the passive phase.\r\nconst transitionStack: StackCursor<Array<Transition> | null> = createCursor(\r\n  null,\r\n);\r\n\r\nfunction peekCacheFromPool(): Cache | null {\r\n  if (!enableCache) {\r\n    return (null: any);\r\n  }\r\n\r\n  // Check if the cache pool already has a cache we can use.\r\n\r\n  // If we're rendering inside a Suspense boundary that is currently hidden,\r\n  // we should use the same cache that we used during the previous render, if\r\n  // one exists.\r\n  const cacheResumedFromPreviousRender = resumedCache.current;\r\n  if (cacheResumedFromPreviousRender !== null) {\r\n    return cacheResumedFromPreviousRender;\r\n  }\r\n\r\n  // Otherwise, check the root's cache pool.\r\n  const root = (getWorkInProgressRoot(): any);\r\n  const cacheFromRootCachePool = root.pooledCache;\r\n\r\n  return cacheFromRootCachePool;\r\n}\r\n\r\nexport function requestCacheFromPool(renderLanes: Lanes): Cache {\r\n  // Similar to previous function, except if there's not already a cache in the\r\n  // pool, we allocate a new one.\r\n  const cacheFromPool = peekCacheFromPool();\r\n  if (cacheFromPool !== null) {\r\n    return cacheFromPool;\r\n  }\r\n\r\n  // Create a fresh cache and add it to the root cache pool. A cache can have\r\n  // multiple owners:\r\n  // - A cache pool that lives on the FiberRoot. This is where all fresh caches\r\n  //   are originally created (TODO: except during refreshes, until we implement\r\n  //   this correctly). The root takes ownership immediately when the cache is\r\n  //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\r\n  //   and the return value of this function is a &Arc<Cache> (borrowed).\r\n  // - One of several fiber types: host root, cache boundary, suspense\r\n  //   component. These retain and release in the commit phase.\r\n\r\n  const root = (getWorkInProgressRoot(): any);\r\n  const freshCache = createCache();\r\n  root.pooledCache = freshCache;\r\n  retainCache(freshCache);\r\n  if (freshCache !== null) {\r\n    root.pooledCacheLanes |= renderLanes;\r\n  }\r\n  return freshCache;\r\n}\r\n\r\nexport function pushRootTransition(\r\n  workInProgress: Fiber,\r\n  root: FiberRoot,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (enableTransitionTracing) {\r\n    const rootTransitions = getWorkInProgressTransitions();\r\n    push(transitionStack, rootTransitions, workInProgress);\r\n  }\r\n}\r\n\r\nexport function popRootTransition(\r\n  workInProgress: Fiber,\r\n  root: FiberRoot,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (enableTransitionTracing) {\r\n    pop(transitionStack, workInProgress);\r\n  }\r\n}\r\n\r\nexport function pushTransition(\r\n  offscreenWorkInProgress: Fiber,\r\n  prevCachePool: SpawnedCachePool | null,\r\n  newTransitions: Array<Transition> | null,\r\n): void {\r\n  if (enableCache) {\r\n    if (prevCachePool === null) {\r\n      push(resumedCache, resumedCache.current, offscreenWorkInProgress);\r\n    } else {\r\n      push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\r\n    }\r\n  }\r\n\r\n  if (enableTransitionTracing) {\r\n    if (transitionStack.current === null) {\r\n      push(transitionStack, newTransitions, offscreenWorkInProgress);\r\n    } else if (newTransitions === null) {\r\n      push(transitionStack, transitionStack.current, offscreenWorkInProgress);\r\n    } else {\r\n      push(\r\n        transitionStack,\r\n        transitionStack.current.concat(newTransitions),\r\n        offscreenWorkInProgress,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function popTransition(workInProgress: Fiber, current: Fiber | null) {\r\n  if (current !== null) {\r\n    if (enableCache) {\r\n      pop(resumedCache, workInProgress);\r\n    }\r\n\r\n    if (enableTransitionTracing) {\r\n      pop(transitionStack, workInProgress);\r\n    }\r\n  }\r\n}\r\n\r\nexport function getSuspendedTransitions(): Array<Transition> | null {\r\n  if (!enableTransitionTracing) {\r\n    return null;\r\n  }\r\n\r\n  return transitionStack.current;\r\n}\r\n\r\nexport function getSuspendedCache(): SpawnedCachePool | null {\r\n  if (!enableCache) {\r\n    return null;\r\n  }\r\n  // This function is called when a Suspense boundary suspends. It returns the\r\n  // cache that would have been used to render fresh data during this render,\r\n  // if there was any, so that we can resume rendering with the same cache when\r\n  // we receive more data.\r\n  const cacheFromPool = peekCacheFromPool();\r\n  if (cacheFromPool === null) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    // We must also save the parent, so that when we resume we can detect\r\n    // a refresh.\r\n    parent: isPrimaryRenderer\r\n      ? CacheContext._currentValue\r\n      : CacheContext._currentValue2,\r\n    pool: cacheFromPool,\r\n  };\r\n}\r\n\r\nexport function getOffscreenDeferredCache(): SpawnedCachePool | null {\r\n  if (!enableCache) {\r\n    return null;\r\n  }\r\n\r\n  const cacheFromPool = peekCacheFromPool();\r\n  if (cacheFromPool === null) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    // We must also store the parent, so that when we resume we can detect\r\n    // a refresh.\r\n    parent: isPrimaryRenderer\r\n      ? CacheContext._currentValue\r\n      : CacheContext._currentValue2,\r\n    pool: cacheFromPool,\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}