{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { HostComponent, HostText, HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { getParentSuspenseInstance } from './ReactDOMHostConfig';\nimport { enableScopeAPI } from 'shared/ReactFeatureFlags';\nconst randomKey = Math.random().toString(36).slice(2);\nconst internalInstanceKey = '__reactFiber$' + randomKey;\nconst internalPropsKey = '__reactProps$' + randomKey;\nconst internalContainerInstanceKey = '__reactContainer$' + randomKey;\nconst internalEventHandlersKey = '__reactEvents$' + randomKey;\nconst internalEventHandlerListenersKey = '__reactListeners$' + randomKey;\nconst internalEventHandlesSetKey = '__reactHandles$' + randomKey;\nexport function detachDeletedInstance(node) {\n  // TODO: This function is only called on host components. I don't think all of\n  // these fields are relevant.\n  delete node[internalInstanceKey];\n  delete node[internalPropsKey];\n  delete node[internalEventHandlersKey];\n  delete node[internalEventHandlerListenersKey];\n  delete node[internalEventHandlesSetKey];\n}\nexport function precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\nexport function markContainerAsRoot(hostRoot, node) {\n  node[internalContainerInstanceKey] = hostRoot;\n}\nexport function unmarkContainerAsRoot(node) {\n  node[internalContainerInstanceKey] = null;\n}\nexport function isContainerMarkedAsRoot(node) {\n  return !!node[internalContainerInstanceKey];\n} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\n// 判断是否是fiber节点  主要是\n\nexport function getClosestInstanceFromNode(targetNode) {\n  let targetInst = targetNode[internalInstanceKey]; // 如果触发事件的节点有react fiber标记则直接返回\n\n  if (targetInst) {\n    // Don't return HostRoot or SuspenseComponent here.\n    return targetInst;\n  } // If the direct event target isn't a React owned DOM node, we need to look\n  // to see if one of its parents is a React owned DOM node.\n\n\n  let parentNode = targetNode.parentNode;\n\n  while (parentNode) {\n    // We'll check if this is a container root that could include\n    // React nodes in the future. We need to check this first because\n    // if we're a child of a dehydrated container, we need to first\n    // find that inner container before moving on to finding the parent\n    // instance. Note that we don't check this field on  the targetNode\n    // itself because the fibers are conceptually between the container\n    // node and the first child. It isn't surrounding the container node.\n    // If it's not a container, we check if it's an instance.\n    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\n\n    if (targetInst) {\n      // Since this wasn't the direct target of the event, we might have\n      // stepped past dehydrated DOM nodes to get here. However they could\n      // also have been non-React nodes. We need to answer which one.\n      // If we the instance doesn't have any children, then there can't be\n      // a nested suspense boundary within it. So we can use this as a fast\n      // bailout. Most of the time, when people add non-React children to\n      // the tree, it is using a ref to a child-less DOM node.\n      // Normally we'd only need to check one of the fibers because if it\n      // has ever gone from having children to deleting them or vice versa\n      // it would have deleted the dehydrated boundary nested inside already.\n      // However, since the HostRoot starts out with an alternate it might\n      // have one on the alternate so we need to check in case this was a\n      // root.\n      const alternate = targetInst.alternate;\n\n      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {\n        // Next we need to figure out if the node that skipped past is\n        // nested within a dehydrated boundary and if so, which one.\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\n\n        while (suspenseInstance !== null) {\n          // We found a suspense instance. That means that we haven't\n          // hydrated it yet. Even though we leave the comments in the\n          // DOM after hydrating, and there are boundaries in the DOM\n          // that could already be hydrated, we wouldn't have found them\n          // through this pass since if the target is hydrated it would\n          // have had an internalInstanceKey on it.\n          // Let's get the fiber associated with the SuspenseComponent\n          // as the deepest instance.\n          const targetSuspenseInst = suspenseInstance[internalInstanceKey];\n\n          if (targetSuspenseInst) {\n            return targetSuspenseInst;\n          } // If we don't find a Fiber on the comment, it might be because\n          // we haven't gotten to hydrate it yet. There might still be a\n          // parent boundary that hasn't above this one so we need to find\n          // the outer most that is known.\n\n\n          suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent\n          // host component also hasn't hydrated yet. We can return it\n          // below since it will bail out on the isMounted check later.\n        }\n      }\n\n      return targetInst;\n    }\n\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n\n  return null;\n}\n/**\r\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\r\n * instance, or null if the node was not rendered by this React.\r\n */\n\nexport function getInstanceFromNode(node) {\n  const inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\n\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n/**\r\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\r\n * DOM node.\r\n */\n\nexport function getNodeFromInstance(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  } // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n\n\n  throw new Error('getNodeFromInstance: Invalid argument.');\n}\nexport function getFiberCurrentPropsFromNode(node) {\n  return node[internalPropsKey] || null;\n}\nexport function updateFiberProps(node, props) {\n  node[internalPropsKey] = props;\n}\nexport function getEventListenerSet(node) {\n  let elementListenerSet = node[internalEventHandlersKey];\n\n  if (elementListenerSet === undefined) {\n    elementListenerSet = node[internalEventHandlersKey] = new Set();\n  }\n\n  return elementListenerSet;\n}\nexport function getFiberFromScopeInstance(scope) {\n  if (enableScopeAPI) {\n    return scope[internalInstanceKey] || null;\n  }\n\n  return null;\n}\nexport function setEventHandlerListeners(scope, listeners) {\n  scope[internalEventHandlerListenersKey] = listeners;\n}\nexport function getEventHandlerListeners(scope) {\n  return scope[internalEventHandlerListenersKey] || null;\n}\nexport function addEventHandleToTarget(target, eventHandle) {\n  let eventHandles = target[internalEventHandlesSetKey];\n\n  if (eventHandles === undefined) {\n    eventHandles = target[internalEventHandlesSetKey] = new Set();\n  }\n\n  eventHandles.add(eventHandle);\n}\nexport function doesTargetHaveEventHandle(target, eventHandle) {\n  const eventHandles = target[internalEventHandlesSetKey];\n\n  if (eventHandles === undefined) {\n    return false;\n  }\n\n  return eventHandles.has(eventHandle);\n}","map":{"version":3,"names":["HostComponent","HostText","HostRoot","SuspenseComponent","getParentSuspenseInstance","enableScopeAPI","randomKey","Math","random","toString","slice","internalInstanceKey","internalPropsKey","internalContainerInstanceKey","internalEventHandlersKey","internalEventHandlerListenersKey","internalEventHandlesSetKey","detachDeletedInstance","node","precacheFiberNode","hostInst","markContainerAsRoot","hostRoot","unmarkContainerAsRoot","isContainerMarkedAsRoot","getClosestInstanceFromNode","targetNode","targetInst","parentNode","alternate","child","suspenseInstance","targetSuspenseInst","getInstanceFromNode","inst","tag","getNodeFromInstance","stateNode","Error","getFiberCurrentPropsFromNode","updateFiberProps","props","getEventListenerSet","elementListenerSet","undefined","Set","getFiberFromScopeInstance","scope","setEventHandlerListeners","listeners","getEventHandlerListeners","addEventHandleToTarget","target","eventHandle","eventHandles","add","doesTargetHaveEventHandle","has"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-dom/src/client/ReactDOMComponentTree.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\r\nimport type {ReactScopeInstance} from 'shared/ReactTypes';\r\nimport type {\r\n  ReactDOMEventHandle,\r\n  ReactDOMEventHandleListener,\r\n} from '../shared/ReactDOMTypes';\r\nimport type {\r\n  Container,\r\n  TextInstance,\r\n  Instance,\r\n  SuspenseInstance,\r\n  Props,\r\n} from './ReactDOMHostConfig';\r\n\r\nimport {\r\n  HostComponent,\r\n  HostText,\r\n  HostRoot,\r\n  SuspenseComponent,\r\n} from 'react-reconciler/src/ReactWorkTags';\r\n\r\nimport {getParentSuspenseInstance} from './ReactDOMHostConfig';\r\n\r\nimport {enableScopeAPI} from 'shared/ReactFeatureFlags';\r\n\r\nconst randomKey = Math.random()\r\n  .toString(36)\r\n  .slice(2);\r\nconst internalInstanceKey = '__reactFiber$' + randomKey;\r\nconst internalPropsKey = '__reactProps$' + randomKey;\r\nconst internalContainerInstanceKey = '__reactContainer$' + randomKey;\r\nconst internalEventHandlersKey = '__reactEvents$' + randomKey;\r\nconst internalEventHandlerListenersKey = '__reactListeners$' + randomKey;\r\nconst internalEventHandlesSetKey = '__reactHandles$' + randomKey;\r\n\r\nexport function detachDeletedInstance(node: Instance): void {\r\n  // TODO: This function is only called on host components. I don't think all of\r\n  // these fields are relevant.\r\n  delete (node: any)[internalInstanceKey];\r\n  delete (node: any)[internalPropsKey];\r\n  delete (node: any)[internalEventHandlersKey];\r\n  delete (node: any)[internalEventHandlerListenersKey];\r\n  delete (node: any)[internalEventHandlesSetKey];\r\n}\r\n\r\nexport function precacheFiberNode(\r\n  hostInst: Fiber,\r\n  node: Instance | TextInstance | SuspenseInstance | ReactScopeInstance,\r\n): void {\r\n  (node: any)[internalInstanceKey] = hostInst;\r\n}\r\n\r\nexport function markContainerAsRoot(hostRoot: Fiber, node: Container): void {\r\n  node[internalContainerInstanceKey] = hostRoot;\r\n}\r\n\r\nexport function unmarkContainerAsRoot(node: Container): void {\r\n  node[internalContainerInstanceKey] = null;\r\n}\r\n\r\nexport function isContainerMarkedAsRoot(node: Container): boolean {\r\n  return !!node[internalContainerInstanceKey];\r\n}\r\n\r\n// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\r\n// If the target node is part of a hydrated or not yet rendered subtree, then\r\n// this may also return a SuspenseComponent or HostRoot to indicate that.\r\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\r\n// pass the Container node as the targetNode, you will not actually get the\r\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\r\n// The same thing applies to Suspense boundaries.\r\n\r\n// 判断是否是fiber节点  主要是\r\nexport function getClosestInstanceFromNode(targetNode: Node): null | Fiber {\r\n  let targetInst = (targetNode: any)[internalInstanceKey];\r\n  // 如果触发事件的节点有react fiber标记则直接返回\r\n  if (targetInst) {\r\n    // Don't return HostRoot or SuspenseComponent here.\r\n    return targetInst;\r\n  }\r\n  // If the direct event target isn't a React owned DOM node, we need to look\r\n  // to see if one of its parents is a React owned DOM node.\r\n  let parentNode = targetNode.parentNode;\r\n  while (parentNode) {\r\n    // We'll check if this is a container root that could include\r\n    // React nodes in the future. We need to check this first because\r\n    // if we're a child of a dehydrated container, we need to first\r\n    // find that inner container before moving on to finding the parent\r\n    // instance. Note that we don't check this field on  the targetNode\r\n    // itself because the fibers are conceptually between the container\r\n    // node and the first child. It isn't surrounding the container node.\r\n    // If it's not a container, we check if it's an instance.\r\n    targetInst =\r\n      (parentNode: any)[internalContainerInstanceKey] ||\r\n      (parentNode: any)[internalInstanceKey];\r\n    if (targetInst) {\r\n      // Since this wasn't the direct target of the event, we might have\r\n      // stepped past dehydrated DOM nodes to get here. However they could\r\n      // also have been non-React nodes. We need to answer which one.\r\n\r\n      // If we the instance doesn't have any children, then there can't be\r\n      // a nested suspense boundary within it. So we can use this as a fast\r\n      // bailout. Most of the time, when people add non-React children to\r\n      // the tree, it is using a ref to a child-less DOM node.\r\n      // Normally we'd only need to check one of the fibers because if it\r\n      // has ever gone from having children to deleting them or vice versa\r\n      // it would have deleted the dehydrated boundary nested inside already.\r\n      // However, since the HostRoot starts out with an alternate it might\r\n      // have one on the alternate so we need to check in case this was a\r\n      // root.\r\n      const alternate = targetInst.alternate;\r\n      if (\r\n        targetInst.child !== null ||\r\n        (alternate !== null && alternate.child !== null)\r\n      ) {\r\n        // Next we need to figure out if the node that skipped past is\r\n        // nested within a dehydrated boundary and if so, which one.\r\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\r\n        while (suspenseInstance !== null) {\r\n          // We found a suspense instance. That means that we haven't\r\n          // hydrated it yet. Even though we leave the comments in the\r\n          // DOM after hydrating, and there are boundaries in the DOM\r\n          // that could already be hydrated, we wouldn't have found them\r\n          // through this pass since if the target is hydrated it would\r\n          // have had an internalInstanceKey on it.\r\n          // Let's get the fiber associated with the SuspenseComponent\r\n          // as the deepest instance.\r\n          const targetSuspenseInst = suspenseInstance[internalInstanceKey];\r\n          if (targetSuspenseInst) {\r\n            return targetSuspenseInst;\r\n          }\r\n          // If we don't find a Fiber on the comment, it might be because\r\n          // we haven't gotten to hydrate it yet. There might still be a\r\n          // parent boundary that hasn't above this one so we need to find\r\n          // the outer most that is known.\r\n          suspenseInstance = getParentSuspenseInstance(suspenseInstance);\r\n          // If we don't find one, then that should mean that the parent\r\n          // host component also hasn't hydrated yet. We can return it\r\n          // below since it will bail out on the isMounted check later.\r\n        }\r\n      }\r\n      return targetInst;\r\n    }\r\n    targetNode = parentNode;\r\n    parentNode = targetNode.parentNode;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\r\n * instance, or null if the node was not rendered by this React.\r\n */\r\nexport function getInstanceFromNode(node: Node): Fiber | null {\r\n  const inst =\r\n    (node: any)[internalInstanceKey] ||\r\n    (node: any)[internalContainerInstanceKey];\r\n  if (inst) {\r\n    if (\r\n      inst.tag === HostComponent ||\r\n      inst.tag === HostText ||\r\n      inst.tag === SuspenseComponent ||\r\n      inst.tag === HostRoot\r\n    ) {\r\n      return inst;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\r\n * DOM node.\r\n */\r\nexport function getNodeFromInstance(inst: Fiber): Instance | TextInstance {\r\n  if (inst.tag === HostComponent || inst.tag === HostText) {\r\n    // In Fiber this, is just the state node right now. We assume it will be\r\n    // a host component or host text.\r\n    return inst.stateNode;\r\n  }\r\n\r\n  // Without this first invariant, passing a non-DOM-component triggers the next\r\n  // invariant for a missing parent, which is super confusing.\r\n  throw new Error('getNodeFromInstance: Invalid argument.');\r\n}\r\n\r\nexport function getFiberCurrentPropsFromNode(\r\n  node: Instance | TextInstance | SuspenseInstance,\r\n): Props {\r\n  return (node: any)[internalPropsKey] || null;\r\n}\r\n\r\nexport function updateFiberProps(\r\n  node: Instance | TextInstance | SuspenseInstance,\r\n  props: Props,\r\n): void {\r\n  (node: any)[internalPropsKey] = props;\r\n}\r\n\r\nexport function getEventListenerSet(node: EventTarget): Set<string> {\r\n  let elementListenerSet = (node: any)[internalEventHandlersKey];\r\n  if (elementListenerSet === undefined) {\r\n    elementListenerSet = (node: any)[internalEventHandlersKey] = new Set();\r\n  }\r\n  return elementListenerSet;\r\n}\r\n\r\nexport function getFiberFromScopeInstance(\r\n  scope: ReactScopeInstance,\r\n): null | Fiber {\r\n  if (enableScopeAPI) {\r\n    return (scope: any)[internalInstanceKey] || null;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function setEventHandlerListeners(\r\n  scope: EventTarget | ReactScopeInstance,\r\n  listeners: Set<ReactDOMEventHandleListener>,\r\n): void {\r\n  (scope: any)[internalEventHandlerListenersKey] = listeners;\r\n}\r\n\r\nexport function getEventHandlerListeners(\r\n  scope: EventTarget | ReactScopeInstance,\r\n): null | Set<ReactDOMEventHandleListener> {\r\n  return (scope: any)[internalEventHandlerListenersKey] || null;\r\n}\r\n\r\nexport function addEventHandleToTarget(\r\n  target: EventTarget | ReactScopeInstance,\r\n  eventHandle: ReactDOMEventHandle,\r\n): void {\r\n  let eventHandles = (target: any)[internalEventHandlesSetKey];\r\n  if (eventHandles === undefined) {\r\n    eventHandles = (target: any)[internalEventHandlesSetKey] = new Set();\r\n  }\r\n  eventHandles.add(eventHandle);\r\n}\r\n\r\nexport function doesTargetHaveEventHandle(\r\n  target: EventTarget | ReactScopeInstance,\r\n  eventHandle: ReactDOMEventHandle,\r\n): boolean {\r\n  const eventHandles = (target: any)[internalEventHandlesSetKey];\r\n  if (eventHandles === undefined) {\r\n    return false;\r\n  }\r\n  return eventHandles.has(eventHandle);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}