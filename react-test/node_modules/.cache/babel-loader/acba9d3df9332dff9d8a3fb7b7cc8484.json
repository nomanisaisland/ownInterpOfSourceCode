{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport isArray from 'shared/isArray';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE } from 'shared/ReactSymbols';\nimport { checkKeyStringCoercion } from 'shared/CheckStringCoercion';\nimport { isValidElement, cloneAndReplaceKey } from './ReactElement';\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n/**\r\n * Escape and wrap key so it is safe to use as a reactid\r\n *\r\n * @param {string} key to be escaped.\r\n * @return {string} the escaped key.\r\n */\n\nfunction escape(key) {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  const escapedString = key.replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\r\n * TODO: Test that a single child and an array with one item have the same key\r\n * pattern.\r\n */\n\n\nlet didWarnAboutMaps = false;\nconst userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n/**\r\n * Generate a key string that identifies a element within a set.\r\n *\r\n * @param {*} element A element that could contain a manual key.\r\n * @param {number} index Index that is used if a manual key is not provided.\r\n * @return {string}\r\n */\n\n\nfunction getElementKey(element, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    if (__DEV__) {\n      checkKeyStringCoercion(element.key);\n    }\n\n    return escape('' + element.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    const child = children;\n    let mappedChild = callback(child); // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n\n    const childKey = nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n\n    if (isArray(mappedChild)) {\n      let escapedChildKey = '';\n\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        if (__DEV__) {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key && (!child || child.key !== mappedChild.key)) {\n            checkKeyStringCoercion(mappedChild.key);\n          }\n        }\n\n        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n        mappedChild.key && (!child || child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n      }\n\n      array.push(mappedChild);\n    }\n\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n\n  const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      const iterableChildren = children;\n\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            console.warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(iterableChildren);\n      let step;\n      let ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n      }\n    } else if (type === 'object') {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      const childrenString = String(children);\n      throw new Error(`Objects are not valid as a React child (found: ${childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString}). ` + 'If you meant to render a collection of children, use an array ' + 'instead.');\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\r\n * Maps children that are typically specified as `props.children`.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\r\n *\r\n * The provided mapFunction(child, index) will be called for each\r\n * leaf child.\r\n *\r\n * @param {?*} children Children tree container.\r\n * @param {function(*, int)} func The map function.\r\n * @param {*} context Context for mapFunction.\r\n * @return {object} Object containing the ordered map of results.\r\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  const result = [];\n  let count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n/**\r\n * Count the number of children that are typically specified as\r\n * `props.children`.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\r\n *\r\n * @param {?*} children Children tree container.\r\n * @return {number} The number of children.\r\n */\n\n\nfunction countChildren(children) {\n  let n = 0;\n  mapChildren(children, () => {\n    n++; // Don't return anything\n  });\n  return n;\n}\n\n/**\r\n * Iterates through children that are typically specified as `props.children`.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\r\n *\r\n * The provided forEachFunc(child, index) will be called for each\r\n * leaf child.\r\n *\r\n * @param {?*} children Children tree container.\r\n * @param {function(*, int)} forEachFunc\r\n * @param {*} forEachContext Context for forEachContext.\r\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  mapChildren(children, function () {\n    forEachFunc.apply(this, arguments); // Don't return anything.\n  }, forEachContext);\n}\n/**\r\n * Flatten a children object (typically specified as `props.children`) and\r\n * return an array with appropriately re-keyed children.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\r\n */\n\n\nfunction toArray(children) {\n  return mapChildren(children, child => child) || [];\n}\n/**\r\n * Returns the first child in a collection of children and verifies that there\r\n * is only one child in the collection.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\r\n *\r\n * The current implementation of this function assumes that a single child gets\r\n * passed without a wrapper, but the purpose of this helper function is to\r\n * abstract away the particular structure of children.\r\n *\r\n * @param {?object} children Child collection structure.\r\n * @return {ReactElement} The first and only `ReactElement` contained in the\r\n * structure.\r\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    throw new Error('React.Children.only expected to receive a single React element child.');\n  }\n\n  return children;\n}\n\nexport { forEachChildren as forEach, mapChildren as map, countChildren as count, onlyChild as only, toArray };","map":{"version":3,"names":["isArray","getIteratorFn","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","checkKeyStringCoercion","isValidElement","cloneAndReplaceKey","SEPARATOR","SUBSEPARATOR","escape","key","escapeRegex","escaperLookup","escapedString","replace","match","didWarnAboutMaps","userProvidedKeyEscapeRegex","escapeUserProvidedKey","text","getElementKey","element","index","__DEV__","toString","mapIntoArray","children","array","escapedPrefix","nameSoFar","callback","type","invokeCallback","$$typeof","child","mappedChild","childKey","escapedChildKey","c","push","nextName","subtreeCount","nextNamePrefix","i","length","iteratorFn","iterableChildren","entries","console","warn","iterator","call","step","ii","next","done","value","childrenString","String","Error","Object","keys","join","mapChildren","func","context","result","count","countChildren","n","forEachChildren","forEachFunc","forEachContext","apply","arguments","toArray","onlyChild","forEach","map","only"],"sources":["E:/react-test/src/react/packages/react/src/ReactChildren.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {ReactNodeList} from 'shared/ReactTypes';\r\n\r\nimport isArray from 'shared/isArray';\r\nimport {\r\n  getIteratorFn,\r\n  REACT_ELEMENT_TYPE,\r\n  REACT_PORTAL_TYPE,\r\n} from 'shared/ReactSymbols';\r\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\r\n\r\nimport {isValidElement, cloneAndReplaceKey} from './ReactElement';\r\n\r\nconst SEPARATOR = '.';\r\nconst SUBSEPARATOR = ':';\r\n\r\n/**\r\n * Escape and wrap key so it is safe to use as a reactid\r\n *\r\n * @param {string} key to be escaped.\r\n * @return {string} the escaped key.\r\n */\r\nfunction escape(key: string): string {\r\n  const escapeRegex = /[=:]/g;\r\n  const escaperLookup = {\r\n    '=': '=0',\r\n    ':': '=2',\r\n  };\r\n  const escapedString = key.replace(escapeRegex, function(match) {\r\n    return escaperLookup[match];\r\n  });\r\n\r\n  return '$' + escapedString;\r\n}\r\n\r\n/**\r\n * TODO: Test that a single child and an array with one item have the same key\r\n * pattern.\r\n */\r\n\r\nlet didWarnAboutMaps = false;\r\n\r\nconst userProvidedKeyEscapeRegex = /\\/+/g;\r\nfunction escapeUserProvidedKey(text: string): string {\r\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\r\n}\r\n\r\n/**\r\n * Generate a key string that identifies a element within a set.\r\n *\r\n * @param {*} element A element that could contain a manual key.\r\n * @param {number} index Index that is used if a manual key is not provided.\r\n * @return {string}\r\n */\r\nfunction getElementKey(element: any, index: number): string {\r\n  // Do some typechecking here since we call this blindly. We want to ensure\r\n  // that we don't block potential future ES APIs.\r\n  if (typeof element === 'object' && element !== null && element.key != null) {\r\n    // Explicit key\r\n    if (__DEV__) {\r\n      checkKeyStringCoercion(element.key);\r\n    }\r\n    return escape('' + element.key);\r\n  }\r\n  // Implicit key determined by the index in the set\r\n  return index.toString(36);\r\n}\r\n\r\nfunction mapIntoArray(\r\n  children: ?ReactNodeList,\r\n  array: Array<React$Node>,\r\n  escapedPrefix: string,\r\n  nameSoFar: string,\r\n  callback: (?React$Node) => ?ReactNodeList,\r\n): number {\r\n  const type = typeof children;\r\n\r\n  if (type === 'undefined' || type === 'boolean') {\r\n    // All of the above are perceived as null.\r\n    children = null;\r\n  }\r\n\r\n  let invokeCallback = false;\r\n\r\n  if (children === null) {\r\n    invokeCallback = true;\r\n  } else {\r\n    switch (type) {\r\n      case 'string':\r\n      case 'number':\r\n        invokeCallback = true;\r\n        break;\r\n      case 'object':\r\n        switch ((children: any).$$typeof) {\r\n          case REACT_ELEMENT_TYPE:\r\n          case REACT_PORTAL_TYPE:\r\n            invokeCallback = true;\r\n        }\r\n    }\r\n  }\r\n\r\n  if (invokeCallback) {\r\n    const child = children;\r\n    let mappedChild = callback(child);\r\n    // If it's the only child, treat the name as if it was wrapped in an array\r\n    // so that it's consistent if the number of children grows:\r\n    const childKey =\r\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\r\n    if (isArray(mappedChild)) {\r\n      let escapedChildKey = '';\r\n      if (childKey != null) {\r\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\r\n      }\r\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\r\n    } else if (mappedChild != null) {\r\n      if (isValidElement(mappedChild)) {\r\n        if (__DEV__) {\r\n          // The `if` statement here prevents auto-disabling of the safe\r\n          // coercion ESLint rule, so we must manually disable it below.\r\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\r\n          if (mappedChild.key && (!child || child.key !== mappedChild.key)) {\r\n            checkKeyStringCoercion(mappedChild.key);\r\n          }\r\n        }\r\n        mappedChild = cloneAndReplaceKey(\r\n          mappedChild,\r\n          // Keep both the (mapped) and old keys if they differ, just as\r\n          // traverseAllChildren used to do for objects as children\r\n          escapedPrefix +\r\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\r\n            (mappedChild.key && (!child || child.key !== mappedChild.key)\r\n              ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\r\n                // eslint-disable-next-line react-internal/safe-string-coercion\r\n                escapeUserProvidedKey('' + mappedChild.key) + '/'\r\n              : '') +\r\n            childKey,\r\n        );\r\n      }\r\n      array.push(mappedChild);\r\n    }\r\n    return 1;\r\n  }\r\n\r\n  let child;\r\n  let nextName;\r\n  let subtreeCount = 0; // Count of children found in the current subtree.\r\n  const nextNamePrefix =\r\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\r\n\r\n  if (isArray(children)) {\r\n    for (let i = 0; i < children.length; i++) {\r\n      child = children[i];\r\n      nextName = nextNamePrefix + getElementKey(child, i);\r\n      subtreeCount += mapIntoArray(\r\n        child,\r\n        array,\r\n        escapedPrefix,\r\n        nextName,\r\n        callback,\r\n      );\r\n    }\r\n  } else {\r\n    const iteratorFn = getIteratorFn(children);\r\n    if (typeof iteratorFn === 'function') {\r\n      const iterableChildren: Iterable<React$Node> & {\r\n        entries: any,\r\n      } = (children: any);\r\n\r\n      if (__DEV__) {\r\n        // Warn about using Maps as children\r\n        if (iteratorFn === iterableChildren.entries) {\r\n          if (!didWarnAboutMaps) {\r\n            console.warn(\r\n              'Using Maps as children is not supported. ' +\r\n                'Use an array of keyed ReactElements instead.',\r\n            );\r\n          }\r\n          didWarnAboutMaps = true;\r\n        }\r\n      }\r\n\r\n      const iterator = iteratorFn.call(iterableChildren);\r\n      let step;\r\n      let ii = 0;\r\n      while (!(step = iterator.next()).done) {\r\n        child = step.value;\r\n        nextName = nextNamePrefix + getElementKey(child, ii++);\r\n        subtreeCount += mapIntoArray(\r\n          child,\r\n          array,\r\n          escapedPrefix,\r\n          nextName,\r\n          callback,\r\n        );\r\n      }\r\n    } else if (type === 'object') {\r\n      // eslint-disable-next-line react-internal/safe-string-coercion\r\n      const childrenString = String((children: any));\r\n\r\n      throw new Error(\r\n        `Objects are not valid as a React child (found: ${\r\n          childrenString === '[object Object]'\r\n            ? 'object with keys {' +\r\n              Object.keys((children: any)).join(', ') +\r\n              '}'\r\n            : childrenString\r\n        }). ` +\r\n          'If you meant to render a collection of children, use an array ' +\r\n          'instead.',\r\n      );\r\n    }\r\n  }\r\n\r\n  return subtreeCount;\r\n}\r\n\r\ntype MapFunc = (child: ?React$Node) => ?ReactNodeList;\r\n\r\n/**\r\n * Maps children that are typically specified as `props.children`.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\r\n *\r\n * The provided mapFunction(child, index) will be called for each\r\n * leaf child.\r\n *\r\n * @param {?*} children Children tree container.\r\n * @param {function(*, int)} func The map function.\r\n * @param {*} context Context for mapFunction.\r\n * @return {object} Object containing the ordered map of results.\r\n */\r\nfunction mapChildren(\r\n  children: ?ReactNodeList,\r\n  func: MapFunc,\r\n  context: mixed,\r\n): ?Array<React$Node> {\r\n  if (children == null) {\r\n    return children;\r\n  }\r\n  const result = [];\r\n  let count = 0;\r\n  mapIntoArray(children, result, '', '', function(child) {\r\n    return func.call(context, child, count++);\r\n  });\r\n  return result;\r\n}\r\n\r\n/**\r\n * Count the number of children that are typically specified as\r\n * `props.children`.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\r\n *\r\n * @param {?*} children Children tree container.\r\n * @return {number} The number of children.\r\n */\r\nfunction countChildren(children: ?ReactNodeList): number {\r\n  let n = 0;\r\n  mapChildren(children, () => {\r\n    n++;\r\n    // Don't return anything\r\n  });\r\n  return n;\r\n}\r\n\r\ntype ForEachFunc = (child: ?React$Node) => void;\r\n\r\n/**\r\n * Iterates through children that are typically specified as `props.children`.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\r\n *\r\n * The provided forEachFunc(child, index) will be called for each\r\n * leaf child.\r\n *\r\n * @param {?*} children Children tree container.\r\n * @param {function(*, int)} forEachFunc\r\n * @param {*} forEachContext Context for forEachContext.\r\n */\r\nfunction forEachChildren(\r\n  children: ?ReactNodeList,\r\n  forEachFunc: ForEachFunc,\r\n  forEachContext: mixed,\r\n): void {\r\n  mapChildren(\r\n    children,\r\n    function() {\r\n      forEachFunc.apply(this, arguments);\r\n      // Don't return anything.\r\n    },\r\n    forEachContext,\r\n  );\r\n}\r\n\r\n/**\r\n * Flatten a children object (typically specified as `props.children`) and\r\n * return an array with appropriately re-keyed children.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\r\n */\r\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\r\n  return mapChildren(children, child => child) || [];\r\n}\r\n\r\n/**\r\n * Returns the first child in a collection of children and verifies that there\r\n * is only one child in the collection.\r\n *\r\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\r\n *\r\n * The current implementation of this function assumes that a single child gets\r\n * passed without a wrapper, but the purpose of this helper function is to\r\n * abstract away the particular structure of children.\r\n *\r\n * @param {?object} children Child collection structure.\r\n * @return {ReactElement} The first and only `ReactElement` contained in the\r\n * structure.\r\n */\r\nfunction onlyChild<T>(children: T): T {\r\n  if (!isValidElement(children)) {\r\n    throw new Error(\r\n      'React.Children.only expected to receive a single React element child.',\r\n    );\r\n  }\r\n\r\n  return children;\r\n}\r\n\r\nexport {\r\n  forEachChildren as forEach,\r\n  mapChildren as map,\r\n  countChildren as count,\r\n  onlyChild as only,\r\n  toArray,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}