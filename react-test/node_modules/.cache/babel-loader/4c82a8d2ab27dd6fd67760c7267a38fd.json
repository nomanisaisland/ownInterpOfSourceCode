{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { DiscreteEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority } from './ReactEventPriorities.old';\nimport { ImmediatePriority, scheduleCallback } from './Scheduler';\nlet syncQueue = null;\nlet includesLegacySyncCallbacks = false;\nlet isFlushingSyncQueue = false;\nexport function scheduleSyncCallback(callback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\nexport function scheduleLegacySyncCallback(callback) {\n  includesLegacySyncCallbacks = true;\n  scheduleSyncCallback(callback);\n}\nexport function flushSyncCallbacksOnlyInLegacyMode() {\n  // Only flushes the queue if there's a legacy sync callback scheduled.\n  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n  // it might make more sense for the queue to be a list of roots instead of a\n  // list of generic callbacks. Then we can have two: one for legacy roots, one\n  // for concurrent roots. And this method would only flush the legacy ones.\n  if (includesLegacySyncCallbacks) {\n    flushSyncCallbacks();\n  }\n}\nexport function flushSyncCallbacks() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n\n    try {\n      const isSync = true;\n      const queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n\n      setCurrentUpdatePriority(DiscreteEventPriority);\n\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      } // Resume flushing in the next tick\n\n\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n\n  return null;\n}","map":{"version":3,"names":["DiscreteEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","ImmediatePriority","scheduleCallback","syncQueue","includesLegacySyncCallbacks","isFlushingSyncQueue","scheduleSyncCallback","callback","push","scheduleLegacySyncCallback","flushSyncCallbacksOnlyInLegacyMode","flushSyncCallbacks","i","previousUpdatePriority","isSync","queue","length","error","slice"],"sources":["E:/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {SchedulerCallback} from './Scheduler';\r\n\r\nimport {\r\n  DiscreteEventPriority,\r\n  getCurrentUpdatePriority,\r\n  setCurrentUpdatePriority,\r\n} from './ReactEventPriorities.old';\r\nimport {ImmediatePriority, scheduleCallback} from './Scheduler';\r\n\r\nlet syncQueue: Array<SchedulerCallback> | null = null;\r\nlet includesLegacySyncCallbacks: boolean = false;\r\nlet isFlushingSyncQueue: boolean = false;\r\n\r\nexport function scheduleSyncCallback(callback: SchedulerCallback) {\r\n  // Push this callback into an internal queue. We'll flush these either in\r\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\r\n  if (syncQueue === null) {\r\n    syncQueue = [callback];\r\n  } else {\r\n    // Push onto existing queue. Don't need to schedule a callback because\r\n    // we already scheduled one when we created the queue.\r\n    syncQueue.push(callback);\r\n  }\r\n}\r\n\r\nexport function scheduleLegacySyncCallback(callback: SchedulerCallback) {\r\n  includesLegacySyncCallbacks = true;\r\n  scheduleSyncCallback(callback);\r\n}\r\n\r\nexport function flushSyncCallbacksOnlyInLegacyMode() {\r\n  // Only flushes the queue if there's a legacy sync callback scheduled.\r\n  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\r\n  // it might make more sense for the queue to be a list of roots instead of a\r\n  // list of generic callbacks. Then we can have two: one for legacy roots, one\r\n  // for concurrent roots. And this method would only flush the legacy ones.\r\n  if (includesLegacySyncCallbacks) {\r\n    flushSyncCallbacks();\r\n  }\r\n}\r\n\r\nexport function flushSyncCallbacks() {\r\n  if (!isFlushingSyncQueue && syncQueue !== null) {\r\n    // Prevent re-entrance.\r\n    isFlushingSyncQueue = true;\r\n    let i = 0;\r\n    const previousUpdatePriority = getCurrentUpdatePriority();\r\n    try {\r\n      const isSync = true;\r\n      const queue = syncQueue;\r\n      // TODO: Is this necessary anymore? The only user code that runs in this\r\n      // queue is in the render or commit phases.\r\n      setCurrentUpdatePriority(DiscreteEventPriority);\r\n      for (; i < queue.length; i++) {\r\n        let callback = queue[i];\r\n        do {\r\n          callback = callback(isSync);\r\n        } while (callback !== null);\r\n      }\r\n      syncQueue = null;\r\n      includesLegacySyncCallbacks = false;\r\n    } catch (error) {\r\n      // If something throws, leave the remaining callbacks on the queue.\r\n      if (syncQueue !== null) {\r\n        syncQueue = syncQueue.slice(i + 1);\r\n      }\r\n      // Resume flushing in the next tick\r\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\r\n      throw error;\r\n    } finally {\r\n      setCurrentUpdatePriority(previousUpdatePriority);\r\n      isFlushingSyncQueue = false;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SACEA,qBADF,EAEEC,wBAFF,EAGEC,wBAHF,QAIO,4BAJP;AAKA,SAAQC,iBAAR,EAA2BC,gBAA3B,QAAkD,aAAlD;AAEA,IAAIC,SAA0C,GAAG,IAAjD;AACA,IAAIC,2BAAoC,GAAG,KAA3C;AACA,IAAIC,mBAA4B,GAAG,KAAnC;AAEA,OAAO,SAASC,oBAAT,CAA8BC,QAA9B,EAA2D;EAChE;EACA;EACA,IAAIJ,SAAS,KAAK,IAAlB,EAAwB;IACtBA,SAAS,GAAG,CAACI,QAAD,CAAZ;EACD,CAFD,MAEO;IACL;IACA;IACAJ,SAAS,CAACK,IAAV,CAAeD,QAAf;EACD;AACF;AAED,OAAO,SAASE,0BAAT,CAAoCF,QAApC,EAAiE;EACtEH,2BAA2B,GAAG,IAA9B;EACAE,oBAAoB,CAACC,QAAD,CAApB;AACD;AAED,OAAO,SAASG,kCAAT,GAA8C;EACnD;EACA;EACA;EACA;EACA;EACA,IAAIN,2BAAJ,EAAiC;IAC/BO,kBAAkB;EACnB;AACF;AAED,OAAO,SAASA,kBAAT,GAA8B;EACnC,IAAI,CAACN,mBAAD,IAAwBF,SAAS,KAAK,IAA1C,EAAgD;IAC9C;IACAE,mBAAmB,GAAG,IAAtB;IACA,IAAIO,CAAC,GAAG,CAAR;IACA,MAAMC,sBAAsB,GAAGd,wBAAwB,EAAvD;;IACA,IAAI;MACF,MAAMe,MAAM,GAAG,IAAf;MACA,MAAMC,KAAK,GAAGZ,SAAd,CAFE,CAGF;MACA;;MACAH,wBAAwB,CAACF,qBAAD,CAAxB;;MACA,OAAOc,CAAC,GAAGG,KAAK,CAACC,MAAjB,EAAyBJ,CAAC,EAA1B,EAA8B;QAC5B,IAAIL,QAAQ,GAAGQ,KAAK,CAACH,CAAD,CAApB;;QACA,GAAG;UACDL,QAAQ,GAAGA,QAAQ,CAACO,MAAD,CAAnB;QACD,CAFD,QAESP,QAAQ,KAAK,IAFtB;MAGD;;MACDJ,SAAS,GAAG,IAAZ;MACAC,2BAA2B,GAAG,KAA9B;IACD,CAdD,CAcE,OAAOa,KAAP,EAAc;MACd;MACA,IAAId,SAAS,KAAK,IAAlB,EAAwB;QACtBA,SAAS,GAAGA,SAAS,CAACe,KAAV,CAAgBN,CAAC,GAAG,CAApB,CAAZ;MACD,CAJa,CAKd;;;MACAV,gBAAgB,CAACD,iBAAD,EAAoBU,kBAApB,CAAhB;MACA,MAAMM,KAAN;IACD,CAtBD,SAsBU;MACRjB,wBAAwB,CAACa,sBAAD,CAAxB;MACAR,mBAAmB,GAAG,KAAtB;IACD;EACF;;EACD,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}