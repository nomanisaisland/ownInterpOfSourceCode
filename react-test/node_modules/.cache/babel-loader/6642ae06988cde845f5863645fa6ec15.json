{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\n// Ids are base 32 strings whose binary representation corresponds to the\n// position of a node in a tree.\n// Every time the tree forks into multiple children, we add additional bits to\n// the left of the sequence that represent the position of the child within the\n// current level of children.\n//\n//      00101       00010001011010101\n//      ╰─┬─╯       ╰───────┬───────╯\n//   Fork 5 of 20       Parent id\n//\n// The leading 0s are important. In the above example, you only need 3 bits to\n// represent slot 5. However, you need 5 bits to represent all the forks at\n// the current level, so we must account for the empty bits at the end.\n//\n// For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n// the zeroth id at a level would be indistinguishable from its parent.\n//\n// If a node has only one child, and does not materialize an id (i.e. does not\n// contain a useId hook), then we don't need to allocate any space in the\n// sequence. It's treated as a transparent indirection. For example, these two\n// trees produce the same ids:\n//\n// <>                          <>\n//   <Indirection>               <A />\n//     <A />                     <B />\n//   </Indirection>            </>\n//   <B />\n// </>\n//\n// However, we cannot skip any node that materializes an id. Otherwise, a parent\n// id that does not fork would be indistinguishable from its child id. For\n// example, this tree does not fork, but the parent and child must have\n// different ids.\n//\n// <Parent>\n//   <Child />\n// </Parent>\n//\n// To handle this scenario, every time we materialize an id, we allocate a\n// new level with a single slot. You can think of this as a fork with only one\n// prong, or an array of children with length 1.\n//\n// It's possible for the size of the sequence to exceed 32 bits, the max\n// size for bitwise operations. When this happens, we make more room by\n// converting the right part of the id to a string and storing it in an overflow\n// variable. We use a base 32 string representation, because 32 is the largest\n// power of 2 that is supported by toString(). We want the base to be large so\n// that the resulting ids are compact, and we want the base to be a power of 2\n// because every log2(base) bits corresponds to a single character, i.e. every\n// log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n// affecting the final result.\nimport { getIsHydrating } from './ReactFiberHydrationContext.new';\nimport { clz32 } from './clz32';\nimport { Forked, NoFlags } from './ReactFiberFlags';\n// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nconst forkStack = [];\nlet forkStackIndex = 0;\nlet treeForkProvider = null;\nlet treeForkCount = 0;\nconst idStack = [];\nlet idStackIndex = 0;\nlet treeContextProvider = null;\nlet treeContextId = 1;\nlet treeContextOverflow = '';\nexport function isForkedChild(workInProgress) {\n  warnIfNotHydrating();\n  return (workInProgress.flags & Forked) !== NoFlags;\n}\nexport function getForksAtLevel(workInProgress) {\n  warnIfNotHydrating();\n  return treeForkCount;\n}\nexport function getTreeId() {\n  const overflow = treeContextOverflow;\n  const idWithLeadingBit = treeContextId;\n  const id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n  return id.toString(32) + overflow;\n}\nexport function pushTreeFork(workInProgress, totalChildren) {\n  // This is called right after we reconcile an array (or iterator) of child\n  // fibers, because that's the only place where we know how many children in\n  // the whole set without doing extra work later, or storing addtional\n  // information on the fiber.\n  //\n  // That's why this function is separate from pushTreeId — it's called during\n  // the render phase of the fork parent, not the child, which is where we push\n  // the other context values.\n  //\n  // In the Fizz implementation this is much simpler because the child is\n  // rendered in the same callstack as the parent.\n  //\n  // It might be better to just add a `forks` field to the Fiber type. It would\n  // make this module simpler.\n  warnIfNotHydrating();\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nexport function pushTreeId(workInProgress, totalChildren, index) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  const baseIdWithLeadingBit = treeContextId;\n  const baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n  // of the id; we use it to account for leading 0s.\n\n  const baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n  const baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n  const slot = index + 1;\n  const length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n  // consideration the leading 1 we use to mark the end of the sequence.\n\n  if (length > 30) {\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n    // This branch assumes the length of the base id is greater than 5; it won't\n    // work for smaller ids, because you need 5 bits per character.\n    //\n    // We encode the id in multiple steps: first the base id, then the\n    // remaining digits.\n    //\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\n    // example, if the current id is 23 bits long, we can convert 20 of those\n    // bits into a string of 4 characters, with 3 bits left over.\n    //\n    // First calculate how many bits in the base id represent a complete\n    // sequence of characters.\n    const numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n\n    const newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n\n    const newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n\n    const restOfBaseId = baseId >> numberOfOverflowBits;\n    const restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n    // we made more room, this time it won't overflow.\n\n    const restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n    const restOfNewBits = slot << restOfBaseLength;\n    const id = restOfNewBits | restOfBaseId;\n    const overflow = newOverflow + baseOverflow;\n    treeContextId = 1 << restOfLength | id;\n    treeContextOverflow = overflow;\n  } else {\n    // Normal path\n    const newBits = slot << baseLength;\n    const id = newBits | baseId;\n    const overflow = baseOverflow;\n    treeContextId = 1 << length | id;\n    treeContextOverflow = overflow;\n  }\n}\nexport function pushMaterializedTreeId(workInProgress) {\n  warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n  // in its children.\n\n  const returnFiber = workInProgress.return;\n\n  if (returnFiber !== null) {\n    const numberOfForks = 1;\n    const slotIndex = 0;\n    pushTreeFork(workInProgress, numberOfForks);\n    pushTreeId(workInProgress, numberOfForks, slotIndex);\n  }\n}\n\nfunction getBitLength(number) {\n  return 32 - clz32(number);\n}\n\nfunction getLeadingBit(id) {\n  return 1 << getBitLength(id) - 1;\n}\n\nexport function popTreeContext(workInProgress) {\n  // Restore the previous values.\n  // This is a bit more complicated than other context-like modules in Fiber\n  // because the same Fiber may appear on the stack multiple times and for\n  // different reasons. We have to keep popping until the work-in-progress is\n  // no longer at the top of the stack.\n  while (workInProgress === treeForkProvider) {\n    treeForkProvider = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n    treeForkCount = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n  }\n\n  while (workInProgress === treeContextProvider) {\n    treeContextProvider = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextOverflow = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextId = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n  }\n}\nexport function getSuspendedTreeContext() {\n  warnIfNotHydrating();\n\n  if (treeContextProvider !== null) {\n    return {\n      id: treeContextId,\n      overflow: treeContextOverflow\n    };\n  } else {\n    return null;\n  }\n}\nexport function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextId = suspendedContext.id;\n  treeContextOverflow = suspendedContext.overflow;\n  treeContextProvider = workInProgress;\n}\n\nfunction warnIfNotHydrating() {\n  if (__DEV__) {\n    if (!getIsHydrating()) {\n      console.error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n    }\n  }\n}","map":{"version":3,"names":["getIsHydrating","clz32","Forked","NoFlags","forkStack","forkStackIndex","treeForkProvider","treeForkCount","idStack","idStackIndex","treeContextProvider","treeContextId","treeContextOverflow","isForkedChild","workInProgress","warnIfNotHydrating","flags","getForksAtLevel","getTreeId","overflow","idWithLeadingBit","id","getLeadingBit","toString","pushTreeFork","totalChildren","pushTreeId","index","baseIdWithLeadingBit","baseOverflow","baseLength","getBitLength","baseId","slot","length","numberOfOverflowBits","newOverflowBits","newOverflow","restOfBaseId","restOfBaseLength","restOfLength","restOfNewBits","newBits","pushMaterializedTreeId","returnFiber","return","numberOfForks","slotIndex","number","popTreeContext","getSuspendedTreeContext","restoreSuspendedTreeContext","suspendedContext","__DEV__","console","error"],"sources":["E:/react-test/src/react/packages/react-reconciler/src/ReactFiberTreeContext.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\n// Ids are base 32 strings whose binary representation corresponds to the\r\n// position of a node in a tree.\r\n\r\n// Every time the tree forks into multiple children, we add additional bits to\r\n// the left of the sequence that represent the position of the child within the\r\n// current level of children.\r\n//\r\n//      00101       00010001011010101\r\n//      ╰─┬─╯       ╰───────┬───────╯\r\n//   Fork 5 of 20       Parent id\r\n//\r\n// The leading 0s are important. In the above example, you only need 3 bits to\r\n// represent slot 5. However, you need 5 bits to represent all the forks at\r\n// the current level, so we must account for the empty bits at the end.\r\n//\r\n// For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\r\n// the zeroth id at a level would be indistinguishable from its parent.\r\n//\r\n// If a node has only one child, and does not materialize an id (i.e. does not\r\n// contain a useId hook), then we don't need to allocate any space in the\r\n// sequence. It's treated as a transparent indirection. For example, these two\r\n// trees produce the same ids:\r\n//\r\n// <>                          <>\r\n//   <Indirection>               <A />\r\n//     <A />                     <B />\r\n//   </Indirection>            </>\r\n//   <B />\r\n// </>\r\n//\r\n// However, we cannot skip any node that materializes an id. Otherwise, a parent\r\n// id that does not fork would be indistinguishable from its child id. For\r\n// example, this tree does not fork, but the parent and child must have\r\n// different ids.\r\n//\r\n// <Parent>\r\n//   <Child />\r\n// </Parent>\r\n//\r\n// To handle this scenario, every time we materialize an id, we allocate a\r\n// new level with a single slot. You can think of this as a fork with only one\r\n// prong, or an array of children with length 1.\r\n//\r\n// It's possible for the size of the sequence to exceed 32 bits, the max\r\n// size for bitwise operations. When this happens, we make more room by\r\n// converting the right part of the id to a string and storing it in an overflow\r\n// variable. We use a base 32 string representation, because 32 is the largest\r\n// power of 2 that is supported by toString(). We want the base to be large so\r\n// that the resulting ids are compact, and we want the base to be a power of 2\r\n// because every log2(base) bits corresponds to a single character, i.e. every\r\n// log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\r\n// affecting the final result.\r\n\r\nimport {getIsHydrating} from './ReactFiberHydrationContext.new';\r\nimport {clz32} from './clz32';\r\nimport {Forked, NoFlags} from './ReactFiberFlags';\r\n\r\nexport type TreeContext = {\r\n  id: number,\r\n  overflow: string,\r\n};\r\n\r\n// TODO: Use the unified fiber stack module instead of this local one?\r\n// Intentionally not using it yet to derisk the initial implementation, because\r\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\r\n// rather the ids be wrong than crash the whole reconciler.\r\nconst forkStack: Array<any> = [];\r\nlet forkStackIndex: number = 0;\r\nlet treeForkProvider: Fiber | null = null;\r\nlet treeForkCount: number = 0;\r\n\r\nconst idStack: Array<any> = [];\r\nlet idStackIndex: number = 0;\r\nlet treeContextProvider: Fiber | null = null;\r\nlet treeContextId: number = 1;\r\nlet treeContextOverflow: string = '';\r\n\r\nexport function isForkedChild(workInProgress: Fiber): boolean {\r\n  warnIfNotHydrating();\r\n  return (workInProgress.flags & Forked) !== NoFlags;\r\n}\r\n\r\nexport function getForksAtLevel(workInProgress: Fiber): number {\r\n  warnIfNotHydrating();\r\n  return treeForkCount;\r\n}\r\n\r\nexport function getTreeId(): string {\r\n  const overflow = treeContextOverflow;\r\n  const idWithLeadingBit = treeContextId;\r\n  const id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\r\n  return id.toString(32) + overflow;\r\n}\r\n\r\nexport function pushTreeFork(\r\n  workInProgress: Fiber,\r\n  totalChildren: number,\r\n): void {\r\n  // This is called right after we reconcile an array (or iterator) of child\r\n  // fibers, because that's the only place where we know how many children in\r\n  // the whole set without doing extra work later, or storing addtional\r\n  // information on the fiber.\r\n  //\r\n  // That's why this function is separate from pushTreeId — it's called during\r\n  // the render phase of the fork parent, not the child, which is where we push\r\n  // the other context values.\r\n  //\r\n  // In the Fizz implementation this is much simpler because the child is\r\n  // rendered in the same callstack as the parent.\r\n  //\r\n  // It might be better to just add a `forks` field to the Fiber type. It would\r\n  // make this module simpler.\r\n\r\n  warnIfNotHydrating();\r\n\r\n  forkStack[forkStackIndex++] = treeForkCount;\r\n  forkStack[forkStackIndex++] = treeForkProvider;\r\n\r\n  treeForkProvider = workInProgress;\r\n  treeForkCount = totalChildren;\r\n}\r\n\r\nexport function pushTreeId(\r\n  workInProgress: Fiber,\r\n  totalChildren: number,\r\n  index: number,\r\n) {\r\n  warnIfNotHydrating();\r\n\r\n  idStack[idStackIndex++] = treeContextId;\r\n  idStack[idStackIndex++] = treeContextOverflow;\r\n  idStack[idStackIndex++] = treeContextProvider;\r\n\r\n  treeContextProvider = workInProgress;\r\n\r\n  const baseIdWithLeadingBit = treeContextId;\r\n  const baseOverflow = treeContextOverflow;\r\n\r\n  // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\r\n  // of the id; we use it to account for leading 0s.\r\n  const baseLength = getBitLength(baseIdWithLeadingBit) - 1;\r\n  const baseId = baseIdWithLeadingBit & ~(1 << baseLength);\r\n\r\n  const slot = index + 1;\r\n  const length = getBitLength(totalChildren) + baseLength;\r\n\r\n  // 30 is the max length we can store without overflowing, taking into\r\n  // consideration the leading 1 we use to mark the end of the sequence.\r\n  if (length > 30) {\r\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\r\n    // This branch assumes the length of the base id is greater than 5; it won't\r\n    // work for smaller ids, because you need 5 bits per character.\r\n    //\r\n    // We encode the id in multiple steps: first the base id, then the\r\n    // remaining digits.\r\n    //\r\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\r\n    // example, if the current id is 23 bits long, we can convert 20 of those\r\n    // bits into a string of 4 characters, with 3 bits left over.\r\n    //\r\n    // First calculate how many bits in the base id represent a complete\r\n    // sequence of characters.\r\n    const numberOfOverflowBits = baseLength - (baseLength % 5);\r\n\r\n    // Then create a bitmask that selects only those bits.\r\n    const newOverflowBits = (1 << numberOfOverflowBits) - 1;\r\n\r\n    // Select the bits, and convert them to a base 32 string.\r\n    const newOverflow = (baseId & newOverflowBits).toString(32);\r\n\r\n    // Now we can remove those bits from the base id.\r\n    const restOfBaseId = baseId >> numberOfOverflowBits;\r\n    const restOfBaseLength = baseLength - numberOfOverflowBits;\r\n\r\n    // Finally, encode the rest of the bits using the normal algorithm. Because\r\n    // we made more room, this time it won't overflow.\r\n    const restOfLength = getBitLength(totalChildren) + restOfBaseLength;\r\n    const restOfNewBits = slot << restOfBaseLength;\r\n    const id = restOfNewBits | restOfBaseId;\r\n    const overflow = newOverflow + baseOverflow;\r\n\r\n    treeContextId = (1 << restOfLength) | id;\r\n    treeContextOverflow = overflow;\r\n  } else {\r\n    // Normal path\r\n    const newBits = slot << baseLength;\r\n    const id = newBits | baseId;\r\n    const overflow = baseOverflow;\r\n\r\n    treeContextId = (1 << length) | id;\r\n    treeContextOverflow = overflow;\r\n  }\r\n}\r\n\r\nexport function pushMaterializedTreeId(workInProgress: Fiber) {\r\n  warnIfNotHydrating();\r\n\r\n  // This component materialized an id. This will affect any ids that appear\r\n  // in its children.\r\n  const returnFiber = workInProgress.return;\r\n  if (returnFiber !== null) {\r\n    const numberOfForks = 1;\r\n    const slotIndex = 0;\r\n    pushTreeFork(workInProgress, numberOfForks);\r\n    pushTreeId(workInProgress, numberOfForks, slotIndex);\r\n  }\r\n}\r\n\r\nfunction getBitLength(number: number): number {\r\n  return 32 - clz32(number);\r\n}\r\n\r\nfunction getLeadingBit(id: number) {\r\n  return 1 << (getBitLength(id) - 1);\r\n}\r\n\r\nexport function popTreeContext(workInProgress: Fiber) {\r\n  // Restore the previous values.\r\n\r\n  // This is a bit more complicated than other context-like modules in Fiber\r\n  // because the same Fiber may appear on the stack multiple times and for\r\n  // different reasons. We have to keep popping until the work-in-progress is\r\n  // no longer at the top of the stack.\r\n\r\n  while (workInProgress === treeForkProvider) {\r\n    treeForkProvider = forkStack[--forkStackIndex];\r\n    forkStack[forkStackIndex] = null;\r\n    treeForkCount = forkStack[--forkStackIndex];\r\n    forkStack[forkStackIndex] = null;\r\n  }\r\n\r\n  while (workInProgress === treeContextProvider) {\r\n    treeContextProvider = idStack[--idStackIndex];\r\n    idStack[idStackIndex] = null;\r\n    treeContextOverflow = idStack[--idStackIndex];\r\n    idStack[idStackIndex] = null;\r\n    treeContextId = idStack[--idStackIndex];\r\n    idStack[idStackIndex] = null;\r\n  }\r\n}\r\n\r\nexport function getSuspendedTreeContext(): TreeContext | null {\r\n  warnIfNotHydrating();\r\n  if (treeContextProvider !== null) {\r\n    return {\r\n      id: treeContextId,\r\n      overflow: treeContextOverflow,\r\n    };\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function restoreSuspendedTreeContext(\r\n  workInProgress: Fiber,\r\n  suspendedContext: TreeContext,\r\n) {\r\n  warnIfNotHydrating();\r\n\r\n  idStack[idStackIndex++] = treeContextId;\r\n  idStack[idStackIndex++] = treeContextOverflow;\r\n  idStack[idStackIndex++] = treeContextProvider;\r\n\r\n  treeContextId = suspendedContext.id;\r\n  treeContextOverflow = suspendedContext.overflow;\r\n  treeContextProvider = workInProgress;\r\n}\r\n\r\nfunction warnIfNotHydrating() {\r\n  if (__DEV__) {\r\n    if (!getIsHydrating()) {\r\n      console.error(\r\n        'Expected to be hydrating. This is a bug in React. Please file ' +\r\n          'an issue.',\r\n      );\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}