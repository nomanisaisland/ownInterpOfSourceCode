{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\nimport { needsStateRestore, restoreStateIfNeeded } from './ReactDOMControlledComponent'; // Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\n\nlet batchedUpdatesImpl = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nlet discreteUpdatesImpl = function (fn, a, b, c, d) {\n  return fn(a, b, c, d);\n};\n\nlet flushSyncImpl = function () {};\n\nlet isInsideEventHandler = false;\n\nfunction finishEventHandler() {\n  // Here we wait until all updates have propagated, which is important\n  // when using controlled components within layers:\n  // https://github.com/facebook/react/issues/1698\n  // Then we restore state of any controlled component.\n  const controlledComponentsHavePendingUpdates = needsStateRestore();\n\n  if (controlledComponentsHavePendingUpdates) {\n    // If a controlled event was fired, we may need to restore the state of\n    // the DOM node back to the controlled value. This is necessary when React\n    // bails out of the update without touching the DOM.\n    // TODO: Restore state in the microtask, after the discrete updates flush,\n    // instead of early flushing them here.\n    flushSyncImpl();\n    restoreStateIfNeeded();\n  }\n}\n\nexport function batchedUpdates(fn, a, b) {\n  if (isInsideEventHandler) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(a, b);\n  }\n\n  isInsideEventHandler = true;\n\n  try {\n    return batchedUpdatesImpl(fn, a, b);\n  } finally {\n    isInsideEventHandler = false;\n    finishEventHandler();\n  }\n} // TODO: Replace with flushSync\n\nexport function discreteUpdates(fn, a, b, c, d) {\n  return discreteUpdatesImpl(fn, a, b, c, d);\n}\nexport function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {\n  batchedUpdatesImpl = _batchedUpdatesImpl;\n  discreteUpdatesImpl = _discreteUpdatesImpl;\n  flushSyncImpl = _flushSyncImpl;\n}","map":{"version":3,"names":["needsStateRestore","restoreStateIfNeeded","batchedUpdatesImpl","fn","bookkeeping","discreteUpdatesImpl","a","b","c","d","flushSyncImpl","isInsideEventHandler","finishEventHandler","controlledComponentsHavePendingUpdates","batchedUpdates","discreteUpdates","setBatchingImplementation","_batchedUpdatesImpl","_discreteUpdatesImpl","_flushSyncImpl"],"sources":["E:/debug-anything/react-test/src/react/packages/react-dom/src/events/ReactDOMUpdateBatching.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nimport {\r\n  needsStateRestore,\r\n  restoreStateIfNeeded,\r\n} from './ReactDOMControlledComponent';\r\n\r\n// Used as a way to call batchedUpdates when we don't have a reference to\r\n// the renderer. Such as when we're dispatching events or if third party\r\n// libraries need to call batchedUpdates. Eventually, this API will go away when\r\n// everything is batched by default. We'll then have a similar API to opt-out of\r\n// scheduled work and instead do synchronous work.\r\n\r\n// Defaults\r\nlet batchedUpdatesImpl = function(fn, bookkeeping) {\r\n  return fn(bookkeeping);\r\n};\r\nlet discreteUpdatesImpl = function(fn, a, b, c, d) {\r\n  return fn(a, b, c, d);\r\n};\r\nlet flushSyncImpl = function() {};\r\n\r\nlet isInsideEventHandler = false;\r\n\r\nfunction finishEventHandler() {\r\n  // Here we wait until all updates have propagated, which is important\r\n  // when using controlled components within layers:\r\n  // https://github.com/facebook/react/issues/1698\r\n  // Then we restore state of any controlled component.\r\n  const controlledComponentsHavePendingUpdates = needsStateRestore();\r\n  if (controlledComponentsHavePendingUpdates) {\r\n    // If a controlled event was fired, we may need to restore the state of\r\n    // the DOM node back to the controlled value. This is necessary when React\r\n    // bails out of the update without touching the DOM.\r\n    // TODO: Restore state in the microtask, after the discrete updates flush,\r\n    // instead of early flushing them here.\r\n    flushSyncImpl();\r\n    restoreStateIfNeeded();\r\n  }\r\n}\r\n\r\nexport function batchedUpdates(fn, a, b) {\r\n  if (isInsideEventHandler) {\r\n    // If we are currently inside another batch, we need to wait until it\r\n    // fully completes before restoring state.\r\n    return fn(a, b);\r\n  }\r\n  isInsideEventHandler = true;\r\n  try {\r\n    return batchedUpdatesImpl(fn, a, b);\r\n  } finally {\r\n    isInsideEventHandler = false;\r\n    finishEventHandler();\r\n  }\r\n}\r\n\r\n// TODO: Replace with flushSync\r\nexport function discreteUpdates(fn, a, b, c, d) {\r\n  return discreteUpdatesImpl(fn, a, b, c, d);\r\n}\r\n\r\nexport function setBatchingImplementation(\r\n  _batchedUpdatesImpl,\r\n  _discreteUpdatesImpl,\r\n  _flushSyncImpl,\r\n) {\r\n  batchedUpdatesImpl = _batchedUpdatesImpl;\r\n  discreteUpdatesImpl = _discreteUpdatesImpl;\r\n  flushSyncImpl = _flushSyncImpl;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,SACEA,iBADF,EAEEC,oBAFF,QAGO,+BAHP,C,CAKA;AACA;AACA;AACA;AACA;AAEA;;AACA,IAAIC,kBAAkB,GAAG,UAASC,EAAT,EAAaC,WAAb,EAA0B;EACjD,OAAOD,EAAE,CAACC,WAAD,CAAT;AACD,CAFD;;AAGA,IAAIC,mBAAmB,GAAG,UAASF,EAAT,EAAaG,CAAb,EAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyB;EACjD,OAAON,EAAE,CAACG,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAUC,CAAV,CAAT;AACD,CAFD;;AAGA,IAAIC,aAAa,GAAG,YAAW,CAAE,CAAjC;;AAEA,IAAIC,oBAAoB,GAAG,KAA3B;;AAEA,SAASC,kBAAT,GAA8B;EAC5B;EACA;EACA;EACA;EACA,MAAMC,sCAAsC,GAAGb,iBAAiB,EAAhE;;EACA,IAAIa,sCAAJ,EAA4C;IAC1C;IACA;IACA;IACA;IACA;IACAH,aAAa;IACbT,oBAAoB;EACrB;AACF;;AAED,OAAO,SAASa,cAAT,CAAwBX,EAAxB,EAA4BG,CAA5B,EAA+BC,CAA/B,EAAkC;EACvC,IAAII,oBAAJ,EAA0B;IACxB;IACA;IACA,OAAOR,EAAE,CAACG,CAAD,EAAIC,CAAJ,CAAT;EACD;;EACDI,oBAAoB,GAAG,IAAvB;;EACA,IAAI;IACF,OAAOT,kBAAkB,CAACC,EAAD,EAAKG,CAAL,EAAQC,CAAR,CAAzB;EACD,CAFD,SAEU;IACRI,oBAAoB,GAAG,KAAvB;IACAC,kBAAkB;EACnB;AACF,C,CAED;;AACA,OAAO,SAASG,eAAT,CAAyBZ,EAAzB,EAA6BG,CAA7B,EAAgCC,CAAhC,EAAmCC,CAAnC,EAAsCC,CAAtC,EAAyC;EAC9C,OAAOJ,mBAAmB,CAACF,EAAD,EAAKG,CAAL,EAAQC,CAAR,EAAWC,CAAX,EAAcC,CAAd,CAA1B;AACD;AAED,OAAO,SAASO,yBAAT,CACLC,mBADK,EAELC,oBAFK,EAGLC,cAHK,EAIL;EACAjB,kBAAkB,GAAGe,mBAArB;EACAZ,mBAAmB,GAAGa,oBAAtB;EACAR,aAAa,GAAGS,cAAhB;AACD"},"metadata":{},"sourceType":"module"}