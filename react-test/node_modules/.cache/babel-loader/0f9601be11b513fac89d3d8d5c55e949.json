{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { noTimeout, supportsHydration } from './ReactFiberHostConfig';\nimport { createHostRootFiber } from './ReactFiber.old';\nimport { NoLane, NoLanes, NoTimestamp, TotalLanes, createLaneMap } from './ReactFiberLane.old';\nimport { enableSuspenseCallback, enableCache, enableProfilerCommitHooks, enableProfilerTimer, enableUpdaterTracking, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { initializeUpdateQueue } from './ReactUpdateQueue.old';\nimport { LegacyRoot, ConcurrentRoot } from './ReactRootTags';\nimport { createCache, retainCache } from './ReactFiberCacheComponent.old';\n\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n  // 不同的组件类型\n  this.tag = tag; // 根节点真实dom\n\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null; // root dom\n  // fiber tree 的根节点\n\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null; // noTimeout 为常数-1\n  // console.log({ timeoutHandle: noTimeout }, \"参数为常数-1\")\n\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.callbackNode = null; // console.log({ callbackPriority: NoLane }, \"常熟二进制0b0000000000000000000000000000000\")\n\n  this.callbackPriority = NoLane; // console.log({ eventTimes: createLaneMap(NoLanes), NoLanes: 0b0000000000000000000000000000000 }, \"NoLanes的值为二进制0b0000000000000000000000000000000\")\n\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n  this.identifierPrefix = identifierPrefix;\n  this.onRecoverableError = onRecoverableError; // console.log(this, \"将一部分需要分配执行优先级的参数分配默认无优先级\");\n  // TODO enableCache暂时不知道什么意思，猜测是缓存之类的\n  // enableCache为手动配置 __EXPERIMENTAL__ true\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  } // 是否支持服务端渲染\n  // 常数true\n  // console.log(supportsHydration)\n\n\n  if (supportsHydration) {\n    // 为服务端渲染准备参数\n    this.mutableSourceEagerHydrationData = null;\n  } // enableSuspenseCallback为常数false\n\n\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  } // 常数false\n\n\n  if (enableTransitionTracing) {\n    this.transitionCallbacks = null;\n    const transitionLanesMap = this.transitionLanes = [];\n\n    for (let i = 0; i < TotalLanes; i++) {\n      transitionLanesMap.push(null);\n    }\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (enableUpdaterTracking) {\n    this.memoizedUpdaters = new Set();\n    const pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n\n    for (let i = 0; i < TotalLanes; i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n\n  if (__DEV__) {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n        break;\n\n      case LegacyRoot:\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n        break;\n    }\n  }\n}\n\n_c = FiberRootNode;\nexport function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix, onRecoverableError, transitionCallbacks) {\n  // 上层函数到目前为止都是基础参数传参和开发提示\n  // 创建 FiberRootNode 对象\n  // tag 值为 ConcurrentRoot，定义在 packages/react-reconciler/src/ReactRootTags.js 文件中；\n  // tag === ConcurrentRoot === 1 ，表示 “根节点”\n  // containerInfo 根节点\n  // tag 节点类型标记 1\n  // hydrationCallbacks null\n  // isStrictMode false\n  // concurrentUpdatesByDefaultOverride false\n  // identifierPrefix \" \"\n  // onRecoverableError  一个reportError报告错误的原生方法(不会阻止其他回调被处理，仍然可以调试)\n  // transitionCallbacks null\n  // hydrate false 表示是浏览器渲染\n  // initialChildren 为null 字面意思为初始子元素\n  const root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError); // console.log(root, \"uninitializedFiber === root.current\")\n  // console.log(root, \"获取到基本的fiber根节点\")\n\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  if (enableTransitionTracing) {\n    root.transitionCallbacks = transitionCallbacks;\n  } // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  // 创建root fiber节点，可以是多个\n  // createHostRootFiber 会调用 packages/react-reconciler/src/ReactFiber.old.js 文件中的 createFiber 方法创建一个 `Fiber HostRoot节点`\n  // `Fiber HostRoot节点` 就是一个 Fiber 对象，只是他的 Tag 等于 3，代表 `HostRoot`\n  // 内部数据（优先级，服务器渲染参数）全部挂在到方法上\n\n\n  const uninitializedFiber = createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride); // console.log(uninitializedFiber, \"获得未初始化，但是参数齐全的fiber根节点\")\n  // 关联FiberRoot和root fiber\n  // react 采用的是fiber双缓存  current fiber树描述了当前呈现的dom树    workInProgress Fiber（由current内alternate属性指定workInProgress）是正在更新的Fiber树\n\n  root.current = uninitializedFiber; // 将根节点实例挂在到stateNode方法上\n\n  uninitializedFiber.stateNode = root; // console.log(root, \"关联root.current和uninitializedFiber.stateNode\")\n  // console.log(enableCache)\n  // enableCache true\n\n  if (enableCache) {\n    const initialCache = createCache();\n    retainCache(initialCache); // console.log(JSON.parse(JSON.stringify(initialCache)), \"缓存标记加一,当前结果不变，下次加一(cache.refCount)\")\n    // The pooledCache is a fresh cache instance that is used temporarily\n    // for newly mounted boundaries during a render. In general, the\n    // pooledCache is always cleared from the root at the end of a render:\n    // it is either released when render commits, or moved to an Offscreen\n    // component if rendering suspends. Because the lifetime of the pooled\n    // cache is distinct from the main memoizedState.cache, it must be\n    // retained separately.\n\n    root.pooledCache = initialCache; // console.log(root.pooledCache, \"将initialCache挂在到root.pooledCache上\");\n\n    retainCache(initialCache);\n    /**\r\n     * {\r\n     *  cache: {\r\n     *    controller: AbortController {\r\n     *      signal: AbortSignal\r\n     *    },\r\n     *    data: Map(0) {size: 0},\r\n     *    refCount: 1,\r\n     *  },\r\n     *  element: null,\r\n     *  isDehydrated: false,\r\n     *  pendingSuspenseBoundaries: null,\r\n     *  transitions: null,\r\n     * }\r\n     */\n\n    s; // console.log(root.pooledCache, \"取得上次结果，retainCache cache.refCount再加一,控制台和真实结果不一样，是浏览器取值的问题，浏览器拿到的是缓存里面的值，最新的值没有拿到，可以先序列号，再反序列化一下（把对象序列化到一个字符串中，以强制执行一次“快照”）\");\n\n    const initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: initialCache,\n      transitions: null,\n      pendingSuspenseBoundaries: null\n    };\n    console.log(initialState, \"initialChildren\");\n    uninitializedFiber.memoizedState = initialState; // console.log(root, \"在root.current中添加initialState当前节点的初始状态\")\n  } else {\n    const initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: null,\n      // not enabled yet\n      transitions: null,\n      pendingSuspenseBoundaries: null\n    };\n    uninitializedFiber.memoizedState = initialState;\n  } // console.log(uninitializedFiber, \"uninitializedFiber === root.current\")\n  // 初始化更新队列\n\n\n  initializeUpdateQueue(uninitializedFiber); // console.log(root,\"uninitializedFiber === root.current\")\n  // console.log(JSON.parse(JSON.stringify(root?.current?.updateQueue)), \" root.current.updateQueue\")\n\n  return root;\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"FiberRootNode\");","map":{"version":3,"names":["noTimeout","supportsHydration","createHostRootFiber","NoLane","NoLanes","NoTimestamp","TotalLanes","createLaneMap","enableSuspenseCallback","enableCache","enableProfilerCommitHooks","enableProfilerTimer","enableUpdaterTracking","enableTransitionTracing","initializeUpdateQueue","LegacyRoot","ConcurrentRoot","createCache","retainCache","FiberRootNode","containerInfo","tag","hydrate","identifierPrefix","onRecoverableError","pendingChildren","current","pingCache","finishedWork","timeoutHandle","context","pendingContext","callbackNode","callbackPriority","eventTimes","expirationTimes","pendingLanes","suspendedLanes","pingedLanes","expiredLanes","mutableReadLanes","finishedLanes","entangledLanes","entanglements","pooledCache","pooledCacheLanes","mutableSourceEagerHydrationData","hydrationCallbacks","transitionCallbacks","transitionLanesMap","transitionLanes","i","push","effectDuration","passiveEffectDuration","memoizedUpdaters","Set","pendingUpdatersLaneMap","__DEV__","_debugRootType","createFiberRoot","initialChildren","isStrictMode","concurrentUpdatesByDefaultOverride","root","uninitializedFiber","stateNode","initialCache","s","initialState","element","isDehydrated","cache","transitions","pendingSuspenseBoundaries","console","log","memoizedState"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberRoot.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { ReactNodeList } from 'shared/ReactTypes';\r\nimport type {\r\n  FiberRoot,\r\n  SuspenseHydrationCallbacks,\r\n  TransitionTracingCallbacks,\r\n} from './ReactInternalTypes';\r\nimport type { RootTag } from './ReactRootTags';\r\nimport type { Cache } from './ReactFiberCacheComponent.old';\r\nimport type {\r\n  PendingSuspenseBoundaries,\r\n  Transition,\r\n} from './ReactFiberTracingMarkerComponent.old';\r\n\r\nimport { noTimeout, supportsHydration } from './ReactFiberHostConfig';\r\nimport { createHostRootFiber } from './ReactFiber.old';\r\nimport {\r\n  NoLane,\r\n  NoLanes,\r\n  NoTimestamp,\r\n  TotalLanes,\r\n  createLaneMap,\r\n} from './ReactFiberLane.old';\r\nimport {\r\n  enableSuspenseCallback,\r\n  enableCache,\r\n  enableProfilerCommitHooks,\r\n  enableProfilerTimer,\r\n  enableUpdaterTracking,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\nimport { initializeUpdateQueue } from './ReactUpdateQueue.old';\r\nimport { LegacyRoot, ConcurrentRoot } from './ReactRootTags';\r\nimport { createCache, retainCache } from './ReactFiberCacheComponent.old';\r\n\r\nexport type RootState = {\r\n  element: any,\r\n  isDehydrated: boolean,\r\n  cache: Cache,\r\n  pendingSuspenseBoundaries: PendingSuspenseBoundaries | null,\r\n  transitions: Set<Transition> | null,\r\n};\r\n\r\nfunction FiberRootNode (\r\n  containerInfo,\r\n  tag,\r\n  hydrate,\r\n  identifierPrefix,\r\n  onRecoverableError,\r\n) {\r\n  // 不同的组件类型\r\n  this.tag = tag;\r\n  // 根节点真实dom\r\n  this.containerInfo = containerInfo;\r\n  this.pendingChildren = null; // root dom\r\n  // fiber tree 的根节点\r\n  this.current = null;\r\n  this.pingCache = null;\r\n  this.finishedWork = null;\r\n  // noTimeout 为常数-1\r\n  // console.log({ timeoutHandle: noTimeout }, \"参数为常数-1\")\r\n  this.timeoutHandle = noTimeout;\r\n  this.context = null;\r\n  this.pendingContext = null;\r\n  this.callbackNode = null;\r\n  // console.log({ callbackPriority: NoLane }, \"常熟二进制0b0000000000000000000000000000000\")\r\n  this.callbackPriority = NoLane;\r\n\r\n\r\n  // console.log({ eventTimes: createLaneMap(NoLanes), NoLanes: 0b0000000000000000000000000000000 }, \"NoLanes的值为二进制0b0000000000000000000000000000000\")\r\n\r\n\r\n  this.eventTimes = createLaneMap(NoLanes);\r\n  this.expirationTimes = createLaneMap(NoTimestamp);\r\n\r\n  this.pendingLanes = NoLanes;\r\n  this.suspendedLanes = NoLanes;\r\n  this.pingedLanes = NoLanes;\r\n  this.expiredLanes = NoLanes;\r\n  this.mutableReadLanes = NoLanes;\r\n  this.finishedLanes = NoLanes;\r\n\r\n  this.entangledLanes = NoLanes;\r\n  this.entanglements = createLaneMap(NoLanes);\r\n  this.identifierPrefix = identifierPrefix;\r\n  this.onRecoverableError = onRecoverableError;\r\n\r\n  // console.log(this, \"将一部分需要分配执行优先级的参数分配默认无优先级\");\r\n\r\n  // TODO enableCache暂时不知道什么意思，猜测是缓存之类的\r\n  // enableCache为手动配置 __EXPERIMENTAL__ true\r\n  if (enableCache) {\r\n    this.pooledCache = null;\r\n    this.pooledCacheLanes = NoLanes;\r\n  }\r\n\r\n  // 是否支持服务端渲染\r\n  // 常数true\r\n  // console.log(supportsHydration)\r\n  if (supportsHydration) {\r\n    // 为服务端渲染准备参数\r\n    this.mutableSourceEagerHydrationData = null;\r\n  }\r\n  // enableSuspenseCallback为常数false\r\n  if (enableSuspenseCallback) {\r\n    this.hydrationCallbacks = null;\r\n  }\r\n\r\n  // 常数false\r\n  if (enableTransitionTracing) {\r\n    this.transitionCallbacks = null;\r\n    const transitionLanesMap = (this.transitionLanes = []);\r\n    for (let i = 0; i < TotalLanes; i++) {\r\n      transitionLanesMap.push(null);\r\n    }\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    this.effectDuration = 0;\r\n    this.passiveEffectDuration = 0;\r\n  }\r\n\r\n  if (enableUpdaterTracking) {\r\n    this.memoizedUpdaters = new Set();\r\n    const pendingUpdatersLaneMap = (this.pendingUpdatersLaneMap = []);\r\n    for (let i = 0; i < TotalLanes; i++) {\r\n      pendingUpdatersLaneMap.push(new Set());\r\n    }\r\n  }\r\n  if (__DEV__) {\r\n    switch (tag) {\r\n      case ConcurrentRoot:\r\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\r\n        break;\r\n      case LegacyRoot:\r\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nexport function createFiberRoot (\r\n  containerInfo: any,\r\n  tag: RootTag,\r\n  hydrate: boolean,\r\n  initialChildren: ReactNodeList,\r\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\r\n  isStrictMode: boolean,\r\n  concurrentUpdatesByDefaultOverride: null | boolean,\r\n  // TODO: We have several of these arguments that are conceptually part of the\r\n  // host config, but because they are passed in at runtime, we have to thread\r\n  // them through the root constructor. Perhaps we should put them all into a\r\n  // single type, like a DynamicHostConfig that is defined by the renderer.\r\n  identifierPrefix: string,\r\n  onRecoverableError: null | ((error: mixed) => void),\r\n  transitionCallbacks: null | TransitionTracingCallbacks,\r\n): FiberRoot {\r\n  // 上层函数到目前为止都是基础参数传参和开发提示\r\n\r\n  // 创建 FiberRootNode 对象\r\n  // tag 值为 ConcurrentRoot，定义在 packages/react-reconciler/src/ReactRootTags.js 文件中；\r\n  // tag === ConcurrentRoot === 1 ，表示 “根节点”\r\n\r\n  // containerInfo 根节点\r\n  // tag 节点类型标记 1\r\n  // hydrationCallbacks null\r\n  // isStrictMode false\r\n  // concurrentUpdatesByDefaultOverride false\r\n  // identifierPrefix \" \"\r\n  // onRecoverableError  一个reportError报告错误的原生方法(不会阻止其他回调被处理，仍然可以调试)\r\n  // transitionCallbacks null\r\n  // hydrate false 表示是浏览器渲染\r\n  // initialChildren 为null 字面意思为初始子元素\r\n\r\n\r\n\r\n  const root: FiberRoot = (new FiberRootNode(\r\n    containerInfo,\r\n    tag,\r\n    hydrate,\r\n    identifierPrefix,\r\n    onRecoverableError,\r\n  ): any);\r\n  // console.log(root, \"uninitializedFiber === root.current\")\r\n  // console.log(root, \"获取到基本的fiber根节点\")\r\n  if (enableSuspenseCallback) {\r\n    root.hydrationCallbacks = hydrationCallbacks;\r\n  }\r\n\r\n  if (enableTransitionTracing) {\r\n    root.transitionCallbacks = transitionCallbacks;\r\n  }\r\n\r\n  // Cyclic construction. This cheats the type system right now because\r\n  // stateNode is any.\r\n  // 创建root fiber节点，可以是多个\r\n  // createHostRootFiber 会调用 packages/react-reconciler/src/ReactFiber.old.js 文件中的 createFiber 方法创建一个 `Fiber HostRoot节点`\r\n  // `Fiber HostRoot节点` 就是一个 Fiber 对象，只是他的 Tag 等于 3，代表 `HostRoot`\r\n\r\n  // 内部数据（优先级，服务器渲染参数）全部挂在到方法上\r\n  const uninitializedFiber = createHostRootFiber(\r\n    tag,\r\n    isStrictMode,\r\n    concurrentUpdatesByDefaultOverride,\r\n  );\r\n  // console.log(uninitializedFiber, \"获得未初始化，但是参数齐全的fiber根节点\")\r\n  // 关联FiberRoot和root fiber\r\n\r\n\r\n  // react 采用的是fiber双缓存  current fiber树描述了当前呈现的dom树    workInProgress Fiber（由current内alternate属性指定workInProgress）是正在更新的Fiber树\r\n  root.current = uninitializedFiber;\r\n\r\n  // 将根节点实例挂在到stateNode方法上\r\n  uninitializedFiber.stateNode = root;\r\n  // console.log(root, \"关联root.current和uninitializedFiber.stateNode\")\r\n  // console.log(enableCache)\r\n  // enableCache true\r\n  if (enableCache) {\r\n    const initialCache = createCache();\r\n\r\n    retainCache(initialCache);\r\n\r\n    // console.log(JSON.parse(JSON.stringify(initialCache)), \"缓存标记加一,当前结果不变，下次加一(cache.refCount)\")\r\n\r\n\r\n    // The pooledCache is a fresh cache instance that is used temporarily\r\n    // for newly mounted boundaries during a render. In general, the\r\n    // pooledCache is always cleared from the root at the end of a render:\r\n    // it is either released when render commits, or moved to an Offscreen\r\n    // component if rendering suspends. Because the lifetime of the pooled\r\n    // cache is distinct from the main memoizedState.cache, it must be\r\n    // retained separately.\r\n    root.pooledCache = initialCache;\r\n\r\n    // console.log(root.pooledCache, \"将initialCache挂在到root.pooledCache上\");\r\n\r\n    retainCache(initialCache);\r\n\r\n    /**\r\n     * {\r\n     *  cache: {\r\n     *    controller: AbortController {\r\n     *      signal: AbortSignal\r\n     *    },\r\n     *    data: Map(0) {size: 0},\r\n     *    refCount: 1,\r\n     *  },\r\n     *  element: null,\r\n     *  isDehydrated: false,\r\n     *  pendingSuspenseBoundaries: null,\r\n     *  transitions: null,\r\n     * }\r\n     */\r\n    s\r\n    // console.log(root.pooledCache, \"取得上次结果，retainCache cache.refCount再加一,控制台和真实结果不一样，是浏览器取值的问题，浏览器拿到的是缓存里面的值，最新的值没有拿到，可以先序列号，再反序列化一下（把对象序列化到一个字符串中，以强制执行一次“快照”）\");\r\n\r\n\r\n    const initialState: RootState = {\r\n      element: initialChildren,\r\n      isDehydrated: hydrate,\r\n      cache: initialCache,\r\n      transitions: null,\r\n      pendingSuspenseBoundaries: null,\r\n    };\r\n    console.log(initialState, \"initialChildren\")\r\n\r\n    uninitializedFiber.memoizedState = initialState;\r\n\r\n    // console.log(root, \"在root.current中添加initialState当前节点的初始状态\")\r\n  } else {\r\n    const initialState: RootState = {\r\n      element: initialChildren,\r\n      isDehydrated: hydrate,\r\n      cache: (null: any), // not enabled yet\r\n      transitions: null,\r\n      pendingSuspenseBoundaries: null,\r\n    };\r\n    uninitializedFiber.memoizedState = initialState;\r\n  }\r\n  // console.log(uninitializedFiber, \"uninitializedFiber === root.current\")\r\n  // 初始化更新队列\r\n  initializeUpdateQueue(uninitializedFiber);\r\n  // console.log(root,\"uninitializedFiber === root.current\")\r\n  // console.log(JSON.parse(JSON.stringify(root?.current?.updateQueue)), \" root.current.updateQueue\")\r\n  return root;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}