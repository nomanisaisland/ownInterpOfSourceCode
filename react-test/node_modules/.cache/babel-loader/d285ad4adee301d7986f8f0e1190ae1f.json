{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\n// TODO: Ideally these types would be opaque but that doesn't work well with\n// our reconciler fork infra, since these leak into non-reconciler packages.\nimport { enableSchedulingProfiler, enableUpdaterTracking, allowConcurrentByDefault, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { isDevToolsPresent } from './ReactFiberDevToolsHook.old';\nimport { ConcurrentUpdatesByDefaultMode, NoMode } from './ReactTypeOfMode';\nimport { clz32 } from './clz32'; // Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\n// If those values are changed that package should be rebuilt and redeployed.\n// 更新任务的\n\nexport const TotalLanes = 31;\nexport const NoLanes =\n/*                        */\n0b0000000000000000000000000000000;\nexport const NoLane =\n/*                          */\n0b0000000000000000000000000000000;\nexport const SyncLane =\n/*                        */\n0b0000000000000000000000000000001;\nexport const InputContinuousHydrationLane =\n/*    */\n0b0000000000000000000000000000010;\nexport const InputContinuousLane =\n/*             */\n0b0000000000000000000000000000100;\nexport const DefaultHydrationLane =\n/*            */\n0b0000000000000000000000000001000;\nexport const DefaultLane =\n/*                     */\n0b0000000000000000000000000010000;\nconst TransitionHydrationLane =\n/*                */\n0b0000000000000000000000000100000;\nconst TransitionLanes =\n/*                       */\n0b0000000001111111111111111000000;\nconst TransitionLane1 =\n/*                        */\n0b0000000000000000000000001000000;\nconst TransitionLane2 =\n/*                        */\n0b0000000000000000000000010000000;\nconst TransitionLane3 =\n/*                        */\n0b0000000000000000000000100000000;\nconst TransitionLane4 =\n/*                        */\n0b0000000000000000000001000000000;\nconst TransitionLane5 =\n/*                        */\n0b0000000000000000000010000000000;\nconst TransitionLane6 =\n/*                        */\n0b0000000000000000000100000000000;\nconst TransitionLane7 =\n/*                        */\n0b0000000000000000001000000000000;\nconst TransitionLane8 =\n/*                        */\n0b0000000000000000010000000000000;\nconst TransitionLane9 =\n/*                        */\n0b0000000000000000100000000000000;\nconst TransitionLane10 =\n/*                       */\n0b0000000000000001000000000000000;\nconst TransitionLane11 =\n/*                       */\n0b0000000000000010000000000000000;\nconst TransitionLane12 =\n/*                       */\n0b0000000000000100000000000000000;\nconst TransitionLane13 =\n/*                       */\n0b0000000000001000000000000000000;\nconst TransitionLane14 =\n/*                       */\n0b0000000000010000000000000000000;\nconst TransitionLane15 =\n/*                       */\n0b0000000000100000000000000000000;\nconst TransitionLane16 =\n/*                       */\n0b0000000001000000000000000000000;\nconst RetryLanes =\n/*                            */\n0b0000111110000000000000000000000;\nconst RetryLane1 =\n/*                             */\n0b0000000010000000000000000000000;\nconst RetryLane2 =\n/*                             */\n0b0000000100000000000000000000000;\nconst RetryLane3 =\n/*                             */\n0b0000001000000000000000000000000;\nconst RetryLane4 =\n/*                             */\n0b0000010000000000000000000000000;\nconst RetryLane5 =\n/*                             */\n0b0000100000000000000000000000000;\nexport const SomeRetryLane = RetryLane1;\nexport const SelectiveHydrationLane =\n/*          */\n0b0001000000000000000000000000000;\nconst NonIdleLanes =\n/*                          */\n0b0001111111111111111111111111111;\nexport const IdleHydrationLane =\n/*               */\n0b0010000000000000000000000000000;\nexport const IdleLane =\n/*                        */\n0b0100000000000000000000000000000;\nexport const OffscreenLane =\n/*                   */\n0b1000000000000000000000000000000; // This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\n\nexport function getLabelForLane(lane) {\n  if (enableSchedulingProfiler) {\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\nexport const NoTimestamp = -1;\nlet nextTransitionLane = TransitionLane1;\nlet nextRetryLane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes) {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncLane:\n      return SyncLane;\n\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n\n    case InputContinuousLane:\n      return InputContinuousLane;\n\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n\n    case DefaultLane:\n      return DefaultLane;\n\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      return lanes & RetryLanes;\n\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n\n    case IdleLane:\n      return IdleLane;\n\n    case OffscreenLane:\n      return OffscreenLane;\n\n    default:\n      if (__DEV__) {\n        console.error('Should have found matching lanes. This is a bug in React.');\n      } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\n\n      return lanes;\n  }\n}\n\nexport function getNextLanes(root, wipLanes) {\n  // Early bailout if there's no pending work left.\n  const pendingLanes = root.pendingLanes;\n\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  let nextLanes = NoLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n\n  if (nonIdlePendingLanes !== NoLanes) {\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\n\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  } // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n\n\n  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n  // bother waiting until the root is complete.\n  (wipLanes & suspendedLanes) === NoLanes) {\n    const nextLane = getHighestPriorityLane(nextLanes);\n    const wipLane = getHighestPriorityLane(wipLanes);\n\n    if ( // Tests whether the next lane is equal or lower priority than the wip\n    // one. This works because the bits decrease in priority as you go left.\n    nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n    // only difference between default updates and transition updates is that\n    // default updates do not support refresh transitions.\n    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if (allowConcurrentByDefault && (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode) {// Do nothing, use the lanes as they were assigned.\n  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  } // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n\n\n  const entangledLanes = root.entangledLanes;\n\n  if (entangledLanes !== NoLanes) {\n    const entanglements = root.entanglements;\n    let lanes = nextLanes & entangledLanes;\n\n    while (lanes > 0) {\n      const index = pickArbitraryLaneIndex(lanes);\n      const lane = 1 << index;\n      nextLanes |= entanglements[index];\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\nexport function getMostRecentEventTime(root, lanes) {\n  const eventTimes = root.eventTimes;\n  let mostRecentEventTime = NoTimestamp;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    const eventTime = eventTimes[index];\n\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n\n    default:\n      if (__DEV__) {\n        console.error('Should have found matching lanes. This is a bug in React.');\n      }\n\n      return NoTimestamp;\n  }\n}\n\nexport function markStarvedLanesAsExpired(root, currentTime) {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n  const pendingLanes = root.pendingLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  const expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n\n  let lanes = pendingLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    const expirationTime = expirationTimes[index];\n\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n} // This returns the highest priority pending lanes regardless of whether they\n// are suspended.\n\nexport function getHighestPriorityPendingLanes(root) {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\nexport function getLanesToRetrySynchronouslyOnError(root) {\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n\n  return NoLanes;\n}\nexport function includesSyncLane(lanes) {\n  return (lanes & SyncLane) !== NoLanes;\n}\nexport function includesNonIdleWork(lanes) {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nexport function includesOnlyRetries(lanes) {\n  return (lanes & RetryLanes) === lanes;\n}\nexport function includesOnlyNonUrgentLanes(lanes) {\n  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n  return (lanes & UrgentLanes) === NoLanes;\n}\nexport function includesOnlyTransitions(lanes) {\n  return (lanes & TransitionLanes) === lanes;\n}\nexport function includesBlockingLane(root, lanes) {\n  if (allowConcurrentByDefault && (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode) {\n    // Concurrent updates by default always use time slicing.\n    return false;\n  }\n\n  const SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\nexport function includesExpiredLane(root, lanes) {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\nexport function isTransitionLane(lane) {\n  return (lane & TransitionLanes) !== NoLanes;\n}\nexport function claimNextTransitionLane() {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  const lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n    nextTransitionLane = TransitionLane1;\n  }\n\n  return lane;\n}\nexport function claimNextRetryLane() {\n  const lane = nextRetryLane;\n  nextRetryLane <<= 1;\n\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\n    nextRetryLane = RetryLane1;\n  }\n\n  return lane;\n}\nexport function getHighestPriorityLane(lanes) {\n  return lanes & -lanes;\n}\nexport function pickArbitraryLane(lanes) {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nexport function includesSomeLane(a, b) {\n  return (a & b) !== NoLanes;\n}\nexport function isSubsetOfLanes(set, subset) {\n  return (set & subset) === subset;\n}\nexport function mergeLanes(a, b) {\n  return a | b;\n}\nexport function removeLanes(set, subset) {\n  return set & ~subset;\n}\nexport function intersectLanes(a, b) {\n  return a & b;\n} // Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\n\nexport function laneToLanes(lane) {\n  return lane;\n}\nexport function higherPriorityLane(a, b) {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\nexport function createLaneMap(initial) {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  const laneMap = [];\n\n  for (let i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n\n  return laneMap;\n}\nexport function markRootUpdated(root, updateLane, eventTime) {\n  root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  const eventTimes = root.eventTimes;\n  const index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n\n  eventTimes[index] = eventTime;\n}\nexport function markRootSuspended(root, suspendedLanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\n  const expirationTimes = root.expirationTimes;\n  let lanes = suspendedLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nexport function markRootPinged(root, pingedLanes, eventTime) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\nexport function markRootMutableRead(root, updateLane) {\n  root.mutableReadLanes |= updateLane & root.pendingLanes;\n}\nexport function markRootFinished(root, remainingLanes) {\n  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n  root.pendingLanes = remainingLanes; // Let's try everything again\n\n  root.suspendedLanes = NoLanes;\n  root.pingedLanes = NoLanes;\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  const entanglements = root.entanglements;\n  const eventTimes = root.eventTimes;\n  const expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n\n  let lanes = noLongerPendingLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nexport function markRootEntangled(root, entangledLanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n  const rootEntangledLanes = root.entangledLanes |= entangledLanes;\n  const entanglements = root.entanglements;\n  let lanes = rootEntangledLanes;\n\n  while (lanes) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    if ( // Is this one of the newly entangled lanes?\n    lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n    entanglements[index] & entangledLanes) {\n      entanglements[index] |= entangledLanes;\n    }\n\n    lanes &= ~lane;\n  }\n}\nexport function getBumpedLaneForHydration(root, renderLanes) {\n  const renderLane = getHighestPriorityLane(renderLanes);\n  let lane;\n\n  switch (renderLane) {\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      lane = TransitionHydrationLane;\n      break;\n\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  } // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n\n\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\nexport function addFiberToLanesMap(root, fiber, lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n    lanes &= ~lane;\n  }\n}\nexport function movePendingFibersToMemoized(root, lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  const memoizedUpdaters = root.memoizedUpdaters;\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const updaters = pendingUpdatersLaneMap[index];\n\n    if (updaters.size > 0) {\n      updaters.forEach(fiber => {\n        const alternate = fiber.alternate;\n\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\nexport function addTransitionToLanesMap(root, transition, lane) {\n  if (enableTransitionTracing) {\n    const transitionLanesMap = root.transitionLanes;\n    const index = laneToIndex(lane);\n    let transitions = transitionLanesMap[index];\n\n    if (transitions === null) {\n      transitions = [];\n    }\n\n    transitions.push(transition);\n    transitionLanesMap[index] = transitions;\n  }\n}\nexport function getTransitionsForLanes(root, lanes) {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  const transitionsForLanes = [];\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const transitions = root.transitionLanes[index];\n\n    if (transitions !== null) {\n      transitions.forEach(transition => {\n        transitionsForLanes.push(transition);\n      });\n    }\n\n    lanes &= ~lane;\n  }\n\n  if (transitionsForLanes.length === 0) {\n    return null;\n  }\n\n  return transitionsForLanes;\n}\nexport function clearTransitionsForLanes(root, lanes) {\n  if (!enableTransitionTracing) {\n    return;\n  }\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const transitions = root.transitionLanes[index];\n\n    if (transitions !== null) {\n      root.transitionLanes[index] = null;\n    }\n\n    lanes &= ~lane;\n  }\n}","map":{"version":3,"names":["enableSchedulingProfiler","enableUpdaterTracking","allowConcurrentByDefault","enableTransitionTracing","isDevToolsPresent","ConcurrentUpdatesByDefaultMode","NoMode","clz32","TotalLanes","NoLanes","NoLane","SyncLane","InputContinuousHydrationLane","InputContinuousLane","DefaultHydrationLane","DefaultLane","TransitionHydrationLane","TransitionLanes","TransitionLane1","TransitionLane2","TransitionLane3","TransitionLane4","TransitionLane5","TransitionLane6","TransitionLane7","TransitionLane8","TransitionLane9","TransitionLane10","TransitionLane11","TransitionLane12","TransitionLane13","TransitionLane14","TransitionLane15","TransitionLane16","RetryLanes","RetryLane1","RetryLane2","RetryLane3","RetryLane4","RetryLane5","SomeRetryLane","SelectiveHydrationLane","NonIdleLanes","IdleHydrationLane","IdleLane","OffscreenLane","getLabelForLane","lane","NoTimestamp","nextTransitionLane","nextRetryLane","getHighestPriorityLanes","lanes","getHighestPriorityLane","__DEV__","console","error","getNextLanes","root","wipLanes","pendingLanes","nextLanes","suspendedLanes","pingedLanes","nonIdlePendingLanes","nonIdleUnblockedLanes","nonIdlePingedLanes","unblockedLanes","nextLane","wipLane","current","mode","entangledLanes","entanglements","index","pickArbitraryLaneIndex","getMostRecentEventTime","eventTimes","mostRecentEventTime","eventTime","computeExpirationTime","currentTime","markStarvedLanesAsExpired","expirationTimes","expirationTime","expiredLanes","getHighestPriorityPendingLanes","getLanesToRetrySynchronouslyOnError","everythingButOffscreen","includesSyncLane","includesNonIdleWork","includesOnlyRetries","includesOnlyNonUrgentLanes","UrgentLanes","includesOnlyTransitions","includesBlockingLane","SyncDefaultLanes","includesExpiredLane","isTransitionLane","claimNextTransitionLane","claimNextRetryLane","pickArbitraryLane","laneToIndex","includesSomeLane","a","b","isSubsetOfLanes","set","subset","mergeLanes","removeLanes","intersectLanes","laneToLanes","higherPriorityLane","createLaneMap","initial","laneMap","i","push","markRootUpdated","updateLane","markRootSuspended","markRootPinged","markRootMutableRead","mutableReadLanes","markRootFinished","remainingLanes","noLongerPendingLanes","markRootEntangled","rootEntangledLanes","getBumpedLaneForHydration","renderLanes","renderLane","addFiberToLanesMap","fiber","pendingUpdatersLaneMap","updaters","add","movePendingFibersToMemoized","memoizedUpdaters","size","forEach","alternate","has","clear","addTransitionToLanesMap","transition","transitionLanesMap","transitionLanes","transitions","getTransitionsForLanes","transitionsForLanes","length","clearTransitionsForLanes"],"sources":["E:/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberLane.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {FiberRoot} from './ReactInternalTypes';\r\nimport type {Transition} from './ReactFiberTracingMarkerComponent.old';\r\n\r\n// TODO: Ideally these types would be opaque but that doesn't work well with\r\n// our reconciler fork infra, since these leak into non-reconciler packages.\r\n\r\nexport type Lanes = number;\r\nexport type Lane = number;\r\nexport type LaneMap<T> = Array<T>;\r\n\r\nimport {\r\n  enableSchedulingProfiler,\r\n  enableUpdaterTracking,\r\n  allowConcurrentByDefault,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook.old';\r\nimport {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';\r\nimport {clz32} from './clz32';\r\n\r\n// Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\r\n// If those values are changed that package should be rebuilt and redeployed.\r\n\r\n// 更新任务的\r\nexport const TotalLanes = 31;\r\n\r\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\r\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\r\n\r\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;\r\n\r\nexport const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;\r\nexport const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;\r\n\r\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;\r\nexport const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;\r\n\r\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;\r\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;\r\nconst TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;\r\nconst TransitionLane2: Lane = /*                        */ 0b0000000000000000000000010000000;\r\nconst TransitionLane3: Lane = /*                        */ 0b0000000000000000000000100000000;\r\nconst TransitionLane4: Lane = /*                        */ 0b0000000000000000000001000000000;\r\nconst TransitionLane5: Lane = /*                        */ 0b0000000000000000000010000000000;\r\nconst TransitionLane6: Lane = /*                        */ 0b0000000000000000000100000000000;\r\nconst TransitionLane7: Lane = /*                        */ 0b0000000000000000001000000000000;\r\nconst TransitionLane8: Lane = /*                        */ 0b0000000000000000010000000000000;\r\nconst TransitionLane9: Lane = /*                        */ 0b0000000000000000100000000000000;\r\nconst TransitionLane10: Lane = /*                       */ 0b0000000000000001000000000000000;\r\nconst TransitionLane11: Lane = /*                       */ 0b0000000000000010000000000000000;\r\nconst TransitionLane12: Lane = /*                       */ 0b0000000000000100000000000000000;\r\nconst TransitionLane13: Lane = /*                       */ 0b0000000000001000000000000000000;\r\nconst TransitionLane14: Lane = /*                       */ 0b0000000000010000000000000000000;\r\nconst TransitionLane15: Lane = /*                       */ 0b0000000000100000000000000000000;\r\nconst TransitionLane16: Lane = /*                       */ 0b0000000001000000000000000000000;\r\n\r\nconst RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;\r\nconst RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;\r\nconst RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;\r\nconst RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;\r\nconst RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;\r\nconst RetryLane5: Lane = /*                             */ 0b0000100000000000000000000000000;\r\n\r\nexport const SomeRetryLane: Lane = RetryLane1;\r\n\r\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;\r\n\r\nconst NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;\r\n\r\nexport const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;\r\nexport const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;\r\n\r\nexport const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;\r\n\r\n// This function is used for the experimental timeline (react-devtools-timeline)\r\n// It should be kept in sync with the Lanes values above.\r\nexport function getLabelForLane(lane: Lane): string | void {\r\n  if (enableSchedulingProfiler) {\r\n    if (lane & SyncLane) {\r\n      return 'Sync';\r\n    }\r\n    if (lane & InputContinuousHydrationLane) {\r\n      return 'InputContinuousHydration';\r\n    }\r\n    if (lane & InputContinuousLane) {\r\n      return 'InputContinuous';\r\n    }\r\n    if (lane & DefaultHydrationLane) {\r\n      return 'DefaultHydration';\r\n    }\r\n    if (lane & DefaultLane) {\r\n      return 'Default';\r\n    }\r\n    if (lane & TransitionHydrationLane) {\r\n      return 'TransitionHydration';\r\n    }\r\n    if (lane & TransitionLanes) {\r\n      return 'Transition';\r\n    }\r\n    if (lane & RetryLanes) {\r\n      return 'Retry';\r\n    }\r\n    if (lane & SelectiveHydrationLane) {\r\n      return 'SelectiveHydration';\r\n    }\r\n    if (lane & IdleHydrationLane) {\r\n      return 'IdleHydration';\r\n    }\r\n    if (lane & IdleLane) {\r\n      return 'Idle';\r\n    }\r\n    if (lane & OffscreenLane) {\r\n      return 'Offscreen';\r\n    }\r\n  }\r\n}\r\n\r\nexport const NoTimestamp = -1;\r\n\r\nlet nextTransitionLane: Lane = TransitionLane1;\r\nlet nextRetryLane: Lane = RetryLane1;\r\n\r\nfunction getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {\r\n  switch (getHighestPriorityLane(lanes)) {\r\n    case SyncLane:\r\n      return SyncLane;\r\n    case InputContinuousHydrationLane:\r\n      return InputContinuousHydrationLane;\r\n    case InputContinuousLane:\r\n      return InputContinuousLane;\r\n    case DefaultHydrationLane:\r\n      return DefaultHydrationLane;\r\n    case DefaultLane:\r\n      return DefaultLane;\r\n    case TransitionHydrationLane:\r\n      return TransitionHydrationLane;\r\n    case TransitionLane1:\r\n    case TransitionLane2:\r\n    case TransitionLane3:\r\n    case TransitionLane4:\r\n    case TransitionLane5:\r\n    case TransitionLane6:\r\n    case TransitionLane7:\r\n    case TransitionLane8:\r\n    case TransitionLane9:\r\n    case TransitionLane10:\r\n    case TransitionLane11:\r\n    case TransitionLane12:\r\n    case TransitionLane13:\r\n    case TransitionLane14:\r\n    case TransitionLane15:\r\n    case TransitionLane16:\r\n      return lanes & TransitionLanes;\r\n    case RetryLane1:\r\n    case RetryLane2:\r\n    case RetryLane3:\r\n    case RetryLane4:\r\n    case RetryLane5:\r\n      return lanes & RetryLanes;\r\n    case SelectiveHydrationLane:\r\n      return SelectiveHydrationLane;\r\n    case IdleHydrationLane:\r\n      return IdleHydrationLane;\r\n    case IdleLane:\r\n      return IdleLane;\r\n    case OffscreenLane:\r\n      return OffscreenLane;\r\n    default:\r\n      if (__DEV__) {\r\n        console.error(\r\n          'Should have found matching lanes. This is a bug in React.',\r\n        );\r\n      }\r\n      // This shouldn't be reachable, but as a fallback, return the entire bitmask.\r\n      return lanes;\r\n  }\r\n}\r\n\r\nexport function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {\r\n  // Early bailout if there's no pending work left.\r\n  const pendingLanes = root.pendingLanes;\r\n  if (pendingLanes === NoLanes) {\r\n    return NoLanes;\r\n  }\r\n\r\n  let nextLanes = NoLanes;\r\n\r\n  const suspendedLanes = root.suspendedLanes;\r\n  const pingedLanes = root.pingedLanes;\r\n\r\n  // Do not work on any idle work until all the non-idle work has finished,\r\n  // even if the work is suspended.\r\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\r\n  if (nonIdlePendingLanes !== NoLanes) {\r\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\r\n    if (nonIdleUnblockedLanes !== NoLanes) {\r\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\r\n    } else {\r\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\r\n      if (nonIdlePingedLanes !== NoLanes) {\r\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\r\n      }\r\n    }\r\n  } else {\r\n    // The only remaining work is Idle.\r\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\r\n    if (unblockedLanes !== NoLanes) {\r\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\r\n    } else {\r\n      if (pingedLanes !== NoLanes) {\r\n        nextLanes = getHighestPriorityLanes(pingedLanes);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // This should only be reachable if we're suspended\r\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\r\n    return NoLanes;\r\n  }\r\n\r\n  // If we're already in the middle of a render, switching lanes will interrupt\r\n  // it and we'll lose our progress. We should only do this if the new lanes are\r\n  // higher priority.\r\n  if (\r\n    wipLanes !== NoLanes &&\r\n    wipLanes !== nextLanes &&\r\n    // If we already suspended with a delay, then interrupting is fine. Don't\r\n    // bother waiting until the root is complete.\r\n    (wipLanes & suspendedLanes) === NoLanes\r\n  ) {\r\n    const nextLane = getHighestPriorityLane(nextLanes);\r\n    const wipLane = getHighestPriorityLane(wipLanes);\r\n    if (\r\n      // Tests whether the next lane is equal or lower priority than the wip\r\n      // one. This works because the bits decrease in priority as you go left.\r\n      nextLane >= wipLane ||\r\n      // Default priority updates should not interrupt transition updates. The\r\n      // only difference between default updates and transition updates is that\r\n      // default updates do not support refresh transitions.\r\n      (nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes)\r\n    ) {\r\n      // Keep working on the existing in-progress tree. Do not interrupt.\r\n      return wipLanes;\r\n    }\r\n  }\r\n\r\n  if (\r\n    allowConcurrentByDefault &&\r\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\r\n  ) {\r\n    // Do nothing, use the lanes as they were assigned.\r\n  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {\r\n    // When updates are sync by default, we entangle continuous priority updates\r\n    // and default updates, so they render in the same batch. The only reason\r\n    // they use separate lanes is because continuous updates should interrupt\r\n    // transitions, but default updates should not.\r\n    nextLanes |= pendingLanes & DefaultLane;\r\n  }\r\n\r\n  // Check for entangled lanes and add them to the batch.\r\n  //\r\n  // A lane is said to be entangled with another when it's not allowed to render\r\n  // in a batch that does not also include the other lane. Typically we do this\r\n  // when multiple updates have the same source, and we only want to respond to\r\n  // the most recent event from that source.\r\n  //\r\n  // Note that we apply entanglements *after* checking for partial work above.\r\n  // This means that if a lane is entangled during an interleaved event while\r\n  // it's already rendering, we won't interrupt it. This is intentional, since\r\n  // entanglement is usually \"best effort\": we'll try our best to render the\r\n  // lanes in the same batch, but it's not worth throwing out partially\r\n  // completed work in order to do it.\r\n  // TODO: Reconsider this. The counter-argument is that the partial work\r\n  // represents an intermediate state, which we don't want to show to the user.\r\n  // And by spending extra time finishing it, we're increasing the amount of\r\n  // time it takes to show the final state, which is what they are actually\r\n  // waiting for.\r\n  //\r\n  // For those exceptions where entanglement is semantically important, like\r\n  // useMutableSource, we should ensure that there is no partial work at the\r\n  // time we apply the entanglement.\r\n  const entangledLanes = root.entangledLanes;\r\n  if (entangledLanes !== NoLanes) {\r\n    const entanglements = root.entanglements;\r\n    let lanes = nextLanes & entangledLanes;\r\n    while (lanes > 0) {\r\n      const index = pickArbitraryLaneIndex(lanes);\r\n      const lane = 1 << index;\r\n\r\n      nextLanes |= entanglements[index];\r\n\r\n      lanes &= ~lane;\r\n    }\r\n  }\r\n\r\n  return nextLanes;\r\n}\r\n\r\nexport function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {\r\n  const eventTimes = root.eventTimes;\r\n\r\n  let mostRecentEventTime = NoTimestamp;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const eventTime = eventTimes[index];\r\n    if (eventTime > mostRecentEventTime) {\r\n      mostRecentEventTime = eventTime;\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n\r\n  return mostRecentEventTime;\r\n}\r\n\r\nfunction computeExpirationTime(lane: Lane, currentTime: number) {\r\n  switch (lane) {\r\n    case SyncLane:\r\n    case InputContinuousHydrationLane:\r\n    case InputContinuousLane:\r\n      // User interactions should expire slightly more quickly.\r\n      //\r\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\r\n      // When we made it larger, a product metric in www regressed, suggesting\r\n      // there's a user interaction that's being starved by a series of\r\n      // synchronous updates. If that theory is correct, the proper solution is\r\n      // to fix the starvation. However, this scenario supports the idea that\r\n      // expiration times are an important safeguard when starvation\r\n      // does happen.\r\n      return currentTime + 250;\r\n    case DefaultHydrationLane:\r\n    case DefaultLane:\r\n    case TransitionHydrationLane:\r\n    case TransitionLane1:\r\n    case TransitionLane2:\r\n    case TransitionLane3:\r\n    case TransitionLane4:\r\n    case TransitionLane5:\r\n    case TransitionLane6:\r\n    case TransitionLane7:\r\n    case TransitionLane8:\r\n    case TransitionLane9:\r\n    case TransitionLane10:\r\n    case TransitionLane11:\r\n    case TransitionLane12:\r\n    case TransitionLane13:\r\n    case TransitionLane14:\r\n    case TransitionLane15:\r\n    case TransitionLane16:\r\n      return currentTime + 5000;\r\n    case RetryLane1:\r\n    case RetryLane2:\r\n    case RetryLane3:\r\n    case RetryLane4:\r\n    case RetryLane5:\r\n      // TODO: Retries should be allowed to expire if they are CPU bound for\r\n      // too long, but when I made this change it caused a spike in browser\r\n      // crashes. There must be some other underlying bug; not super urgent but\r\n      // ideally should figure out why and fix it. Unfortunately we don't have\r\n      // a repro for the crashes, only detected via production metrics.\r\n      return NoTimestamp;\r\n    case SelectiveHydrationLane:\r\n    case IdleHydrationLane:\r\n    case IdleLane:\r\n    case OffscreenLane:\r\n      // Anything idle priority or lower should never expire.\r\n      return NoTimestamp;\r\n    default:\r\n      if (__DEV__) {\r\n        console.error(\r\n          'Should have found matching lanes. This is a bug in React.',\r\n        );\r\n      }\r\n      return NoTimestamp;\r\n  }\r\n}\r\n\r\nexport function markStarvedLanesAsExpired(\r\n  root: FiberRoot,\r\n  currentTime: number,\r\n): void {\r\n  // TODO: This gets called every time we yield. We can optimize by storing\r\n  // the earliest expiration time on the root. Then use that to quickly bail out\r\n  // of this function.\r\n\r\n  const pendingLanes = root.pendingLanes;\r\n  const suspendedLanes = root.suspendedLanes;\r\n  const pingedLanes = root.pingedLanes;\r\n  const expirationTimes = root.expirationTimes;\r\n\r\n  // Iterate through the pending lanes and check if we've reached their\r\n  // expiration time. If so, we'll assume the update is being starved and mark\r\n  // it as expired to force it to finish.\r\n  let lanes = pendingLanes;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const expirationTime = expirationTimes[index];\r\n    if (expirationTime === NoTimestamp) {\r\n      // Found a pending lane with no expiration time. If it's not suspended, or\r\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\r\n      // using the current time.\r\n      if (\r\n        (lane & suspendedLanes) === NoLanes ||\r\n        (lane & pingedLanes) !== NoLanes\r\n      ) {\r\n        // Assumes timestamps are monotonically increasing.\r\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\r\n      }\r\n    } else if (expirationTime <= currentTime) {\r\n      // This lane expired\r\n      root.expiredLanes |= lane;\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\n// This returns the highest priority pending lanes regardless of whether they\r\n// are suspended.\r\nexport function getHighestPriorityPendingLanes(root: FiberRoot) {\r\n  return getHighestPriorityLanes(root.pendingLanes);\r\n}\r\n\r\nexport function getLanesToRetrySynchronouslyOnError(root: FiberRoot): Lanes {\r\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\r\n  if (everythingButOffscreen !== NoLanes) {\r\n    return everythingButOffscreen;\r\n  }\r\n  if (everythingButOffscreen & OffscreenLane) {\r\n    return OffscreenLane;\r\n  }\r\n  return NoLanes;\r\n}\r\n\r\nexport function includesSyncLane(lanes: Lanes) {\r\n  return (lanes & SyncLane) !== NoLanes;\r\n}\r\n\r\nexport function includesNonIdleWork(lanes: Lanes) {\r\n  return (lanes & NonIdleLanes) !== NoLanes;\r\n}\r\nexport function includesOnlyRetries(lanes: Lanes) {\r\n  return (lanes & RetryLanes) === lanes;\r\n}\r\nexport function includesOnlyNonUrgentLanes(lanes: Lanes) {\r\n  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\r\n  return (lanes & UrgentLanes) === NoLanes;\r\n}\r\nexport function includesOnlyTransitions(lanes: Lanes) {\r\n  return (lanes & TransitionLanes) === lanes;\r\n}\r\n\r\nexport function includesBlockingLane(root: FiberRoot, lanes: Lanes) {\r\n  if (\r\n    allowConcurrentByDefault &&\r\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\r\n  ) {\r\n    // Concurrent updates by default always use time slicing.\r\n    return false;\r\n  }\r\n  const SyncDefaultLanes =\r\n    InputContinuousHydrationLane |\r\n    InputContinuousLane |\r\n    DefaultHydrationLane |\r\n    DefaultLane;\r\n  return (lanes & SyncDefaultLanes) !== NoLanes;\r\n}\r\n\r\nexport function includesExpiredLane(root: FiberRoot, lanes: Lanes) {\r\n  // This is a separate check from includesBlockingLane because a lane can\r\n  // expire after a render has already started.\r\n  return (lanes & root.expiredLanes) !== NoLanes;\r\n}\r\n\r\nexport function isTransitionLane(lane: Lane) {\r\n  return (lane & TransitionLanes) !== NoLanes;\r\n}\r\n\r\nexport function claimNextTransitionLane(): Lane {\r\n  // Cycle through the lanes, assigning each new transition to the next lane.\r\n  // In most cases, this means every transition gets its own lane, until we\r\n  // run out of lanes and cycle back to the beginning.\r\n  const lane = nextTransitionLane;\r\n  nextTransitionLane <<= 1;\r\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\r\n    nextTransitionLane = TransitionLane1;\r\n  }\r\n  return lane;\r\n}\r\n\r\nexport function claimNextRetryLane(): Lane {\r\n  const lane = nextRetryLane;\r\n  nextRetryLane <<= 1;\r\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\r\n    nextRetryLane = RetryLane1;\r\n  }\r\n  return lane;\r\n}\r\n\r\nexport function getHighestPriorityLane(lanes: Lanes): Lane {\r\n  return lanes & -lanes;\r\n}\r\n\r\nexport function pickArbitraryLane(lanes: Lanes): Lane {\r\n  // This wrapper function gets inlined. Only exists so to communicate that it\r\n  // doesn't matter which bit is selected; you can pick any bit without\r\n  // affecting the algorithms where its used. Here I'm using\r\n  // getHighestPriorityLane because it requires the fewest operations.\r\n  return getHighestPriorityLane(lanes);\r\n}\r\n\r\nfunction pickArbitraryLaneIndex(lanes: Lanes) {\r\n  return 31 - clz32(lanes);\r\n}\r\n\r\nfunction laneToIndex(lane: Lane) {\r\n  return pickArbitraryLaneIndex(lane);\r\n}\r\n\r\nexport function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {\r\n  return (a & b) !== NoLanes;\r\n}\r\n\r\nexport function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {\r\n  return (set & subset) === subset;\r\n}\r\n\r\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\r\n  return a | b;\r\n}\r\n\r\nexport function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {\r\n  return set & ~subset;\r\n}\r\n\r\nexport function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\r\n  return a & b;\r\n}\r\n\r\n// Seems redundant, but it changes the type from a single lane (used for\r\n// updates) to a group of lanes (used for flushing work).\r\nexport function laneToLanes(lane: Lane): Lanes {\r\n  return lane;\r\n}\r\n\r\nexport function higherPriorityLane(a: Lane, b: Lane) {\r\n  // This works because the bit ranges decrease in priority as you go left.\r\n  return a !== NoLane && a < b ? a : b;\r\n}\r\n\r\nexport function createLaneMap<T>(initial: T): LaneMap<T> {\r\n  // Intentionally pushing one by one.\r\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\r\n  const laneMap = [];\r\n  for (let i = 0; i < TotalLanes; i++) {\r\n    laneMap.push(initial);\r\n  }\r\n  return laneMap;\r\n}\r\n\r\nexport function markRootUpdated(\r\n  root: FiberRoot,\r\n  updateLane: Lane,\r\n  eventTime: number,\r\n) {\r\n  root.pendingLanes |= updateLane;\r\n\r\n  // If there are any suspended transitions, it's possible this new update\r\n  // could unblock them. Clear the suspended lanes so that we can try rendering\r\n  // them again.\r\n  //\r\n  // TODO: We really only need to unsuspend only lanes that are in the\r\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\r\n  // path. This would exclude suspended updates in an unrelated sibling tree,\r\n  // since there's no way for this update to unblock it.\r\n  //\r\n  // We don't do this if the incoming update is idle, because we never process\r\n  // idle updates until after all the regular updates have finished; there's no\r\n  // way it could unblock a transition.\r\n  if (updateLane !== IdleLane) {\r\n    root.suspendedLanes = NoLanes;\r\n    root.pingedLanes = NoLanes;\r\n  }\r\n\r\n  const eventTimes = root.eventTimes;\r\n  const index = laneToIndex(updateLane);\r\n  // We can always overwrite an existing timestamp because we prefer the most\r\n  // recent event, and we assume time is monotonically increasing.\r\n  eventTimes[index] = eventTime;\r\n}\r\n\r\nexport function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {\r\n  root.suspendedLanes |= suspendedLanes;\r\n  root.pingedLanes &= ~suspendedLanes;\r\n\r\n  // The suspended lanes are no longer CPU-bound. Clear their expiration times.\r\n  const expirationTimes = root.expirationTimes;\r\n  let lanes = suspendedLanes;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    expirationTimes[index] = NoTimestamp;\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function markRootPinged(\r\n  root: FiberRoot,\r\n  pingedLanes: Lanes,\r\n  eventTime: number,\r\n) {\r\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\r\n}\r\n\r\nexport function markRootMutableRead(root: FiberRoot, updateLane: Lane) {\r\n  root.mutableReadLanes |= updateLane & root.pendingLanes;\r\n}\r\n\r\nexport function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {\r\n  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\r\n\r\n  root.pendingLanes = remainingLanes;\r\n\r\n  // Let's try everything again\r\n  root.suspendedLanes = NoLanes;\r\n  root.pingedLanes = NoLanes;\r\n\r\n  root.expiredLanes &= remainingLanes;\r\n  root.mutableReadLanes &= remainingLanes;\r\n\r\n  root.entangledLanes &= remainingLanes;\r\n\r\n  const entanglements = root.entanglements;\r\n  const eventTimes = root.eventTimes;\r\n  const expirationTimes = root.expirationTimes;\r\n\r\n  // Clear the lanes that no longer have pending work\r\n  let lanes = noLongerPendingLanes;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    entanglements[index] = NoLanes;\r\n    eventTimes[index] = NoTimestamp;\r\n    expirationTimes[index] = NoTimestamp;\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {\r\n  // In addition to entangling each of the given lanes with each other, we also\r\n  // have to consider _transitive_ entanglements. For each lane that is already\r\n  // entangled with *any* of the given lanes, that lane is now transitively\r\n  // entangled with *all* the given lanes.\r\n  //\r\n  // Translated: If C is entangled with A, then entangling A with B also\r\n  // entangles C with B.\r\n  //\r\n  // If this is hard to grasp, it might help to intentionally break this\r\n  // function and look at the tests that fail in ReactTransition-test.js. Try\r\n  // commenting out one of the conditions below.\r\n\r\n  const rootEntangledLanes = (root.entangledLanes |= entangledLanes);\r\n  const entanglements = root.entanglements;\r\n  let lanes = rootEntangledLanes;\r\n  while (lanes) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n    if (\r\n      // Is this one of the newly entangled lanes?\r\n      (lane & entangledLanes) |\r\n      // Is this lane transitively entangled with the newly entangled lanes?\r\n      (entanglements[index] & entangledLanes)\r\n    ) {\r\n      entanglements[index] |= entangledLanes;\r\n    }\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function getBumpedLaneForHydration(\r\n  root: FiberRoot,\r\n  renderLanes: Lanes,\r\n): Lane {\r\n  const renderLane = getHighestPriorityLane(renderLanes);\r\n\r\n  let lane;\r\n  switch (renderLane) {\r\n    case InputContinuousLane:\r\n      lane = InputContinuousHydrationLane;\r\n      break;\r\n    case DefaultLane:\r\n      lane = DefaultHydrationLane;\r\n      break;\r\n    case TransitionLane1:\r\n    case TransitionLane2:\r\n    case TransitionLane3:\r\n    case TransitionLane4:\r\n    case TransitionLane5:\r\n    case TransitionLane6:\r\n    case TransitionLane7:\r\n    case TransitionLane8:\r\n    case TransitionLane9:\r\n    case TransitionLane10:\r\n    case TransitionLane11:\r\n    case TransitionLane12:\r\n    case TransitionLane13:\r\n    case TransitionLane14:\r\n    case TransitionLane15:\r\n    case TransitionLane16:\r\n    case RetryLane1:\r\n    case RetryLane2:\r\n    case RetryLane3:\r\n    case RetryLane4:\r\n    case RetryLane5:\r\n      lane = TransitionHydrationLane;\r\n      break;\r\n    case IdleLane:\r\n      lane = IdleHydrationLane;\r\n      break;\r\n    default:\r\n      // Everything else is already either a hydration lane, or shouldn't\r\n      // be retried at a hydration lane.\r\n      lane = NoLane;\r\n      break;\r\n  }\r\n\r\n  // Check if the lane we chose is suspended. If so, that indicates that we\r\n  // already attempted and failed to hydrate at that level. Also check if we're\r\n  // already rendering that lane, which is rare but could happen.\r\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\r\n    // Give up trying to hydrate and fall back to client render.\r\n    return NoLane;\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nexport function addFiberToLanesMap(\r\n  root: FiberRoot,\r\n  fiber: Fiber,\r\n  lanes: Lanes | Lane,\r\n) {\r\n  if (!enableUpdaterTracking) {\r\n    return;\r\n  }\r\n  if (!isDevToolsPresent) {\r\n    return;\r\n  }\r\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const updaters = pendingUpdatersLaneMap[index];\r\n    updaters.add(fiber);\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function movePendingFibersToMemoized(root: FiberRoot, lanes: Lanes) {\r\n  if (!enableUpdaterTracking) {\r\n    return;\r\n  }\r\n  if (!isDevToolsPresent) {\r\n    return;\r\n  }\r\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\r\n  const memoizedUpdaters = root.memoizedUpdaters;\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const updaters = pendingUpdatersLaneMap[index];\r\n    if (updaters.size > 0) {\r\n      updaters.forEach(fiber => {\r\n        const alternate = fiber.alternate;\r\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\r\n          memoizedUpdaters.add(fiber);\r\n        }\r\n      });\r\n      updaters.clear();\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function addTransitionToLanesMap(\r\n  root: FiberRoot,\r\n  transition: Transition,\r\n  lane: Lane,\r\n) {\r\n  if (enableTransitionTracing) {\r\n    const transitionLanesMap = root.transitionLanes;\r\n    const index = laneToIndex(lane);\r\n    let transitions = transitionLanesMap[index];\r\n    if (transitions === null) {\r\n      transitions = [];\r\n    }\r\n    transitions.push(transition);\r\n\r\n    transitionLanesMap[index] = transitions;\r\n  }\r\n}\r\n\r\nexport function getTransitionsForLanes(\r\n  root: FiberRoot,\r\n  lanes: Lane | Lanes,\r\n): Array<Transition> | null {\r\n  if (!enableTransitionTracing) {\r\n    return null;\r\n  }\r\n\r\n  const transitionsForLanes = [];\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n    const transitions = root.transitionLanes[index];\r\n    if (transitions !== null) {\r\n      transitions.forEach(transition => {\r\n        transitionsForLanes.push(transition);\r\n      });\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n\r\n  if (transitionsForLanes.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return transitionsForLanes;\r\n}\r\n\r\nexport function clearTransitionsForLanes(root: FiberRoot, lanes: Lane | Lanes) {\r\n  if (!enableTransitionTracing) {\r\n    return;\r\n  }\r\n\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const transitions = root.transitionLanes[index];\r\n    if (transitions !== null) {\r\n      root.transitionLanes[index] = null;\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}