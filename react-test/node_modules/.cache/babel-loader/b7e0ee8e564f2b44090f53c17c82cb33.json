{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { isFiberMounted } from './ReactFiberTreeReflection';\nimport { disableLegacyContext } from 'shared/ReactFeatureFlags';\nimport { ClassComponent, HostRoot } from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport checkPropTypes from 'shared/checkPropTypes';\nimport { createCursor, push, pop } from './ReactFiberStack.old';\nlet warnedAboutMissingGetChildContext;\n\nif (__DEV__) {\n  warnedAboutMissingGetChildContext = {};\n}\n\nexport const emptyContextObject = {};\n\nif (__DEV__) {\n  Object.freeze(emptyContextObject);\n} // A cursor to the current merged context object on the stack.\n\n\nconst contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n\nconst didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\n\nlet previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    const type = workInProgress.type;\n    const contextTypes = type.contextTypes;\n\n    if (!contextTypes) {\n      return emptyContextObject;\n    } // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n    const instance = workInProgress.stateNode;\n\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    const context = {};\n\n    for (const key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    if (__DEV__) {\n      const name = getComponentNameFromFiber(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name);\n    } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n\n\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged() {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type) {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    if (contextStackCursor.current !== emptyContextObject) {\n      throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  if (disableLegacyContext) {\n    return parentContext;\n  } else {\n    const instance = fiber.stateNode;\n    const childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n    if (typeof instance.getChildContext !== 'function') {\n      if (__DEV__) {\n        const componentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          console.error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n\n      return parentContext;\n    }\n\n    const childContext = instance.getChildContext();\n\n    for (const contextKey in childContext) {\n      if (!(contextKey in childContextTypes)) {\n        throw new Error(`${getComponentNameFromFiber(fiber) || 'Unknown'}.getChildContext(): key \"${contextKey}\" is not defined in childContextTypes.`);\n      }\n    }\n\n    if (__DEV__) {\n      const name = getComponentNameFromFiber(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\n    }\n\n    return { ...parentContext,\n      ...childContext\n    };\n  }\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n\n    const memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n\n    if (!instance) {\n      throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      const mergedContext = processChildContext(workInProgress, type, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n      throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    let node = fiber;\n\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n\n        case ClassComponent:\n          {\n            const Component = node.type;\n\n            if (isContextProvider(Component)) {\n              return node.stateNode.__reactInternalMemoizedMergedChildContext;\n            }\n\n            break;\n          }\n      }\n\n      node = node.return;\n    } while (node !== null);\n\n    throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nexport { getUnmaskedContext, cacheContext, getMaskedContext, hasContextChanged, popContext, popTopLevelContextObject, pushTopLevelContextObject, processChildContext, isContextProvider, pushContextProvider, invalidateContextProvider, findCurrentUnmaskedContext };","map":{"version":3,"names":["isFiberMounted","disableLegacyContext","ClassComponent","HostRoot","getComponentNameFromFiber","checkPropTypes","createCursor","push","pop","warnedAboutMissingGetChildContext","__DEV__","emptyContextObject","Object","freeze","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","workInProgress","Component","didPushOwnContextIfProvider","isContextProvider","current","cacheContext","unmaskedContext","maskedContext","instance","stateNode","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","type","contextTypes","context","key","name","hasContextChanged","childContextTypes","undefined","popContext","fiber","popTopLevelContextObject","pushTopLevelContextObject","didChange","Error","processChildContext","parentContext","getChildContext","componentName","console","error","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","findCurrentUnmaskedContext","tag","node","return"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberContext.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {StackCursor} from './ReactFiberStack.old';\r\n\r\nimport {isFiberMounted} from './ReactFiberTreeReflection';\r\nimport {disableLegacyContext} from 'shared/ReactFeatureFlags';\r\nimport {ClassComponent, HostRoot} from './ReactWorkTags';\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport checkPropTypes from 'shared/checkPropTypes';\r\n\r\nimport {createCursor, push, pop} from './ReactFiberStack.old';\r\n\r\nlet warnedAboutMissingGetChildContext;\r\n\r\nif (__DEV__) {\r\n  warnedAboutMissingGetChildContext = {};\r\n}\r\n\r\nexport const emptyContextObject = {};\r\nif (__DEV__) {\r\n  Object.freeze(emptyContextObject);\r\n}\r\n\r\n// A cursor to the current merged context object on the stack.\r\nconst contextStackCursor: StackCursor<Object> = createCursor(\r\n  emptyContextObject,\r\n);\r\n// A cursor to a boolean indicating whether the context has changed.\r\nconst didPerformWorkStackCursor: StackCursor<boolean> = createCursor(false);\r\n// Keep track of the previous context object that was on the stack.\r\n// We use this to get access to the parent context after we have already\r\n// pushed the next context provider, and now need to merge their contexts.\r\nlet previousContext: Object = emptyContextObject;\r\n\r\nfunction getUnmaskedContext(\r\n  workInProgress: Fiber,\r\n  Component: Function,\r\n  didPushOwnContextIfProvider: boolean,\r\n): Object {\r\n  if (disableLegacyContext) {\r\n    return emptyContextObject;\r\n  } else {\r\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\r\n      // If the fiber is a context provider itself, when we read its context\r\n      // we may have already pushed its own child context on the stack. A context\r\n      // provider should not \"see\" its own child context. Therefore we read the\r\n      // previous (parent) context instead for a context provider.\r\n      return previousContext;\r\n    }\r\n    return contextStackCursor.current;\r\n  }\r\n}\r\n\r\nfunction cacheContext(\r\n  workInProgress: Fiber,\r\n  unmaskedContext: Object,\r\n  maskedContext: Object,\r\n): void {\r\n  if (disableLegacyContext) {\r\n    return;\r\n  } else {\r\n    const instance = workInProgress.stateNode;\r\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\r\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\r\n  }\r\n}\r\n\r\nfunction getMaskedContext(\r\n  workInProgress: Fiber,\r\n  unmaskedContext: Object,\r\n): Object {\r\n  if (disableLegacyContext) {\r\n    return emptyContextObject;\r\n  } else {\r\n    const type = workInProgress.type;\r\n    const contextTypes = type.contextTypes;\r\n    if (!contextTypes) {\r\n      return emptyContextObject;\r\n    }\r\n\r\n    // Avoid recreating masked context unless unmasked context has changed.\r\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\r\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\r\n    const instance = workInProgress.stateNode;\r\n    if (\r\n      instance &&\r\n      instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\r\n    ) {\r\n      return instance.__reactInternalMemoizedMaskedChildContext;\r\n    }\r\n\r\n    const context = {};\r\n    for (const key in contextTypes) {\r\n      context[key] = unmaskedContext[key];\r\n    }\r\n\r\n    if (__DEV__) {\r\n      const name = getComponentNameFromFiber(workInProgress) || 'Unknown';\r\n      checkPropTypes(contextTypes, context, 'context', name);\r\n    }\r\n\r\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\r\n    // Context is created before the class component is instantiated so check for instance.\r\n    if (instance) {\r\n      cacheContext(workInProgress, unmaskedContext, context);\r\n    }\r\n\r\n    return context;\r\n  }\r\n}\r\n\r\nfunction hasContextChanged(): boolean {\r\n  if (disableLegacyContext) {\r\n    return false;\r\n  } else {\r\n    return didPerformWorkStackCursor.current;\r\n  }\r\n}\r\n\r\nfunction isContextProvider(type: Function): boolean {\r\n  if (disableLegacyContext) {\r\n    return false;\r\n  } else {\r\n    const childContextTypes = type.childContextTypes;\r\n    return childContextTypes !== null && childContextTypes !== undefined;\r\n  }\r\n}\r\n\r\nfunction popContext(fiber: Fiber): void {\r\n  if (disableLegacyContext) {\r\n    return;\r\n  } else {\r\n    pop(didPerformWorkStackCursor, fiber);\r\n    pop(contextStackCursor, fiber);\r\n  }\r\n}\r\n\r\nfunction popTopLevelContextObject(fiber: Fiber): void {\r\n  if (disableLegacyContext) {\r\n    return;\r\n  } else {\r\n    pop(didPerformWorkStackCursor, fiber);\r\n    pop(contextStackCursor, fiber);\r\n  }\r\n}\r\n\r\nfunction pushTopLevelContextObject(\r\n  fiber: Fiber,\r\n  context: Object,\r\n  didChange: boolean,\r\n): void {\r\n  if (disableLegacyContext) {\r\n    return;\r\n  } else {\r\n    if (contextStackCursor.current !== emptyContextObject) {\r\n      throw new Error(\r\n        'Unexpected context found on stack. ' +\r\n          'This error is likely caused by a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n\r\n    push(contextStackCursor, context, fiber);\r\n    push(didPerformWorkStackCursor, didChange, fiber);\r\n  }\r\n}\r\n\r\nfunction processChildContext(\r\n  fiber: Fiber,\r\n  type: any,\r\n  parentContext: Object,\r\n): Object {\r\n  if (disableLegacyContext) {\r\n    return parentContext;\r\n  } else {\r\n    const instance = fiber.stateNode;\r\n    const childContextTypes = type.childContextTypes;\r\n\r\n    // TODO (bvaughn) Replace this behavior with an invariant() in the future.\r\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\r\n    if (typeof instance.getChildContext !== 'function') {\r\n      if (__DEV__) {\r\n        const componentName = getComponentNameFromFiber(fiber) || 'Unknown';\r\n\r\n        if (!warnedAboutMissingGetChildContext[componentName]) {\r\n          warnedAboutMissingGetChildContext[componentName] = true;\r\n          console.error(\r\n            '%s.childContextTypes is specified but there is no getChildContext() method ' +\r\n              'on the instance. You can either define getChildContext() on %s or remove ' +\r\n              'childContextTypes from it.',\r\n            componentName,\r\n            componentName,\r\n          );\r\n        }\r\n      }\r\n      return parentContext;\r\n    }\r\n\r\n    const childContext = instance.getChildContext();\r\n    for (const contextKey in childContext) {\r\n      if (!(contextKey in childContextTypes)) {\r\n        throw new Error(\r\n          `${getComponentNameFromFiber(fiber) ||\r\n            'Unknown'}.getChildContext(): key \"${contextKey}\" is not defined in childContextTypes.`,\r\n        );\r\n      }\r\n    }\r\n    if (__DEV__) {\r\n      const name = getComponentNameFromFiber(fiber) || 'Unknown';\r\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\r\n    }\r\n\r\n    return {...parentContext, ...childContext};\r\n  }\r\n}\r\n\r\nfunction pushContextProvider(workInProgress: Fiber): boolean {\r\n  if (disableLegacyContext) {\r\n    return false;\r\n  } else {\r\n    const instance = workInProgress.stateNode;\r\n    // We push the context as early as possible to ensure stack integrity.\r\n    // If the instance does not exist yet, we will push null at first,\r\n    // and replace it on the stack later when invalidating the context.\r\n    const memoizedMergedChildContext =\r\n      (instance && instance.__reactInternalMemoizedMergedChildContext) ||\r\n      emptyContextObject;\r\n\r\n    // Remember the parent context so we can merge with it later.\r\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\r\n    previousContext = contextStackCursor.current;\r\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\r\n    push(\r\n      didPerformWorkStackCursor,\r\n      didPerformWorkStackCursor.current,\r\n      workInProgress,\r\n    );\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction invalidateContextProvider(\r\n  workInProgress: Fiber,\r\n  type: any,\r\n  didChange: boolean,\r\n): void {\r\n  if (disableLegacyContext) {\r\n    return;\r\n  } else {\r\n    const instance = workInProgress.stateNode;\r\n\r\n    if (!instance) {\r\n      throw new Error(\r\n        'Expected to have an instance by this point. ' +\r\n          'This error is likely caused by a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n\r\n    if (didChange) {\r\n      // Merge parent and own context.\r\n      // Skip this if we're not updating due to sCU.\r\n      // This avoids unnecessarily recomputing memoized values.\r\n      const mergedContext = processChildContext(\r\n        workInProgress,\r\n        type,\r\n        previousContext,\r\n      );\r\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext;\r\n\r\n      // Replace the old (or empty) context with the new one.\r\n      // It is important to unwind the context in the reverse order.\r\n      pop(didPerformWorkStackCursor, workInProgress);\r\n      pop(contextStackCursor, workInProgress);\r\n      // Now push the new context and mark that it has changed.\r\n      push(contextStackCursor, mergedContext, workInProgress);\r\n      push(didPerformWorkStackCursor, didChange, workInProgress);\r\n    } else {\r\n      pop(didPerformWorkStackCursor, workInProgress);\r\n      push(didPerformWorkStackCursor, didChange, workInProgress);\r\n    }\r\n  }\r\n}\r\n\r\nfunction findCurrentUnmaskedContext(fiber: Fiber): Object {\r\n  if (disableLegacyContext) {\r\n    return emptyContextObject;\r\n  } else {\r\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\r\n    // makes sense elsewhere\r\n    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\r\n      throw new Error(\r\n        'Expected subtree parent to be a mounted class component. ' +\r\n          'This error is likely caused by a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n\r\n    let node = fiber;\r\n    do {\r\n      switch (node.tag) {\r\n        case HostRoot:\r\n          return node.stateNode.context;\r\n        case ClassComponent: {\r\n          const Component = node.type;\r\n          if (isContextProvider(Component)) {\r\n            return node.stateNode.__reactInternalMemoizedMergedChildContext;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n      node = node.return;\r\n    } while (node !== null);\r\n\r\n    throw new Error(\r\n      'Found unexpected detached subtree parent. ' +\r\n        'This error is likely caused by a bug in React. Please file an issue.',\r\n    );\r\n  }\r\n}\r\n\r\nexport {\r\n  getUnmaskedContext,\r\n  cacheContext,\r\n  getMaskedContext,\r\n  hasContextChanged,\r\n  popContext,\r\n  popTopLevelContextObject,\r\n  pushTopLevelContextObject,\r\n  processChildContext,\r\n  isContextProvider,\r\n  pushContextProvider,\r\n  invalidateContextProvider,\r\n  findCurrentUnmaskedContext,\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}