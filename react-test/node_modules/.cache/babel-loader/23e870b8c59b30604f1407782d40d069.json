{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { precacheFiberNode, updateFiberProps, getClosestInstanceFromNode, getFiberFromScopeInstance, getInstanceFromNode as getInstanceFromNodeDOMTree, isContainerMarkedAsRoot } from './ReactDOMComponentTree';\nexport { detachDeletedInstance } from './ReactDOMComponentTree';\nimport { hasRole } from './DOMAccessibilityRoles';\nimport { createElement, createTextNode, setInitialProperties, diffProperties, updateProperties, diffHydratedProperties, diffHydratedText, trapClickOnNonInteractiveElement, checkForUnmatchedText, warnForDeletedHydratableElement, warnForDeletedHydratableText, warnForInsertedHydratedElement, warnForInsertedHydratedText } from './ReactDOMComponent';\nimport { getSelectionInformation, restoreSelection } from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport { validateDOMNesting, updatedAncestorInfo } from './validateDOMNesting';\nimport { isEnabled as ReactBrowserEventEmitterIsEnabled, setEnabled as ReactBrowserEventEmitterSetEnabled, getEventPriority } from '../events/ReactDOMEventListener';\nimport { getChildNamespace } from '../shared/DOMNamespaces';\nimport { ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE } from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\nimport { retryIfBlockedOn } from '../events/ReactDOMEventReplaying';\nimport { enableCreateEventHandleAPI, enableScopeAPI } from 'shared/ReactFeatureFlags';\nimport { HostComponent, HostText } from 'react-reconciler/src/ReactWorkTags';\nimport { listenToAllSupportedEvents } from '../events/DOMPluginEventSystem';\nimport { DefaultEventPriority } from 'react-reconciler/src/ReactEventPriorities'; // TODO: Remove this deep import when we delete the legacy root API\n\nimport { ConcurrentMode, NoMode } from 'react-reconciler/src/ReactTypeOfMode';\nconst SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\nconst STYLE = 'style';\nlet eventsEnabled = null;\nlet selectionInformation = null;\nexport * from 'react-reconciler/src/ReactFiberHostConfigWithNoPersistence';\nexport function getRootHostContext(rootContainerInstance) {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        const root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n\n    default:\n      {\n        const container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        const ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  return namespace;\n}\nexport function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  if (__DEV__) {\n    const parentHostContextDev = parentHostContext;\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  const parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\nexport function getPublicInstance(instance) {\n  return instance;\n}\nexport function prepareForCommit(containerInfo) {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  let activeInstance = null;\n\n  if (enableCreateEventHandleAPI) {\n    const focusedElem = selectionInformation.focusedElem;\n\n    if (focusedElem !== null) {\n      activeInstance = getClosestInstanceFromNode(focusedElem);\n    }\n  }\n\n  ReactBrowserEventEmitterSetEnabled(false);\n  return activeInstance;\n}\nexport function beforeActiveInstanceBlur(internalInstanceHandle) {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchBeforeDetachedBlur(selectionInformation.focusedElem, internalInstanceHandle);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\nexport function afterActiveInstanceBlur() {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchAfterDetachedBlur(selectionInformation.focusedElem);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\nexport function resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n  selectionInformation = null;\n}\nexport function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  let parentNamespace;\n\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = hostContext;\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  const domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\nexport function appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n\n    case 'img':\n      return true;\n\n    default:\n      return false;\n  }\n}\nexport function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n\n  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n}\nexport function shouldSetTextContent(type, props) {\n  return type === 'textarea' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n}\nexport function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n\n  const textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\nexport function getCurrentEventPriority() {\n  const currentEvent = window.event;\n\n  if (currentEvent === undefined) {\n    return DefaultEventPriority;\n  }\n\n  return getEventPriority(currentEvent.type);\n}\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true; // This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n\nexport const scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nexport const cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\nexport const noTimeout = -1;\nconst localPromise = typeof Promise === 'function' ? Promise : undefined; // -------------------\n//     Microtasks\n// -------------------\n\nexport const supportsMicrotasks = true;\nexport const scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : typeof localPromise !== 'undefined' ? callback => localPromise.resolve(null).then(callback).catch(handleErrorInNextTick) : scheduleTimeout; // TODO: Determine the best fallback here.\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n} // -------------------\n//     Mutation\n// -------------------\n\n\nexport const supportsMutation = true;\nexport function commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      if (newProps.autoFocus) {\n        domElement.focus();\n      }\n\n      return;\n\n    case 'img':\n      {\n        if (newProps.src) {\n          domElement.src = newProps.src;\n        }\n\n        return;\n      }\n  }\n}\nexport function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps); // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n\n  updateFiberProps(domElement, newProps);\n}\nexport function resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\nexport function commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\nexport function appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function appendChildToContainer(container, child) {\n  let parentNode;\n\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = container.parentNode;\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  } // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n\n\n  const reactRootContainer = container._reactRootContainer;\n\n  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(parentNode);\n  }\n}\nexport function insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\nexport function insertInContainerBefore(container, child, beforeChild) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction createEvent(type, bubbles) {\n  const event = document.createEvent('Event');\n  event.initEvent(type, bubbles, false);\n  return event;\n}\n\nfunction dispatchBeforeDetachedBlur(target, internalInstanceHandle) {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('beforeblur', true); // Dispatch \"beforeblur\" directly on the target,\n    // so it gets picked up by the event system and\n    // can propagate through the React internal tree.\n    // $FlowFixMe: internal field\n\n    event._detachedInterceptFiber = internalInstanceHandle;\n    target.dispatchEvent(event);\n  }\n}\n\nfunction dispatchAfterDetachedBlur(target) {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('afterblur', false); // So we know what was detached, make the relatedTarget the\n    // detached target on the \"afterblur\" event.\n\n    event.relatedTarget = target; // Dispatch the event on the document.\n\n    document.dispatchEvent(event);\n  }\n}\n\nexport function removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\nexport function removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\nexport function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  let node = suspenseInstance; // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  do {\n    const nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      const data = nextNode.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode); // Retry if any event replaying was blocked on this.\n\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = nextNode;\n  } while (node); // TODO: Warn, we didn't find the end comment boundary.\n  // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(suspenseInstance);\n}\nexport function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary(container.parentNode, suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary(container, suspenseInstance);\n  } else {// Document nodes should never contain suspense boundaries.\n  } // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(container);\n}\nexport function hideInstance(instance) {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = instance;\n  const style = instance.style;\n\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\nexport function hideTextInstance(textInstance) {\n  textInstance.nodeValue = '';\n}\nexport function unhideInstance(instance, props) {\n  instance = instance;\n  const styleProp = props[STYLE];\n  const display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\nexport function unhideTextInstance(textInstance, text) {\n  textInstance.nodeValue = text;\n}\nexport function clearContainer(container) {\n  if (container.nodeType === ELEMENT_NODE) {\n    container.textContent = '';\n  } else if (container.nodeType === DOCUMENT_NODE) {\n    const body = container.body;\n\n    if (body != null) {\n      body.textContent = '';\n    }\n  }\n} // -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\nexport function canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  } // This has now been refined to an element node.\n\n\n  return instance;\n}\nexport function canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a text node.\n\n\n  return instance;\n}\nexport function canHydrateSuspenseInstance(instance) {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a suspense node.\n\n\n  return instance;\n}\nexport function isSuspenseInstancePending(instance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\nexport function isSuspenseInstanceFallback(instance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\nexport function registerSuspenseInstanceRetry(instance, callback) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n      break;\n    }\n\n    if (nodeType === COMMENT_NODE) {\n      const nodeData = node.data;\n\n      if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n        break;\n      }\n\n      if (nodeData === SUSPENSE_END_DATA) {\n        return null;\n      }\n    }\n  }\n\n  return node;\n}\n\nexport function getNextHydratableSibling(instance) {\n  return getNextHydratable(instance.nextSibling);\n}\nexport function getFirstHydratableChild(parentInstance) {\n  return getNextHydratable(parentInstance.firstChild);\n}\nexport function getFirstHydratableChildWithinContainer(parentContainer) {\n  return getNextHydratable(parentContainer.firstChild);\n}\nexport function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {\n  return getNextHydratable(parentInstance.nextSibling);\n}\nexport function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {\n  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n\n  updateFiberProps(instance, props);\n  let parentNamespace;\n\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  } // TODO: Temporary hack to check if we're in a concurrent root. We can delete\n  // when the legacy root API is removed.\n\n\n  const isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);\n}\nexport function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {\n  precacheFiberNode(internalInstanceHandle, textInstance); // TODO: Temporary hack to check if we're in a concurrent root. We can delete\n  // when the legacy root API is removed.\n\n  const isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n  return diffHydratedText(textInstance, text, isConcurrentMode);\n}\nexport function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\nexport function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n  let node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = node.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling(node);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.nextSibling;\n  } // TODO: Warn, we didn't find the end comment boundary.\n\n\n  return null;\n} // Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\n\nexport function getParentSuspenseInstance(targetInstance) {\n  let node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = node.data;\n\n      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        if (depth === 0) {\n          return node;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.previousSibling;\n  }\n\n  return null;\n}\nexport function commitHydratedContainer(container) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\nexport function commitHydratedSuspenseInstance(suspenseInstance) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\nexport function shouldDeleteUnhydratedTailInstances(parentType) {\n  return parentType !== 'head' && parentType !== 'body';\n}\nexport function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {\n  const shouldWarnDev = true;\n  checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n}\nexport function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {\n  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    const shouldWarnDev = true;\n    checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n  }\n}\nexport function didNotHydrateInstanceWithinContainer(parentContainer, instance) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\nexport function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n\n    if (parentNode !== null) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentNode, instance);\n      } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentNode, instance);\n      }\n    }\n  }\n}\nexport function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentInstance, instance);\n      } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentInstance, instance);\n      }\n    }\n  }\n}\nexport function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer) {\n  if (__DEV__) {// TODO: warnForInsertedHydratedSuspense(parentContainer);\n  }\n}\nexport function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(parentInstance) {\n  if (__DEV__) {// const parentNode: Element | Document | null = parentInstance.parentNode;\n    // TODO: warnForInsertedHydratedSuspense(parentNode);\n  }\n}\nexport function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      warnForInsertedHydratedElement(parentInstance, type, props);\n    }\n  }\n}\nexport function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      warnForInsertedHydratedText(parentInstance, text);\n    }\n  }\n}\nexport function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {\n  if (__DEV__) {// TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\nexport function errorHydratingContainer(parentContainer) {\n  if (__DEV__) {\n    // TODO: This gets logged by onRecoverableError, too, so we should be\n    // able to remove it.\n    console.error('An error occurred during hydration. The server HTML was replaced with client content in <%s>.', parentContainer.nodeName.toLowerCase());\n  }\n}\nexport function getInstanceFromNode(node) {\n  return getClosestInstanceFromNode(node) || null;\n}\nexport function preparePortalMount(portalInstance) {\n  listenToAllSupportedEvents(portalInstance);\n}\nexport function prepareScopeUpdate(scopeInstance, internalInstanceHandle) {\n  if (enableScopeAPI) {\n    precacheFiberNode(internalInstanceHandle, scopeInstance);\n  }\n}\nexport function getInstanceFromScope(scopeInstance) {\n  if (enableScopeAPI) {\n    return getFiberFromScopeInstance(scopeInstance);\n  }\n\n  return null;\n}\nexport const supportsTestSelectors = true;\nexport function findFiberRoot(node) {\n  const stack = [node];\n  let index = 0;\n\n  while (index < stack.length) {\n    const current = stack[index++];\n\n    if (isContainerMarkedAsRoot(current)) {\n      return getInstanceFromNodeDOMTree(current);\n    }\n\n    stack.push(...current.children);\n  }\n\n  return null;\n}\nexport function getBoundingRect(node) {\n  const rect = node.getBoundingClientRect();\n  return {\n    x: rect.left,\n    y: rect.top,\n    width: rect.width,\n    height: rect.height\n  };\n}\nexport function matchAccessibilityRole(node, role) {\n  if (hasRole(node, role)) {\n    return true;\n  }\n\n  return false;\n}\nexport function getTextContent(fiber) {\n  switch (fiber.tag) {\n    case HostComponent:\n      let textContent = '';\n      const childNodes = fiber.stateNode.childNodes;\n\n      for (let i = 0; i < childNodes.length; i++) {\n        const childNode = childNodes[i];\n\n        if (childNode.nodeType === Node.TEXT_NODE) {\n          textContent += childNode.textContent;\n        }\n      }\n\n      return textContent;\n\n    case HostText:\n      return fiber.stateNode.textContent;\n  }\n\n  return null;\n}\nexport function isHiddenSubtree(fiber) {\n  return fiber.tag === HostComponent && fiber.memoizedProps.hidden === true;\n}\nexport function setFocusIfFocusable(node) {\n  // The logic for determining if an element is focusable is kind of complex,\n  // and since we want to actually change focus anyway- we can just skip it.\n  // Instead we'll just listen for a \"focus\" event to verify that focus was set.\n  //\n  // We could compare the node to document.activeElement after focus,\n  // but this would not handle the case where application code managed focus to automatically blur.\n  let didFocus = false;\n\n  const handleFocus = () => {\n    didFocus = true;\n  };\n\n  const element = node;\n\n  try {\n    element.addEventListener('focus', handleFocus);\n    (element.focus || HTMLElement.prototype.focus).call(element);\n  } finally {\n    element.removeEventListener('focus', handleFocus);\n  }\n\n  return didFocus;\n}\nexport function setupIntersectionObserver(targets, callback, options) {\n  const rectRatioCache = new Map();\n  targets.forEach(target => {\n    rectRatioCache.set(target, {\n      rect: getBoundingRect(target),\n      ratio: 0\n    });\n  });\n\n  const handleIntersection = entries => {\n    entries.forEach(entry => {\n      const {\n        boundingClientRect,\n        intersectionRatio,\n        target\n      } = entry;\n      rectRatioCache.set(target, {\n        rect: {\n          x: boundingClientRect.left,\n          y: boundingClientRect.top,\n          width: boundingClientRect.width,\n          height: boundingClientRect.height\n        },\n        ratio: intersectionRatio\n      });\n    });\n    callback(Array.from(rectRatioCache.values()));\n  };\n\n  const observer = new IntersectionObserver(handleIntersection, options);\n  targets.forEach(target => {\n    observer.observe(target);\n  });\n  return {\n    disconnect: () => observer.disconnect(),\n    observe: target => {\n      rectRatioCache.set(target, {\n        rect: getBoundingRect(target),\n        ratio: 0\n      });\n      observer.observe(target);\n    },\n    unobserve: target => {\n      rectRatioCache.delete(target);\n      observer.unobserve(target);\n    }\n  };\n}","map":{"version":3,"names":["precacheFiberNode","updateFiberProps","getClosestInstanceFromNode","getFiberFromScopeInstance","getInstanceFromNode","getInstanceFromNodeDOMTree","isContainerMarkedAsRoot","detachDeletedInstance","hasRole","createElement","createTextNode","setInitialProperties","diffProperties","updateProperties","diffHydratedProperties","diffHydratedText","trapClickOnNonInteractiveElement","checkForUnmatchedText","warnForDeletedHydratableElement","warnForDeletedHydratableText","warnForInsertedHydratedElement","warnForInsertedHydratedText","getSelectionInformation","restoreSelection","setTextContent","validateDOMNesting","updatedAncestorInfo","isEnabled","ReactBrowserEventEmitterIsEnabled","setEnabled","ReactBrowserEventEmitterSetEnabled","getEventPriority","getChildNamespace","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","dangerousStyleValue","retryIfBlockedOn","enableCreateEventHandleAPI","enableScopeAPI","HostComponent","HostText","listenToAllSupportedEvents","DefaultEventPriority","ConcurrentMode","NoMode","SUPPRESS_HYDRATION_WARNING","SUSPENSE_START_DATA","SUSPENSE_END_DATA","SUSPENSE_PENDING_START_DATA","SUSPENSE_FALLBACK_START_DATA","STYLE","eventsEnabled","selectionInformation","getRootHostContext","rootContainerInstance","type","namespace","nodeType","root","documentElement","namespaceURI","container","parentNode","ownNamespace","tagName","__DEV__","validatedTag","toLowerCase","ancestorInfo","getChildHostContext","parentHostContext","parentHostContextDev","parentNamespace","getPublicInstance","instance","prepareForCommit","containerInfo","activeInstance","focusedElem","beforeActiveInstanceBlur","internalInstanceHandle","dispatchBeforeDetachedBlur","afterActiveInstanceBlur","dispatchAfterDetachedBlur","resetAfterCommit","createInstance","props","hostContext","hostContextDev","children","string","ownAncestorInfo","domElement","appendInitialChild","parentInstance","child","appendChild","finalizeInitialChildren","autoFocus","prepareUpdate","oldProps","newProps","shouldSetTextContent","dangerouslySetInnerHTML","__html","createTextInstance","text","textNode","getCurrentEventPriority","currentEvent","window","event","undefined","isPrimaryRenderer","warnsIfNotActing","scheduleTimeout","setTimeout","cancelTimeout","clearTimeout","noTimeout","localPromise","Promise","supportsMicrotasks","scheduleMicrotask","queueMicrotask","callback","resolve","then","catch","handleErrorInNextTick","error","supportsMutation","commitMount","focus","src","commitUpdate","updatePayload","resetTextContent","commitTextUpdate","textInstance","oldText","newText","nodeValue","appendChildToContainer","insertBefore","reactRootContainer","_reactRootContainer","onclick","beforeChild","insertInContainerBefore","createEvent","bubbles","document","initEvent","target","_detachedInterceptFiber","dispatchEvent","relatedTarget","removeChild","removeChildFromContainer","clearSuspenseBoundary","suspenseInstance","node","depth","nextNode","nextSibling","data","clearSuspenseBoundaryFromContainer","hideInstance","style","setProperty","display","hideTextInstance","unhideInstance","styleProp","hasOwnProperty","unhideTextInstance","clearContainer","textContent","body","supportsHydration","canHydrateInstance","nodeName","canHydrateTextInstance","canHydrateSuspenseInstance","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","_reactRetry","getNextHydratable","nodeData","getNextHydratableSibling","getFirstHydratableChild","firstChild","getFirstHydratableChildWithinContainer","parentContainer","getFirstHydratableChildWithinSuspenseInstance","hydrateInstance","shouldWarnDev","isConcurrentMode","mode","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","getParentSuspenseInstance","targetInstance","previousSibling","commitHydratedContainer","commitHydratedSuspenseInstance","shouldDeleteUnhydratedTailInstances","parentType","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","parentProps","didNotHydrateInstanceWithinContainer","didNotHydrateInstanceWithinSuspenseInstance","didNotHydrateInstance","didNotFindHydratableInstanceWithinContainer","didNotFindHydratableTextInstanceWithinContainer","didNotFindHydratableSuspenseInstanceWithinContainer","didNotFindHydratableInstanceWithinSuspenseInstance","didNotFindHydratableTextInstanceWithinSuspenseInstance","didNotFindHydratableSuspenseInstanceWithinSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","errorHydratingContainer","console","preparePortalMount","portalInstance","prepareScopeUpdate","scopeInstance","getInstanceFromScope","supportsTestSelectors","findFiberRoot","stack","index","length","current","push","getBoundingRect","rect","getBoundingClientRect","x","left","y","top","width","height","matchAccessibilityRole","role","getTextContent","fiber","tag","childNodes","stateNode","i","childNode","Node","isHiddenSubtree","memoizedProps","hidden","setFocusIfFocusable","didFocus","handleFocus","element","addEventListener","HTMLElement","prototype","call","removeEventListener","setupIntersectionObserver","targets","options","rectRatioCache","Map","forEach","set","ratio","handleIntersection","entries","entry","boundingClientRect","intersectionRatio","Array","from","values","observer","IntersectionObserver","observe","disconnect","unobserve","delete"],"sources":["E:/react-test/src/react/packages/react-dom/src/client/ReactDOMHostConfig.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {DOMEventName} from '../events/DOMEventNames';\r\nimport type {Fiber, FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\r\nimport type {\r\n  BoundingRect,\r\n  IntersectionObserverOptions,\r\n  ObserveVisibleRectsCallback,\r\n} from 'react-reconciler/src/ReactTestSelectors';\r\nimport type {ReactScopeInstance} from 'shared/ReactTypes';\r\n\r\nimport {\r\n  precacheFiberNode,\r\n  updateFiberProps,\r\n  getClosestInstanceFromNode,\r\n  getFiberFromScopeInstance,\r\n  getInstanceFromNode as getInstanceFromNodeDOMTree,\r\n  isContainerMarkedAsRoot,\r\n} from './ReactDOMComponentTree';\r\nexport {detachDeletedInstance} from './ReactDOMComponentTree';\r\nimport {hasRole} from './DOMAccessibilityRoles';\r\nimport {\r\n  createElement,\r\n  createTextNode,\r\n  setInitialProperties,\r\n  diffProperties,\r\n  updateProperties,\r\n  diffHydratedProperties,\r\n  diffHydratedText,\r\n  trapClickOnNonInteractiveElement,\r\n  checkForUnmatchedText,\r\n  warnForDeletedHydratableElement,\r\n  warnForDeletedHydratableText,\r\n  warnForInsertedHydratedElement,\r\n  warnForInsertedHydratedText,\r\n} from './ReactDOMComponent';\r\nimport {getSelectionInformation, restoreSelection} from './ReactInputSelection';\r\nimport setTextContent from './setTextContent';\r\nimport {validateDOMNesting, updatedAncestorInfo} from './validateDOMNesting';\r\nimport {\r\n  isEnabled as ReactBrowserEventEmitterIsEnabled,\r\n  setEnabled as ReactBrowserEventEmitterSetEnabled,\r\n  getEventPriority,\r\n} from '../events/ReactDOMEventListener';\r\nimport {getChildNamespace} from '../shared/DOMNamespaces';\r\nimport {\r\n  ELEMENT_NODE,\r\n  TEXT_NODE,\r\n  COMMENT_NODE,\r\n  DOCUMENT_NODE,\r\n  DOCUMENT_FRAGMENT_NODE,\r\n} from '../shared/HTMLNodeType';\r\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\r\n\r\nimport {retryIfBlockedOn} from '../events/ReactDOMEventReplaying';\r\n\r\nimport {\r\n  enableCreateEventHandleAPI,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {HostComponent, HostText} from 'react-reconciler/src/ReactWorkTags';\r\nimport {listenToAllSupportedEvents} from '../events/DOMPluginEventSystem';\r\n\r\nimport {DefaultEventPriority} from 'react-reconciler/src/ReactEventPriorities';\r\n\r\n// TODO: Remove this deep import when we delete the legacy root API\r\nimport {ConcurrentMode, NoMode} from 'react-reconciler/src/ReactTypeOfMode';\r\n\r\nexport type Type = string;\r\nexport type Props = {\r\n  autoFocus?: boolean,\r\n  children?: mixed,\r\n  disabled?: boolean,\r\n  hidden?: boolean,\r\n  suppressHydrationWarning?: boolean,\r\n  dangerouslySetInnerHTML?: mixed,\r\n  style?: {display?: string, ...},\r\n  bottom?: null | number,\r\n  left?: null | number,\r\n  right?: null | number,\r\n  top?: null | number,\r\n  ...\r\n};\r\nexport type EventTargetChildElement = {\r\n  type: string,\r\n  props: null | {\r\n    style?: {\r\n      position?: string,\r\n      zIndex?: number,\r\n      bottom?: string,\r\n      left?: string,\r\n      right?: string,\r\n      top?: string,\r\n      ...\r\n    },\r\n    ...\r\n  },\r\n  ...\r\n};\r\nexport type Container =\r\n  | (Element & {_reactRootContainer?: FiberRoot, ...})\r\n  | (Document & {_reactRootContainer?: FiberRoot, ...})\r\n  | (DocumentFragment & {_reactRootContainer?: FiberRoot, ...});\r\nexport type Instance = Element;\r\nexport type TextInstance = Text;\r\nexport type SuspenseInstance = Comment & {_reactRetry?: () => void, ...};\r\nexport type HydratableInstance = Instance | TextInstance | SuspenseInstance;\r\nexport type PublicInstance = Element | Text;\r\ntype HostContextDev = {\r\n  namespace: string,\r\n  ancestorInfo: mixed,\r\n  ...\r\n};\r\ntype HostContextProd = string;\r\nexport type HostContext = HostContextDev | HostContextProd;\r\nexport type UpdatePayload = Array<mixed>;\r\nexport type ChildSet = void; // Unused\r\nexport type TimeoutHandle = TimeoutID;\r\nexport type NoTimeout = -1;\r\nexport type RendererInspectionConfig = $ReadOnly<{||}>;\r\n\r\ntype SelectionInformation = {|\r\n  focusedElem: null | HTMLElement,\r\n  selectionRange: mixed,\r\n|};\r\n\r\nconst SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\r\n\r\nconst SUSPENSE_START_DATA = '$';\r\nconst SUSPENSE_END_DATA = '/$';\r\nconst SUSPENSE_PENDING_START_DATA = '$?';\r\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\r\n\r\nconst STYLE = 'style';\r\n\r\nlet eventsEnabled: ?boolean = null;\r\nlet selectionInformation: null | SelectionInformation = null;\r\n\r\nexport * from 'react-reconciler/src/ReactFiberHostConfigWithNoPersistence';\r\n\r\nexport function getRootHostContext(\r\n  rootContainerInstance: Container,\r\n): HostContext {\r\n  let type;\r\n  let namespace;\r\n  const nodeType = rootContainerInstance.nodeType;\r\n  switch (nodeType) {\r\n    case DOCUMENT_NODE:\r\n    case DOCUMENT_FRAGMENT_NODE: {\r\n      type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\r\n      const root = (rootContainerInstance: any).documentElement;\r\n      namespace = root ? root.namespaceURI : getChildNamespace(null, '');\r\n      break;\r\n    }\r\n    default: {\r\n      const container: any =\r\n        nodeType === COMMENT_NODE\r\n          ? rootContainerInstance.parentNode\r\n          : rootContainerInstance;\r\n      const ownNamespace = container.namespaceURI || null;\r\n      type = container.tagName;\r\n      namespace = getChildNamespace(ownNamespace, type);\r\n      break;\r\n    }\r\n  }\r\n  if (__DEV__) {\r\n    const validatedTag = type.toLowerCase();\r\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\r\n    return {namespace, ancestorInfo};\r\n  }\r\n  return namespace;\r\n}\r\n\r\nexport function getChildHostContext(\r\n  parentHostContext: HostContext,\r\n  type: string,\r\n  rootContainerInstance: Container,\r\n): HostContext {\r\n  if (__DEV__) {\r\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\r\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\r\n    const ancestorInfo = updatedAncestorInfo(\r\n      parentHostContextDev.ancestorInfo,\r\n      type,\r\n    );\r\n    return {namespace, ancestorInfo};\r\n  }\r\n  const parentNamespace = ((parentHostContext: any): HostContextProd);\r\n  return getChildNamespace(parentNamespace, type);\r\n}\r\n\r\nexport function getPublicInstance(instance: Instance): * {\r\n  return instance;\r\n}\r\n\r\nexport function prepareForCommit(containerInfo: Container): Object | null {\r\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\r\n  selectionInformation = getSelectionInformation();\r\n  let activeInstance = null;\r\n  if (enableCreateEventHandleAPI) {\r\n    const focusedElem = selectionInformation.focusedElem;\r\n    if (focusedElem !== null) {\r\n      activeInstance = getClosestInstanceFromNode(focusedElem);\r\n    }\r\n  }\r\n  ReactBrowserEventEmitterSetEnabled(false);\r\n  return activeInstance;\r\n}\r\n\r\nexport function beforeActiveInstanceBlur(internalInstanceHandle: Object): void {\r\n  if (enableCreateEventHandleAPI) {\r\n    ReactBrowserEventEmitterSetEnabled(true);\r\n    dispatchBeforeDetachedBlur(\r\n      (selectionInformation: any).focusedElem,\r\n      internalInstanceHandle,\r\n    );\r\n    ReactBrowserEventEmitterSetEnabled(false);\r\n  }\r\n}\r\n\r\nexport function afterActiveInstanceBlur(): void {\r\n  if (enableCreateEventHandleAPI) {\r\n    ReactBrowserEventEmitterSetEnabled(true);\r\n    dispatchAfterDetachedBlur((selectionInformation: any).focusedElem);\r\n    ReactBrowserEventEmitterSetEnabled(false);\r\n  }\r\n}\r\n\r\nexport function resetAfterCommit(containerInfo: Container): void {\r\n  restoreSelection(selectionInformation);\r\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\r\n  eventsEnabled = null;\r\n  selectionInformation = null;\r\n}\r\n\r\nexport function createInstance(\r\n  type: string,\r\n  props: Props,\r\n  rootContainerInstance: Container,\r\n  hostContext: HostContext,\r\n  internalInstanceHandle: Object,\r\n): Instance {\r\n  let parentNamespace: string;\r\n  if (__DEV__) {\r\n    // TODO: take namespace into account when validating.\r\n    const hostContextDev = ((hostContext: any): HostContextDev);\r\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\r\n    if (\r\n      typeof props.children === 'string' ||\r\n      typeof props.children === 'number'\r\n    ) {\r\n      const string = '' + props.children;\r\n      const ownAncestorInfo = updatedAncestorInfo(\r\n        hostContextDev.ancestorInfo,\r\n        type,\r\n      );\r\n      validateDOMNesting(null, string, ownAncestorInfo);\r\n    }\r\n    parentNamespace = hostContextDev.namespace;\r\n  } else {\r\n    parentNamespace = ((hostContext: any): HostContextProd);\r\n  }\r\n  const domElement: Instance = createElement(\r\n    type,\r\n    props,\r\n    rootContainerInstance,\r\n    parentNamespace,\r\n  );\r\n  precacheFiberNode(internalInstanceHandle, domElement);\r\n  updateFiberProps(domElement, props);\r\n  return domElement;\r\n}\r\n\r\nexport function appendInitialChild(\r\n  parentInstance: Instance,\r\n  child: Instance | TextInstance,\r\n): void {\r\n  parentInstance.appendChild(child);\r\n}\r\n\r\nexport function finalizeInitialChildren(\r\n  domElement: Instance,\r\n  type: string,\r\n  props: Props,\r\n  rootContainerInstance: Container,\r\n  hostContext: HostContext,\r\n): boolean {\r\n  setInitialProperties(domElement, type, props, rootContainerInstance);\r\n  switch (type) {\r\n    case 'button':\r\n    case 'input':\r\n    case 'select':\r\n    case 'textarea':\r\n      return !!props.autoFocus;\r\n    case 'img':\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nexport function prepareUpdate(\r\n  domElement: Instance,\r\n  type: string,\r\n  oldProps: Props,\r\n  newProps: Props,\r\n  rootContainerInstance: Container,\r\n  hostContext: HostContext,\r\n): null | Array<mixed> {\r\n  if (__DEV__) {\r\n    const hostContextDev = ((hostContext: any): HostContextDev);\r\n    if (\r\n      typeof newProps.children !== typeof oldProps.children &&\r\n      (typeof newProps.children === 'string' ||\r\n        typeof newProps.children === 'number')\r\n    ) {\r\n      const string = '' + newProps.children;\r\n      const ownAncestorInfo = updatedAncestorInfo(\r\n        hostContextDev.ancestorInfo,\r\n        type,\r\n      );\r\n      validateDOMNesting(null, string, ownAncestorInfo);\r\n    }\r\n  }\r\n  return diffProperties(\r\n    domElement,\r\n    type,\r\n    oldProps,\r\n    newProps,\r\n    rootContainerInstance,\r\n  );\r\n}\r\n\r\nexport function shouldSetTextContent(type: string, props: Props): boolean {\r\n  return (\r\n    type === 'textarea' ||\r\n    type === 'noscript' ||\r\n    typeof props.children === 'string' ||\r\n    typeof props.children === 'number' ||\r\n    (typeof props.dangerouslySetInnerHTML === 'object' &&\r\n      props.dangerouslySetInnerHTML !== null &&\r\n      props.dangerouslySetInnerHTML.__html != null)\r\n  );\r\n}\r\n\r\nexport function createTextInstance(\r\n  text: string,\r\n  rootContainerInstance: Container,\r\n  hostContext: HostContext,\r\n  internalInstanceHandle: Object,\r\n): TextInstance {\r\n  if (__DEV__) {\r\n    const hostContextDev = ((hostContext: any): HostContextDev);\r\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\r\n  }\r\n  const textNode: TextInstance = createTextNode(text, rootContainerInstance);\r\n  precacheFiberNode(internalInstanceHandle, textNode);\r\n  return textNode;\r\n}\r\n\r\nexport function getCurrentEventPriority(): * {\r\n  const currentEvent = window.event;\r\n  if (currentEvent === undefined) {\r\n    return DefaultEventPriority;\r\n  }\r\n  return getEventPriority(currentEvent.type);\r\n}\r\n\r\nexport const isPrimaryRenderer = true;\r\nexport const warnsIfNotActing = true;\r\n// This initialization code may run even on server environments\r\n// if a component just imports ReactDOM (e.g. for findDOMNode).\r\n// Some environments might not have setTimeout or clearTimeout.\r\nexport const scheduleTimeout: any =\r\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\r\nexport const cancelTimeout: any =\r\n  typeof clearTimeout === 'function' ? clearTimeout : (undefined: any);\r\nexport const noTimeout = -1;\r\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\r\n\r\n// -------------------\r\n//     Microtasks\r\n// -------------------\r\nexport const supportsMicrotasks = true;\r\nexport const scheduleMicrotask: any =\r\n  typeof queueMicrotask === 'function'\r\n    ? queueMicrotask\r\n    : typeof localPromise !== 'undefined'\r\n    ? callback =>\r\n        localPromise\r\n          .resolve(null)\r\n          .then(callback)\r\n          .catch(handleErrorInNextTick)\r\n    : scheduleTimeout; // TODO: Determine the best fallback here.\r\n\r\nfunction handleErrorInNextTick(error) {\r\n  setTimeout(() => {\r\n    throw error;\r\n  });\r\n}\r\n\r\n// -------------------\r\n//     Mutation\r\n// -------------------\r\n\r\nexport const supportsMutation = true;\r\n\r\nexport function commitMount(\r\n  domElement: Instance,\r\n  type: string,\r\n  newProps: Props,\r\n  internalInstanceHandle: Object,\r\n): void {\r\n  // Despite the naming that might imply otherwise, this method only\r\n  // fires if there is an `Update` effect scheduled during mounting.\r\n  // This happens if `finalizeInitialChildren` returns `true` (which it\r\n  // does to implement the `autoFocus` attribute on the client). But\r\n  // there are also other cases when this might happen (such as patching\r\n  // up text content during hydration mismatch). So we'll check this again.\r\n  switch (type) {\r\n    case 'button':\r\n    case 'input':\r\n    case 'select':\r\n    case 'textarea':\r\n      if (newProps.autoFocus) {\r\n        ((domElement: any):\r\n          | HTMLButtonElement\r\n          | HTMLInputElement\r\n          | HTMLSelectElement\r\n          | HTMLTextAreaElement).focus();\r\n      }\r\n      return;\r\n    case 'img': {\r\n      if ((newProps: any).src) {\r\n        ((domElement: any): HTMLImageElement).src = (newProps: any).src;\r\n      }\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nexport function commitUpdate(\r\n  domElement: Instance,\r\n  updatePayload: Array<mixed>,\r\n  type: string,\r\n  oldProps: Props,\r\n  newProps: Props,\r\n  internalInstanceHandle: Object,\r\n): void {\r\n  // Apply the diff to the DOM node.\r\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\r\n  // Update the props handle so that we know which props are the ones with\r\n  // with current event handlers.\r\n  updateFiberProps(domElement, newProps);\r\n}\r\n\r\nexport function resetTextContent(domElement: Instance): void {\r\n  setTextContent(domElement, '');\r\n}\r\n\r\nexport function commitTextUpdate(\r\n  textInstance: TextInstance,\r\n  oldText: string,\r\n  newText: string,\r\n): void {\r\n  textInstance.nodeValue = newText;\r\n}\r\n\r\nexport function appendChild(\r\n  parentInstance: Instance,\r\n  child: Instance | TextInstance,\r\n): void {\r\n  parentInstance.appendChild(child);\r\n}\r\n\r\nexport function appendChildToContainer(\r\n  container: Container,\r\n  child: Instance | TextInstance,\r\n): void {\r\n  let parentNode;\r\n  if (container.nodeType === COMMENT_NODE) {\r\n    parentNode = (container.parentNode: any);\r\n    parentNode.insertBefore(child, container);\r\n  } else {\r\n    parentNode = container;\r\n    parentNode.appendChild(child);\r\n  }\r\n  // This container might be used for a portal.\r\n  // If something inside a portal is clicked, that click should bubble\r\n  // through the React tree. However, on Mobile Safari the click would\r\n  // never bubble through the *DOM* tree unless an ancestor with onclick\r\n  // event exists. So we wouldn't see it and dispatch it.\r\n  // This is why we ensure that non React root containers have inline onclick\r\n  // defined.\r\n  // https://github.com/facebook/react/issues/11918\r\n  const reactRootContainer = container._reactRootContainer;\r\n  if (\r\n    (reactRootContainer === null || reactRootContainer === undefined) &&\r\n    parentNode.onclick === null\r\n  ) {\r\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\r\n    trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement));\r\n  }\r\n}\r\n\r\nexport function insertBefore(\r\n  parentInstance: Instance,\r\n  child: Instance | TextInstance,\r\n  beforeChild: Instance | TextInstance | SuspenseInstance,\r\n): void {\r\n  parentInstance.insertBefore(child, beforeChild);\r\n}\r\n\r\nexport function insertInContainerBefore(\r\n  container: Container,\r\n  child: Instance | TextInstance,\r\n  beforeChild: Instance | TextInstance | SuspenseInstance,\r\n): void {\r\n  if (container.nodeType === COMMENT_NODE) {\r\n    (container.parentNode: any).insertBefore(child, beforeChild);\r\n  } else {\r\n    container.insertBefore(child, beforeChild);\r\n  }\r\n}\r\n\r\nfunction createEvent(type: DOMEventName, bubbles: boolean): Event {\r\n  const event = document.createEvent('Event');\r\n  event.initEvent(((type: any): string), bubbles, false);\r\n  return event;\r\n}\r\n\r\nfunction dispatchBeforeDetachedBlur(\r\n  target: HTMLElement,\r\n  internalInstanceHandle: Object,\r\n): void {\r\n  if (enableCreateEventHandleAPI) {\r\n    const event = createEvent('beforeblur', true);\r\n    // Dispatch \"beforeblur\" directly on the target,\r\n    // so it gets picked up by the event system and\r\n    // can propagate through the React internal tree.\r\n    // $FlowFixMe: internal field\r\n    event._detachedInterceptFiber = internalInstanceHandle;\r\n    target.dispatchEvent(event);\r\n  }\r\n}\r\n\r\nfunction dispatchAfterDetachedBlur(target: HTMLElement): void {\r\n  if (enableCreateEventHandleAPI) {\r\n    const event = createEvent('afterblur', false);\r\n    // So we know what was detached, make the relatedTarget the\r\n    // detached target on the \"afterblur\" event.\r\n    (event: any).relatedTarget = target;\r\n    // Dispatch the event on the document.\r\n    document.dispatchEvent(event);\r\n  }\r\n}\r\n\r\nexport function removeChild(\r\n  parentInstance: Instance,\r\n  child: Instance | TextInstance | SuspenseInstance,\r\n): void {\r\n  parentInstance.removeChild(child);\r\n}\r\n\r\nexport function removeChildFromContainer(\r\n  container: Container,\r\n  child: Instance | TextInstance | SuspenseInstance,\r\n): void {\r\n  if (container.nodeType === COMMENT_NODE) {\r\n    (container.parentNode: any).removeChild(child);\r\n  } else {\r\n    container.removeChild(child);\r\n  }\r\n}\r\n\r\nexport function clearSuspenseBoundary(\r\n  parentInstance: Instance,\r\n  suspenseInstance: SuspenseInstance,\r\n): void {\r\n  let node = suspenseInstance;\r\n  // Delete all nodes within this suspense boundary.\r\n  // There might be nested nodes so we need to keep track of how\r\n  // deep we are and only break out when we're back on top.\r\n  let depth = 0;\r\n  do {\r\n    const nextNode = node.nextSibling;\r\n    parentInstance.removeChild(node);\r\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\r\n      const data = ((nextNode: any).data: string);\r\n      if (data === SUSPENSE_END_DATA) {\r\n        if (depth === 0) {\r\n          parentInstance.removeChild(nextNode);\r\n          // Retry if any event replaying was blocked on this.\r\n          retryIfBlockedOn(suspenseInstance);\r\n          return;\r\n        } else {\r\n          depth--;\r\n        }\r\n      } else if (\r\n        data === SUSPENSE_START_DATA ||\r\n        data === SUSPENSE_PENDING_START_DATA ||\r\n        data === SUSPENSE_FALLBACK_START_DATA\r\n      ) {\r\n        depth++;\r\n      }\r\n    }\r\n    node = nextNode;\r\n  } while (node);\r\n  // TODO: Warn, we didn't find the end comment boundary.\r\n  // Retry if any event replaying was blocked on this.\r\n  retryIfBlockedOn(suspenseInstance);\r\n}\r\n\r\nexport function clearSuspenseBoundaryFromContainer(\r\n  container: Container,\r\n  suspenseInstance: SuspenseInstance,\r\n): void {\r\n  if (container.nodeType === COMMENT_NODE) {\r\n    clearSuspenseBoundary((container.parentNode: any), suspenseInstance);\r\n  } else if (container.nodeType === ELEMENT_NODE) {\r\n    clearSuspenseBoundary((container: any), suspenseInstance);\r\n  } else {\r\n    // Document nodes should never contain suspense boundaries.\r\n  }\r\n  // Retry if any event replaying was blocked on this.\r\n  retryIfBlockedOn(container);\r\n}\r\n\r\nexport function hideInstance(instance: Instance): void {\r\n  // TODO: Does this work for all element types? What about MathML? Should we\r\n  // pass host context to this method?\r\n  instance = ((instance: any): HTMLElement);\r\n  const style = instance.style;\r\n  if (typeof style.setProperty === 'function') {\r\n    style.setProperty('display', 'none', 'important');\r\n  } else {\r\n    style.display = 'none';\r\n  }\r\n}\r\n\r\nexport function hideTextInstance(textInstance: TextInstance): void {\r\n  textInstance.nodeValue = '';\r\n}\r\n\r\nexport function unhideInstance(instance: Instance, props: Props): void {\r\n  instance = ((instance: any): HTMLElement);\r\n  const styleProp = props[STYLE];\r\n  const display =\r\n    styleProp !== undefined &&\r\n    styleProp !== null &&\r\n    styleProp.hasOwnProperty('display')\r\n      ? styleProp.display\r\n      : null;\r\n  instance.style.display = dangerousStyleValue('display', display);\r\n}\r\n\r\nexport function unhideTextInstance(\r\n  textInstance: TextInstance,\r\n  text: string,\r\n): void {\r\n  textInstance.nodeValue = text;\r\n}\r\n\r\nexport function clearContainer(container: Container): void {\r\n  if (container.nodeType === ELEMENT_NODE) {\r\n    ((container: any): Element).textContent = '';\r\n  } else if (container.nodeType === DOCUMENT_NODE) {\r\n    const body = ((container: any): Document).body;\r\n    if (body != null) {\r\n      body.textContent = '';\r\n    }\r\n  }\r\n}\r\n\r\n// -------------------\r\n//     Hydration\r\n// -------------------\r\n\r\nexport const supportsHydration = true;\r\n\r\nexport function canHydrateInstance(\r\n  instance: HydratableInstance,\r\n  type: string,\r\n  props: Props,\r\n): null | Instance {\r\n  if (\r\n    instance.nodeType !== ELEMENT_NODE ||\r\n    type.toLowerCase() !== instance.nodeName.toLowerCase()\r\n  ) {\r\n    return null;\r\n  }\r\n  // This has now been refined to an element node.\r\n  return ((instance: any): Instance);\r\n}\r\n\r\nexport function canHydrateTextInstance(\r\n  instance: HydratableInstance,\r\n  text: string,\r\n): null | TextInstance {\r\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\r\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\r\n    return null;\r\n  }\r\n  // This has now been refined to a text node.\r\n  return ((instance: any): TextInstance);\r\n}\r\n\r\nexport function canHydrateSuspenseInstance(\r\n  instance: HydratableInstance,\r\n): null | SuspenseInstance {\r\n  if (instance.nodeType !== COMMENT_NODE) {\r\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\r\n    return null;\r\n  }\r\n  // This has now been refined to a suspense node.\r\n  return ((instance: any): SuspenseInstance);\r\n}\r\n\r\nexport function isSuspenseInstancePending(instance: SuspenseInstance) {\r\n  return instance.data === SUSPENSE_PENDING_START_DATA;\r\n}\r\n\r\nexport function isSuspenseInstanceFallback(instance: SuspenseInstance) {\r\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\r\n}\r\n\r\nexport function registerSuspenseInstanceRetry(\r\n  instance: SuspenseInstance,\r\n  callback: () => void,\r\n) {\r\n  instance._reactRetry = callback;\r\n}\r\n\r\nfunction getNextHydratable(node) {\r\n  // Skip non-hydratable nodes.\r\n  for (; node != null; node = node.nextSibling) {\r\n    const nodeType = node.nodeType;\r\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\r\n      break;\r\n    }\r\n    if (nodeType === COMMENT_NODE) {\r\n      const nodeData = (node: any).data;\r\n      if (\r\n        nodeData === SUSPENSE_START_DATA ||\r\n        nodeData === SUSPENSE_FALLBACK_START_DATA ||\r\n        nodeData === SUSPENSE_PENDING_START_DATA\r\n      ) {\r\n        break;\r\n      }\r\n      if (nodeData === SUSPENSE_END_DATA) {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n  return (node: any);\r\n}\r\n\r\nexport function getNextHydratableSibling(\r\n  instance: HydratableInstance,\r\n): null | HydratableInstance {\r\n  return getNextHydratable(instance.nextSibling);\r\n}\r\n\r\nexport function getFirstHydratableChild(\r\n  parentInstance: Instance,\r\n): null | HydratableInstance {\r\n  return getNextHydratable(parentInstance.firstChild);\r\n}\r\n\r\nexport function getFirstHydratableChildWithinContainer(\r\n  parentContainer: Container,\r\n): null | HydratableInstance {\r\n  return getNextHydratable(parentContainer.firstChild);\r\n}\r\n\r\nexport function getFirstHydratableChildWithinSuspenseInstance(\r\n  parentInstance: SuspenseInstance,\r\n): null | HydratableInstance {\r\n  return getNextHydratable(parentInstance.nextSibling);\r\n}\r\n\r\nexport function hydrateInstance(\r\n  instance: Instance,\r\n  type: string,\r\n  props: Props,\r\n  rootContainerInstance: Container,\r\n  hostContext: HostContext,\r\n  internalInstanceHandle: Object,\r\n  shouldWarnDev: boolean,\r\n): null | Array<mixed> {\r\n  precacheFiberNode(internalInstanceHandle, instance);\r\n  // TODO: Possibly defer this until the commit phase where all the events\r\n  // get attached.\r\n  updateFiberProps(instance, props);\r\n  let parentNamespace: string;\r\n  if (__DEV__) {\r\n    const hostContextDev = ((hostContext: any): HostContextDev);\r\n    parentNamespace = hostContextDev.namespace;\r\n  } else {\r\n    parentNamespace = ((hostContext: any): HostContextProd);\r\n  }\r\n\r\n  // TODO: Temporary hack to check if we're in a concurrent root. We can delete\r\n  // when the legacy root API is removed.\r\n  const isConcurrentMode =\r\n    ((internalInstanceHandle: Fiber).mode & ConcurrentMode) !== NoMode;\r\n\r\n  return diffHydratedProperties(\r\n    instance,\r\n    type,\r\n    props,\r\n    parentNamespace,\r\n    rootContainerInstance,\r\n    isConcurrentMode,\r\n    shouldWarnDev,\r\n  );\r\n}\r\n\r\nexport function hydrateTextInstance(\r\n  textInstance: TextInstance,\r\n  text: string,\r\n  internalInstanceHandle: Object,\r\n  shouldWarnDev: boolean,\r\n): boolean {\r\n  precacheFiberNode(internalInstanceHandle, textInstance);\r\n\r\n  // TODO: Temporary hack to check if we're in a concurrent root. We can delete\r\n  // when the legacy root API is removed.\r\n  const isConcurrentMode =\r\n    ((internalInstanceHandle: Fiber).mode & ConcurrentMode) !== NoMode;\r\n\r\n  return diffHydratedText(textInstance, text, isConcurrentMode);\r\n}\r\n\r\nexport function hydrateSuspenseInstance(\r\n  suspenseInstance: SuspenseInstance,\r\n  internalInstanceHandle: Object,\r\n) {\r\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\r\n}\r\n\r\nexport function getNextHydratableInstanceAfterSuspenseInstance(\r\n  suspenseInstance: SuspenseInstance,\r\n): null | HydratableInstance {\r\n  let node = suspenseInstance.nextSibling;\r\n  // Skip past all nodes within this suspense boundary.\r\n  // There might be nested nodes so we need to keep track of how\r\n  // deep we are and only break out when we're back on top.\r\n  let depth = 0;\r\n  while (node) {\r\n    if (node.nodeType === COMMENT_NODE) {\r\n      const data = ((node: any).data: string);\r\n      if (data === SUSPENSE_END_DATA) {\r\n        if (depth === 0) {\r\n          return getNextHydratableSibling((node: any));\r\n        } else {\r\n          depth--;\r\n        }\r\n      } else if (\r\n        data === SUSPENSE_START_DATA ||\r\n        data === SUSPENSE_FALLBACK_START_DATA ||\r\n        data === SUSPENSE_PENDING_START_DATA\r\n      ) {\r\n        depth++;\r\n      }\r\n    }\r\n    node = node.nextSibling;\r\n  }\r\n  // TODO: Warn, we didn't find the end comment boundary.\r\n  return null;\r\n}\r\n\r\n// Returns the SuspenseInstance if this node is a direct child of a\r\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\r\n// SUSPENSE_x_START_DATA. Otherwise, null.\r\nexport function getParentSuspenseInstance(\r\n  targetInstance: Node,\r\n): null | SuspenseInstance {\r\n  let node = targetInstance.previousSibling;\r\n  // Skip past all nodes within this suspense boundary.\r\n  // There might be nested nodes so we need to keep track of how\r\n  // deep we are and only break out when we're back on top.\r\n  let depth = 0;\r\n  while (node) {\r\n    if (node.nodeType === COMMENT_NODE) {\r\n      const data = ((node: any).data: string);\r\n      if (\r\n        data === SUSPENSE_START_DATA ||\r\n        data === SUSPENSE_FALLBACK_START_DATA ||\r\n        data === SUSPENSE_PENDING_START_DATA\r\n      ) {\r\n        if (depth === 0) {\r\n          return ((node: any): SuspenseInstance);\r\n        } else {\r\n          depth--;\r\n        }\r\n      } else if (data === SUSPENSE_END_DATA) {\r\n        depth++;\r\n      }\r\n    }\r\n    node = node.previousSibling;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function commitHydratedContainer(container: Container): void {\r\n  // Retry if any event replaying was blocked on this.\r\n  retryIfBlockedOn(container);\r\n}\r\n\r\nexport function commitHydratedSuspenseInstance(\r\n  suspenseInstance: SuspenseInstance,\r\n): void {\r\n  // Retry if any event replaying was blocked on this.\r\n  retryIfBlockedOn(suspenseInstance);\r\n}\r\n\r\nexport function shouldDeleteUnhydratedTailInstances(\r\n  parentType: string,\r\n): boolean {\r\n  return parentType !== 'head' && parentType !== 'body';\r\n}\r\n\r\nexport function didNotMatchHydratedContainerTextInstance(\r\n  parentContainer: Container,\r\n  textInstance: TextInstance,\r\n  text: string,\r\n  isConcurrentMode: boolean,\r\n) {\r\n  const shouldWarnDev = true;\r\n  checkForUnmatchedText(\r\n    textInstance.nodeValue,\r\n    text,\r\n    isConcurrentMode,\r\n    shouldWarnDev,\r\n  );\r\n}\r\n\r\nexport function didNotMatchHydratedTextInstance(\r\n  parentType: string,\r\n  parentProps: Props,\r\n  parentInstance: Instance,\r\n  textInstance: TextInstance,\r\n  text: string,\r\n  isConcurrentMode: boolean,\r\n) {\r\n  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\r\n    const shouldWarnDev = true;\r\n    checkForUnmatchedText(\r\n      textInstance.nodeValue,\r\n      text,\r\n      isConcurrentMode,\r\n      shouldWarnDev,\r\n    );\r\n  }\r\n}\r\n\r\nexport function didNotHydrateInstanceWithinContainer(\r\n  parentContainer: Container,\r\n  instance: HydratableInstance,\r\n) {\r\n  if (__DEV__) {\r\n    if (instance.nodeType === ELEMENT_NODE) {\r\n      warnForDeletedHydratableElement(parentContainer, (instance: any));\r\n    } else if (instance.nodeType === COMMENT_NODE) {\r\n      // TODO: warnForDeletedHydratableSuspenseBoundary\r\n    } else {\r\n      warnForDeletedHydratableText(parentContainer, (instance: any));\r\n    }\r\n  }\r\n}\r\n\r\nexport function didNotHydrateInstanceWithinSuspenseInstance(\r\n  parentInstance: SuspenseInstance,\r\n  instance: HydratableInstance,\r\n) {\r\n  if (__DEV__) {\r\n    // $FlowFixMe: Only Element or Document can be parent nodes.\r\n    const parentNode: Element | Document | null = parentInstance.parentNode;\r\n    if (parentNode !== null) {\r\n      if (instance.nodeType === ELEMENT_NODE) {\r\n        warnForDeletedHydratableElement(parentNode, (instance: any));\r\n      } else if (instance.nodeType === COMMENT_NODE) {\r\n        // TODO: warnForDeletedHydratableSuspenseBoundary\r\n      } else {\r\n        warnForDeletedHydratableText(parentNode, (instance: any));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function didNotHydrateInstance(\r\n  parentType: string,\r\n  parentProps: Props,\r\n  parentInstance: Instance,\r\n  instance: HydratableInstance,\r\n  isConcurrentMode: boolean,\r\n) {\r\n  if (__DEV__) {\r\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\r\n      if (instance.nodeType === ELEMENT_NODE) {\r\n        warnForDeletedHydratableElement(parentInstance, (instance: any));\r\n      } else if (instance.nodeType === COMMENT_NODE) {\r\n        // TODO: warnForDeletedHydratableSuspenseBoundary\r\n      } else {\r\n        warnForDeletedHydratableText(parentInstance, (instance: any));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableInstanceWithinContainer(\r\n  parentContainer: Container,\r\n  type: string,\r\n  props: Props,\r\n) {\r\n  if (__DEV__) {\r\n    warnForInsertedHydratedElement(parentContainer, type, props);\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableTextInstanceWithinContainer(\r\n  parentContainer: Container,\r\n  text: string,\r\n) {\r\n  if (__DEV__) {\r\n    warnForInsertedHydratedText(parentContainer, text);\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableSuspenseInstanceWithinContainer(\r\n  parentContainer: Container,\r\n) {\r\n  if (__DEV__) {\r\n    // TODO: warnForInsertedHydratedSuspense(parentContainer);\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableInstanceWithinSuspenseInstance(\r\n  parentInstance: SuspenseInstance,\r\n  type: string,\r\n  props: Props,\r\n) {\r\n  if (__DEV__) {\r\n    // $FlowFixMe: Only Element or Document can be parent nodes.\r\n    const parentNode: Element | Document | null = parentInstance.parentNode;\r\n    if (parentNode !== null)\r\n      warnForInsertedHydratedElement(parentNode, type, props);\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableTextInstanceWithinSuspenseInstance(\r\n  parentInstance: SuspenseInstance,\r\n  text: string,\r\n) {\r\n  if (__DEV__) {\r\n    // $FlowFixMe: Only Element or Document can be parent nodes.\r\n    const parentNode: Element | Document | null = parentInstance.parentNode;\r\n    if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(\r\n  parentInstance: SuspenseInstance,\r\n) {\r\n  if (__DEV__) {\r\n    // const parentNode: Element | Document | null = parentInstance.parentNode;\r\n    // TODO: warnForInsertedHydratedSuspense(parentNode);\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableInstance(\r\n  parentType: string,\r\n  parentProps: Props,\r\n  parentInstance: Instance,\r\n  type: string,\r\n  props: Props,\r\n  isConcurrentMode: boolean,\r\n) {\r\n  if (__DEV__) {\r\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\r\n      warnForInsertedHydratedElement(parentInstance, type, props);\r\n    }\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableTextInstance(\r\n  parentType: string,\r\n  parentProps: Props,\r\n  parentInstance: Instance,\r\n  text: string,\r\n  isConcurrentMode: boolean,\r\n) {\r\n  if (__DEV__) {\r\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\r\n      warnForInsertedHydratedText(parentInstance, text);\r\n    }\r\n  }\r\n}\r\n\r\nexport function didNotFindHydratableSuspenseInstance(\r\n  parentType: string,\r\n  parentProps: Props,\r\n  parentInstance: Instance,\r\n) {\r\n  if (__DEV__) {\r\n    // TODO: warnForInsertedHydratedSuspense(parentInstance);\r\n  }\r\n}\r\n\r\nexport function errorHydratingContainer(parentContainer: Container): void {\r\n  if (__DEV__) {\r\n    // TODO: This gets logged by onRecoverableError, too, so we should be\r\n    // able to remove it.\r\n    console.error(\r\n      'An error occurred during hydration. The server HTML was replaced with client content in <%s>.',\r\n      parentContainer.nodeName.toLowerCase(),\r\n    );\r\n  }\r\n}\r\n\r\nexport function getInstanceFromNode(node: HTMLElement): null | Object {\r\n  return getClosestInstanceFromNode(node) || null;\r\n}\r\n\r\nexport function preparePortalMount(portalInstance: Instance): void {\r\n  listenToAllSupportedEvents(portalInstance);\r\n}\r\n\r\nexport function prepareScopeUpdate(\r\n  scopeInstance: ReactScopeInstance,\r\n  internalInstanceHandle: Object,\r\n): void {\r\n  if (enableScopeAPI) {\r\n    precacheFiberNode(internalInstanceHandle, scopeInstance);\r\n  }\r\n}\r\n\r\nexport function getInstanceFromScope(\r\n  scopeInstance: ReactScopeInstance,\r\n): null | Object {\r\n  if (enableScopeAPI) {\r\n    return getFiberFromScopeInstance(scopeInstance);\r\n  }\r\n  return null;\r\n}\r\n\r\nexport const supportsTestSelectors = true;\r\n\r\nexport function findFiberRoot(node: Instance): null | FiberRoot {\r\n  const stack = [node];\r\n  let index = 0;\r\n  while (index < stack.length) {\r\n    const current = stack[index++];\r\n    if (isContainerMarkedAsRoot(current)) {\r\n      return ((getInstanceFromNodeDOMTree(current): any): FiberRoot);\r\n    }\r\n    stack.push(...current.children);\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function getBoundingRect(node: Instance): BoundingRect {\r\n  const rect = node.getBoundingClientRect();\r\n  return {\r\n    x: rect.left,\r\n    y: rect.top,\r\n    width: rect.width,\r\n    height: rect.height,\r\n  };\r\n}\r\n\r\nexport function matchAccessibilityRole(node: Instance, role: string): boolean {\r\n  if (hasRole(node, role)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function getTextContent(fiber: Fiber): string | null {\r\n  switch (fiber.tag) {\r\n    case HostComponent:\r\n      let textContent = '';\r\n      const childNodes = fiber.stateNode.childNodes;\r\n      for (let i = 0; i < childNodes.length; i++) {\r\n        const childNode = childNodes[i];\r\n        if (childNode.nodeType === Node.TEXT_NODE) {\r\n          textContent += childNode.textContent;\r\n        }\r\n      }\r\n      return textContent;\r\n    case HostText:\r\n      return fiber.stateNode.textContent;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function isHiddenSubtree(fiber: Fiber): boolean {\r\n  return fiber.tag === HostComponent && fiber.memoizedProps.hidden === true;\r\n}\r\n\r\nexport function setFocusIfFocusable(node: Instance): boolean {\r\n  // The logic for determining if an element is focusable is kind of complex,\r\n  // and since we want to actually change focus anyway- we can just skip it.\r\n  // Instead we'll just listen for a \"focus\" event to verify that focus was set.\r\n  //\r\n  // We could compare the node to document.activeElement after focus,\r\n  // but this would not handle the case where application code managed focus to automatically blur.\r\n  let didFocus = false;\r\n  const handleFocus = () => {\r\n    didFocus = true;\r\n  };\r\n\r\n  const element = ((node: any): HTMLElement);\r\n  try {\r\n    element.addEventListener('focus', handleFocus);\r\n    (element.focus || HTMLElement.prototype.focus).call(element);\r\n  } finally {\r\n    element.removeEventListener('focus', handleFocus);\r\n  }\r\n\r\n  return didFocus;\r\n}\r\n\r\ntype RectRatio = {\r\n  ratio: number,\r\n  rect: BoundingRect,\r\n};\r\n\r\nexport function setupIntersectionObserver(\r\n  targets: Array<Instance>,\r\n  callback: ObserveVisibleRectsCallback,\r\n  options?: IntersectionObserverOptions,\r\n): {|\r\n  disconnect: () => void,\r\n  observe: (instance: Instance) => void,\r\n  unobserve: (instance: Instance) => void,\r\n|} {\r\n  const rectRatioCache: Map<Instance, RectRatio> = new Map();\r\n  targets.forEach(target => {\r\n    rectRatioCache.set(target, {\r\n      rect: getBoundingRect(target),\r\n      ratio: 0,\r\n    });\r\n  });\r\n\r\n  const handleIntersection = (entries: Array<IntersectionObserverEntry>) => {\r\n    entries.forEach(entry => {\r\n      const {boundingClientRect, intersectionRatio, target} = entry;\r\n      rectRatioCache.set(target, {\r\n        rect: {\r\n          x: boundingClientRect.left,\r\n          y: boundingClientRect.top,\r\n          width: boundingClientRect.width,\r\n          height: boundingClientRect.height,\r\n        },\r\n        ratio: intersectionRatio,\r\n      });\r\n    });\r\n\r\n    callback(Array.from(rectRatioCache.values()));\r\n  };\r\n\r\n  const observer = new IntersectionObserver(handleIntersection, options);\r\n  targets.forEach(target => {\r\n    observer.observe((target: any));\r\n  });\r\n\r\n  return {\r\n    disconnect: () => observer.disconnect(),\r\n    observe: target => {\r\n      rectRatioCache.set(target, {\r\n        rect: getBoundingRect(target),\r\n        ratio: 0,\r\n      });\r\n      observer.observe((target: any));\r\n    },\r\n    unobserve: target => {\r\n      rectRatioCache.delete(target);\r\n      observer.unobserve((target: any));\r\n    },\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}