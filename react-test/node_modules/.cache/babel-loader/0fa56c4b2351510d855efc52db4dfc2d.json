{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE, IS_LEGACY_FB_SUPPORT_MODE, SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS } from './EventSystemFlags';\nimport { allNativeEvents } from './EventRegistry';\nimport { IS_CAPTURE_PHASE, IS_EVENT_HANDLE_NON_MANAGED_NODE, IS_NON_DELEGATED } from './EventSystemFlags';\nimport { isReplayingEvent } from './CurrentReplayingEvent';\nimport { HostRoot, HostPortal, HostComponent, HostText, ScopeComponent } from 'react-reconciler/src/ReactWorkTags';\nimport getEventTarget from './getEventTarget';\nimport { getClosestInstanceFromNode, getEventListenerSet, getEventHandlerListeners } from '../client/ReactDOMComponentTree';\nimport { COMMENT_NODE } from '../shared/HTMLNodeType';\nimport { batchedUpdates } from './ReactDOMUpdateBatching';\nimport getListener from './getListener';\nimport { passiveBrowserEventsSupported } from './checkPassiveEvents';\nimport { enableLegacyFBSupport, enableCreateEventHandleAPI, enableScopeAPI } from 'shared/ReactFeatureFlags';\nimport { invokeGuardedCallbackAndCatchFirstError, rethrowCaughtError } from 'shared/ReactErrorUtils';\nimport { DOCUMENT_NODE } from '../shared/HTMLNodeType';\nimport { createEventListenerWrapperWithPriority } from './ReactDOMEventListener';\nimport { removeEventListener, addEventCaptureListener, addEventBubbleListener, addEventBubbleListenerWithPassiveFlag, addEventCaptureListenerWithPassiveFlag } from './EventListener';\nimport * as BeforeInputEventPlugin from './plugins/BeforeInputEventPlugin';\nimport * as ChangeEventPlugin from './plugins/ChangeEventPlugin';\nimport * as EnterLeaveEventPlugin from './plugins/EnterLeaveEventPlugin';\nimport * as SelectEventPlugin from './plugins/SelectEventPlugin';\nimport * as SimpleEventPlugin from './plugins/SimpleEventPlugin';\n// TODO: remove top-level side effect.\nSimpleEventPlugin.registerEvents();\nEnterLeaveEventPlugin.registerEvents();\nChangeEventPlugin.registerEvents();\nSelectEventPlugin.registerEvents();\nBeforeInputEventPlugin.registerEvents();\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  // TODO: we should remove the concept of a \"SimpleEventPlugin\".\n  // This is the basic functionality of the event system. All\n  // the other plugins are essentially polyfills. So the plugin\n  // should probably be inlined somewhere and have its logic\n  // be core the to event system. This would potentially allow\n  // us to ship builds of React without the polyfilled plugins below.\n  SimpleEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n  const shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the\n  // event's native \"bubble\" phase, which means that we're\n  // not in the capture phase. That's because we emulate\n  // the capture phase here still. This is a trade-off,\n  // because in an ideal world we would not emulate and use\n  // the phases properly, like we do with the SimpleEvent\n  // plugin. However, the plugins below either expect\n  // emulation (EnterLeave) or use state localized to that\n  // plugin (BeforeInput, Change, Select). The state in\n  // these modules complicates things, as you'll essentially\n  // get the case where the capture phase event might change\n  // state, only for the following bubble event to come in\n  // later and not trigger anything as the state now\n  // invalidates the heuristics of the event plugin. We\n  // could alter all these plugins to work in such ways, but\n  // that might cause other unknown side-effects that we\n  // can't foresee right now.\n\n  if (shouldProcessPolyfillPlugins) {\n    EnterLeaveEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n    ChangeEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n    SelectEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n    BeforeInputEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n  }\n} // List of events that need to be individually attached to media elements.\n\n\nexport const mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'resize', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']; // We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\n\nexport const nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle', // In order to reduce bytes, we insert the above array of media events\n// into this Set. Note: the \"error\" event isn't an exclusive media event,\n// and can occur on other elements too. Rather than duplicate that event,\n// we just take it from the media events array.\n...mediaEventTypes]);\n\nfunction executeDispatch(event, listener, currentTarget) {\n  const type = event.type || 'unknown-event';\n  event.currentTarget = currentTarget;\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\nfunction processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {\n  let previousInstance;\n\n  if (inCapturePhase) {\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\n      const {\n        instance,\n        currentTarget,\n        listener\n      } = dispatchListeners[i];\n\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  } else {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      const {\n        instance,\n        currentTarget,\n        listener\n      } = dispatchListeners[i];\n\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  }\n}\n\nexport function processDispatchQueue(dispatchQueue, eventSystemFlags) {\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n\n  for (let i = 0; i < dispatchQueue.length; i++) {\n    const {\n      event,\n      listeners\n    } = dispatchQueue[i];\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.\n  } // This would be a good time to rethrow if any of the event handlers threw.\n\n\n  rethrowCaughtError();\n}\n\nfunction dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  const dispatchQueue = [];\n  extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n  processDispatchQueue(dispatchQueue, eventSystemFlags);\n}\n\nexport function listenToNonDelegatedEvent(domEventName, targetElement) {\n  if (__DEV__) {\n    if (!nonDelegatedEvents.has(domEventName)) {\n      console.error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". ' + 'This is a bug in React. Please file an issue.', domEventName);\n    }\n  }\n\n  const isCapturePhaseListener = false;\n  const listenerSet = getEventListenerSet(targetElement);\n  const listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\n\n  if (!listenerSet.has(listenerSetKey)) {\n    addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);\n    listenerSet.add(listenerSetKey);\n  }\n}\nexport function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n  if (__DEV__) {\n    if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\n      console.error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. ' + 'This is a bug in React. Please file an issue.', domEventName);\n    }\n  }\n\n  let eventSystemFlags = 0;\n\n  if (isCapturePhaseListener) {\n    eventSystemFlags |= IS_CAPTURE_PHASE;\n  }\n\n  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n} // This is only used by createEventHandle when the\n// target is not a DOM element. E.g. window.\n\nexport function listenToNativeEventForNonManagedEventTarget(domEventName, isCapturePhaseListener, target) {\n  let eventSystemFlags = IS_EVENT_HANDLE_NON_MANAGED_NODE;\n  const listenerSet = getEventListenerSet(target);\n  const listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\n\n  if (!listenerSet.has(listenerSetKey)) {\n    if (isCapturePhaseListener) {\n      eventSystemFlags |= IS_CAPTURE_PHASE;\n    }\n\n    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n    listenerSet.add(listenerSetKey);\n  }\n}\nconst listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);\nexport function listenToAllSupportedEvents(rootContainerElement) {\n  // 给真实dom\n  if (!rootContainerElement[listeningMarker]) {\n    rootContainerElement[listeningMarker] = true;\n    allNativeEvents.forEach(domEventName => {\n      // We handle selectionchange separately because it\n      // doesn't bubble and needs to be on the document.\n      if (domEventName !== 'selectionchange') {\n        if (!nonDelegatedEvents.has(domEventName)) {\n          listenToNativeEvent(domEventName, false, rootContainerElement);\n        }\n\n        listenToNativeEvent(domEventName, true, rootContainerElement);\n      }\n    });\n    const ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n\n    if (ownerDocument !== null) {\n      // The selectionchange event also needs deduplication\n      // but it is attached to the document.\n      if (!ownerDocument[listeningMarker]) {\n        ownerDocument[listeningMarker] = true;\n        listenToNativeEvent('selectionchange', false, ownerDocument);\n      }\n    }\n  }\n}\n\nfunction addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {\n  let listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be\n  // active and not passive.\n\n  let isPassiveListener = undefined;\n\n  if (passiveBrowserEventsSupported) {\n    // Browsers introduced an intervention, making these events\n    // passive by default on document. React doesn't bind them\n    // to document anymore, but changing this now would undo\n    // the performance wins from the change. So we emulate\n    // the existing behavior manually on the roots now.\n    // https://github.com/facebook/react/issues/19651\n    if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {\n      isPassiveListener = true;\n    }\n  }\n\n  targetContainer = enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport ? targetContainer.ownerDocument : targetContainer;\n  let unsubscribeListener; // When legacyFBSupport is enabled, it's for when we\n  // want to add a one time event listener to a container.\n  // This should only be used with enableLegacyFBSupport\n  // due to requirement to provide compatibility with\n  // internal FB www event tooling. This works by removing\n  // the event listener as soon as it is invoked. We could\n  // also attempt to use the {once: true} param on\n  // addEventListener, but that requires support and some\n  // browsers do not support this today, and given this is\n  // to support legacy code patterns, it's likely they'll\n  // need support for such browsers.\n\n  if (enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport) {\n    const originalListener = listener;\n\n    listener = function () {\n      removeEventListener(targetContainer, domEventName, unsubscribeListener, isCapturePhaseListener);\n\n      for (var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++) {\n        p[_key] = arguments[_key];\n      }\n\n      return originalListener.apply(this, p);\n    };\n  } // TODO: There are too many combinations here. Consolidate them.\n\n\n  if (isCapturePhaseListener) {\n    if (isPassiveListener !== undefined) {\n      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n    } else {\n      unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);\n    }\n  } else {\n    if (isPassiveListener !== undefined) {\n      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n    } else {\n      unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);\n    }\n  }\n}\n\nfunction deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer) {\n  // We defer all click events with legacy FB support mode on.\n  // This means we add a one time event listener to trigger\n  // after the FB delegated listeners fire.\n  const isDeferredListenerForLegacyFBSupport = true;\n  addTrappedEventListener(targetContainer, domEventName, IS_LEGACY_FB_SUPPORT_MODE, false, isDeferredListenerForLegacyFBSupport);\n}\n\nfunction isMatchingRootContainer(grandContainer, targetContainer) {\n  return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;\n}\n\nexport function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n  let ancestorInst = targetInst;\n\n  if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {\n    const targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we\n    // defer the event to the null with a one\n    // time event listener so we can defer the event.\n\n    if (enableLegacyFBSupport && // If our event flags match the required flags for entering\n    // FB legacy mode and we are processing the \"click\" event,\n    // then we can defer the event to the \"document\", to allow\n    // for legacy FB support, where the expected behavior was to\n    // match React < 16 behavior of delegated clicks to the doc.\n    domEventName === 'click' && (eventSystemFlags & SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE) === 0 && !isReplayingEvent(nativeEvent)) {\n      deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer);\n      return;\n    }\n\n    if (targetInst !== null) {\n      // The below logic attempts to work out if we need to change\n      // the target fiber to a different ancestor. We had similar logic\n      // in the legacy event system, except the big difference between\n      // systems is that the modern event system now has an event listener\n      // attached to each React Root and React Portal Root. Together,\n      // the DOM nodes representing these roots are the \"rootContainer\".\n      // To figure out which ancestor instance we should use, we traverse\n      // up the fiber tree from the target instance and attempt to find\n      // root boundaries that match that of our current \"rootContainer\".\n      // If we find that \"rootContainer\", we find the parent fiber\n      // sub-tree for that root and make that our ancestor instance.\n      let node = targetInst;\n\n      mainLoop: while (true) {\n        if (node === null) {\n          return;\n        }\n\n        const nodeTag = node.tag;\n\n        if (nodeTag === HostRoot || nodeTag === HostPortal) {\n          let container = node.stateNode.containerInfo;\n\n          if (isMatchingRootContainer(container, targetContainerNode)) {\n            break;\n          }\n\n          if (nodeTag === HostPortal) {\n            // The target is a portal, but it's not the rootContainer we're looking for.\n            // Normally portals handle their own events all the way down to the root.\n            // So we should be able to stop now. However, we don't know if this portal\n            // was part of *our* root.\n            let grandNode = node.return;\n\n            while (grandNode !== null) {\n              const grandTag = grandNode.tag;\n\n              if (grandTag === HostRoot || grandTag === HostPortal) {\n                const grandContainer = grandNode.stateNode.containerInfo;\n\n                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {\n                  // This is the rootContainer we're looking for and we found it as\n                  // a parent of the Portal. That means we can ignore it because the\n                  // Portal will bubble through to us.\n                  return;\n                }\n              }\n\n              grandNode = grandNode.return;\n            }\n          } // Now we need to find it's corresponding host fiber in the other\n          // tree. To do this we can use getClosestInstanceFromNode, but we\n          // need to validate that the fiber is a host instance, otherwise\n          // we need to traverse up through the DOM till we find the correct\n          // node that is from the other tree.\n\n\n          while (container !== null) {\n            const parentNode = getClosestInstanceFromNode(container);\n\n            if (parentNode === null) {\n              return;\n            }\n\n            const parentTag = parentNode.tag;\n\n            if (parentTag === HostComponent || parentTag === HostText) {\n              node = ancestorInst = parentNode;\n              continue mainLoop;\n            }\n\n            container = container.parentNode;\n          }\n        }\n\n        node = node.return;\n      }\n    }\n  }\n\n  batchedUpdates(() => dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst, targetContainer));\n}\n\nfunction createDispatchListener(instance, listener, currentTarget) {\n  return {\n    instance,\n    listener,\n    currentTarget\n  };\n}\n\nexport function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {\n  const captureName = reactName !== null ? reactName + 'Capture' : null;\n  const reactEventName = inCapturePhase ? captureName : reactName;\n  let listeners = [];\n  let instance = targetFiber;\n  let lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.\n\n  while (instance !== null) {\n    const {\n      stateNode,\n      tag\n    } = instance; // Handle listeners that are on HostComponents (i.e. <div>)\n\n    if (tag === HostComponent && stateNode !== null) {\n      lastHostComponent = stateNode; // createEventHandle listeners\n\n      if (enableCreateEventHandleAPI) {\n        const eventHandlerListeners = getEventHandlerListeners(lastHostComponent);\n\n        if (eventHandlerListeners !== null) {\n          eventHandlerListeners.forEach(entry => {\n            if (entry.type === nativeEventType && entry.capture === inCapturePhase) {\n              listeners.push(createDispatchListener(instance, entry.callback, lastHostComponent));\n            }\n          });\n        }\n      } // Standard React on* listeners, i.e. onClick or onClickCapture\n\n\n      if (reactEventName !== null) {\n        const listener = getListener(instance, reactEventName);\n\n        if (listener != null) {\n          listeners.push(createDispatchListener(instance, listener, lastHostComponent));\n        }\n      }\n    } else if (enableCreateEventHandleAPI && enableScopeAPI && tag === ScopeComponent && lastHostComponent !== null && stateNode !== null) {\n      // Scopes\n      const reactScopeInstance = stateNode;\n      const eventHandlerListeners = getEventHandlerListeners(reactScopeInstance);\n\n      if (eventHandlerListeners !== null) {\n        eventHandlerListeners.forEach(entry => {\n          if (entry.type === nativeEventType && entry.capture === inCapturePhase) {\n            listeners.push(createDispatchListener(instance, entry.callback, lastHostComponent));\n          }\n        });\n      }\n    } // If we are only accumulating events for the target, then we don't\n    // continue to propagate through the React fiber tree to find other\n    // listeners.\n\n\n    if (accumulateTargetOnly) {\n      break;\n    } // If we are processing the onBeforeBlur event, then we need to take\n    // into consideration that part of the React tree might have been hidden\n    // or deleted (as we're invoking this event during commit). We can find\n    // this out by checking if intercept fiber set on the event matches the\n    // current instance fiber. In which case, we should clear all existing\n    // listeners.\n\n\n    if (enableCreateEventHandleAPI && nativeEvent.type === 'beforeblur') {\n      // $FlowFixMe: internal field\n      const detachedInterceptFiber = nativeEvent._detachedInterceptFiber;\n\n      if (detachedInterceptFiber !== null && (detachedInterceptFiber === instance || detachedInterceptFiber === instance.alternate)) {\n        listeners = [];\n      }\n    }\n\n    instance = instance.return;\n  }\n\n  return listeners;\n} // We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\n\nexport function accumulateTwoPhaseListeners(targetFiber, reactName) {\n  const captureName = reactName + 'Capture';\n  const listeners = [];\n  let instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.\n\n  while (instance !== null) {\n    const {\n      stateNode,\n      tag\n    } = instance; // Handle listeners that are on HostComponents (i.e. <div>)\n\n    if (tag === HostComponent && stateNode !== null) {\n      const currentTarget = stateNode;\n      const captureListener = getListener(instance, captureName);\n\n      if (captureListener != null) {\n        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n      }\n\n      const bubbleListener = getListener(instance, reactName);\n\n      if (bubbleListener != null) {\n        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n      }\n    }\n\n    instance = instance.return;\n  }\n\n  return listeners;\n}\n\nfunction getParent(inst) {\n  if (inst === null) {\n    return null;\n  }\n\n  do {\n    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n\n  if (inst) {\n    return inst;\n  }\n\n  return null;\n}\n/**\r\n * Return the lowest common ancestor of A and B, or null if they are in\r\n * different trees.\r\n */\n\n\nfunction getLowestCommonAncestor(instA, instB) {\n  let nodeA = instA;\n  let nodeB = instB;\n  let depthA = 0;\n\n  for (let tempA = nodeA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n\n  let depthB = 0;\n\n  for (let tempB = nodeB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  } // If A is deeper, crawl up.\n\n\n  while (depthA - depthB > 0) {\n    nodeA = getParent(nodeA);\n    depthA--;\n  } // If B is deeper, crawl up.\n\n\n  while (depthB - depthA > 0) {\n    nodeB = getParent(nodeB);\n    depthB--;\n  } // Walk in lockstep until we find a match.\n\n\n  let depth = depthA;\n\n  while (depth--) {\n    if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {\n      return nodeA;\n    }\n\n    nodeA = getParent(nodeA);\n    nodeB = getParent(nodeB);\n  }\n\n  return null;\n}\n\nfunction accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\n  const registrationName = event._reactName;\n  const listeners = [];\n  let instance = target;\n\n  while (instance !== null) {\n    if (instance === common) {\n      break;\n    }\n\n    const {\n      alternate,\n      stateNode,\n      tag\n    } = instance;\n\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n\n    if (tag === HostComponent && stateNode !== null) {\n      const currentTarget = stateNode;\n\n      if (inCapturePhase) {\n        const captureListener = getListener(instance, registrationName);\n\n        if (captureListener != null) {\n          listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n        }\n      } else if (!inCapturePhase) {\n        const bubbleListener = getListener(instance, registrationName);\n\n        if (bubbleListener != null) {\n          listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n        }\n      }\n    }\n\n    instance = instance.return;\n  }\n\n  if (listeners.length !== 0) {\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n  }\n} // We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\n\n\nexport function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {\n  const common = from && to ? getLowestCommonAncestor(from, to) : null;\n\n  if (from !== null) {\n    accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);\n  }\n\n  if (to !== null && enterEvent !== null) {\n    accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);\n  }\n}\nexport function accumulateEventHandleNonManagedNodeListeners(reactEventType, currentTarget, inCapturePhase) {\n  const listeners = [];\n  const eventListeners = getEventHandlerListeners(currentTarget);\n\n  if (eventListeners !== null) {\n    eventListeners.forEach(entry => {\n      if (entry.type === reactEventType && entry.capture === inCapturePhase) {\n        listeners.push(createDispatchListener(null, entry.callback, currentTarget));\n      }\n    });\n  }\n\n  return listeners;\n}\nexport function getListenerSetKey(domEventName, capture) {\n  return `${domEventName}__${capture ? 'capture' : 'bubble'}`;\n}","map":{"version":3,"names":["SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE","IS_LEGACY_FB_SUPPORT_MODE","SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS","allNativeEvents","IS_CAPTURE_PHASE","IS_EVENT_HANDLE_NON_MANAGED_NODE","IS_NON_DELEGATED","isReplayingEvent","HostRoot","HostPortal","HostComponent","HostText","ScopeComponent","getEventTarget","getClosestInstanceFromNode","getEventListenerSet","getEventHandlerListeners","COMMENT_NODE","batchedUpdates","getListener","passiveBrowserEventsSupported","enableLegacyFBSupport","enableCreateEventHandleAPI","enableScopeAPI","invokeGuardedCallbackAndCatchFirstError","rethrowCaughtError","DOCUMENT_NODE","createEventListenerWrapperWithPriority","removeEventListener","addEventCaptureListener","addEventBubbleListener","addEventBubbleListenerWithPassiveFlag","addEventCaptureListenerWithPassiveFlag","BeforeInputEventPlugin","ChangeEventPlugin","EnterLeaveEventPlugin","SelectEventPlugin","SimpleEventPlugin","registerEvents","extractEvents","dispatchQueue","domEventName","targetInst","nativeEvent","nativeEventTarget","eventSystemFlags","targetContainer","shouldProcessPolyfillPlugins","mediaEventTypes","nonDelegatedEvents","Set","executeDispatch","event","listener","currentTarget","type","undefined","processDispatchQueueItemsInOrder","dispatchListeners","inCapturePhase","previousInstance","i","length","instance","isPropagationStopped","processDispatchQueue","listeners","dispatchEventsForPlugins","listenToNonDelegatedEvent","targetElement","__DEV__","has","console","error","isCapturePhaseListener","listenerSet","listenerSetKey","getListenerSetKey","addTrappedEventListener","add","listenToNativeEvent","target","listenToNativeEventForNonManagedEventTarget","listeningMarker","Math","random","toString","slice","listenToAllSupportedEvents","rootContainerElement","forEach","ownerDocument","nodeType","isDeferredListenerForLegacyFBSupport","isPassiveListener","unsubscribeListener","originalListener","p","apply","deferClickToDocumentForLegacyFBSupport","isMatchingRootContainer","grandContainer","parentNode","dispatchEventForPluginEventSystem","ancestorInst","targetContainerNode","node","mainLoop","nodeTag","tag","container","stateNode","containerInfo","grandNode","return","grandTag","parentTag","createDispatchListener","accumulateSinglePhaseListeners","targetFiber","reactName","nativeEventType","accumulateTargetOnly","captureName","reactEventName","lastHostComponent","eventHandlerListeners","entry","capture","push","callback","reactScopeInstance","detachedInterceptFiber","_detachedInterceptFiber","alternate","accumulateTwoPhaseListeners","captureListener","unshift","bubbleListener","getParent","inst","getLowestCommonAncestor","instA","instB","nodeA","nodeB","depthA","tempA","depthB","tempB","depth","accumulateEnterLeaveListenersForEvent","common","registrationName","_reactName","accumulateEnterLeaveTwoPhaseListeners","leaveEvent","enterEvent","from","to","accumulateEventHandleNonManagedNodeListeners","reactEventType","eventListeners"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-dom/src/events/DOMPluginEventSystem.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {DOMEventName} from './DOMEventNames';\r\nimport {\r\n  type EventSystemFlags,\r\n  SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE,\r\n  IS_LEGACY_FB_SUPPORT_MODE,\r\n  SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS,\r\n} from './EventSystemFlags';\r\nimport type {AnyNativeEvent} from './PluginModuleType';\r\nimport type {\r\n  KnownReactSyntheticEvent,\r\n  ReactSyntheticEvent,\r\n} from './ReactSyntheticEventType';\r\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\r\n\r\nimport {allNativeEvents} from './EventRegistry';\r\nimport {\r\n  IS_CAPTURE_PHASE,\r\n  IS_EVENT_HANDLE_NON_MANAGED_NODE,\r\n  IS_NON_DELEGATED,\r\n} from './EventSystemFlags';\r\nimport {isReplayingEvent} from './CurrentReplayingEvent';\r\n\r\nimport {\r\n  HostRoot,\r\n  HostPortal,\r\n  HostComponent,\r\n  HostText,\r\n  ScopeComponent,\r\n} from 'react-reconciler/src/ReactWorkTags';\r\n\r\nimport getEventTarget from './getEventTarget';\r\nimport {\r\n  getClosestInstanceFromNode,\r\n  getEventListenerSet,\r\n  getEventHandlerListeners,\r\n} from '../client/ReactDOMComponentTree';\r\nimport {COMMENT_NODE} from '../shared/HTMLNodeType';\r\nimport {batchedUpdates} from './ReactDOMUpdateBatching';\r\nimport getListener from './getListener';\r\nimport {passiveBrowserEventsSupported} from './checkPassiveEvents';\r\n\r\nimport {\r\n  enableLegacyFBSupport,\r\n  enableCreateEventHandleAPI,\r\n  enableScopeAPI,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {\r\n  invokeGuardedCallbackAndCatchFirstError,\r\n  rethrowCaughtError,\r\n} from 'shared/ReactErrorUtils';\r\nimport {DOCUMENT_NODE} from '../shared/HTMLNodeType';\r\nimport {createEventListenerWrapperWithPriority} from './ReactDOMEventListener';\r\nimport {\r\n  removeEventListener,\r\n  addEventCaptureListener,\r\n  addEventBubbleListener,\r\n  addEventBubbleListenerWithPassiveFlag,\r\n  addEventCaptureListenerWithPassiveFlag,\r\n} from './EventListener';\r\nimport * as BeforeInputEventPlugin from './plugins/BeforeInputEventPlugin';\r\nimport * as ChangeEventPlugin from './plugins/ChangeEventPlugin';\r\nimport * as EnterLeaveEventPlugin from './plugins/EnterLeaveEventPlugin';\r\nimport * as SelectEventPlugin from './plugins/SelectEventPlugin';\r\nimport * as SimpleEventPlugin from './plugins/SimpleEventPlugin';\r\n\r\ntype DispatchListener = {|\r\n  instance: null | Fiber,\r\n  listener: Function,\r\n  currentTarget: EventTarget,\r\n|};\r\n\r\ntype DispatchEntry = {|\r\n  event: ReactSyntheticEvent,\r\n  listeners: Array<DispatchListener>,\r\n|};\r\n\r\nexport type DispatchQueue = Array<DispatchEntry>;\r\n\r\n// TODO: remove top-level side effect.\r\nSimpleEventPlugin.registerEvents();\r\nEnterLeaveEventPlugin.registerEvents();\r\nChangeEventPlugin.registerEvents();\r\nSelectEventPlugin.registerEvents();\r\nBeforeInputEventPlugin.registerEvents();\r\n\r\nfunction extractEvents(\r\n  dispatchQueue: DispatchQueue,\r\n  domEventName: DOMEventName,\r\n  targetInst: null | Fiber,\r\n  nativeEvent: AnyNativeEvent,\r\n  nativeEventTarget: null | EventTarget,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n) {\r\n  // TODO: we should remove the concept of a \"SimpleEventPlugin\".\r\n  // This is the basic functionality of the event system. All\r\n  // the other plugins are essentially polyfills. So the plugin\r\n  // should probably be inlined somewhere and have its logic\r\n  // be core the to event system. This would potentially allow\r\n  // us to ship builds of React without the polyfilled plugins below.\r\n  SimpleEventPlugin.extractEvents(\r\n    dispatchQueue,\r\n    domEventName,\r\n    targetInst,\r\n    nativeEvent,\r\n    nativeEventTarget,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n  );\r\n  const shouldProcessPolyfillPlugins =\r\n    (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\r\n  // We don't process these events unless we are in the\r\n  // event's native \"bubble\" phase, which means that we're\r\n  // not in the capture phase. That's because we emulate\r\n  // the capture phase here still. This is a trade-off,\r\n  // because in an ideal world we would not emulate and use\r\n  // the phases properly, like we do with the SimpleEvent\r\n  // plugin. However, the plugins below either expect\r\n  // emulation (EnterLeave) or use state localized to that\r\n  // plugin (BeforeInput, Change, Select). The state in\r\n  // these modules complicates things, as you'll essentially\r\n  // get the case where the capture phase event might change\r\n  // state, only for the following bubble event to come in\r\n  // later and not trigger anything as the state now\r\n  // invalidates the heuristics of the event plugin. We\r\n  // could alter all these plugins to work in such ways, but\r\n  // that might cause other unknown side-effects that we\r\n  // can't foresee right now.\r\n  if (shouldProcessPolyfillPlugins) {\r\n    EnterLeaveEventPlugin.extractEvents(\r\n      dispatchQueue,\r\n      domEventName,\r\n      targetInst,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n    );\r\n    ChangeEventPlugin.extractEvents(\r\n      dispatchQueue,\r\n      domEventName,\r\n      targetInst,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n    );\r\n    SelectEventPlugin.extractEvents(\r\n      dispatchQueue,\r\n      domEventName,\r\n      targetInst,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n    );\r\n    BeforeInputEventPlugin.extractEvents(\r\n      dispatchQueue,\r\n      domEventName,\r\n      targetInst,\r\n      nativeEvent,\r\n      nativeEventTarget,\r\n      eventSystemFlags,\r\n      targetContainer,\r\n    );\r\n  }\r\n}\r\n\r\n// List of events that need to be individually attached to media elements.\r\nexport const mediaEventTypes: Array<DOMEventName> = [\r\n  'abort',\r\n  'canplay',\r\n  'canplaythrough',\r\n  'durationchange',\r\n  'emptied',\r\n  'encrypted',\r\n  'ended',\r\n  'error',\r\n  'loadeddata',\r\n  'loadedmetadata',\r\n  'loadstart',\r\n  'pause',\r\n  'play',\r\n  'playing',\r\n  'progress',\r\n  'ratechange',\r\n  'resize',\r\n  'seeked',\r\n  'seeking',\r\n  'stalled',\r\n  'suspend',\r\n  'timeupdate',\r\n  'volumechange',\r\n  'waiting',\r\n];\r\n\r\n// We should not delegate these events to the container, but rather\r\n// set them on the actual target element itself. This is primarily\r\n// because these events do not consistently bubble in the DOM.\r\nexport const nonDelegatedEvents: Set<DOMEventName> = new Set([\r\n  'cancel',\r\n  'close',\r\n  'invalid',\r\n  'load',\r\n  'scroll',\r\n  'toggle',\r\n  // In order to reduce bytes, we insert the above array of media events\r\n  // into this Set. Note: the \"error\" event isn't an exclusive media event,\r\n  // and can occur on other elements too. Rather than duplicate that event,\r\n  // we just take it from the media events array.\r\n  ...mediaEventTypes,\r\n]);\r\n\r\nfunction executeDispatch(\r\n  event: ReactSyntheticEvent,\r\n  listener: Function,\r\n  currentTarget: EventTarget,\r\n): void {\r\n  const type = event.type || 'unknown-event';\r\n  event.currentTarget = currentTarget;\r\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\r\n  event.currentTarget = null;\r\n}\r\n\r\nfunction processDispatchQueueItemsInOrder(\r\n  event: ReactSyntheticEvent,\r\n  dispatchListeners: Array<DispatchListener>,\r\n  inCapturePhase: boolean,\r\n): void {\r\n  let previousInstance;\r\n  if (inCapturePhase) {\r\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\r\n      const {instance, currentTarget, listener} = dispatchListeners[i];\r\n      if (instance !== previousInstance && event.isPropagationStopped()) {\r\n        return;\r\n      }\r\n      executeDispatch(event, listener, currentTarget);\r\n      previousInstance = instance;\r\n    }\r\n  } else {\r\n    for (let i = 0; i < dispatchListeners.length; i++) {\r\n      const {instance, currentTarget, listener} = dispatchListeners[i];\r\n      if (instance !== previousInstance && event.isPropagationStopped()) {\r\n        return;\r\n      }\r\n      executeDispatch(event, listener, currentTarget);\r\n      previousInstance = instance;\r\n    }\r\n  }\r\n}\r\n\r\nexport function processDispatchQueue(\r\n  dispatchQueue: DispatchQueue,\r\n  eventSystemFlags: EventSystemFlags,\r\n): void {\r\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n  for (let i = 0; i < dispatchQueue.length; i++) {\r\n    const {event, listeners} = dispatchQueue[i];\r\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\r\n    //  event system doesn't use pooling.\r\n  }\r\n  // This would be a good time to rethrow if any of the event handlers threw.\r\n  rethrowCaughtError();\r\n}\r\n\r\nfunction dispatchEventsForPlugins(\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  nativeEvent: AnyNativeEvent,\r\n  targetInst: null | Fiber,\r\n  targetContainer: EventTarget,\r\n): void {\r\n  const nativeEventTarget = getEventTarget(nativeEvent);\r\n  const dispatchQueue: DispatchQueue = [];\r\n  extractEvents(\r\n    dispatchQueue,\r\n    domEventName,\r\n    targetInst,\r\n    nativeEvent,\r\n    nativeEventTarget,\r\n    eventSystemFlags,\r\n    targetContainer,\r\n  );\r\n  processDispatchQueue(dispatchQueue, eventSystemFlags);\r\n}\r\n\r\nexport function listenToNonDelegatedEvent(\r\n  domEventName: DOMEventName,\r\n  targetElement: Element,\r\n): void {\r\n  if (__DEV__) {\r\n    if (!nonDelegatedEvents.has(domEventName)) {\r\n      console.error(\r\n        'Did not expect a listenToNonDelegatedEvent() call for \"%s\". ' +\r\n          'This is a bug in React. Please file an issue.',\r\n        domEventName,\r\n      );\r\n    }\r\n  }\r\n  const isCapturePhaseListener = false;\r\n  const listenerSet = getEventListenerSet(targetElement);\r\n  const listenerSetKey = getListenerSetKey(\r\n    domEventName,\r\n    isCapturePhaseListener,\r\n  );\r\n  if (!listenerSet.has(listenerSetKey)) {\r\n    addTrappedEventListener(\r\n      targetElement,\r\n      domEventName,\r\n      IS_NON_DELEGATED,\r\n      isCapturePhaseListener,\r\n    );\r\n    listenerSet.add(listenerSetKey);\r\n  }\r\n}\r\n\r\nexport function listenToNativeEvent(\r\n  domEventName: DOMEventName,\r\n  isCapturePhaseListener: boolean,\r\n  target: EventTarget,\r\n): void {\r\n  if (__DEV__) {\r\n    if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\r\n      console.error(\r\n        'Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. ' +\r\n          'This is a bug in React. Please file an issue.',\r\n        domEventName,\r\n      );\r\n    }\r\n  }\r\n\r\n  let eventSystemFlags = 0;\r\n  if (isCapturePhaseListener) {\r\n    eventSystemFlags |= IS_CAPTURE_PHASE;\r\n  }\r\n  addTrappedEventListener(\r\n    target,\r\n    domEventName,\r\n    eventSystemFlags,\r\n    isCapturePhaseListener,\r\n  );\r\n}\r\n\r\n// This is only used by createEventHandle when the\r\n// target is not a DOM element. E.g. window.\r\nexport function listenToNativeEventForNonManagedEventTarget(\r\n  domEventName: DOMEventName,\r\n  isCapturePhaseListener: boolean,\r\n  target: EventTarget,\r\n): void {\r\n  let eventSystemFlags = IS_EVENT_HANDLE_NON_MANAGED_NODE;\r\n  const listenerSet = getEventListenerSet(target);\r\n  const listenerSetKey = getListenerSetKey(\r\n    domEventName,\r\n    isCapturePhaseListener,\r\n  );\r\n  if (!listenerSet.has(listenerSetKey)) {\r\n    if (isCapturePhaseListener) {\r\n      eventSystemFlags |= IS_CAPTURE_PHASE;\r\n    }\r\n    addTrappedEventListener(\r\n      target,\r\n      domEventName,\r\n      eventSystemFlags,\r\n      isCapturePhaseListener,\r\n    );\r\n    listenerSet.add(listenerSetKey);\r\n  }\r\n}\r\n\r\nconst listeningMarker =\r\n  '_reactListening' +\r\n  Math.random()\r\n    .toString(36)\r\n    .slice(2);\r\n\r\nexport function listenToAllSupportedEvents(rootContainerElement: EventTarget) {\r\n  // 给真实dom\r\n  if (!(rootContainerElement: any)[listeningMarker]) {\r\n    (rootContainerElement: any)[listeningMarker] = true;\r\n    allNativeEvents.forEach(domEventName => {\r\n      // We handle selectionchange separately because it\r\n      // doesn't bubble and needs to be on the document.\r\n      if (domEventName !== 'selectionchange') {\r\n        if (!nonDelegatedEvents.has(domEventName)) {\r\n          listenToNativeEvent(domEventName, false, rootContainerElement);\r\n        }\r\n        listenToNativeEvent(domEventName, true, rootContainerElement);\r\n      }\r\n    });\r\n    const ownerDocument =\r\n      (rootContainerElement: any).nodeType === DOCUMENT_NODE\r\n        ? rootContainerElement\r\n        : (rootContainerElement: any).ownerDocument;\r\n    if (ownerDocument !== null) {\r\n      // The selectionchange event also needs deduplication\r\n      // but it is attached to the document.\r\n      if (!(ownerDocument: any)[listeningMarker]) {\r\n        (ownerDocument: any)[listeningMarker] = true;\r\n        listenToNativeEvent('selectionchange', false, ownerDocument);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction addTrappedEventListener(\r\n  targetContainer: EventTarget,\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  isCapturePhaseListener: boolean,\r\n  isDeferredListenerForLegacyFBSupport?: boolean,\r\n) {\r\n  let listener = createEventListenerWrapperWithPriority(\r\n    targetContainer,\r\n    domEventName,\r\n    eventSystemFlags,\r\n  );\r\n  // If passive option is not supported, then the event will be\r\n  // active and not passive.\r\n  let isPassiveListener = undefined;\r\n  if (passiveBrowserEventsSupported) {\r\n    // Browsers introduced an intervention, making these events\r\n    // passive by default on document. React doesn't bind them\r\n    // to document anymore, but changing this now would undo\r\n    // the performance wins from the change. So we emulate\r\n    // the existing behavior manually on the roots now.\r\n    // https://github.com/facebook/react/issues/19651\r\n    if (\r\n      domEventName === 'touchstart' ||\r\n      domEventName === 'touchmove' ||\r\n      domEventName === 'wheel'\r\n    ) {\r\n      isPassiveListener = true;\r\n    }\r\n  }\r\n\r\n  targetContainer =\r\n    enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport\r\n      ? (targetContainer: any).ownerDocument\r\n      : targetContainer;\r\n\r\n  let unsubscribeListener;\r\n  // When legacyFBSupport is enabled, it's for when we\r\n  // want to add a one time event listener to a container.\r\n  // This should only be used with enableLegacyFBSupport\r\n  // due to requirement to provide compatibility with\r\n  // internal FB www event tooling. This works by removing\r\n  // the event listener as soon as it is invoked. We could\r\n  // also attempt to use the {once: true} param on\r\n  // addEventListener, but that requires support and some\r\n  // browsers do not support this today, and given this is\r\n  // to support legacy code patterns, it's likely they'll\r\n  // need support for such browsers.\r\n  if (enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport) {\r\n    const originalListener = listener;\r\n    listener = function(...p) {\r\n      removeEventListener(\r\n        targetContainer,\r\n        domEventName,\r\n        unsubscribeListener,\r\n        isCapturePhaseListener,\r\n      );\r\n      return originalListener.apply(this, p);\r\n    };\r\n  }\r\n  // TODO: There are too many combinations here. Consolidate them.\r\n  if (isCapturePhaseListener) {\r\n    if (isPassiveListener !== undefined) {\r\n      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(\r\n        targetContainer,\r\n        domEventName,\r\n        listener,\r\n        isPassiveListener,\r\n      );\r\n    } else {\r\n      unsubscribeListener = addEventCaptureListener(\r\n        targetContainer,\r\n        domEventName,\r\n        listener,\r\n      );\r\n    }\r\n  } else {\r\n    if (isPassiveListener !== undefined) {\r\n      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(\r\n        targetContainer,\r\n        domEventName,\r\n        listener,\r\n        isPassiveListener,\r\n      );\r\n    } else {\r\n      unsubscribeListener = addEventBubbleListener(\r\n        targetContainer,\r\n        domEventName,\r\n        listener,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction deferClickToDocumentForLegacyFBSupport(\r\n  domEventName: DOMEventName,\r\n  targetContainer: EventTarget,\r\n): void {\r\n  // We defer all click events with legacy FB support mode on.\r\n  // This means we add a one time event listener to trigger\r\n  // after the FB delegated listeners fire.\r\n  const isDeferredListenerForLegacyFBSupport = true;\r\n  addTrappedEventListener(\r\n    targetContainer,\r\n    domEventName,\r\n    IS_LEGACY_FB_SUPPORT_MODE,\r\n    false,\r\n    isDeferredListenerForLegacyFBSupport,\r\n  );\r\n}\r\n\r\nfunction isMatchingRootContainer(\r\n  grandContainer: Element,\r\n  targetContainer: EventTarget,\r\n): boolean {\r\n  return (\r\n    grandContainer === targetContainer ||\r\n    (grandContainer.nodeType === COMMENT_NODE &&\r\n      grandContainer.parentNode === targetContainer)\r\n  );\r\n}\r\n\r\nexport function dispatchEventForPluginEventSystem(\r\n  domEventName: DOMEventName,\r\n  eventSystemFlags: EventSystemFlags,\r\n  nativeEvent: AnyNativeEvent,\r\n  targetInst: null | Fiber,\r\n  targetContainer: EventTarget,\r\n): void {\r\n  let ancestorInst = targetInst;\r\n  if (\r\n    (eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 &&\r\n    (eventSystemFlags & IS_NON_DELEGATED) === 0\r\n  ) {\r\n    const targetContainerNode = ((targetContainer: any): Node);\r\n\r\n    // If we are using the legacy FB support flag, we\r\n    // defer the event to the null with a one\r\n    // time event listener so we can defer the event.\r\n    if (\r\n      enableLegacyFBSupport &&\r\n      // If our event flags match the required flags for entering\r\n      // FB legacy mode and we are processing the \"click\" event,\r\n      // then we can defer the event to the \"document\", to allow\r\n      // for legacy FB support, where the expected behavior was to\r\n      // match React < 16 behavior of delegated clicks to the doc.\r\n      domEventName === 'click' &&\r\n      (eventSystemFlags & SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE) === 0 &&\r\n      !isReplayingEvent(nativeEvent)\r\n    ) {\r\n      deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer);\r\n      return;\r\n    }\r\n    if (targetInst !== null) {\r\n      // The below logic attempts to work out if we need to change\r\n      // the target fiber to a different ancestor. We had similar logic\r\n      // in the legacy event system, except the big difference between\r\n      // systems is that the modern event system now has an event listener\r\n      // attached to each React Root and React Portal Root. Together,\r\n      // the DOM nodes representing these roots are the \"rootContainer\".\r\n      // To figure out which ancestor instance we should use, we traverse\r\n      // up the fiber tree from the target instance and attempt to find\r\n      // root boundaries that match that of our current \"rootContainer\".\r\n      // If we find that \"rootContainer\", we find the parent fiber\r\n      // sub-tree for that root and make that our ancestor instance.\r\n      let node = targetInst;\r\n\r\n      mainLoop: while (true) {\r\n        if (node === null) {\r\n          return;\r\n        }\r\n        const nodeTag = node.tag;\r\n        if (nodeTag === HostRoot || nodeTag === HostPortal) {\r\n          let container = node.stateNode.containerInfo;\r\n          if (isMatchingRootContainer(container, targetContainerNode)) {\r\n            break;\r\n          }\r\n          if (nodeTag === HostPortal) {\r\n            // The target is a portal, but it's not the rootContainer we're looking for.\r\n            // Normally portals handle their own events all the way down to the root.\r\n            // So we should be able to stop now. However, we don't know if this portal\r\n            // was part of *our* root.\r\n            let grandNode = node.return;\r\n            while (grandNode !== null) {\r\n              const grandTag = grandNode.tag;\r\n              if (grandTag === HostRoot || grandTag === HostPortal) {\r\n                const grandContainer = grandNode.stateNode.containerInfo;\r\n                if (\r\n                  isMatchingRootContainer(grandContainer, targetContainerNode)\r\n                ) {\r\n                  // This is the rootContainer we're looking for and we found it as\r\n                  // a parent of the Portal. That means we can ignore it because the\r\n                  // Portal will bubble through to us.\r\n                  return;\r\n                }\r\n              }\r\n              grandNode = grandNode.return;\r\n            }\r\n          }\r\n          // Now we need to find it's corresponding host fiber in the other\r\n          // tree. To do this we can use getClosestInstanceFromNode, but we\r\n          // need to validate that the fiber is a host instance, otherwise\r\n          // we need to traverse up through the DOM till we find the correct\r\n          // node that is from the other tree.\r\n          while (container !== null) {\r\n            const parentNode = getClosestInstanceFromNode(container);\r\n            if (parentNode === null) {\r\n              return;\r\n            }\r\n            const parentTag = parentNode.tag;\r\n            if (parentTag === HostComponent || parentTag === HostText) {\r\n              node = ancestorInst = parentNode;\r\n              continue mainLoop;\r\n            }\r\n            container = container.parentNode;\r\n          }\r\n        }\r\n        node = node.return;\r\n      }\r\n    }\r\n  }\r\n\r\n  batchedUpdates(() =>\r\n    dispatchEventsForPlugins(\r\n      domEventName,\r\n      eventSystemFlags,\r\n      nativeEvent,\r\n      ancestorInst,\r\n      targetContainer,\r\n    ),\r\n  );\r\n}\r\n\r\nfunction createDispatchListener(\r\n  instance: null | Fiber,\r\n  listener: Function,\r\n  currentTarget: EventTarget,\r\n): DispatchListener {\r\n  return {\r\n    instance,\r\n    listener,\r\n    currentTarget,\r\n  };\r\n}\r\n\r\nexport function accumulateSinglePhaseListeners(\r\n  targetFiber: Fiber | null,\r\n  reactName: string | null,\r\n  nativeEventType: string,\r\n  inCapturePhase: boolean,\r\n  accumulateTargetOnly: boolean,\r\n  nativeEvent: AnyNativeEvent,\r\n): Array<DispatchListener> {\r\n  const captureName = reactName !== null ? reactName + 'Capture' : null;\r\n  const reactEventName = inCapturePhase ? captureName : reactName;\r\n  let listeners: Array<DispatchListener> = [];\r\n\r\n  let instance = targetFiber;\r\n  let lastHostComponent = null;\r\n\r\n  // Accumulate all instances and listeners via the target -> root path.\r\n  while (instance !== null) {\r\n    const {stateNode, tag} = instance;\r\n    // Handle listeners that are on HostComponents (i.e. <div>)\r\n    if (tag === HostComponent && stateNode !== null) {\r\n      lastHostComponent = stateNode;\r\n\r\n      // createEventHandle listeners\r\n      if (enableCreateEventHandleAPI) {\r\n        const eventHandlerListeners = getEventHandlerListeners(\r\n          lastHostComponent,\r\n        );\r\n        if (eventHandlerListeners !== null) {\r\n          eventHandlerListeners.forEach(entry => {\r\n            if (\r\n              entry.type === nativeEventType &&\r\n              entry.capture === inCapturePhase\r\n            ) {\r\n              listeners.push(\r\n                createDispatchListener(\r\n                  instance,\r\n                  entry.callback,\r\n                  (lastHostComponent: any),\r\n                ),\r\n              );\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Standard React on* listeners, i.e. onClick or onClickCapture\r\n      if (reactEventName !== null) {\r\n        const listener = getListener(instance, reactEventName);\r\n        if (listener != null) {\r\n          listeners.push(\r\n            createDispatchListener(instance, listener, lastHostComponent),\r\n          );\r\n        }\r\n      }\r\n    } else if (\r\n      enableCreateEventHandleAPI &&\r\n      enableScopeAPI &&\r\n      tag === ScopeComponent &&\r\n      lastHostComponent !== null &&\r\n      stateNode !== null\r\n    ) {\r\n      // Scopes\r\n      const reactScopeInstance = stateNode;\r\n      const eventHandlerListeners = getEventHandlerListeners(\r\n        reactScopeInstance,\r\n      );\r\n      if (eventHandlerListeners !== null) {\r\n        eventHandlerListeners.forEach(entry => {\r\n          if (\r\n            entry.type === nativeEventType &&\r\n            entry.capture === inCapturePhase\r\n          ) {\r\n            listeners.push(\r\n              createDispatchListener(\r\n                instance,\r\n                entry.callback,\r\n                (lastHostComponent: any),\r\n              ),\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n    // If we are only accumulating events for the target, then we don't\r\n    // continue to propagate through the React fiber tree to find other\r\n    // listeners.\r\n    if (accumulateTargetOnly) {\r\n      break;\r\n    }\r\n    // If we are processing the onBeforeBlur event, then we need to take\r\n    // into consideration that part of the React tree might have been hidden\r\n    // or deleted (as we're invoking this event during commit). We can find\r\n    // this out by checking if intercept fiber set on the event matches the\r\n    // current instance fiber. In which case, we should clear all existing\r\n    // listeners.\r\n    if (enableCreateEventHandleAPI && nativeEvent.type === 'beforeblur') {\r\n      // $FlowFixMe: internal field\r\n      const detachedInterceptFiber = nativeEvent._detachedInterceptFiber;\r\n      if (\r\n        detachedInterceptFiber !== null &&\r\n        (detachedInterceptFiber === instance ||\r\n          detachedInterceptFiber === instance.alternate)\r\n      ) {\r\n        listeners = [];\r\n      }\r\n    }\r\n    instance = instance.return;\r\n  }\r\n  return listeners;\r\n}\r\n\r\n// We should only use this function for:\r\n// - BeforeInputEventPlugin\r\n// - ChangeEventPlugin\r\n// - SelectEventPlugin\r\n// This is because we only process these plugins\r\n// in the bubble phase, so we need to accumulate two\r\n// phase event listeners (via emulation).\r\nexport function accumulateTwoPhaseListeners(\r\n  targetFiber: Fiber | null,\r\n  reactName: string,\r\n): Array<DispatchListener> {\r\n  const captureName = reactName + 'Capture';\r\n  const listeners: Array<DispatchListener> = [];\r\n  let instance = targetFiber;\r\n\r\n  // Accumulate all instances and listeners via the target -> root path.\r\n  while (instance !== null) {\r\n    const {stateNode, tag} = instance;\r\n    // Handle listeners that are on HostComponents (i.e. <div>)\r\n    if (tag === HostComponent && stateNode !== null) {\r\n      const currentTarget = stateNode;\r\n      const captureListener = getListener(instance, captureName);\r\n      if (captureListener != null) {\r\n        listeners.unshift(\r\n          createDispatchListener(instance, captureListener, currentTarget),\r\n        );\r\n      }\r\n      const bubbleListener = getListener(instance, reactName);\r\n      if (bubbleListener != null) {\r\n        listeners.push(\r\n          createDispatchListener(instance, bubbleListener, currentTarget),\r\n        );\r\n      }\r\n    }\r\n    instance = instance.return;\r\n  }\r\n  return listeners;\r\n}\r\n\r\nfunction getParent(inst: Fiber | null): Fiber | null {\r\n  if (inst === null) {\r\n    return null;\r\n  }\r\n  do {\r\n    inst = inst.return;\r\n    // TODO: If this is a HostRoot we might want to bail out.\r\n    // That is depending on if we want nested subtrees (layers) to bubble\r\n    // events to their parent. We could also go through parentNode on the\r\n    // host node but that wouldn't work for React Native and doesn't let us\r\n    // do the portal feature.\r\n  } while (inst && inst.tag !== HostComponent);\r\n  if (inst) {\r\n    return inst;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Return the lowest common ancestor of A and B, or null if they are in\r\n * different trees.\r\n */\r\nfunction getLowestCommonAncestor(instA: Fiber, instB: Fiber): Fiber | null {\r\n  let nodeA = instA;\r\n  let nodeB = instB;\r\n  let depthA = 0;\r\n  for (let tempA = nodeA; tempA; tempA = getParent(tempA)) {\r\n    depthA++;\r\n  }\r\n  let depthB = 0;\r\n  for (let tempB = nodeB; tempB; tempB = getParent(tempB)) {\r\n    depthB++;\r\n  }\r\n\r\n  // If A is deeper, crawl up.\r\n  while (depthA - depthB > 0) {\r\n    nodeA = getParent(nodeA);\r\n    depthA--;\r\n  }\r\n\r\n  // If B is deeper, crawl up.\r\n  while (depthB - depthA > 0) {\r\n    nodeB = getParent(nodeB);\r\n    depthB--;\r\n  }\r\n\r\n  // Walk in lockstep until we find a match.\r\n  let depth = depthA;\r\n  while (depth--) {\r\n    if (nodeA === nodeB || (nodeB !== null && nodeA === nodeB.alternate)) {\r\n      return nodeA;\r\n    }\r\n    nodeA = getParent(nodeA);\r\n    nodeB = getParent(nodeB);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction accumulateEnterLeaveListenersForEvent(\r\n  dispatchQueue: DispatchQueue,\r\n  event: KnownReactSyntheticEvent,\r\n  target: Fiber,\r\n  common: Fiber | null,\r\n  inCapturePhase: boolean,\r\n): void {\r\n  const registrationName = event._reactName;\r\n  const listeners: Array<DispatchListener> = [];\r\n\r\n  let instance = target;\r\n  while (instance !== null) {\r\n    if (instance === common) {\r\n      break;\r\n    }\r\n    const {alternate, stateNode, tag} = instance;\r\n    if (alternate !== null && alternate === common) {\r\n      break;\r\n    }\r\n    if (tag === HostComponent && stateNode !== null) {\r\n      const currentTarget = stateNode;\r\n      if (inCapturePhase) {\r\n        const captureListener = getListener(instance, registrationName);\r\n        if (captureListener != null) {\r\n          listeners.unshift(\r\n            createDispatchListener(instance, captureListener, currentTarget),\r\n          );\r\n        }\r\n      } else if (!inCapturePhase) {\r\n        const bubbleListener = getListener(instance, registrationName);\r\n        if (bubbleListener != null) {\r\n          listeners.push(\r\n            createDispatchListener(instance, bubbleListener, currentTarget),\r\n          );\r\n        }\r\n      }\r\n    }\r\n    instance = instance.return;\r\n  }\r\n  if (listeners.length !== 0) {\r\n    dispatchQueue.push({event, listeners});\r\n  }\r\n}\r\n\r\n// We should only use this function for:\r\n// - EnterLeaveEventPlugin\r\n// This is because we only process this plugin\r\n// in the bubble phase, so we need to accumulate two\r\n// phase event listeners.\r\nexport function accumulateEnterLeaveTwoPhaseListeners(\r\n  dispatchQueue: DispatchQueue,\r\n  leaveEvent: KnownReactSyntheticEvent,\r\n  enterEvent: null | KnownReactSyntheticEvent,\r\n  from: Fiber | null,\r\n  to: Fiber | null,\r\n): void {\r\n  const common = from && to ? getLowestCommonAncestor(from, to) : null;\r\n\r\n  if (from !== null) {\r\n    accumulateEnterLeaveListenersForEvent(\r\n      dispatchQueue,\r\n      leaveEvent,\r\n      from,\r\n      common,\r\n      false,\r\n    );\r\n  }\r\n  if (to !== null && enterEvent !== null) {\r\n    accumulateEnterLeaveListenersForEvent(\r\n      dispatchQueue,\r\n      enterEvent,\r\n      to,\r\n      common,\r\n      true,\r\n    );\r\n  }\r\n}\r\n\r\nexport function accumulateEventHandleNonManagedNodeListeners(\r\n  reactEventType: DOMEventName,\r\n  currentTarget: EventTarget,\r\n  inCapturePhase: boolean,\r\n): Array<DispatchListener> {\r\n  const listeners: Array<DispatchListener> = [];\r\n\r\n  const eventListeners = getEventHandlerListeners(currentTarget);\r\n  if (eventListeners !== null) {\r\n    eventListeners.forEach(entry => {\r\n      if (entry.type === reactEventType && entry.capture === inCapturePhase) {\r\n        listeners.push(\r\n          createDispatchListener(null, entry.callback, currentTarget),\r\n        );\r\n      }\r\n    });\r\n  }\r\n  return listeners;\r\n}\r\n\r\nexport function getListenerSetKey(\r\n  domEventName: DOMEventName,\r\n  capture: boolean,\r\n): string {\r\n  return `${domEventName}__${capture ? 'capture' : 'bubble'}`;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}