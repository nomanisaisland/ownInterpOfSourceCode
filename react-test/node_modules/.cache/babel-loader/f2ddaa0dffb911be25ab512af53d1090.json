{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\n// An array of all update queues that received updates during the current\n// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nlet interleavedQueues = null;\nexport function pushInterleavedQueue(queue) {\n  if (interleavedQueues === null) {\n    interleavedQueues = [queue];\n  } else {\n    interleavedQueues.push(queue);\n  }\n}\nexport function hasInterleavedUpdates() {\n  return interleavedQueues !== null;\n}\nexport function enqueueInterleavedUpdates() {\n  // Transfer the interleaved updates onto the main queue. Each queue has a\n  // `pending` field and an `interleaved` field. When they are not null, they\n  // point to the last node in a circular linked list. We need to append the\n  // interleaved list to the end of the pending list by joining them into a\n  // single, circular list.\n  if (interleavedQueues !== null) {\n    for (let i = 0; i < interleavedQueues.length; i++) {\n      const queue = interleavedQueues[i];\n      const lastInterleavedUpdate = queue.interleaved;\n\n      if (lastInterleavedUpdate !== null) {\n        queue.interleaved = null;\n        const firstInterleavedUpdate = lastInterleavedUpdate.next;\n        const lastPendingUpdate = queue.pending;\n\n        if (lastPendingUpdate !== null) {\n          const firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = firstInterleavedUpdate;\n          lastInterleavedUpdate.next = firstPendingUpdate;\n        }\n\n        queue.pending = lastInterleavedUpdate;\n      }\n    }\n\n    interleavedQueues = null;\n  }\n}","map":{"version":3,"names":["interleavedQueues","pushInterleavedQueue","queue","push","hasInterleavedUpdates","enqueueInterleavedUpdates","i","length","lastInterleavedUpdate","interleaved","firstInterleavedUpdate","next","lastPendingUpdate","pending","firstPendingUpdate"],"sources":["E:/react-test/src/react/packages/react-reconciler/src/ReactFiberInterleavedUpdates.new.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {UpdateQueue as HookQueue} from './ReactFiberHooks.new';\r\nimport type {SharedQueue as ClassQueue} from './ReactUpdateQueue.new';\r\n\r\n// An array of all update queues that received updates during the current\r\n// render. When this render exits, either because it finishes or because it is\r\n// interrupted, the interleaved updates will be transferred onto the main part\r\n// of the queue.\r\nlet interleavedQueues: Array<\r\n  HookQueue<any, any> | ClassQueue<any>,\r\n> | null = null;\r\n\r\nexport function pushInterleavedQueue(\r\n  queue: HookQueue<any, any> | ClassQueue<any>,\r\n) {\r\n  if (interleavedQueues === null) {\r\n    interleavedQueues = [queue];\r\n  } else {\r\n    interleavedQueues.push(queue);\r\n  }\r\n}\r\n\r\nexport function hasInterleavedUpdates() {\r\n  return interleavedQueues !== null;\r\n}\r\n\r\nexport function enqueueInterleavedUpdates() {\r\n  // Transfer the interleaved updates onto the main queue. Each queue has a\r\n  // `pending` field and an `interleaved` field. When they are not null, they\r\n  // point to the last node in a circular linked list. We need to append the\r\n  // interleaved list to the end of the pending list by joining them into a\r\n  // single, circular list.\r\n  if (interleavedQueues !== null) {\r\n    for (let i = 0; i < interleavedQueues.length; i++) {\r\n      const queue = interleavedQueues[i];\r\n      const lastInterleavedUpdate = queue.interleaved;\r\n      if (lastInterleavedUpdate !== null) {\r\n        queue.interleaved = null;\r\n        const firstInterleavedUpdate = lastInterleavedUpdate.next;\r\n        const lastPendingUpdate = queue.pending;\r\n        if (lastPendingUpdate !== null) {\r\n          const firstPendingUpdate = lastPendingUpdate.next;\r\n          lastPendingUpdate.next = (firstInterleavedUpdate: any);\r\n          lastInterleavedUpdate.next = (firstPendingUpdate: any);\r\n        }\r\n        queue.pending = (lastInterleavedUpdate: any);\r\n      }\r\n    }\r\n    interleavedQueues = null;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA,IAAIA,iBAEI,GAAG,IAFX;AAIA,OAAO,SAASC,oBAAT,CACLC,KADK,EAEL;EACA,IAAIF,iBAAiB,KAAK,IAA1B,EAAgC;IAC9BA,iBAAiB,GAAG,CAACE,KAAD,CAApB;EACD,CAFD,MAEO;IACLF,iBAAiB,CAACG,IAAlB,CAAuBD,KAAvB;EACD;AACF;AAED,OAAO,SAASE,qBAAT,GAAiC;EACtC,OAAOJ,iBAAiB,KAAK,IAA7B;AACD;AAED,OAAO,SAASK,yBAAT,GAAqC;EAC1C;EACA;EACA;EACA;EACA;EACA,IAAIL,iBAAiB,KAAK,IAA1B,EAAgC;IAC9B,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,iBAAiB,CAACO,MAAtC,EAA8CD,CAAC,EAA/C,EAAmD;MACjD,MAAMJ,KAAK,GAAGF,iBAAiB,CAACM,CAAD,CAA/B;MACA,MAAME,qBAAqB,GAAGN,KAAK,CAACO,WAApC;;MACA,IAAID,qBAAqB,KAAK,IAA9B,EAAoC;QAClCN,KAAK,CAACO,WAAN,GAAoB,IAApB;QACA,MAAMC,sBAAsB,GAAGF,qBAAqB,CAACG,IAArD;QACA,MAAMC,iBAAiB,GAAGV,KAAK,CAACW,OAAhC;;QACA,IAAID,iBAAiB,KAAK,IAA1B,EAAgC;UAC9B,MAAME,kBAAkB,GAAGF,iBAAiB,CAACD,IAA7C;UACAC,iBAAiB,CAACD,IAAlB,GAA0BD,sBAA1B;UACAF,qBAAqB,CAACG,IAAtB,GAA8BG,kBAA9B;QACD;;QACDZ,KAAK,CAACW,OAAN,GAAiBL,qBAAjB;MACD;IACF;;IACDR,iBAAiB,GAAG,IAApB;EACD;AACF"},"metadata":{},"sourceType":"module"}