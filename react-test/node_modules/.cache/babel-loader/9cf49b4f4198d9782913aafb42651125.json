{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { noTimeout, supportsHydration } from './ReactFiberHostConfig';\nimport { createHostRootFiber } from './ReactFiber.old';\nimport { NoLane, NoLanes, NoTimestamp, TotalLanes, createLaneMap } from './ReactFiberLane.old';\nimport { enableSuspenseCallback, enableCache, enableProfilerCommitHooks, enableProfilerTimer, enableUpdaterTracking, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { initializeUpdateQueue } from './ReactUpdateQueue.old';\nimport { LegacyRoot, ConcurrentRoot } from './ReactRootTags';\nimport { createCache, retainCache } from './ReactFiberCacheComponent.old';\n\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n  this.tag = tag; // 根节点真实dom\n\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null; // noTimeout 为常数-1\n\n  console.log({\n    timeoutHandle: noTimeout\n  }, \"参数为常数-1\");\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.callbackNode = null;\n  console.log({\n    callbackPriority: NoLane\n  }, \"常熟二进制0b0000000000000000000000000000000\");\n  this.callbackPriority = NoLane;\n  console.log({\n    eventTimes: createLaneMap(NoLanes),\n    NoLanes: 0b0000000000000000000000000000000\n  }, \"NoLanes的值为二进制0b0000000000000000000000000000000\");\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n  this.identifierPrefix = identifierPrefix;\n  this.onRecoverableError = onRecoverableError;\n  console.log(this, \"将一部分需要分配执行优先级的参数分配默认无优先级\"); // TODO enableCache暂时不知道什么意思，猜测是缓存之类的\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  } // 是否支持服务端渲染\n\n\n  if (supportsHydration) {\n    // 为服务端渲染准备参数\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  } // 常数false\n\n\n  if (enableTransitionTracing) {\n    this.transitionCallbacks = null;\n    const transitionLanesMap = this.transitionLanes = [];\n\n    for (let i = 0; i < TotalLanes; i++) {\n      transitionLanesMap.push(null);\n    }\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (enableUpdaterTracking) {\n    this.memoizedUpdaters = new Set();\n    const pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n\n    for (let i = 0; i < TotalLanes; i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n\n  if (__DEV__) {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n        break;\n\n      case LegacyRoot:\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n        break;\n    }\n  }\n}\n\n_c = FiberRootNode;\nexport function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix, onRecoverableError, transitionCallbacks) {\n  // 创建 FiberRootNode 对象\n  // tag 值为 ConcurrentRoot，定义在 packages/react-reconciler/src/ReactRootTags.js 文件中；\n  // tag === ConcurrentRoot === 1 ，表示 “根节点”\n  console.log({\n    containerInfo,\n    tag,\n    hydrate,\n    identifierPrefix,\n    onRecoverableError\n  }, \"传入必要参数获取根节点基本信息\");\n  const root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n  console.log(root, \"获取到基本的fiber根节点\");\n\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  if (enableTransitionTracing) {\n    root.transitionCallbacks = transitionCallbacks;\n  } // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  // 创建root fiber节点，可以是多个\n  // createHostRootFiber 会调用 packages/react-reconciler/src/ReactFiber.old.js 文件中的 createFiber 方法创建一个 `Fiber HostRoot节点`\n  // `Fiber HostRoot节点` 就是一个 Fiber 对象，只是他的 Tag 等于 3，代表 `HostRoot`\n  // 内部数据（优先级，服务器渲染参数）全部挂在到方法上\n\n\n  const uninitializedFiber = createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride);\n  console.log(uninitializedFiber, \"获得未初始化，但是参数齐全的fiber根节点\"); // 关联FiberRoot和root fiber\n\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n  console.log(root, \"关联root.current和uninitializedFiber.stateNode\");\n\n  if (enableCache) {\n    const initialCache = createCache();\n    retainCache(initialCache);\n    console.log(JSON.parse(JSON.stringify(initialCache)), \"缓存标记加一,当前结果不变，下次加一(cache.refCount)\"); // The pooledCache is a fresh cache instance that is used temporarily\n    // for newly mounted boundaries during a render. In general, the\n    // pooledCache is always cleared from the root at the end of a render:\n    // it is either released when render commits, or moved to an Offscreen\n    // component if rendering suspends. Because the lifetime of the pooled\n    // cache is distinct from the main memoizedState.cache, it must be\n    // retained separately.\n\n    root.pooledCache = initialCache;\n    console.log(root.pooledCache, \"将initialCache挂在到root.pooledCache上\");\n    retainCache(initialCache); //     {controller: AbortController, data: Map(0), refCount: 2}\n    // controller: AbortController {signal: AbortSignal}\n    // data: Map(0) {size: 0}\n    // refCount: 1\n    // [[Prototype]]: Object\n\n    console.log(root.pooledCache, \"取得上次结果，retainCache cache.refCount再加一,控制台和真实结果不一样，是浏览器取值的问题，浏览器拿到的是缓存里面的值，最新的值没有拿到，可以先序列号，再反序列化一下（把对象序列化到一个字符串中，以强制执行一次“快照”）\");\n    const initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: initialCache,\n      transitions: null,\n      pendingSuspenseBoundaries: null\n    };\n    uninitializedFiber.memoizedState = initialState;\n    console.log(root, \"在root.current中添加initialState当前节点的初始状态\");\n  } else {\n    const initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: null,\n      // not enabled yet\n      transitions: null,\n      pendingSuspenseBoundaries: null\n    };\n    uninitializedFiber.memoizedState = initialState;\n  }\n\n  console.log(uninitializedFiber, \"uninitializedFiber === root.current\");\n  initializeUpdateQueue(uninitializedFiber);\n  console.log(\"将v\");\n  return root;\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"FiberRootNode\");","map":{"version":3,"names":["noTimeout","supportsHydration","createHostRootFiber","NoLane","NoLanes","NoTimestamp","TotalLanes","createLaneMap","enableSuspenseCallback","enableCache","enableProfilerCommitHooks","enableProfilerTimer","enableUpdaterTracking","enableTransitionTracing","initializeUpdateQueue","LegacyRoot","ConcurrentRoot","createCache","retainCache","FiberRootNode","containerInfo","tag","hydrate","identifierPrefix","onRecoverableError","pendingChildren","current","pingCache","finishedWork","console","log","timeoutHandle","context","pendingContext","callbackNode","callbackPriority","eventTimes","expirationTimes","pendingLanes","suspendedLanes","pingedLanes","expiredLanes","mutableReadLanes","finishedLanes","entangledLanes","entanglements","pooledCache","pooledCacheLanes","mutableSourceEagerHydrationData","hydrationCallbacks","transitionCallbacks","transitionLanesMap","transitionLanes","i","push","effectDuration","passiveEffectDuration","memoizedUpdaters","Set","pendingUpdatersLaneMap","__DEV__","_debugRootType","createFiberRoot","initialChildren","isStrictMode","concurrentUpdatesByDefaultOverride","root","uninitializedFiber","stateNode","initialCache","JSON","parse","stringify","initialState","element","isDehydrated","cache","transitions","pendingSuspenseBoundaries","memoizedState"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberRoot.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { ReactNodeList } from 'shared/ReactTypes';\r\nimport type {\r\n  FiberRoot,\r\n  SuspenseHydrationCallbacks,\r\n  TransitionTracingCallbacks,\r\n} from './ReactInternalTypes';\r\nimport type { RootTag } from './ReactRootTags';\r\nimport type { Cache } from './ReactFiberCacheComponent.old';\r\nimport type {\r\n  PendingSuspenseBoundaries,\r\n  Transition,\r\n} from './ReactFiberTracingMarkerComponent.old';\r\n\r\nimport { noTimeout, supportsHydration } from './ReactFiberHostConfig';\r\nimport { createHostRootFiber } from './ReactFiber.old';\r\nimport {\r\n  NoLane,\r\n  NoLanes,\r\n  NoTimestamp,\r\n  TotalLanes,\r\n  createLaneMap,\r\n} from './ReactFiberLane.old';\r\nimport {\r\n  enableSuspenseCallback,\r\n  enableCache,\r\n  enableProfilerCommitHooks,\r\n  enableProfilerTimer,\r\n  enableUpdaterTracking,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\nimport { initializeUpdateQueue } from './ReactUpdateQueue.old';\r\nimport { LegacyRoot, ConcurrentRoot } from './ReactRootTags';\r\nimport { createCache, retainCache } from './ReactFiberCacheComponent.old';\r\n\r\nexport type RootState = {\r\n  element: any,\r\n  isDehydrated: boolean,\r\n  cache: Cache,\r\n  pendingSuspenseBoundaries: PendingSuspenseBoundaries | null,\r\n  transitions: Set<Transition> | null,\r\n};\r\n\r\nfunction FiberRootNode (\r\n  containerInfo,\r\n  tag,\r\n  hydrate,\r\n  identifierPrefix,\r\n  onRecoverableError,\r\n) {\r\n  this.tag = tag;\r\n  // 根节点真实dom\r\n  this.containerInfo = containerInfo;\r\n  this.pendingChildren = null;\r\n  this.current = null;\r\n  this.pingCache = null;\r\n  this.finishedWork = null;\r\n  // noTimeout 为常数-1\r\n  console.log({ timeoutHandle: noTimeout }, \"参数为常数-1\")\r\n  this.timeoutHandle = noTimeout;\r\n  this.context = null;\r\n  this.pendingContext = null;\r\n  this.callbackNode = null;\r\n  console.log({ callbackPriority: NoLane }, \"常熟二进制0b0000000000000000000000000000000\")\r\n  this.callbackPriority = NoLane;\r\n\r\n\r\n  console.log({ eventTimes: createLaneMap(NoLanes), NoLanes: 0b0000000000000000000000000000000 }, \"NoLanes的值为二进制0b0000000000000000000000000000000\")\r\n\r\n\r\n  this.eventTimes = createLaneMap(NoLanes);\r\n  this.expirationTimes = createLaneMap(NoTimestamp);\r\n\r\n  this.pendingLanes = NoLanes;\r\n  this.suspendedLanes = NoLanes;\r\n  this.pingedLanes = NoLanes;\r\n  this.expiredLanes = NoLanes;\r\n  this.mutableReadLanes = NoLanes;\r\n  this.finishedLanes = NoLanes;\r\n\r\n  this.entangledLanes = NoLanes;\r\n  this.entanglements = createLaneMap(NoLanes);\r\n  this.identifierPrefix = identifierPrefix;\r\n  this.onRecoverableError = onRecoverableError;\r\n\r\n  console.log(this, \"将一部分需要分配执行优先级的参数分配默认无优先级\");\r\n\r\n  // TODO enableCache暂时不知道什么意思，猜测是缓存之类的\r\n  if (enableCache) {\r\n    this.pooledCache = null;\r\n    this.pooledCacheLanes = NoLanes;\r\n  }\r\n\r\n  // 是否支持服务端渲染\r\n  if (supportsHydration) {\r\n    // 为服务端渲染准备参数\r\n    this.mutableSourceEagerHydrationData = null;\r\n  }\r\n\r\n  if (enableSuspenseCallback) {\r\n    this.hydrationCallbacks = null;\r\n  }\r\n\r\n  // 常数false\r\n  if (enableTransitionTracing) {\r\n    this.transitionCallbacks = null;\r\n    const transitionLanesMap = (this.transitionLanes = []);\r\n    for (let i = 0; i < TotalLanes; i++) {\r\n      transitionLanesMap.push(null);\r\n    }\r\n  }\r\n\r\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\r\n    this.effectDuration = 0;\r\n    this.passiveEffectDuration = 0;\r\n  }\r\n\r\n  if (enableUpdaterTracking) {\r\n    this.memoizedUpdaters = new Set();\r\n    const pendingUpdatersLaneMap = (this.pendingUpdatersLaneMap = []);\r\n    for (let i = 0; i < TotalLanes; i++) {\r\n      pendingUpdatersLaneMap.push(new Set());\r\n    }\r\n  }\r\n  if (__DEV__) {\r\n    switch (tag) {\r\n      case ConcurrentRoot:\r\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\r\n        break;\r\n      case LegacyRoot:\r\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nexport function createFiberRoot (\r\n  containerInfo: any,\r\n  tag: RootTag,\r\n  hydrate: boolean,\r\n  initialChildren: ReactNodeList,\r\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\r\n  isStrictMode: boolean,\r\n  concurrentUpdatesByDefaultOverride: null | boolean,\r\n  // TODO: We have several of these arguments that are conceptually part of the\r\n  // host config, but because they are passed in at runtime, we have to thread\r\n  // them through the root constructor. Perhaps we should put them all into a\r\n  // single type, like a DynamicHostConfig that is defined by the renderer.\r\n  identifierPrefix: string,\r\n  onRecoverableError: null | ((error: mixed) => void),\r\n  transitionCallbacks: null | TransitionTracingCallbacks,\r\n): FiberRoot {\r\n  // 创建 FiberRootNode 对象\r\n  // tag 值为 ConcurrentRoot，定义在 packages/react-reconciler/src/ReactRootTags.js 文件中；\r\n  // tag === ConcurrentRoot === 1 ，表示 “根节点”\r\n  console.log({\r\n    containerInfo,\r\n    tag,\r\n    hydrate,\r\n    identifierPrefix,\r\n    onRecoverableError,\r\n  }, \"传入必要参数获取根节点基本信息\")\r\n  const root: FiberRoot = (new FiberRootNode(\r\n    containerInfo,\r\n    tag,\r\n    hydrate,\r\n    identifierPrefix,\r\n    onRecoverableError,\r\n  ): any);\r\n  console.log(root, \"获取到基本的fiber根节点\")\r\n  if (enableSuspenseCallback) {\r\n    root.hydrationCallbacks = hydrationCallbacks;\r\n  }\r\n\r\n  if (enableTransitionTracing) {\r\n    root.transitionCallbacks = transitionCallbacks;\r\n  }\r\n\r\n  // Cyclic construction. This cheats the type system right now because\r\n  // stateNode is any.\r\n  // 创建root fiber节点，可以是多个\r\n  // createHostRootFiber 会调用 packages/react-reconciler/src/ReactFiber.old.js 文件中的 createFiber 方法创建一个 `Fiber HostRoot节点`\r\n  // `Fiber HostRoot节点` 就是一个 Fiber 对象，只是他的 Tag 等于 3，代表 `HostRoot`\r\n\r\n  // 内部数据（优先级，服务器渲染参数）全部挂在到方法上\r\n  const uninitializedFiber = createHostRootFiber(\r\n    tag,\r\n    isStrictMode,\r\n    concurrentUpdatesByDefaultOverride,\r\n  );\r\n  console.log(uninitializedFiber, \"获得未初始化，但是参数齐全的fiber根节点\")\r\n  // 关联FiberRoot和root fiber\r\n  root.current = uninitializedFiber;\r\n  uninitializedFiber.stateNode = root;\r\n  console.log(root, \"关联root.current和uninitializedFiber.stateNode\")\r\n  if (enableCache) {\r\n    const initialCache = createCache();\r\n\r\n    retainCache(initialCache);\r\n\r\n    console.log(JSON.parse(JSON.stringify(initialCache)), \"缓存标记加一,当前结果不变，下次加一(cache.refCount)\")\r\n\r\n\r\n    // The pooledCache is a fresh cache instance that is used temporarily\r\n    // for newly mounted boundaries during a render. In general, the\r\n    // pooledCache is always cleared from the root at the end of a render:\r\n    // it is either released when render commits, or moved to an Offscreen\r\n    // component if rendering suspends. Because the lifetime of the pooled\r\n    // cache is distinct from the main memoizedState.cache, it must be\r\n    // retained separately.\r\n    root.pooledCache = initialCache;\r\n\r\n    console.log(root.pooledCache, \"将initialCache挂在到root.pooledCache上\");\r\n\r\n    retainCache(initialCache);\r\n\r\n\r\n    //     {controller: AbortController, data: Map(0), refCount: 2}\r\n    // controller: AbortController {signal: AbortSignal}\r\n    // data: Map(0) {size: 0}\r\n    // refCount: 1\r\n    // [[Prototype]]: Object\r\n    console.log(root.pooledCache, \"取得上次结果，retainCache cache.refCount再加一,控制台和真实结果不一样，是浏览器取值的问题，浏览器拿到的是缓存里面的值，最新的值没有拿到，可以先序列号，再反序列化一下（把对象序列化到一个字符串中，以强制执行一次“快照”）\");\r\n\r\n    const initialState: RootState = {\r\n      element: initialChildren,\r\n      isDehydrated: hydrate,\r\n      cache: initialCache,\r\n      transitions: null,\r\n      pendingSuspenseBoundaries: null,\r\n    };\r\n    uninitializedFiber.memoizedState = initialState;\r\n\r\n    console.log(root, \"在root.current中添加initialState当前节点的初始状态\")\r\n  } else {\r\n    const initialState: RootState = {\r\n      element: initialChildren,\r\n      isDehydrated: hydrate,\r\n      cache: (null: any), // not enabled yet\r\n      transitions: null,\r\n      pendingSuspenseBoundaries: null,\r\n    };\r\n    uninitializedFiber.memoizedState = initialState;\r\n  }\r\n  console.log(uninitializedFiber, \"uninitializedFiber === root.current\")\r\n  initializeUpdateQueue(uninitializedFiber);\r\n  console.log(\"将v\")\r\n  return root;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}