{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { get as getInstance } from 'shared/ReactInstanceMap';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { ClassComponent, HostComponent, HostRoot, HostPortal, HostText, SuspenseComponent } from './ReactWorkTags';\nimport { NoFlags, Placement, Hydrating } from './ReactFiberFlags';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nexport function getNearestMountedFiber(fiber) {\n  let node = fiber;\n  let nearestMounted = fiber; // 一般没有这个属性的都是服务端渲染进来的\n\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    let nextNode = node;\n\n    do {\n      node = nextNode; // 为服务端服务\n\n      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n        // This is an insertion or in-progress hydration. The nearest possible\n        // mounted fiber is the parent but we need to continue to figure out\n        // if that one is still mounted.\n        nearestMounted = node.return;\n      }\n\n      nextNode = node.return;\n    } while (nextNode);\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return nearestMounted;\n  } // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n\n\n  return null;\n}\nexport function getSuspenseInstanceFromFiber(fiber) {\n  if (fiber.tag === SuspenseComponent) {\n    let suspenseState = fiber.memoizedState;\n\n    if (suspenseState === null) {\n      const current = fiber.alternate;\n\n      if (current !== null) {\n        suspenseState = current.memoizedState;\n      }\n    }\n\n    if (suspenseState !== null) {\n      return suspenseState.dehydrated;\n    }\n  }\n\n  return null;\n}\nexport function getContainerFromFiber(fiber) {\n  return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;\n}\nexport function isFiberMounted(fiber) {\n  return getNearestMountedFiber(fiber) === fiber;\n}\nexport function isMounted(component) {\n  if (__DEV__) {\n    const owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.tag === ClassComponent) {\n      const ownerFiber = owner;\n      const instance = ownerFiber.stateNode;\n\n      if (!instance._warnedAboutRefsInRender) {\n        console.error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n      }\n\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  const fiber = getInstance(component);\n\n  if (!fiber) {\n    return false;\n  }\n\n  return getNearestMountedFiber(fiber) === fiber;\n}\n\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n}\n\nexport function findCurrentFiberUsingSlowPath(fiber) {\n  const alternate = fiber.alternate;\n\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    const nearestMounted = getNearestMountedFiber(fiber);\n\n    if (nearestMounted === null) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (nearestMounted !== fiber) {\n      return null;\n    }\n\n    return fiber;\n  } // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n\n\n  let a = fiber;\n  let b = alternate;\n\n  while (true) {\n    const parentA = a.return;\n\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n\n    const parentB = parentA.alternate;\n\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      const nextParent = parentA.return;\n\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      } // If there's no parent, we're at the root.\n\n\n      break;\n    } // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n\n\n    if (parentA.child === parentB.child) {\n      let child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n\n        child = child.sibling;\n      } // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n\n\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n\n        child = child.sibling;\n      }\n\n      if (!didFindChild) {\n        // Search parent B's child set\n        child = parentB.child;\n\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n\n          child = child.sibling;\n        }\n\n        if (!didFindChild) {\n          throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n        }\n      }\n    }\n\n    if (a.alternate !== b) {\n      throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n  } // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n\n\n  if (a.tag !== HostRoot) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  } // Otherwise B has to be current branch.\n\n\n  return alternate;\n}\nexport function findCurrentHostFiber(parent) {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  let child = node.child;\n\n  while (child !== null) {\n    const match = findCurrentHostFiberImpl(child);\n\n    if (match !== null) {\n      return match;\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nexport function findCurrentHostFiberWithNoPortals(parent) {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberWithNoPortalsImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  let child = node.child;\n\n  while (child !== null) {\n    if (child.tag !== HostPortal) {\n      const match = findCurrentHostFiberWithNoPortalsImpl(child);\n\n      if (match !== null) {\n        return match;\n      }\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nexport function isFiberSuspenseAndTimedOut(fiber) {\n  const memoizedState = fiber.memoizedState;\n  return fiber.tag === SuspenseComponent && memoizedState !== null && memoizedState.dehydrated === null;\n}\nexport function doesFiberContain(parentFiber, childFiber) {\n  let node = childFiber;\n  const parentFiberAlternate = parentFiber.alternate;\n\n  while (node !== null) {\n    if (node === parentFiber || node === parentFiberAlternate) {\n      return true;\n    }\n\n    node = node.return;\n  }\n\n  return false;\n}","map":{"version":3,"names":["get","getInstance","ReactSharedInternals","getComponentNameFromFiber","ClassComponent","HostComponent","HostRoot","HostPortal","HostText","SuspenseComponent","NoFlags","Placement","Hydrating","ReactCurrentOwner","getNearestMountedFiber","fiber","node","nearestMounted","alternate","nextNode","flags","return","tag","getSuspenseInstanceFromFiber","suspenseState","memoizedState","current","dehydrated","getContainerFromFiber","stateNode","containerInfo","isFiberMounted","isMounted","component","__DEV__","owner","ownerFiber","instance","_warnedAboutRefsInRender","console","error","assertIsMounted","Error","findCurrentFiberUsingSlowPath","a","b","parentA","parentB","nextParent","child","sibling","didFindChild","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberImpl","match","findCurrentHostFiberWithNoPortals","findCurrentHostFiberWithNoPortalsImpl","isFiberSuspenseAndTimedOut","doesFiberContain","parentFiber","childFiber","parentFiberAlternate"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberTreeReflection.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber} from './ReactInternalTypes';\r\nimport type {Container, SuspenseInstance} from './ReactFiberHostConfig';\r\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\r\n\r\nimport {get as getInstance} from 'shared/ReactInstanceMap';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport {\r\n  ClassComponent,\r\n  HostComponent,\r\n  HostRoot,\r\n  HostPortal,\r\n  HostText,\r\n  SuspenseComponent,\r\n} from './ReactWorkTags';\r\nimport {NoFlags, Placement, Hydrating} from './ReactFiberFlags';\r\n\r\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\n\r\nexport function getNearestMountedFiber(fiber: Fiber): null | Fiber {\r\n  let node = fiber;\r\n  let nearestMounted = fiber;\r\n  // 一般没有这个属性的都是服务端渲染进来的\r\n  if (!fiber.alternate) {\r\n    // If there is no alternate, this might be a new tree that isn't inserted\r\n    // yet. If it is, then it will have a pending insertion effect on it.\r\n    let nextNode = node;\r\n    do {\r\n      node = nextNode;\r\n      // 为服务端服务\r\n      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\r\n        // This is an insertion or in-progress hydration. The nearest possible\r\n        // mounted fiber is the parent but we need to continue to figure out\r\n        // if that one is still mounted.\r\n        nearestMounted = node.return;\r\n      }\r\n      nextNode = node.return;\r\n    } while (nextNode);\r\n  } else {\r\n    while (node.return) {\r\n      node = node.return;\r\n    }\r\n  }\r\n  if (node.tag === HostRoot) {\r\n    // TODO: Check if this was a nested HostRoot when used with\r\n    // renderContainerIntoSubtree.\r\n    return nearestMounted;\r\n  }\r\n  // If we didn't hit the root, that means that we're in an disconnected tree\r\n  // that has been unmounted.\r\n  return null;\r\n}\r\n\r\nexport function getSuspenseInstanceFromFiber(\r\n  fiber: Fiber,\r\n): null | SuspenseInstance {\r\n  if (fiber.tag === SuspenseComponent) {\r\n    let suspenseState: SuspenseState | null = fiber.memoizedState;\r\n    if (suspenseState === null) {\r\n      const current = fiber.alternate;\r\n      if (current !== null) {\r\n        suspenseState = current.memoizedState;\r\n      }\r\n    }\r\n    if (suspenseState !== null) {\r\n      return suspenseState.dehydrated;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function getContainerFromFiber(fiber: Fiber): null | Container {\r\n  return fiber.tag === HostRoot\r\n    ? (fiber.stateNode.containerInfo: Container)\r\n    : null;\r\n}\r\n\r\nexport function isFiberMounted(fiber: Fiber): boolean {\r\n  return getNearestMountedFiber(fiber) === fiber;\r\n}\r\n\r\nexport function isMounted(component: React$Component<any, any>): boolean {\r\n  if (__DEV__) {\r\n    const owner = (ReactCurrentOwner.current: any);\r\n    if (owner !== null && owner.tag === ClassComponent) {\r\n      const ownerFiber: Fiber = owner;\r\n      const instance = ownerFiber.stateNode;\r\n      if (!instance._warnedAboutRefsInRender) {\r\n        console.error(\r\n          '%s is accessing isMounted inside its render() function. ' +\r\n            'render() should be a pure function of props and state. It should ' +\r\n            'never access something that requires stale data from the previous ' +\r\n            'render, such as refs. Move this logic to componentDidMount and ' +\r\n            'componentDidUpdate instead.',\r\n          getComponentNameFromFiber(ownerFiber) || 'A component',\r\n        );\r\n      }\r\n      instance._warnedAboutRefsInRender = true;\r\n    }\r\n  }\r\n\r\n  const fiber: ?Fiber = getInstance(component);\r\n  if (!fiber) {\r\n    return false;\r\n  }\r\n  return getNearestMountedFiber(fiber) === fiber;\r\n}\r\n\r\nfunction assertIsMounted(fiber) {\r\n  if (getNearestMountedFiber(fiber) !== fiber) {\r\n    throw new Error('Unable to find node on an unmounted component.');\r\n  }\r\n}\r\n\r\nexport function findCurrentFiberUsingSlowPath(fiber: Fiber): Fiber | null {\r\n  const alternate = fiber.alternate;\r\n  if (!alternate) {\r\n    // If there is no alternate, then we only need to check if it is mounted.\r\n    const nearestMounted = getNearestMountedFiber(fiber);\r\n\r\n    if (nearestMounted === null) {\r\n      throw new Error('Unable to find node on an unmounted component.');\r\n    }\r\n\r\n    if (nearestMounted !== fiber) {\r\n      return null;\r\n    }\r\n    return fiber;\r\n  }\r\n  // If we have two possible branches, we'll walk backwards up to the root\r\n  // to see what path the root points to. On the way we may hit one of the\r\n  // special cases and we'll deal with them.\r\n  let a: Fiber = fiber;\r\n  let b: Fiber = alternate;\r\n  while (true) {\r\n    const parentA = a.return;\r\n    if (parentA === null) {\r\n      // We're at the root.\r\n      break;\r\n    }\r\n    const parentB = parentA.alternate;\r\n    if (parentB === null) {\r\n      // There is no alternate. This is an unusual case. Currently, it only\r\n      // happens when a Suspense component is hidden. An extra fragment fiber\r\n      // is inserted in between the Suspense fiber and its children. Skip\r\n      // over this extra fragment fiber and proceed to the next parent.\r\n      const nextParent = parentA.return;\r\n      if (nextParent !== null) {\r\n        a = b = nextParent;\r\n        continue;\r\n      }\r\n      // If there's no parent, we're at the root.\r\n      break;\r\n    }\r\n\r\n    // If both copies of the parent fiber point to the same child, we can\r\n    // assume that the child is current. This happens when we bailout on low\r\n    // priority: the bailed out fiber's child reuses the current child.\r\n    if (parentA.child === parentB.child) {\r\n      let child = parentA.child;\r\n      while (child) {\r\n        if (child === a) {\r\n          // We've determined that A is the current branch.\r\n          assertIsMounted(parentA);\r\n          return fiber;\r\n        }\r\n        if (child === b) {\r\n          // We've determined that B is the current branch.\r\n          assertIsMounted(parentA);\r\n          return alternate;\r\n        }\r\n        child = child.sibling;\r\n      }\r\n\r\n      // We should never have an alternate for any mounting node. So the only\r\n      // way this could possibly happen is if this was unmounted, if at all.\r\n      throw new Error('Unable to find node on an unmounted component.');\r\n    }\r\n\r\n    if (a.return !== b.return) {\r\n      // The return pointer of A and the return pointer of B point to different\r\n      // fibers. We assume that return pointers never criss-cross, so A must\r\n      // belong to the child set of A.return, and B must belong to the child\r\n      // set of B.return.\r\n      a = parentA;\r\n      b = parentB;\r\n    } else {\r\n      // The return pointers point to the same fiber. We'll have to use the\r\n      // default, slow path: scan the child sets of each parent alternate to see\r\n      // which child belongs to which set.\r\n      //\r\n      // Search parent A's child set\r\n      let didFindChild = false;\r\n      let child = parentA.child;\r\n      while (child) {\r\n        if (child === a) {\r\n          didFindChild = true;\r\n          a = parentA;\r\n          b = parentB;\r\n          break;\r\n        }\r\n        if (child === b) {\r\n          didFindChild = true;\r\n          b = parentA;\r\n          a = parentB;\r\n          break;\r\n        }\r\n        child = child.sibling;\r\n      }\r\n      if (!didFindChild) {\r\n        // Search parent B's child set\r\n        child = parentB.child;\r\n        while (child) {\r\n          if (child === a) {\r\n            didFindChild = true;\r\n            a = parentB;\r\n            b = parentA;\r\n            break;\r\n          }\r\n          if (child === b) {\r\n            didFindChild = true;\r\n            b = parentB;\r\n            a = parentA;\r\n            break;\r\n          }\r\n          child = child.sibling;\r\n        }\r\n\r\n        if (!didFindChild) {\r\n          throw new Error(\r\n            'Child was not found in either parent set. This indicates a bug ' +\r\n              'in React related to the return pointer. Please file an issue.',\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    if (a.alternate !== b) {\r\n      throw new Error(\r\n        \"Return fibers should always be each others' alternates. \" +\r\n          'This error is likely caused by a bug in React. Please file an issue.',\r\n      );\r\n    }\r\n  }\r\n\r\n  // If the root is not a host container, we're in a disconnected tree. I.e.\r\n  // unmounted.\r\n  if (a.tag !== HostRoot) {\r\n    throw new Error('Unable to find node on an unmounted component.');\r\n  }\r\n\r\n  if (a.stateNode.current === a) {\r\n    // We've determined that A is the current branch.\r\n    return fiber;\r\n  }\r\n  // Otherwise B has to be current branch.\r\n  return alternate;\r\n}\r\n\r\nexport function findCurrentHostFiber(parent: Fiber): Fiber | null {\r\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\r\n  return currentParent !== null\r\n    ? findCurrentHostFiberImpl(currentParent)\r\n    : null;\r\n}\r\n\r\nfunction findCurrentHostFiberImpl(node: Fiber) {\r\n  // Next we'll drill down this component to find the first HostComponent/Text.\r\n  if (node.tag === HostComponent || node.tag === HostText) {\r\n    return node;\r\n  }\r\n\r\n  let child = node.child;\r\n  while (child !== null) {\r\n    const match = findCurrentHostFiberImpl(child);\r\n    if (match !== null) {\r\n      return match;\r\n    }\r\n    child = child.sibling;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function findCurrentHostFiberWithNoPortals(parent: Fiber): Fiber | null {\r\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\r\n  return currentParent !== null\r\n    ? findCurrentHostFiberWithNoPortalsImpl(currentParent)\r\n    : null;\r\n}\r\n\r\nfunction findCurrentHostFiberWithNoPortalsImpl(node: Fiber) {\r\n  // Next we'll drill down this component to find the first HostComponent/Text.\r\n  if (node.tag === HostComponent || node.tag === HostText) {\r\n    return node;\r\n  }\r\n\r\n  let child = node.child;\r\n  while (child !== null) {\r\n    if (child.tag !== HostPortal) {\r\n      const match = findCurrentHostFiberWithNoPortalsImpl(child);\r\n      if (match !== null) {\r\n        return match;\r\n      }\r\n    }\r\n    child = child.sibling;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function isFiberSuspenseAndTimedOut(fiber: Fiber): boolean {\r\n  const memoizedState = fiber.memoizedState;\r\n  return (\r\n    fiber.tag === SuspenseComponent &&\r\n    memoizedState !== null &&\r\n    memoizedState.dehydrated === null\r\n  );\r\n}\r\n\r\nexport function doesFiberContain(\r\n  parentFiber: Fiber,\r\n  childFiber: Fiber,\r\n): boolean {\r\n  let node = childFiber;\r\n  const parentFiberAlternate = parentFiber.alternate;\r\n  while (node !== null) {\r\n    if (node === parentFiber || node === parentFiberAlternate) {\r\n      return true;\r\n    }\r\n    node = node.return;\r\n  }\r\n  return false;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}