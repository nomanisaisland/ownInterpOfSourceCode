{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\nimport { NoLane, NoLanes, isSubsetOfLanes, mergeLanes, isTransitionLane, intersectLanes, markRootEntangled } from './ReactFiberLane.old';\nimport { enterDisallowedContextReadInDEV, exitDisallowedContextReadInDEV } from './ReactFiberNewContext.old';\nimport { Callback, ShouldCapture, DidCapture } from './ReactFiberFlags';\nimport { debugRenderPhaseSideEffectsForStrictMode } from 'shared/ReactFeatureFlags';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { markSkippedUpdateLanes, isInterleavedUpdate } from './ReactFiberWorkLoop.old';\nimport { pushInterleavedQueue } from './ReactFiberInterleavedUpdates.old';\nimport { setIsStrictModeForDevtools } from './ReactFiberDevToolsHook.old';\nimport assign from 'shared/assign';\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nlet hasForceUpdate = false;\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\n\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n} //对于HostRoot或者ClassComponent会使用initializeUpdateQueue创建updateQueue，然后将updateQueue挂载到fiber节点上\n\n\nexport function initializeUpdateQueue(fiber) {\n  const queue = {\n    baseState: fiber.memoizedState,\n    //初始state，后面会基于这个state，根据Update计算新的state\n    firstBaseUpdate: null,\n    // Update形成的链表的头\n    lastBaseUpdate: null,\n    //Update形成的链表的尾\n    //新产生的update会以单向环状链表保存在shared.pending上，计算state的时候会剪开这个环状链表，并且连接在\n    //lastBaseUpdate后\n    shared: {\n      pending: null,\n      // shared.pending,等待处理的 update\n      interleaved: null,\n      lanes: NoLanes\n    },\n    effects: null\n  };\n  fiber.updateQueue = queue;\n}\nexport function cloneUpdateQueue(current, workInProgress) {\n  // Clone the update queue from current. Unless it's already a clone.\n  const queue = workInProgress.updateQueue;\n  const currentQueue = current.updateQueue;\n\n  if (queue === currentQueue) {\n    const clone = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\nexport function createUpdate(eventTime, lane) {\n  const update = {\n    eventTime,\n    // 任务时间，通过performance.now()获取的毫秒数。\n    lane,\n    // 优先级相关字段,不同的update优先级不同\n    tag: UpdateState,\n    // 更新的类型，包括UpdateState | ReplaceState | ForceUpdate | CaptureUpdate。\n    payload: null,\n    // 更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参。\n    callback: null,\n    // 更新的回调函数。即在commit 阶段的 layout 子阶段一节中提到的回调函数。\n    next: null // 与其他Update连接形成链表\n\n  };\n  return update;\n}\nexport function enqueueUpdate(fiber, update, lane) {\n  // fiber为rootFiber组件根节点\n  const updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    // 当fiber节点卸载时发生\n    return;\n  }\n\n  const sharedQueue = updateQueue.shared;\n\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = sharedQueue.interleaved; // 如果interleaved为空时表示是第一次更新，此时处于mount阶段\n\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      // 首位相连形成链表\n      update.next = update; // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n\n      pushInterleavedQueue(sharedQueue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n\n    sharedQueue.interleaved = update;\n  } else {\n    const pending = sharedQueue.pending;\n    console.log(sharedQueue);\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    sharedQueue.pending = update;\n  }\n\n  if (__DEV__) {\n    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n      console.error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\nexport function entangleTransitions(root, fiber, lane) {\n  const updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue = updateQueue.shared;\n\n  if (isTransitionLane(lane)) {\n    let queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\nexport function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  let queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n\n  const current = workInProgress.alternate;\n\n  if (current !== null) {\n    const currentQueue = current.updateQueue;\n\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      let newFirst = null;\n      let newLast = null;\n      const firstBaseUpdate = queue.firstBaseUpdate;\n\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        let update = firstBaseUpdate;\n\n        do {\n          const clone = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          }\n\n          update = update.next;\n        } while (update !== null); // Append the captured update the end of the cloned list.\n\n\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        effects: currentQueue.effects\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  } // Append the update to the end of the list.\n\n\n  const lastBaseUpdate = queue.lastBaseUpdate;\n\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        const payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n          }\n\n          const nextState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        const payload = update.payload;\n        let partialState;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n          }\n\n          partialState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nexport function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n  // This is always non-null on a ClassComponent or HostRoot\n  const queue = workInProgress.updateQueue;\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  let firstBaseUpdate = queue.firstBaseUpdate;\n  let lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n\n  let pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null; // Append pending updates to base queue\n\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n\n    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n\n    const current = workInProgress.alternate;\n\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      const currentQueue = current.updateQueue;\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  } // These values may change as we process the queue.\n\n\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    let newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n\n    let newLanes = NoLanes;\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n    let update = firstBaseUpdate;\n\n    do {\n      const updateLane = update.lane;\n      const updateEventTime = update.eventTime;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n          next: null\n        };\n\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Update the remaining priority in the queue.\n\n\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newLastBaseUpdate !== null) {\n          const clone = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Process this update.\n\n\n        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n        const callback = update.callback;\n\n        if (callback !== null && // If the update was already committed, we should not queue its\n        // callback again.\n        update.lane !== NoLane) {\n          workInProgress.flags |= Callback;\n          const effects = queue.effects;\n\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n\n      update = update.next;\n\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          const lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n\n          const firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = newBaseState;\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n    // process them during this render, but we do need to track which lanes\n    // are remaining.\n\n    const lastInterleaved = queue.shared.interleaved;\n\n    if (lastInterleaved !== null) {\n      let interleaved = lastInterleaved;\n\n      do {\n        newLanes = mergeLanes(newLanes, interleaved.lane);\n        interleaved = interleaved.next;\n      } while (interleaved !== lastInterleaved);\n    } else if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    } // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + `received: ${callback}`);\n  }\n\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nexport function checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\nexport function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n  // Commit the effects\n  const effects = finishedQueue.effects;\n  finishedQueue.effects = null;\n\n  if (effects !== null) {\n    for (let i = 0; i < effects.length; i++) {\n      const effect = effects[i];\n      const callback = effect.callback;\n\n      if (callback !== null) {\n        effect.callback = null;\n        callCallback(callback, instance);\n      }\n    }\n  }\n}","map":{"version":3,"names":["NoLane","NoLanes","isSubsetOfLanes","mergeLanes","isTransitionLane","intersectLanes","markRootEntangled","enterDisallowedContextReadInDEV","exitDisallowedContextReadInDEV","Callback","ShouldCapture","DidCapture","debugRenderPhaseSideEffectsForStrictMode","StrictLegacyMode","markSkippedUpdateLanes","isInterleavedUpdate","pushInterleavedQueue","setIsStrictModeForDevtools","assign","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","__DEV__","initializeUpdateQueue","fiber","queue","baseState","memoizedState","firstBaseUpdate","lastBaseUpdate","shared","pending","interleaved","lanes","effects","updateQueue","cloneUpdateQueue","current","workInProgress","currentQueue","clone","createUpdate","eventTime","lane","update","tag","payload","callback","next","enqueueUpdate","sharedQueue","console","log","error","entangleTransitions","root","queueLanes","pendingLanes","newQueueLanes","enqueueCapturedUpdate","capturedUpdate","alternate","newFirst","newLast","getStateFromUpdate","prevState","nextProps","instance","nextState","call","mode","flags","partialState","undefined","processUpdateQueue","props","renderLanes","pendingQueue","lastPendingUpdate","firstPendingUpdate","currentLastBaseUpdate","newState","newLanes","newBaseState","newFirstBaseUpdate","newLastBaseUpdate","updateLane","updateEventTime","push","lastInterleaved","callCallback","context","Error","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedWork","finishedQueue","i","length","effect"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactUpdateQueue.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\n// UpdateQueue is a linked list of prioritized updates.\r\n//\r\n// Like fibers, update queues come in pairs: a current queue, which represents\r\n// the visible state of the screen, and a work-in-progress queue, which can be\r\n// mutated and processed asynchronously before it is committed — a form of\r\n// double buffering. If a work-in-progress render is discarded before finishing,\r\n// we create a new work-in-progress by cloning the current queue.\r\n//\r\n// Both queues share a persistent, singly-linked list structure. To schedule an\r\n// update, we append it to the end of both queues. Each queue maintains a\r\n// pointer to first update in the persistent list that hasn't been processed.\r\n// The work-in-progress pointer always has a position equal to or greater than\r\n// the current queue, since we always work on that one. The current queue's\r\n// pointer is only updated during the commit phase, when we swap in the\r\n// work-in-progress.\r\n//\r\n// For example:\r\n//\r\n//   Current pointer:           A - B - C - D - E - F\r\n//   Work-in-progress pointer:              D - E - F\r\n//                                          ^\r\n//                                          The work-in-progress queue has\r\n//                                          processed more updates than current.\r\n//\r\n// The reason we append to both queues is because otherwise we might drop\r\n// updates without ever processing them. For example, if we only add updates to\r\n// the work-in-progress queue, some updates could be lost whenever a work-in\r\n// -progress render restarts by cloning from current. Similarly, if we only add\r\n// updates to the current queue, the updates will be lost whenever an already\r\n// in-progress queue commits and swaps with the current queue. However, by\r\n// adding to both queues, we guarantee that the update will be part of the next\r\n// work-in-progress. (And because the work-in-progress queue becomes the\r\n// current queue once it commits, there's no danger of applying the same\r\n// update twice.)\r\n//\r\n// Prioritization\r\n// --------------\r\n//\r\n// Updates are not sorted by priority, but by insertion; new updates are always\r\n// appended to the end of the list.\r\n//\r\n// The priority is still important, though. When processing the update queue\r\n// during the render phase, only the updates with sufficient priority are\r\n// included in the result. If we skip an update because it has insufficient\r\n// priority, it remains in the queue to be processed later, during a lower\r\n// priority render. Crucially, all updates subsequent to a skipped update also\r\n// remain in the queue *regardless of their priority*. That means high priority\r\n// updates are sometimes processed twice, at two separate priorities. We also\r\n// keep track of a base state, that represents the state before the first\r\n// update in the queue is applied.\r\n//\r\n// For example:\r\n//\r\n//   Given a base state of '', and the following queue of updates\r\n//\r\n//     A1 - B2 - C1 - D2\r\n//\r\n//   where the number indicates the priority, and the update is applied to the\r\n//   previous state by appending a letter, React will process these updates as\r\n//   two separate renders, one per distinct priority level:\r\n//\r\n//   First render, at priority 1:\r\n//     Base state: ''\r\n//     Updates: [A1, C1]\r\n//     Result state: 'AC'\r\n//\r\n//   Second render, at priority 2:\r\n//     Base state: 'A'            <-  The base state does not include C1,\r\n//                                    because B2 was skipped.\r\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\r\n//     Result state: 'ABCD'\r\n//\r\n// Because we process updates in insertion order, and rebase high priority\r\n// updates when preceding updates are skipped, the final result is deterministic\r\n// regardless of priority. Intermediate state may vary according to system\r\n// resources, but the final state is always the same.\r\n\r\nimport type { Fiber, FiberRoot } from './ReactInternalTypes';\r\nimport type { Lanes, Lane } from './ReactFiberLane.old';\r\n\r\nimport {\r\n  NoLane,\r\n  NoLanes,\r\n  isSubsetOfLanes,\r\n  mergeLanes,\r\n  isTransitionLane,\r\n  intersectLanes,\r\n  markRootEntangled,\r\n} from './ReactFiberLane.old';\r\nimport {\r\n  enterDisallowedContextReadInDEV,\r\n  exitDisallowedContextReadInDEV,\r\n} from './ReactFiberNewContext.old';\r\nimport { Callback, ShouldCapture, DidCapture } from './ReactFiberFlags';\r\n\r\nimport { debugRenderPhaseSideEffectsForStrictMode } from 'shared/ReactFeatureFlags';\r\n\r\nimport { StrictLegacyMode } from './ReactTypeOfMode';\r\nimport {\r\n  markSkippedUpdateLanes,\r\n  isInterleavedUpdate,\r\n} from './ReactFiberWorkLoop.old';\r\nimport { pushInterleavedQueue } from './ReactFiberInterleavedUpdates.old';\r\nimport { setIsStrictModeForDevtools } from './ReactFiberDevToolsHook.old';\r\n\r\nimport assign from 'shared/assign';\r\n\r\nexport type Update<State> = {|\r\n  // TODO: Temporary field. Will remove this by storing a map of\r\n  // transition -> event time on the root.\r\n  eventTime: number,\r\n    lane: Lane,\r\n\r\n      tag: 0 | 1 | 2 | 3,\r\n        payload: any,\r\n          callback: (() => mixed) | null,\r\n\r\n            next: Update < State > | null,\r\n|};\r\n\r\nexport type SharedQueue<State> = {|\r\n  pending: Update < State > | null,\r\n    interleaved: Update < State > | null,\r\n      lanes: Lanes,\r\n|};\r\n\r\nexport type UpdateQueue<State> = {|\r\n  baseState: State,\r\n    firstBaseUpdate: Update < State > | null,\r\n      lastBaseUpdate: Update < State > | null,\r\n        shared: SharedQueue < State >,\r\n          effects: Array < Update < State >> | null,\r\n|};\r\n\r\nexport const UpdateState = 0;\r\nexport const ReplaceState = 1;\r\nexport const ForceUpdate = 2;\r\nexport const CaptureUpdate = 3;\r\n\r\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\r\n// It should only be read right after calling `processUpdateQueue`, via\r\n// `checkHasForceUpdateAfterProcessing`.\r\nlet hasForceUpdate = false;\r\n\r\nlet didWarnUpdateInsideUpdate;\r\nlet currentlyProcessingQueue;\r\nexport let resetCurrentlyProcessingQueue;\r\nif (__DEV__) {\r\n  didWarnUpdateInsideUpdate = false;\r\n  currentlyProcessingQueue = null;\r\n  resetCurrentlyProcessingQueue = () => {\r\n    currentlyProcessingQueue = null;\r\n  };\r\n}\r\n\r\n//对于HostRoot或者ClassComponent会使用initializeUpdateQueue创建updateQueue，然后将updateQueue挂载到fiber节点上\r\nexport function initializeUpdateQueue<State> (fiber: Fiber): void {\r\n  const queue: UpdateQueue<State> = {\r\n    baseState: fiber.memoizedState, //初始state，后面会基于这个state，根据Update计算新的state\r\n    firstBaseUpdate: null, // Update形成的链表的头\r\n    lastBaseUpdate: null, //Update形成的链表的尾\r\n    //新产生的update会以单向环状链表保存在shared.pending上，计算state的时候会剪开这个环状链表，并且连接在\r\n    //lastBaseUpdate后\r\n    shared: {\r\n      pending: null, // shared.pending,等待处理的 update\r\n      interleaved: null,\r\n      lanes: NoLanes,\r\n    },\r\n    effects: null,\r\n  };\r\n  fiber.updateQueue = queue;\r\n}\r\n\r\nexport function cloneUpdateQueue<State> (\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n): void {\r\n  // Clone the update queue from current. Unless it's already a clone.\r\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\r\n  const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\r\n  if (queue === currentQueue) {\r\n    const clone: UpdateQueue<State> = {\r\n      baseState: currentQueue.baseState,\r\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\r\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\r\n      shared: currentQueue.shared,\r\n      effects: currentQueue.effects,\r\n    };\r\n    workInProgress.updateQueue = clone;\r\n  }\r\n}\r\n\r\nexport function createUpdate (eventTime: number, lane: Lane): Update<*> {\r\n  const update: Update<*> = {\r\n    eventTime, // 任务时间，通过performance.now()获取的毫秒数。\r\n    lane, // 优先级相关字段,不同的update优先级不同\r\n\r\n    tag: UpdateState,  // 更新的类型，包括UpdateState | ReplaceState | ForceUpdate | CaptureUpdate。\r\n    payload: null,  // 更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参。\r\n    callback: null,  // 更新的回调函数。即在commit 阶段的 layout 子阶段一节中提到的回调函数。\r\n\r\n    next: null,  // 与其他Update连接形成链表\r\n  };\r\n  return update;\r\n}\r\n\r\nexport function enqueueUpdate<State> (\r\n  fiber: Fiber,\r\n  update: Update<State>,\r\n  lane: Lane,\r\n) {\r\n  // fiber为rootFiber组件根节点\r\n  const updateQueue = fiber.updateQueue;\r\n  if (updateQueue === null) {\r\n    // Only occurs if the fiber has been unmounted.\r\n    // 当fiber节点卸载时发生\r\n    return;\r\n  }\r\n\r\n  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;\r\n  if (isInterleavedUpdate(fiber, lane)) {\r\n    const interleaved = sharedQueue.interleaved;\r\n    // 如果interleaved为空时表示是第一次更新，此时处于mount阶段\r\n    if (interleaved === null) {\r\n      // This is the first update. Create a circular list.\r\n      // 首位相连形成链表\r\n      update.next = update;\r\n      // At the end of the current render, this queue's interleaved updates will\r\n      // be transferred to the pending queue.\r\n      pushInterleavedQueue(sharedQueue);\r\n    } else {\r\n      update.next = interleaved.next;\r\n      interleaved.next = update;\r\n    }\r\n    sharedQueue.interleaved = update;\r\n  } else {\r\n    const pending = sharedQueue.pending;\r\n    console.log(sharedQueue)\r\n    if (pending === null) {\r\n      // This is the first update. Create a circular list.\r\n      update.next = update;\r\n    } else {\r\n      update.next = pending.next;\r\n      pending.next = update;\r\n    }\r\n    sharedQueue.pending = update;\r\n  }\r\n  if (__DEV__) {\r\n    if (\r\n      currentlyProcessingQueue === sharedQueue &&\r\n      !didWarnUpdateInsideUpdate\r\n    ) {\r\n      console.error(\r\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\r\n        'from inside an update function. Update functions should be pure, ' +\r\n        'with zero side-effects. Consider using componentDidUpdate or a ' +\r\n        'callback.',\r\n      );\r\n      didWarnUpdateInsideUpdate = true;\r\n    }\r\n  }\r\n}\r\n\r\nexport function entangleTransitions (root: FiberRoot, fiber: Fiber, lane: Lane) {\r\n  const updateQueue = fiber.updateQueue;\r\n  if (updateQueue === null) {\r\n    // Only occurs if the fiber has been unmounted.\r\n    return;\r\n  }\r\n\r\n  const sharedQueue: SharedQueue<mixed> = (updateQueue: any).shared;\r\n  if (isTransitionLane(lane)) {\r\n    let queueLanes = sharedQueue.lanes;\r\n\r\n    // If any entangled lanes are no longer pending on the root, then they must\r\n    // have finished. We can remove them from the shared queue, which represents\r\n    // a superset of the actually pending lanes. In some cases we may entangle\r\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\r\n    // entangle when we should.\r\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes);\r\n\r\n    // Entangle the new transition lane with the other transition lanes.\r\n    const newQueueLanes = mergeLanes(queueLanes, lane);\r\n    sharedQueue.lanes = newQueueLanes;\r\n    // Even if queue.lanes already include lane, we don't know for certain if\r\n    // the lane finished since the last time we entangled it. So we need to\r\n    // entangle it again, just to be sure.\r\n    markRootEntangled(root, newQueueLanes);\r\n  }\r\n}\r\n\r\nexport function enqueueCapturedUpdate<State> (\r\n  workInProgress: Fiber,\r\n  capturedUpdate: Update<State>,\r\n) {\r\n  // Captured updates are updates that are thrown by a child during the render\r\n  // phase. They should be discarded if the render is aborted. Therefore,\r\n  // we should only put them on the work-in-progress queue, not the current one.\r\n  let queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\r\n\r\n  // Check if the work-in-progress queue is a clone.\r\n  const current = workInProgress.alternate;\r\n  if (current !== null) {\r\n    const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\r\n    if (queue === currentQueue) {\r\n      // The work-in-progress queue is the same as current. This happens when\r\n      // we bail out on a parent fiber that then captures an error thrown by\r\n      // a child. Since we want to append the update only to the work-in\r\n      // -progress queue, we need to clone the updates. We usually clone during\r\n      // processUpdateQueue, but that didn't happen in this case because we\r\n      // skipped over the parent when we bailed out.\r\n      let newFirst = null;\r\n      let newLast = null;\r\n      const firstBaseUpdate = queue.firstBaseUpdate;\r\n      if (firstBaseUpdate !== null) {\r\n        // Loop through the updates and clone them.\r\n        let update = firstBaseUpdate;\r\n        do {\r\n          const clone: Update<State> = {\r\n            eventTime: update.eventTime,\r\n            lane: update.lane,\r\n\r\n            tag: update.tag,\r\n            payload: update.payload,\r\n            callback: update.callback,\r\n\r\n            next: null,\r\n          };\r\n          if (newLast === null) {\r\n            newFirst = newLast = clone;\r\n          } else {\r\n            newLast.next = clone;\r\n            newLast = clone;\r\n          }\r\n          update = update.next;\r\n        } while (update !== null);\r\n\r\n        // Append the captured update the end of the cloned list.\r\n        if (newLast === null) {\r\n          newFirst = newLast = capturedUpdate;\r\n        } else {\r\n          newLast.next = capturedUpdate;\r\n          newLast = capturedUpdate;\r\n        }\r\n      } else {\r\n        // There are no base updates.\r\n        newFirst = newLast = capturedUpdate;\r\n      }\r\n      queue = {\r\n        baseState: currentQueue.baseState,\r\n        firstBaseUpdate: newFirst,\r\n        lastBaseUpdate: newLast,\r\n        shared: currentQueue.shared,\r\n        effects: currentQueue.effects,\r\n      };\r\n      workInProgress.updateQueue = queue;\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Append the update to the end of the list.\r\n  const lastBaseUpdate = queue.lastBaseUpdate;\r\n  if (lastBaseUpdate === null) {\r\n    queue.firstBaseUpdate = capturedUpdate;\r\n  } else {\r\n    lastBaseUpdate.next = capturedUpdate;\r\n  }\r\n  queue.lastBaseUpdate = capturedUpdate;\r\n}\r\n\r\nfunction getStateFromUpdate<State> (\r\n  workInProgress: Fiber,\r\n  queue: UpdateQueue<State>,\r\n  update: Update<State>,\r\n  prevState: State,\r\n  nextProps: any,\r\n  instance: any,\r\n): any {\r\n  switch (update.tag) {\r\n    case ReplaceState: {\r\n      const payload = update.payload;\r\n      if (typeof payload === 'function') {\r\n        // Updater function\r\n        if (__DEV__) {\r\n          enterDisallowedContextReadInDEV();\r\n        }\r\n        const nextState = payload.call(instance, prevState, nextProps);\r\n        if (__DEV__) {\r\n          if (\r\n            debugRenderPhaseSideEffectsForStrictMode &&\r\n            workInProgress.mode & StrictLegacyMode\r\n          ) {\r\n            setIsStrictModeForDevtools(true);\r\n            try {\r\n              payload.call(instance, prevState, nextProps);\r\n            } finally {\r\n              setIsStrictModeForDevtools(false);\r\n            }\r\n          }\r\n          exitDisallowedContextReadInDEV();\r\n        }\r\n        return nextState;\r\n      }\r\n      // State object\r\n      return payload;\r\n    }\r\n    case CaptureUpdate: {\r\n      workInProgress.flags =\r\n        (workInProgress.flags & ~ShouldCapture) | DidCapture;\r\n    }\r\n    // Intentional fallthrough\r\n    case UpdateState: {\r\n      const payload = update.payload;\r\n      let partialState;\r\n      if (typeof payload === 'function') {\r\n        // Updater function\r\n        if (__DEV__) {\r\n          enterDisallowedContextReadInDEV();\r\n        }\r\n        partialState = payload.call(instance, prevState, nextProps);\r\n        if (__DEV__) {\r\n          if (\r\n            debugRenderPhaseSideEffectsForStrictMode &&\r\n            workInProgress.mode & StrictLegacyMode\r\n          ) {\r\n            setIsStrictModeForDevtools(true);\r\n            try {\r\n              payload.call(instance, prevState, nextProps);\r\n            } finally {\r\n              setIsStrictModeForDevtools(false);\r\n            }\r\n          }\r\n          exitDisallowedContextReadInDEV();\r\n        }\r\n      } else {\r\n        // Partial state object\r\n        partialState = payload;\r\n      }\r\n      if (partialState === null || partialState === undefined) {\r\n        // Null and undefined are treated as no-ops.\r\n        return prevState;\r\n      }\r\n      // Merge the partial state and the previous state.\r\n      return assign({}, prevState, partialState);\r\n    }\r\n    case ForceUpdate: {\r\n      hasForceUpdate = true;\r\n      return prevState;\r\n    }\r\n  }\r\n  return prevState;\r\n}\r\n\r\nexport function processUpdateQueue<State> (\r\n  workInProgress: Fiber,\r\n  props: any,\r\n  instance: any,\r\n  renderLanes: Lanes,\r\n): void {\r\n  // This is always non-null on a ClassComponent or HostRoot\r\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\r\n\r\n  hasForceUpdate = false;\r\n\r\n  if (__DEV__) {\r\n    currentlyProcessingQueue = queue.shared;\r\n  }\r\n\r\n  let firstBaseUpdate = queue.firstBaseUpdate;\r\n  let lastBaseUpdate = queue.lastBaseUpdate;\r\n\r\n  // Check if there are pending updates. If so, transfer them to the base queue.\r\n  let pendingQueue = queue.shared.pending;\r\n  if (pendingQueue !== null) {\r\n    queue.shared.pending = null;\r\n\r\n    // The pending queue is circular. Disconnect the pointer between first\r\n    // and last so that it's non-circular.\r\n    const lastPendingUpdate = pendingQueue;\r\n    const firstPendingUpdate = lastPendingUpdate.next;\r\n    lastPendingUpdate.next = null;\r\n    // Append pending updates to base queue\r\n    if (lastBaseUpdate === null) {\r\n      firstBaseUpdate = firstPendingUpdate;\r\n    } else {\r\n      lastBaseUpdate.next = firstPendingUpdate;\r\n    }\r\n    lastBaseUpdate = lastPendingUpdate;\r\n\r\n    // If there's a current queue, and it's different from the base queue, then\r\n    // we need to transfer the updates to that queue, too. Because the base\r\n    // queue is a singly-linked list with no cycles, we can append to both\r\n    // lists and take advantage of structural sharing.\r\n    // TODO: Pass `current` as argument\r\n    const current = workInProgress.alternate;\r\n    if (current !== null) {\r\n      // This is always non-null on a ClassComponent or HostRoot\r\n      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\r\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\r\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\r\n        if (currentLastBaseUpdate === null) {\r\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\r\n        } else {\r\n          currentLastBaseUpdate.next = firstPendingUpdate;\r\n        }\r\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\r\n      }\r\n    }\r\n  }\r\n\r\n  // These values may change as we process the queue.\r\n  if (firstBaseUpdate !== null) {\r\n    // Iterate through the list of updates to compute the result.\r\n    let newState = queue.baseState;\r\n    // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\r\n    // from the original lanes.\r\n    let newLanes = NoLanes;\r\n\r\n    let newBaseState = null;\r\n    let newFirstBaseUpdate = null;\r\n    let newLastBaseUpdate = null;\r\n\r\n    let update = firstBaseUpdate;\r\n    do {\r\n      const updateLane = update.lane;\r\n      const updateEventTime = update.eventTime;\r\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\r\n        // Priority is insufficient. Skip this update. If this is the first\r\n        // skipped update, the previous update/state is the new base\r\n        // update/state.\r\n        const clone: Update<State> = {\r\n          eventTime: updateEventTime,\r\n          lane: updateLane,\r\n\r\n          tag: update.tag,\r\n          payload: update.payload,\r\n          callback: update.callback,\r\n\r\n          next: null,\r\n        };\r\n        if (newLastBaseUpdate === null) {\r\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\r\n          newBaseState = newState;\r\n        } else {\r\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\r\n        }\r\n        // Update the remaining priority in the queue.\r\n        newLanes = mergeLanes(newLanes, updateLane);\r\n      } else {\r\n        // This update does have sufficient priority.\r\n\r\n        if (newLastBaseUpdate !== null) {\r\n          const clone: Update<State> = {\r\n            eventTime: updateEventTime,\r\n            // This update is going to be committed so we never want uncommit\r\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\r\n            // this will never be skipped by the check above.\r\n            lane: NoLane,\r\n\r\n            tag: update.tag,\r\n            payload: update.payload,\r\n            callback: update.callback,\r\n\r\n            next: null,\r\n          };\r\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\r\n        }\r\n\r\n        // Process this update.\r\n        newState = getStateFromUpdate(\r\n          workInProgress,\r\n          queue,\r\n          update,\r\n          newState,\r\n          props,\r\n          instance,\r\n        );\r\n        const callback = update.callback;\r\n        if (\r\n          callback !== null &&\r\n          // If the update was already committed, we should not queue its\r\n          // callback again.\r\n          update.lane !== NoLane\r\n        ) {\r\n          workInProgress.flags |= Callback;\r\n          const effects = queue.effects;\r\n          if (effects === null) {\r\n            queue.effects = [update];\r\n          } else {\r\n            effects.push(update);\r\n          }\r\n        }\r\n      }\r\n      update = update.next;\r\n      if (update === null) {\r\n        pendingQueue = queue.shared.pending;\r\n        if (pendingQueue === null) {\r\n          break;\r\n        } else {\r\n          // An update was scheduled from inside a reducer. Add the new\r\n          // pending updates to the end of the list and keep processing.\r\n          const lastPendingUpdate = pendingQueue;\r\n          // Intentionally unsound. Pending updates form a circular list, but we\r\n          // unravel them when transferring them to the base queue.\r\n          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);\r\n            lastPendingUpdate.next = null;\r\n            update = firstPendingUpdate;\r\n            queue.lastBaseUpdate = lastPendingUpdate;\r\n            queue.shared.pending = null;\r\n        }\r\n      }\r\n    } while (true);\r\n\r\n            if (newLastBaseUpdate === null) {\r\n              newBaseState = newState;\r\n    }\r\n\r\n            queue.baseState = ((newBaseState: any): State);\r\n            queue.firstBaseUpdate = newFirstBaseUpdate;\r\n            queue.lastBaseUpdate = newLastBaseUpdate;\r\n\r\n            // Interleaved updates are stored on a separate queue. We aren't going to\r\n            // process them during this render, but we do need to track which lanes\r\n            // are remaining.\r\n            const lastInterleaved = queue.shared.interleaved;\r\n            if (lastInterleaved !== null) {\r\n              let interleaved = lastInterleaved;\r\n            do {\r\n              newLanes = mergeLanes(newLanes, interleaved.lane);\r\n            interleaved = ((interleaved: any).next: Update<State>);\r\n      } while (interleaved !== lastInterleaved);\r\n    } else if (firstBaseUpdate === null) {\r\n                // `queue.lanes` is used for entangling transitions. We can set it back to\r\n                // zero once the queue is empty.\r\n                queue.shared.lanes = NoLanes;\r\n    }\r\n\r\n              // Set the remaining expiration time to be whatever is remaining in the queue.\r\n              // This should be fine because the only two other things that contribute to\r\n              // expiration time are props and context. We're already in the middle of the\r\n              // begin phase by the time we start processing the queue, so we've already\r\n              // dealt with the props. Context in components that specify\r\n              // shouldComponentUpdate is tricky; but we'll have to account for\r\n              // that regardless.\r\n              markSkippedUpdateLanes(newLanes);\r\n              workInProgress.lanes = newLanes;\r\n              workInProgress.memoizedState = newState;\r\n  }\r\n\r\n              if (__DEV__) {\r\n                currentlyProcessingQueue = null;\r\n  }\r\n}\r\n\r\n              function callCallback(callback, context) {\r\n  if (typeof callback !== 'function') {\r\n    throw new Error(\r\n              'Invalid argument passed as callback. Expected a function. Instead ' +\r\n              `received: ${callback}`,\r\n              );\r\n  }\r\n\r\n              callback.call(context);\r\n}\r\n\r\n              export function resetHasForceUpdateBeforeProcessing() {\r\n                hasForceUpdate = false;\r\n}\r\n\r\n              export function checkHasForceUpdateAfterProcessing(): boolean {\r\n  return hasForceUpdate;\r\n}\r\n\r\n              export function commitUpdateQueue<State>(\r\n                finishedWork: Fiber,\r\n                finishedQueue: UpdateQueue<State>,\r\n                  instance: any,\r\n                  ): void {\r\n  // Commit the effects\r\n  const effects = finishedQueue.effects;\r\n                  finishedQueue.effects = null;\r\n                  if (effects !== null) {\r\n    for (let i = 0; i < effects.length; i++) {\r\n      const effect = effects[i];\r\n                  const callback = effect.callback;\r\n                  if (callback !== null) {\r\n                    effect.callback = null;\r\n                  callCallback(callback, instance);\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,SACEA,MADF,EAEEC,OAFF,EAGEC,eAHF,EAIEC,UAJF,EAKEC,gBALF,EAMEC,cANF,EAOEC,iBAPF,QAQO,sBARP;AASA,SACEC,+BADF,EAEEC,8BAFF,QAGO,4BAHP;AAIA,SAASC,QAAT,EAAmBC,aAAnB,EAAkCC,UAAlC,QAAoD,mBAApD;AAEA,SAASC,wCAAT,QAAyD,0BAAzD;AAEA,SAASC,gBAAT,QAAiC,mBAAjC;AACA,SACEC,sBADF,EAEEC,mBAFF,QAGO,0BAHP;AAIA,SAASC,oBAAT,QAAqC,oCAArC;AACA,SAASC,0BAAT,QAA2C,8BAA3C;AAEA,OAAOC,MAAP,MAAmB,eAAnB;AA6BA,OAAO,MAAMC,WAAW,GAAG,CAApB;AACP,OAAO,MAAMC,YAAY,GAAG,CAArB;AACP,OAAO,MAAMC,WAAW,GAAG,CAApB;AACP,OAAO,MAAMC,aAAa,GAAG,CAAtB,C,CAEP;AACA;AACA;;AACA,IAAIC,cAAc,GAAG,KAArB;AAEA,IAAIC,yBAAJ;AACA,IAAIC,wBAAJ;AACA,OAAO,IAAIC,6BAAJ;;AACP,IAAIC,OAAJ,EAAa;EACXH,yBAAyB,GAAG,KAA5B;EACAC,wBAAwB,GAAG,IAA3B;;EACAC,6BAA6B,GAAG,MAAM;IACpCD,wBAAwB,GAAG,IAA3B;EACD,CAFD;AAGD,C,CAED;;;AACA,OAAO,SAASG,qBAAT,CAAuCC,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"},"metadata":{},"sourceType":"module"}