{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport { SyntheticEvent } from '../../events/SyntheticEvent';\nimport isTextInputElement from '../isTextInputElement';\nimport shallowEqual from 'shared/shallowEqual';\nimport { registerTwoPhaseEvent } from '../EventRegistry';\nimport getActiveElement from '../../client/getActiveElement';\nimport { getNodeFromInstance } from '../../client/ReactDOMComponentTree';\nimport { hasSelectionCapabilities } from '../../client/ReactInputSelection';\nimport { DOCUMENT_NODE } from '../../shared/HTMLNodeType';\nimport { accumulateTwoPhaseListeners } from '../DOMPluginEventSystem';\nconst skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);\n}\n\nlet activeElement = null;\nlet activeElementInst = null;\nlet lastSelection = null;\nlet mouseDown = false;\n/**\r\n * Get an object which is a unique representation of the current selection.\r\n *\r\n * The return value will not be consistent across nodes or browsers, but\r\n * two identical selections on the same node will return identical objects.\r\n */\n\nfunction getSelection(node) {\n  // console.log(node,\"currentSelection\")\n  // node选中的元素节点\n  // 当node为 text search tel password url textarea 等节点时为true\n  // console.log(node,\"dsfa\")\n  if (node.selectionStart && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else {\n    const win = node.ownerDocument && node.ownerDocument.defaultView || window; // console.log(win,\"win\")\n\n    const selection = win.getSelection();\n    console.log(selection, \"selection\");\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n/**\r\n * Get document associated with the event target.\r\n */\n\n\nfunction getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n}\n/**\r\n * Poll selection to see whether it's changed.\r\n *\r\n * @param {object} nativeEvent\r\n * @param {object} nativeEventTarget\r\n * @return {?SyntheticEvent}\r\n */\n\n\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n  // 构造选择事件\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  // 找到目标事件\n  const doc = getEventTargetDocument(nativeEventTarget); // console.log(doc,\"doc\")\n  // 如果mouseDown事件触发了，并且没有聚焦的元素\n\n  if (mouseDown || activeElement == null || activeElement !== getActiveElement(doc)) {\n    return;\n  } // Only fire when selection has actually changed.\n  // 找到当前选中的节点信息  如果时第一次选中的话返回选中的节点信息，如果选中后有内容输出的话，返回输入的数据长度\n\n\n  const currentSelection = getSelection(activeElement); // console.log(currentSelection,\"currentSelection\")\n\n  console.log(lastSelection, \"lastSelection\");\n\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n    const listeners = accumulateTwoPhaseListeners(activeElementInst, 'onSelect');\n\n    if (listeners.length > 0) {\n      const event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);\n      dispatchQueue.push({\n        event,\n        listeners\n      });\n      event.target = activeElement;\n    }\n  }\n}\n/**\r\n * This plugin creates an `onSelect` event that normalizes select events\r\n * across form elements.\r\n *\r\n * Supported elements are:\r\n * - input (see `isTextInputElement`)\r\n * - textarea\r\n * - contentEditable\r\n *\r\n * This differs from native browser implementations in the following ways:\r\n * - Fires on contentEditable fields as well as inputs.\r\n * - Fires for collapsed selection.\r\n * - Fires after user input.\r\n */\n\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n\n  switch (domEventName) {\n    // Track the input node that has focus.\n    case 'focusin':\n      if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n        // 当前活动元素\n        activeElement = targetNode; // 当前活动元素fiber实例\n\n        activeElementInst = targetInst;\n        lastSelection = null;\n      }\n\n      break;\n\n    case 'focusout':\n      activeElement = null;\n      activeElementInst = null;\n      lastSelection = null;\n      break;\n    // Don't fire the event while the user is dragging. This matches the\n    // semantics of the native select event.\n\n    case 'mousedown':\n      mouseDown = true;\n      break;\n\n    case 'contextmenu':\n    case 'mouseup':\n    case 'dragend':\n      mouseDown = false;\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n      break;\n    // Chrome and IE fire non-standard event when selection is changed (and\n    // sometimes when it hasn't). IE's event fires out of order with respect\n    // to key and input events on deletion, so we discard it.\n    //\n    // Firefox doesn't support selectionchange, so check selection status\n    // after each key entry. The selection changes after keydown and before\n    // keyup, but we check on keydown as well in the case of holding down a\n    // key, when multiple keydown events are fired but only one keyup is.\n    // This is also our approach for IE handling, for the reason above.\n\n    case 'selectionchange':\n      if (skipSelectionChangeEvent) {\n        break;\n      }\n\n    // falls through\n\n    case 'keydown':\n    case 'keyup':\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n  }\n}\n\nexport { registerEvents, extractEvents };","map":{"version":3,"names":["canUseDOM","SyntheticEvent","isTextInputElement","shallowEqual","registerTwoPhaseEvent","getActiveElement","getNodeFromInstance","hasSelectionCapabilities","DOCUMENT_NODE","accumulateTwoPhaseListeners","skipSelectionChangeEvent","document","documentMode","registerEvents","activeElement","activeElementInst","lastSelection","mouseDown","getSelection","node","selectionStart","start","end","selectionEnd","win","ownerDocument","defaultView","window","selection","console","log","anchorNode","anchorOffset","focusNode","focusOffset","getEventTargetDocument","eventTarget","nodeType","constructSelectEvent","dispatchQueue","nativeEvent","nativeEventTarget","doc","currentSelection","listeners","length","event","push","target","extractEvents","domEventName","targetInst","eventSystemFlags","targetContainer","targetNode","contentEditable"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-dom/src/events/plugins/SelectEventPlugin.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {AnyNativeEvent} from '../PluginModuleType';\r\nimport type {DOMEventName} from '../DOMEventNames';\r\nimport type {DispatchQueue} from '../DOMPluginEventSystem';\r\nimport type {EventSystemFlags} from '../EventSystemFlags';\r\n\r\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\r\nimport {SyntheticEvent} from '../../events/SyntheticEvent';\r\nimport isTextInputElement from '../isTextInputElement';\r\nimport shallowEqual from 'shared/shallowEqual';\r\n\r\nimport {registerTwoPhaseEvent} from '../EventRegistry';\r\nimport getActiveElement from '../../client/getActiveElement';\r\nimport {getNodeFromInstance} from '../../client/ReactDOMComponentTree';\r\nimport {hasSelectionCapabilities} from '../../client/ReactInputSelection';\r\nimport {DOCUMENT_NODE} from '../../shared/HTMLNodeType';\r\nimport {accumulateTwoPhaseListeners} from '../DOMPluginEventSystem';\r\n\r\nconst skipSelectionChangeEvent =\r\n  canUseDOM && 'documentMode' in document && document.documentMode <= 11;\r\n\r\nfunction registerEvents() {\r\n  registerTwoPhaseEvent('onSelect', [\r\n    'focusout',\r\n    'contextmenu',\r\n    'dragend',\r\n    'focusin',\r\n    'keydown',\r\n    'keyup',\r\n    'mousedown',\r\n    'mouseup',\r\n    'selectionchange',\r\n  ]);\r\n}\r\n\r\nlet activeElement = null;\r\nlet activeElementInst = null;\r\nlet lastSelection = null;\r\nlet mouseDown = false;\r\n\r\n/**\r\n * Get an object which is a unique representation of the current selection.\r\n *\r\n * The return value will not be consistent across nodes or browsers, but\r\n * two identical selections on the same node will return identical objects.\r\n */\r\nfunction getSelection(node: any) {\r\n  // console.log(node,\"currentSelection\")\r\n  // node选中的元素节点\r\n  // 当node为 text search tel password url textarea 等节点时为true\r\n  // console.log(node,\"dsfa\")\r\n  if (node.selectionStart && hasSelectionCapabilities(node)) {\r\n    return {\r\n      start: node.selectionStart,\r\n      end: node.selectionEnd,\r\n    };\r\n  } else {\r\n    const win =\r\n      (node.ownerDocument && node.ownerDocument.defaultView) || window;\r\n    // console.log(win,\"win\")\r\n    const selection = win.getSelection();\r\n    console.log(selection,\"selection\")\r\n    return {\r\n      anchorNode: selection.anchorNode,\r\n      anchorOffset: selection.anchorOffset,\r\n      focusNode: selection.focusNode,\r\n      focusOffset: selection.focusOffset,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Get document associated with the event target.\r\n */\r\nfunction getEventTargetDocument(eventTarget: any) {\r\n  return eventTarget.window === eventTarget\r\n    ? eventTarget.document\r\n    : eventTarget.nodeType === DOCUMENT_NODE\r\n    ? eventTarget\r\n    : eventTarget.ownerDocument;\r\n}\r\n\r\n/**\r\n * Poll selection to see whether it's changed.\r\n *\r\n * @param {object} nativeEvent\r\n * @param {object} nativeEventTarget\r\n * @return {?SyntheticEvent}\r\n */\r\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\r\n  // 构造选择事件\r\n  // Ensure we have the right element, and that the user is not dragging a\r\n  // selection (this matches native `select` event behavior). In HTML5, select\r\n  // fires only on input and textarea thus if there's no focused element we\r\n  // won't dispatch.\r\n  // 找到目标事件\r\n  const doc = getEventTargetDocument(nativeEventTarget);\r\n  // console.log(doc,\"doc\")\r\n  // 如果mouseDown事件触发了，并且没有聚焦的元素\r\n  if (\r\n    mouseDown ||\r\n    activeElement == null ||\r\n    activeElement !== getActiveElement(doc)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  // Only fire when selection has actually changed.\r\n\r\n  // 找到当前选中的节点信息  如果时第一次选中的话返回选中的节点信息，如果选中后有内容输出的话，返回输入的数据长度\r\n  const currentSelection = getSelection(activeElement);\r\n  // console.log(currentSelection,\"currentSelection\")\r\n  console.log(lastSelection,\"lastSelection\")\r\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\r\n    lastSelection = currentSelection;\r\n\r\n    const listeners = accumulateTwoPhaseListeners(\r\n      activeElementInst,\r\n      'onSelect',\r\n    );\r\n    if (listeners.length > 0) {\r\n      const event = new SyntheticEvent(\r\n        'onSelect',\r\n        'select',\r\n        null,\r\n        nativeEvent,\r\n        nativeEventTarget,\r\n      );\r\n      dispatchQueue.push({event, listeners});\r\n      event.target = activeElement;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This plugin creates an `onSelect` event that normalizes select events\r\n * across form elements.\r\n *\r\n * Supported elements are:\r\n * - input (see `isTextInputElement`)\r\n * - textarea\r\n * - contentEditable\r\n *\r\n * This differs from native browser implementations in the following ways:\r\n * - Fires on contentEditable fields as well as inputs.\r\n * - Fires for collapsed selection.\r\n * - Fires after user input.\r\n */\r\nfunction extractEvents(\r\n  dispatchQueue: DispatchQueue,\r\n  domEventName: DOMEventName,\r\n  targetInst: null | Fiber,\r\n  nativeEvent: AnyNativeEvent,\r\n  nativeEventTarget: null | EventTarget,\r\n  eventSystemFlags: EventSystemFlags,\r\n  targetContainer: EventTarget,\r\n) {\r\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\r\n\r\n  switch (domEventName) {\r\n    // Track the input node that has focus.\r\n    case 'focusin':\r\n      if (\r\n        isTextInputElement((targetNode: any)) ||\r\n        targetNode.contentEditable === 'true'\r\n      ) {\r\n        // 当前活动元素\r\n        activeElement = targetNode;\r\n        // 当前活动元素fiber实例\r\n        activeElementInst = targetInst;\r\n        lastSelection = null;\r\n      }\r\n      break;\r\n    case 'focusout':\r\n      activeElement = null;\r\n      activeElementInst = null;\r\n      lastSelection = null;\r\n      break;\r\n    // Don't fire the event while the user is dragging. This matches the\r\n    // semantics of the native select event.\r\n    case 'mousedown':\r\n      mouseDown = true;\r\n      break;\r\n    case 'contextmenu':\r\n    case 'mouseup':\r\n    case 'dragend':\r\n      mouseDown = false;\r\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\r\n      break;\r\n    // Chrome and IE fire non-standard event when selection is changed (and\r\n    // sometimes when it hasn't). IE's event fires out of order with respect\r\n    // to key and input events on deletion, so we discard it.\r\n    //\r\n    // Firefox doesn't support selectionchange, so check selection status\r\n    // after each key entry. The selection changes after keydown and before\r\n    // keyup, but we check on keydown as well in the case of holding down a\r\n    // key, when multiple keydown events are fired but only one keyup is.\r\n    // This is also our approach for IE handling, for the reason above.\r\n    case 'selectionchange':\r\n      if (skipSelectionChangeEvent) {\r\n        break;\r\n      }\r\n    // falls through\r\n    case 'keydown':\r\n    case 'keyup':\r\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\r\n  }\r\n}\r\n\r\nexport {registerEvents, extractEvents};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}