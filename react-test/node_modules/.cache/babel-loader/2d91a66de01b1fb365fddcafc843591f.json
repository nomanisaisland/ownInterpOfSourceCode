{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { enableSuspenseAvoidThisFallback, enableCPUSuspense, enableUseMutableSource } from 'shared/ReactFeatureFlags';\nimport checkPropTypes from 'shared/checkPropTypes';\nimport { markComponentRenderStarted, markComponentRenderStopped, setIsStrictModeForDevtools } from './ReactFiberDevToolsHook.old';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, ForwardRef, Fragment, Mode, ContextProvider, ContextConsumer, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent, TracingMarkerComponent } from './ReactWorkTags';\nimport { NoFlags, PerformedWork, Placement, Hydrating, ContentReset, DidCapture, Update, Ref, RefStatic, ChildDeletion, ForceUpdateForLegacySuspense, StaticMask, ShouldCapture, ForceClientRender } from './ReactFiberFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, disableModulePatternComponents, enableProfilerCommitHooks, enableProfilerTimer, warnAboutDefaultPropsOnFunctionComponents, enableScopeAPI, enableCache, enableLazyContextPropagation, enableSuspenseLayoutEffectSemantics, enableSchedulingProfiler, enablePersistentOffscreenHostContainer, enableTransitionTracing, enableLegacyHidden } from 'shared/ReactFeatureFlags';\nimport isArray from 'shared/isArray';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\nimport { REACT_LAZY_TYPE, getIteratorFn } from 'shared/ReactSymbols';\nimport { getCurrentFiberOwnerNameInDevOrNull, setIsRendering } from './ReactCurrentFiber';\nimport { resolveFunctionForHotReloading, resolveForwardRefForHotReloading, resolveClassForHotReloading } from './ReactFiberHotReloading.old';\nimport { mountChildFibers, reconcileChildFibers, cloneChildFibers } from './ReactChildFiber.old';\nimport { processUpdateQueue, cloneUpdateQueue, initializeUpdateQueue, enqueueCapturedUpdate } from './ReactUpdateQueue.old';\nimport { NoLane, NoLanes, SyncLane, OffscreenLane, DefaultHydrationLane, SomeRetryLane, NoTimestamp, includesSomeLane, laneToLanes, removeLanes, mergeLanes, getBumpedLaneForHydration, pickArbitraryLane } from './ReactFiberLane.old';\nimport { ConcurrentMode, NoMode, ProfileMode, StrictLegacyMode } from './ReactTypeOfMode';\nimport { shouldSetTextContent, isSuspenseInstancePending, isSuspenseInstanceFallback, registerSuspenseInstanceRetry, supportsHydration, isPrimaryRenderer, supportsPersistence, getOffscreenContainerProps } from './ReactFiberHostConfig';\nimport { shouldError, shouldSuspend } from './ReactFiberReconciler';\nimport { pushHostContext, pushHostContainer } from './ReactFiberHostContext.old';\nimport { suspenseStackCursor, pushSuspenseContext, InvisibleParentSuspenseContext, ForceSuspenseFallback, hasSuspenseContext, setDefaultShallowSuspenseContext, addSubtreeSuspenseContext, setShallowSuspenseContext } from './ReactFiberSuspenseContext.old';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent.old';\nimport { pushProvider, propagateContextChange, lazilyPropagateParentContextChanges, propagateParentContextChangesToDeferredTree, checkIfContextChanged, readContext, prepareToReadContext, scheduleContextWorkOnParentPath } from './ReactFiberNewContext.old';\nimport { renderWithHooks, checkDidRenderIdHook, bailoutHooks } from './ReactFiberHooks.old';\nimport { stopProfilerTimerIfRunning } from './ReactProfilerTimer.old';\nimport { getMaskedContext, getUnmaskedContext, hasContextChanged as hasLegacyContextChanged, pushContextProvider as pushLegacyContextProvider, isContextProvider as isLegacyContextProvider, pushTopLevelContextObject, invalidateContextProvider } from './ReactFiberContext.old';\nimport { getIsHydrating, enterHydrationState, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, tryToClaimNextHydratableInstance, warnIfHydrating, queueHydrationError } from './ReactFiberHydrationContext.old';\nimport { adoptClassInstance, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance } from './ReactFiberClassComponent.old';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.old';\nimport { resolveLazyComponentTag, createFiberFromTypeAndProps, createFiberFromFragment, createFiberFromOffscreen, createWorkInProgress, createOffscreenHostContainerFiber, isSimpleFunctionComponent } from './ReactFiber.old';\nimport { retryDehydratedSuspenseBoundary, scheduleUpdateOnFiber, renderDidSuspendDelayIfPossible, markSkippedUpdateLanes, getWorkInProgressRoot, pushRenderLanes } from './ReactFiberWorkLoop.old';\nimport { setWorkInProgressVersion } from './ReactMutableSource.old';\nimport { pushCacheProvider, CacheContext } from './ReactFiberCacheComponent.old';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { createClassErrorUpdate } from './ReactFiberThrow.old';\nimport { completeSuspendedOffscreenHostContainer } from './ReactFiberCompleteWork.old';\nimport is from 'shared/objectIs';\nimport { getForksAtLevel, isForkedChild, pushTreeId, pushMaterializedTreeId } from './ReactFiberTreeContext.old';\nimport { requestCacheFromPool, pushRootTransition, getSuspendedCache, pushTransition, getOffscreenDeferredCache, getSuspendedTransitions } from './ReactFiberTransition.old';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nlet didReceiveUpdate = false;\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n} // 创建子fiber的过程会进入reconcileChildren，该函数的作用是为workInProgress fiber节点生成它的child fiber即 workInProgress.child。然后继续深度优先遍历它的子节点执行相同的操作。\n\n\nexport function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    // mount阶段\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    // update阶段\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (current === null) {\n    const type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      let resolvedType = type;\n\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n    }\n\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(type));\n      }\n    }\n\n    const child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentNameFromType(type));\n    }\n  }\n\n  const currentChild = current.child; // This is always exactly one child\n\n  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  const newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        const lazyComponent = outerMemoType;\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          outerMemoType = null;\n        } // Inner propTypes will be validated in the function component path.\n\n\n        const outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n        if (outerPropTypes) {\n          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop', getComponentNameFromType(outerMemoType));\n        }\n      }\n    }\n  }\n\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\n    __DEV__ ? workInProgress.type === current.type : true)) {\n      didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n      // would during a normal fiber bailout.\n      //\n      // We don't have strong guarantees that the props object is referentially\n      // equal during updates where we can't bail out anyway — like if the props\n      // are shallowly equal, but there's a local state or context update in the\n      // same batch.\n      //\n      // However, as a principle, we should aim to make the behavior consistent\n      // across different ways of memoizing a component. For example, React.memo\n      // has a different internal Fiber layout if you pass a normal function\n      // component (SimpleMemoComponent) versus if you pass a different type\n      // like forwardRef (MemoComponent). But this is an implementation detail.\n      // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n      // affect whether the props object is reused during a bailout.\n\n      workInProgress.pendingProps = nextProps = prevProps;\n\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n}\n\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  const prevState = current !== null ? current.memoizedState : null;\n\n  if (nextProps.mode === 'hidden' || enableLegacyHidden && nextProps.mode === 'unstable-defer-without-hiding') {\n    // Rendering a hidden tree.\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      // TODO: Consider how Offscreen should work with transitions in the future\n      const nextState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n        transitions: null\n      };\n      workInProgress.memoizedState = nextState;\n\n      if (enableCache) {\n        // push the cache pool even though we're going to bail out\n        // because otherwise there'd be a context mismatch\n        if (current !== null) {\n          pushTransition(workInProgress, null, null);\n        }\n      }\n\n      pushRenderLanes(workInProgress, renderLanes);\n    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n      let spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n\n      let nextBaseLanes;\n\n      if (prevState !== null) {\n        const prevBaseLanes = prevState.baseLanes;\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n\n        if (enableCache) {\n          // Save the cache pool so we can resume later.\n          spawnedCachePool = getOffscreenDeferredCache();\n        }\n      } else {\n        nextBaseLanes = renderLanes;\n      } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n      const nextState = {\n        baseLanes: nextBaseLanes,\n        cachePool: spawnedCachePool,\n        transitions: null\n      };\n      workInProgress.memoizedState = nextState;\n      workInProgress.updateQueue = null;\n\n      if (enableCache) {\n        // push the cache pool even though we're going to bail out\n        // because otherwise there'd be a context mismatch\n        if (current !== null) {\n          pushTransition(workInProgress, null, null);\n        }\n      } // We're about to bail out, but we need to push this to the stack anyway\n      // to avoid a push/pop misalignment.\n\n\n      pushRenderLanes(workInProgress, nextBaseLanes);\n\n      if (enableLazyContextPropagation && current !== null) {\n        // Since this tree will resume rendering in a separate render, we need\n        // to propagate parent contexts now so we don't lose track of which\n        // ones changed.\n        propagateParentContextChangesToDeferredTree(current, workInProgress, renderLanes);\n      }\n\n      return null;\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n      // Rendering at offscreen, so we can clear the base lanes.\n      const nextState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n        transitions: null\n      };\n      workInProgress.memoizedState = nextState; // Push the lanes that were skipped when we bailed out.\n\n      const subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n\n      if (enableCache && current !== null) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        const prevCachePool = prevState !== null ? prevState.cachePool : null; // TODO: Consider if and how Offscreen pre-rendering should\n        // be attributed to the transition that spawned it\n\n        pushTransition(workInProgress, prevCachePool, null);\n      }\n\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\n    }\n  } else {\n    // Rendering a visible tree.\n    let subtreeRenderLanes;\n\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n      subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n      let prevCachePool = null;\n\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        prevCachePool = prevState.cachePool;\n      }\n\n      pushTransition(workInProgress, prevCachePool, null); // Since we're not hidden anymore, reset the state\n\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n      subtreeRenderLanes = renderLanes;\n\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        if (current !== null) {\n          pushTransition(workInProgress, null, null);\n        }\n      }\n    }\n\n    pushRenderLanes(workInProgress, subtreeRenderLanes);\n  }\n\n  if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n    // In persistent mode, the offscreen children are wrapped in a host node.\n    // TODO: Optimize this to use the OffscreenComponent fiber instead of\n    // an extra HostComponent fiber. Need to make sure this doesn't break Fabric\n    // or some other infra that expects a HostComponent.\n    const isHidden = nextProps.mode === 'hidden' && (!enableLegacyHidden || workInProgress.tag !== LegacyHiddenComponent);\n    const offscreenContainer = reconcileOffscreenHostContainer(current, workInProgress, isHidden, nextChildren, renderLanes);\n    return offscreenContainer;\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n    return workInProgress.child;\n  }\n}\n\nfunction reconcileOffscreenHostContainer(currentOffscreen, offscreen, isHidden, children, renderLanes) {\n  const containerProps = getOffscreenContainerProps(isHidden ? 'hidden' : 'visible', children);\n  let hostContainer;\n\n  if (currentOffscreen === null) {\n    hostContainer = createOffscreenHostContainerFiber(containerProps, offscreen.mode, renderLanes, null);\n  } else {\n    const currentHostContainer = currentOffscreen.child;\n\n    if (currentHostContainer === null) {\n      hostContainer = createOffscreenHostContainerFiber(containerProps, offscreen.mode, renderLanes, null);\n      hostContainer.flags |= Placement;\n    } else {\n      hostContainer = createWorkInProgress(currentHostContainer, containerProps);\n    }\n  }\n\n  hostContainer.return = offscreen;\n  offscreen.child = hostContainer;\n  return hostContainer;\n} // Note: These happen to have identical begin phases, for now. We shouldn't hold\n// ourselves to this constraint, though. If the behavior diverges, we should\n// fork the function.\n\n\nconst updateLegacyHiddenComponent = updateOffscreenComponent;\n\nfunction updateCacheComponent(current, workInProgress, renderLanes) {\n  if (!enableCache) {\n    return null;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const parentCache = readContext(CacheContext);\n\n  if (current === null) {\n    // Initial mount. Request a fresh cache from the pool.\n    const freshCache = requestCacheFromPool(renderLanes);\n    const initialState = {\n      parent: parentCache,\n      cache: freshCache\n    };\n    workInProgress.memoizedState = initialState;\n    initializeUpdateQueue(workInProgress);\n    pushCacheProvider(workInProgress, freshCache);\n  } else {\n    // Check for updates\n    if (includesSomeLane(current.lanes, renderLanes)) {\n      cloneUpdateQueue(current, workInProgress);\n      processUpdateQueue(workInProgress, null, null, renderLanes);\n    }\n\n    const prevState = current.memoizedState;\n    const nextState = workInProgress.memoizedState; // Compare the new parent cache to the previous to see detect there was\n    // a refresh.\n\n    if (prevState.parent !== parentCache) {\n      // Refresh in parent. Update the parent.\n      const derivedState = {\n        parent: parentCache,\n        cache: parentCache\n      }; // Copied from getDerivedStateFromProps implementation. Once the update\n      // queue is empty, persist the derived state onto the base state.\n\n      workInProgress.memoizedState = derivedState;\n\n      if (workInProgress.lanes === NoLanes) {\n        const updateQueue = workInProgress.updateQueue;\n        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n      }\n\n      pushCacheProvider(workInProgress, parentCache); // No need to propagate a context change because the refreshed parent\n      // already did.\n    } else {\n      // The parent didn't refresh. Now check if this cache did.\n      const nextCache = nextState.cache;\n      pushCacheProvider(workInProgress, nextCache);\n\n      if (nextCache !== prevState.cache) {\n        // This cache refreshed. Propagate a context change.\n        propagateContextChange(workInProgress, CacheContext, renderLanes);\n      }\n    }\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n} // This should only be called if the name changes\n\n\nfunction updateTracingMarkerComponent(current, workInProgress, renderLanes) {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current, workInProgress, renderLanes) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderLanes) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderLanes) {\n  if (enableProfilerTimer) {\n    workInProgress.flags |= Update;\n\n    if (enableProfilerCommitHooks) {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      const stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  const ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n\n    if (enableSuspenseLayoutEffectSemantics) {\n      workInProgress.flags |= RefStatic;\n    }\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (__DEV__) {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false:\n        {\n          const instance = workInProgress.stateNode;\n          const ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n          // Is there a better way to do this?\n\n          const tempInstance = new ctor(workInProgress.memoizedProps, instance.context);\n          const state = tempInstance.state;\n          instance.updater.enqueueSetState(instance, state, null);\n          break;\n        }\n\n      case true:\n        {\n          workInProgress.flags |= DidCapture;\n          workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n\n          const error = new Error('Simulated error coming from DevTools');\n          const lane = pickArbitraryLane(renderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          const update = createClassErrorUpdate(workInProgress, createCapturedValue(error, workInProgress), lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          break;\n        }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n\n  if (instance === null) {\n    if (current !== null) {\n      // A class component without an instance only mounts if it suspended\n      // inside a non-concurrent tree, in an inconsistent state. We want to\n      // treat it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.flags |= Placement;\n    } // In the initial pass we might need to construct the instance.\n\n\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n  }\n\n  const nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n\n  if (__DEV__) {\n    const inst = workInProgress.stateNode;\n\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        console.error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n      }\n\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  const instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (enableSchedulingProfiler) {\n      markComponentRenderStarted(workInProgress);\n    }\n\n    if (__DEV__) {\n      setIsRendering(true);\n      nextChildren = instance.render();\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      setIsRendering(false);\n    } else {\n      nextChildren = instance.render();\n    }\n\n    if (enableSchedulingProfiler) {\n      markComponentRenderStopped();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  const nextState = workInProgress.memoizedState;\n  const root = workInProgress.stateNode;\n  pushRootTransition(workInProgress, root, renderLanes);\n\n  if (enableCache) {\n    const nextCache = nextState.cache;\n    pushCacheProvider(workInProgress, nextCache);\n\n    if (nextCache !== prevState.cache) {\n      // The root cache refreshed.\n      propagateContextChange(workInProgress, CacheContext, renderLanes);\n    }\n  } // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n\n  const nextChildren = nextState.element;\n\n  if (supportsHydration && prevState.isDehydrated) {\n    // This is a hydration root whose shell has not yet hydrated. We should\n    // attempt to hydrate.\n    // Flip isDehydrated to false to indicate that when this render\n    // finishes, the root will no longer be dehydrated.\n    const overrideState = {\n      element: nextChildren,\n      isDehydrated: false,\n      cache: nextState.cache,\n      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\n      transitions: nextState.transitions\n    };\n    const updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n    // have reducer functions so it doesn't need rebasing.\n\n    updateQueue.baseState = overrideState;\n    workInProgress.memoizedState = overrideState;\n\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during a previous attempt to hydrate the shell, so we\n      // forced a client render.\n      const recoverableError = new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.');\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n    } else if (nextChildren !== prevChildren) {\n      const recoverableError = new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.');\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n    } else {\n      // The outermost shell has not hydrated yet. Start hydrating.\n      enterHydrationState(workInProgress);\n\n      if (enableUseMutableSource) {\n        const mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;\n\n        if (mutableSourceEagerHydrationData != null) {\n          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\n            const mutableSource = mutableSourceEagerHydrationData[i];\n            const version = mutableSourceEagerHydrationData[i + 1];\n            setWorkInProgressVersion(mutableSource, version);\n          }\n        }\n      }\n\n      const child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n      workInProgress.child = child;\n      let node = child;\n\n      while (node) {\n        // Mark each child as hydrating. This is a fast path to know whether this\n        // tree is part of a hydrating tree. This is used to determine if a child\n        // node has fully mounted yet, and for scheduling event replaying.\n        // Conceptually this is similar to Placement in that a new subtree is\n        // inserted into the React tree here. It just happens to not need DOM\n        // mutations because it already exists.\n        node.flags = node.flags & ~Placement | Hydrating;\n        node = node.sibling;\n      }\n    }\n  } else {\n    // Root is not dehydrated. Either this is a client-only root, or it\n    // already hydrated.\n    resetHydrationState();\n\n    if (nextChildren === prevChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nfunction mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n  // Revert to client rendering.\n  resetHydrationState();\n  queueHydrationError(recoverableError);\n  workInProgress.flags |= ForceClientRender;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n  if (_current !== null) {\n    // A lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  const lazyComponent = elementType;\n  const payload = lazyComponent._payload;\n  const init = lazyComponent._init;\n  let Component = init(payload); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  const resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        if (__DEV__) {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ClassComponent:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ForwardRef:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case MemoComponent:\n      {\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(Component));\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes);\n        return child;\n      }\n  }\n\n  let hint = '';\n\n  if (__DEV__) {\n    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n\n\n  throw new Error(`Element type is invalid. Received a promise that resolves to: ${Component}. ` + `Lazy element type must resolve to a class or function.${hint}`);\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  } // Promote the fiber to a class and try rendering again.\n\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n}\n\nfunction mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  let value;\n  let hasId;\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (__DEV__) {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n  }\n\n  if ( // Run these checks in production only if the flag is off.\n  // Eventually we'll delete this branch altogether.\n  !disableModulePatternComponents && typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    } // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    let hasContext = false;\n\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    initializeUpdateQueue(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error('%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with React.useContext() instead.', getComponentNameFromType(Component) || 'Unknown');\n      }\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n          hasId = checkDidRenderIdHook();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n      }\n    }\n\n    if (workInProgress.ref !== null) {\n      let info = '';\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      let warningKey = ownerName || '';\n      const debugSource = workInProgress._debugSource;\n\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n        console.error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n      }\n    }\n\n    if (warnAboutDefaultPropsOnFunctionComponents && Component.defaultProps !== undefined) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error('%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support getDerivedStateFromProps.', componentName);\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support contextType.', componentName);\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nconst SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane\n};\n\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCache(),\n    transitions: null\n  };\n}\n\nfunction updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n  let cachePool = null;\n\n  if (enableCache) {\n    const prevCachePool = prevOffscreenState.cachePool;\n\n    if (prevCachePool !== null) {\n      const parentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n\n      if (prevCachePool.parent !== parentCache) {\n        // Detected a refresh in the parent. This overrides any previously\n        // suspended cache.\n        cachePool = {\n          parent: parentCache,\n          pool: parentCache\n        };\n      } else {\n        // We can reuse the cache from last time. The only thing that would have\n        // overridden it is a parent refresh, which we checked for above.\n        cachePool = prevCachePool;\n      }\n    } else {\n      // If there's no previous cache pool, grab the current one.\n      cachePool = getSuspendedCache();\n    }\n  }\n\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool,\n    transitions: prevOffscreenState.transitions\n  };\n} // TODO: Probably should inline this back\n\n\nfunction shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    const suspenseState = current.memoizedState;\n\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  } // Not currently showing content. Consult the Suspense context.\n\n\n  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n}\n\nfunction getRemainingWorkInPrimaryTree(current, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  let suspenseContext = suspenseStackCursor.current;\n  let showFallback = false;\n  const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (didSuspend || shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (current === null || current.memoizedState !== null) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n      if (!enableSuspenseAvoidThisFallback || nextProps.unstable_avoidThisFallback !== true) {\n        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n\n  if (current === null) {\n    // Initial mount\n    // If we're currently hydrating, try to hydrate this boundary.\n    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n    const suspenseState = workInProgress.memoizedState;\n\n    if (suspenseState !== null) {\n      const dehydrated = suspenseState.dehydrated;\n\n      if (dehydrated !== null) {\n        return mountDehydratedSuspenseComponent(workInProgress, dehydrated, renderLanes);\n      }\n    }\n\n    const nextPrimaryChildren = nextProps.children;\n    const nextFallbackChildren = nextProps.fallback;\n\n    if (showFallback) {\n      const fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n\n      if (enableTransitionTracing) {\n        const currentTransitions = getSuspendedTransitions();\n\n        if (currentTransitions !== null) {\n          const primaryChildUpdateQueue = {\n            transitions: currentTransitions\n          };\n          primaryChildFragment.updateQueue = primaryChildUpdateQueue;\n        }\n      }\n\n      return fallbackFragment;\n    } else if (enableCPUSuspense && typeof nextProps.unstable_expectedLoadTime === 'number') {\n      // This is a CPU-bound tree. Skip this tree and show a placeholder to\n      // unblock the surrounding content. Then immediately retry after the\n      // initial commit.\n      const fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to\n      // get it started back up to attempt the next item. While in terms of\n      // priority this work has the same priority as this current render, it's\n      // not part of the same transition once the transition has committed. If\n      // it's sync, we still want to yield so that it can be painted.\n      // Conceptually, this is really the same as pinging. We can use any\n      // RetryLane even if it's the one currently rendering since we're leaving\n      // it behind on this node.\n\n      workInProgress.lanes = SomeRetryLane;\n      return fallbackFragment;\n    } else {\n      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);\n    }\n  } else {\n    // This is an update.\n    // If the current fiber has a SuspenseState, that means it's already showing\n    // a fallback.\n    const prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      // The current tree is already showing a fallback\n      // Special path for hydration\n      const dehydrated = prevState.dehydrated;\n\n      if (dehydrated !== null) {\n        if (!didSuspend) {\n          return updateDehydratedSuspenseComponent(current, workInProgress, dehydrated, prevState, renderLanes);\n        } else if (workInProgress.flags & ForceClientRender) {\n          // Something errored during hydration. Try again without hydrating.\n          workInProgress.flags &= ~ForceClientRender;\n          return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));\n        } else if (workInProgress.memoizedState !== null) {\n          // Something suspended and we should still be in dehydrated mode.\n          // Leave the existing child in place.\n          workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n          // but the normal suspense pass doesn't.\n\n          workInProgress.flags |= DidCapture;\n          return null;\n        } else {\n          // Suspended but we should no longer be in dehydrated mode.\n          // Therefore we now have to render the fallback.\n          const nextPrimaryChildren = nextProps.children;\n          const nextFallbackChildren = nextProps.fallback;\n          const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n          const primaryChildFragment = workInProgress.child;\n          primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n          workInProgress.memoizedState = SUSPENDED_MARKER;\n          return fallbackChildFragment;\n        }\n      }\n\n      if (showFallback) {\n        const nextFallbackChildren = nextProps.fallback;\n        const nextPrimaryChildren = nextProps.children;\n        const fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n        const primaryChildFragment = workInProgress.child;\n        const prevOffscreenState = current.child.memoizedState;\n        primaryChildFragment.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n\n        if (enableTransitionTracing) {\n          const currentTransitions = getSuspendedTransitions();\n\n          if (currentTransitions !== null) {\n            const primaryChildUpdateQueue = {\n              transitions: currentTransitions\n            };\n            primaryChildFragment.updateQueue = primaryChildUpdateQueue;\n          }\n        }\n\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return fallbackChildFragment;\n      } else {\n        const nextPrimaryChildren = nextProps.children;\n        const primaryChildFragment = updateSuspensePrimaryChildren(current, workInProgress, nextPrimaryChildren, renderLanes);\n        workInProgress.memoizedState = null;\n        return primaryChildFragment;\n      }\n    } else {\n      // The current tree is not already showing a fallback.\n      if (showFallback) {\n        // Timed out.\n        const nextFallbackChildren = nextProps.fallback;\n        const nextPrimaryChildren = nextProps.children;\n        const fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n        const primaryChildFragment = workInProgress.child;\n        const prevOffscreenState = current.child.memoizedState;\n        primaryChildFragment.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n\n        if (enableTransitionTracing) {\n          const currentTransitions = getSuspendedTransitions();\n\n          if (currentTransitions !== null) {\n            const primaryChildUpdateQueue = {\n              transitions: currentTransitions\n            };\n            primaryChildFragment.updateQueue = primaryChildUpdateQueue;\n          }\n        } // Skip the primary children, and continue working on the\n        // fallback children.\n\n\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return fallbackChildFragment;\n      } else {\n        // Still haven't timed out. Continue rendering the children, like we\n        // normally do.\n        const nextPrimaryChildren = nextProps.children;\n        const primaryChildFragment = updateSuspensePrimaryChildren(current, workInProgress, nextPrimaryChildren, renderLanes);\n        workInProgress.memoizedState = null;\n        return primaryChildFragment;\n      }\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode, renderLanes);\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const progressedPrimaryFragment = workInProgress.child;\n  const primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  let primaryChildFragment;\n  let fallbackChildFragment;\n\n  if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode, NoLanes);\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n  const currentPrimaryChildFragment = current.child;\n  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  const primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n    mode: 'visible',\n    children: primaryChildren\n  });\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    const deletions = workInProgress.deletions;\n\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const currentPrimaryChildFragment = current.child;\n  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  const primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  let primaryChildFragment;\n\n  if ( // In legacy mode, we commit the primary tree as if it successfully\n  // completed, even though it's in an inconsistent state.\n  (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n  // already cloned. In legacy mode, the only case where this isn't true is\n  // when DevTools forces us to display a fallback; we skip the first render\n  // pass entirely and go straight to rendering the fallback. (In Concurrent\n  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n  // only codepath.)\n  workInProgress.child !== currentPrimaryChildFragment) {\n    const progressedPrimaryFragment = workInProgress.child;\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n    }\n\n    if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n      // In persistent mode, the offscreen children are wrapped in a host node.\n      // We need to complete it now, because we're going to skip over its normal\n      // complete phase and go straight to rendering the fallback.\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\n      const offscreenContainer = primaryChildFragment.child;\n      const containerProps = getOffscreenContainerProps('hidden', primaryChildren);\n      offscreenContainer.pendingProps = containerProps;\n      offscreenContainer.memoizedProps = containerProps;\n      completeSuspendedOffscreenHostContainer(currentOffscreenContainer, offscreenContainer);\n    } // The fallback fiber was added as a deletion during the first pass.\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n\n\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n\n    if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n      // In persistent mode, the offscreen children are wrapped in a host node.\n      // We need to complete it now, because we're going to skip over its normal\n      // complete phase and go straight to rendering the fallback.\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\n\n      if (currentOffscreenContainer !== null) {\n        const isHidden = true;\n        const offscreenContainer = reconcileOffscreenHostContainer(currentPrimaryChildFragment, primaryChildFragment, isHidden, primaryChildren, renderLanes);\n        offscreenContainer.memoizedProps = offscreenContainer.pendingProps;\n        completeSuspendedOffscreenHostContainer(currentOffscreenContainer, offscreenContainer);\n      }\n    } // Since we're reusing a current tree, we need to reuse the flags, too.\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n\n\n    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n\n  let fallbackChildFragment;\n\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n  } else {\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n  // Falling back to client rendering. Because this has performance\n  // implications, it's considered a recoverable error, even though the user\n  // likely won't observe anything wrong with the UI.\n  //\n  // The error is passed in as an argument to enforce that every caller provide\n  // a custom message, or explicitly opt out (currently the only path that opts\n  // out is legacy mode; every concurrent path provides an error).\n  if (recoverableError !== null) {\n    queueHydrationError(recoverableError);\n  } // This will add the old fiber to the deletion list\n\n\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n\n  const nextProps = workInProgress.pendingProps;\n  const primaryChildren = nextProps.children;\n  const primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes); // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const fiberMode = workInProgress.mode;\n  const primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode, NoLanes);\n  const fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n\n  fallbackChildFragment.flags |= Placement;\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (__DEV__) {\n      console.error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderLanes) {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // TODO: When we delete legacy mode, we should make this error argument\n    // required — every concurrent mode path that causes hydration to\n    // de-opt to client rendering should have an error message.\n    null);\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // TODO: The server should serialize the error message so we can log it\n    // here on the client. Or, in production, a hash/id that corresponds to\n    // the error.\n    new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.'));\n  }\n\n  if (enableLazyContextPropagation && // TODO: Factoring is a little weird, since we check this right below, too.\n  // But don't want to re-arrange the if-else chain until/unless this\n  // feature lands.\n  !didReceiveUpdate) {\n    // We need to check if any children have context before we decide to bail\n    // out, so propagate the changes now.\n    lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n  } // We use lanes to indicate that a child might depend on context, so if\n  // any context has changed, we need to treat is as if the input might have changed.\n\n\n  const hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n    const root = getWorkInProgressRoot();\n\n    if (root !== null) {\n      const attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n\n      if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n        // Intentionally mutating since this render will get interrupted. This\n        // is one of the very rare times where we mutate the current tree\n        // during the render phase.\n        suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n\n        const eventTime = NoTimestamp;\n        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\n      } else {// We have already tried to ping at a higher priority than we're rendering with\n        // so if we got here, we must have failed to hydrate at those levels. We must\n        // now give up. Instead, we're going to delete the whole subtree and instead inject\n        // a new real Suspense boundary to take its place, which may render content\n        // or fallback. This might suspend for a while and if it does we might still have\n        // an opportunity to hydrate before this pass commits.\n      }\n    } // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n\n\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error('This Suspense boundary received an update before it finished ' + 'hydrating. This caused the boundary to switch to client rendering. ' + 'The usual way to fix this is to wrap the original update ' + 'in startTransition.'));\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n    const retry = retryDehydratedSuspenseBoundary.bind(null, current);\n    registerSuspenseInstanceRetry(suspenseInstance, retry);\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n    const nextProps = workInProgress.pendingProps;\n    const primaryChildren = nextProps.children;\n    const primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes); // Mark the children as hydrating. This is a fast path to know whether this\n    // tree is part of a hydrating tree. This is used to determine if a child\n    // node has fully mounted yet, and for scheduling event replaying.\n    // Conceptually this is similar to Placement in that a new subtree is\n    // inserted into the React tree here. It just happens to not need DOM\n    // mutations because it already exists.\n\n    primaryChildFragment.flags |= Hydrating;\n    return primaryChildFragment;\n  }\n}\n\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow = null;\n\n  while (row !== null) {\n    const currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  if (__DEV__) {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          default:\n            console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n            break;\n        }\n      } else {\n        console.error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  if (__DEV__) {\n    const isAnArray = isArray(childSlot);\n    const isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isAnArray || isIterable) {\n      const type = isAnArray ? 'array' : 'iterable';\n      console.error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{% s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  if (__DEV__) {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        const iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n\n              i++;\n            }\n          }\n        } else {\n          console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n  const renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder = nextProps.revealOrder;\n  const tailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  let suspenseContext = suspenseStackCursor.current;\n  const shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.flags |= DidCapture;\n  } else {\n    const didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          const lastContentRow = findLastContentRow(workInProgress.child);\n          let tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          let tail = null;\n          let row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            const currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            const nextRow = row.sibling;\n            row.sibling = tail;\n            tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          tail, null, // last\n          tailMode);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderLanes) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(current, workInProgress, renderLanes) {\n  const providerType = workInProgress.type;\n  const context = providerType._context;\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n        console.error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n      }\n    }\n\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  if (enableLazyContextPropagation) {// In the lazy propagation implementation, we don't scan for matching\n    // consumers until something bails out, because until something bails out\n    // we're going to visit those nodes, anyway. The trade-off is that it shifts\n    // responsibility to the consumer to track whether something has changed.\n  } else {\n    if (oldProps !== null) {\n      const oldValue = oldProps.value;\n\n      if (is(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children && !hasLegacyContextChanged()) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderLanes) {\n  let context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  if (__DEV__) {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const newValue = readContext(context);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  let newChildren;\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  } else {\n    newChildren = render(newValue);\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\nexport function checkIfWorkInProgressReceivedUpdate() {\n  return didReceiveUpdate;\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes); // 判断优先级\n  // Check if the children have any pending work.\n\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    if (enableLazyContextPropagation && current !== null) {\n      // Before bailing out, check if there are any context changes in\n      // the children.\n      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n\n      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      }\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    const deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  } else {\n    throw new Error('Did not expect this call in production. ' + 'This is a bug in React. Please file an issue.');\n  }\n}\n\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  const updateLanes = current.lanes;\n\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  } // No pending update, but because context is propagated lazily, we need\n  // to check for a context change before we bail out.\n\n\n  if (enableLazyContextPropagation) {\n    const dependencies = current.dependencies;\n\n    if (dependencies !== null && checkIfContextChanged(dependencies)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      const root = workInProgress.stateNode;\n      pushRootTransition(workInProgress, root, renderLanes);\n\n      if (enableCache) {\n        const cache = current.memoizedState.cache;\n        pushCacheProvider(workInProgress, cache);\n      }\n\n      resetHydrationState();\n      break;\n\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          pushLegacyContextProvider(workInProgress);\n        }\n\n        break;\n      }\n\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n\n    case ContextProvider:\n      {\n        const newValue = workInProgress.memoizedProps.value;\n        const context = workInProgress.type._context;\n        pushProvider(workInProgress, context, newValue);\n        break;\n      }\n\n    case Profiler:\n      if (enableProfilerTimer) {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        const hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        if (enableProfilerCommitHooks) {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          const stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n\n      break;\n\n    case SuspenseComponent:\n      {\n        const state = workInProgress.memoizedState;\n\n        if (state !== null) {\n          if (state.dehydrated !== null) {\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n            // been unsuspended it has committed as a resolved Suspense component.\n            // If it needs to be retried, it should have work scheduled on it.\n\n            workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n            // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\n            return null;\n          } // If this boundary is currently timed out, we need to decide\n          // whether to retry the primary children, or to skip over it and\n          // go straight to the fallback. Check the priority of the primary\n          // child fragment.\n\n\n          const primaryChildFragment = workInProgress.child;\n          const primaryChildLanes = primaryChildFragment.childLanes;\n\n          if (includesSomeLane(renderLanes, primaryChildLanes)) {\n            // The primary children have pending work. Use the normal path\n            // to attempt to render the primary children again.\n            return updateSuspenseComponent(current, workInProgress, renderLanes);\n          } else {\n            // The primary child fragment does not have pending work marked\n            // on it\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n            // priority. Bailout.\n\n            const child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\n            if (child !== null) {\n              // The fallback children have pending work. Skip over the\n              // primary children and work on the fallback.\n              return child.sibling;\n            } else {\n              // Note: We can return `null` here because we already checked\n              // whether there were nested context consumers, via the call to\n              // `bailoutOnAlreadyFinishedWork` above.\n              return null;\n            }\n          }\n        } else {\n          pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n        }\n\n        break;\n      }\n\n    case SuspenseListComponent:\n      {\n        const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n        let hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (enableLazyContextPropagation && !hasChildWork) {\n          // Context changes may not have been propagated yet. We need to do\n          // that now, before we can decide whether to bail out.\n          // TODO: We use `childLanes` as a heuristic for whether there is\n          // remaining work in a few places, including\n          // `bailoutOnAlreadyFinishedWork` and\n          // `updateDehydratedSuspenseComponent`. We should maybe extract this\n          // into a dedicated function.\n          lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n          hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n        }\n\n        if (didSuspendBefore) {\n          if (hasChildWork) {\n            // If something was in fallback state last time, and we have all the\n            // same children then we're still in progressive loading state.\n            // Something might get unblocked by state updates or retries in the\n            // tree which will affect the tail. So we need to use the normal\n            // path to compute the correct tail.\n            return updateSuspenseListComponent(current, workInProgress, renderLanes);\n          } // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n\n\n          workInProgress.flags |= DidCapture;\n        } // If nothing suspended before and we're rendering the same children,\n        // then the tail doesn't matter. Anything new that suspends will work\n        // in the \"together\" mode, so we can continue from the state we had.\n\n\n        const renderState = workInProgress.memoizedState;\n\n        if (renderState !== null) {\n          // Reset to the \"together\" mode in case we've started a different\n          // update in the past but didn't complete it.\n          renderState.rendering = null;\n          renderState.tail = null;\n          renderState.lastEffect = null;\n        }\n\n        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n        if (hasChildWork) {\n          break;\n        } else {\n          // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n          return null;\n        }\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        // Need to check if the tree still needs to be deferred. This is\n        // almost identical to the logic used in the normal update path,\n        // so we'll just enter that. The only difference is we'll bail out\n        // at the next level instead of this one, because the child props\n        // have not changed. Which is fine.\n        // TODO: Probably should refactor `beginWork` to split the bailout\n        // path from the normal path. I'm tempted to do a labeled break here\n        // but I won't :)\n        workInProgress.lanes = NoLanes;\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          const cache = current.memoizedState.cache;\n          pushCacheProvider(workInProgress, cache);\n        }\n\n        break;\n      }\n  }\n\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(current, workInProgress, renderLanes) {\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n    }\n  } // 1.update时满足条件即可复用current fiber进入bailoutOnAlreadyFinishedWork函数\n  // 首次渲染时current为null， update时current不为null\n  // update时\n\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasLegacyContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n    __DEV__ ? workInProgress.type !== current.type : false)) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n      // may not be work scheduled on `current`, so we check for this flag.\n      (workInProgress.flags & DidCapture) === NoFlags) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n      }\n\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      const slotIndex = workInProgress.index;\n      const numberOfForks = getForksAtLevel(workInProgress);\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  } // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n\n\n  workInProgress.lanes = NoLanes; //2.根据tag来创建不同的fiber 最后进入reconcileChildren函数\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n      }\n\n    case LazyComponent:\n      {\n        const elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n      }\n\n    case FunctionComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateClassComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n\n    case HostText:\n      return updateHostText(current, workInProgress);\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n\n    case ForwardRef:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps);\n        return updateForwardRef(current, workInProgress, type, resolvedProps, renderLanes);\n      }\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n\n    case MemoComponent:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = type.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(type));\n            }\n          }\n        }\n\n        resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n        return updateMemoComponent(current, workInProgress, type, resolvedProps, renderLanes);\n      }\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n      }\n\n    case IncompleteClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return mountIncompleteClassComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          return updateScopeComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n\n    case LegacyHiddenComponent:\n      {\n        if (enableLegacyHidden) {\n          return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          return updateCacheComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          return updateTracingMarkerComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n  }\n\n  throw new Error(`Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` + 'React. Please file an issue.');\n}\n\nexport { beginWork };","map":{"version":3,"names":["enableSuspenseAvoidThisFallback","enableCPUSuspense","enableUseMutableSource","checkPropTypes","markComponentRenderStarted","markComponentRenderStopped","setIsStrictModeForDevtools","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","ForwardRef","Fragment","Mode","ContextProvider","ContextConsumer","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","TracingMarkerComponent","NoFlags","PerformedWork","Placement","Hydrating","ContentReset","DidCapture","Update","Ref","RefStatic","ChildDeletion","ForceUpdateForLegacySuspense","StaticMask","ShouldCapture","ForceClientRender","ReactSharedInternals","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","disableModulePatternComponents","enableProfilerCommitHooks","enableProfilerTimer","warnAboutDefaultPropsOnFunctionComponents","enableScopeAPI","enableCache","enableLazyContextPropagation","enableSuspenseLayoutEffectSemantics","enableSchedulingProfiler","enablePersistentOffscreenHostContainer","enableTransitionTracing","enableLegacyHidden","isArray","shallowEqual","getComponentNameFromFiber","getComponentNameFromType","ReactStrictModeWarnings","REACT_LAZY_TYPE","getIteratorFn","getCurrentFiberOwnerNameInDevOrNull","setIsRendering","resolveFunctionForHotReloading","resolveForwardRefForHotReloading","resolveClassForHotReloading","mountChildFibers","reconcileChildFibers","cloneChildFibers","processUpdateQueue","cloneUpdateQueue","initializeUpdateQueue","enqueueCapturedUpdate","NoLane","NoLanes","SyncLane","OffscreenLane","DefaultHydrationLane","SomeRetryLane","NoTimestamp","includesSomeLane","laneToLanes","removeLanes","mergeLanes","getBumpedLaneForHydration","pickArbitraryLane","ConcurrentMode","NoMode","ProfileMode","StrictLegacyMode","shouldSetTextContent","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","supportsHydration","isPrimaryRenderer","supportsPersistence","getOffscreenContainerProps","shouldError","shouldSuspend","pushHostContext","pushHostContainer","suspenseStackCursor","pushSuspenseContext","InvisibleParentSuspenseContext","ForceSuspenseFallback","hasSuspenseContext","setDefaultShallowSuspenseContext","addSubtreeSuspenseContext","setShallowSuspenseContext","findFirstSuspended","pushProvider","propagateContextChange","lazilyPropagateParentContextChanges","propagateParentContextChangesToDeferredTree","checkIfContextChanged","readContext","prepareToReadContext","scheduleContextWorkOnParentPath","renderWithHooks","checkDidRenderIdHook","bailoutHooks","stopProfilerTimerIfRunning","getMaskedContext","getUnmaskedContext","hasContextChanged","hasLegacyContextChanged","pushContextProvider","pushLegacyContextProvider","isContextProvider","isLegacyContextProvider","pushTopLevelContextObject","invalidateContextProvider","getIsHydrating","enterHydrationState","reenterHydrationStateFromDehydratedSuspenseInstance","resetHydrationState","tryToClaimNextHydratableInstance","warnIfHydrating","queueHydrationError","adoptClassInstance","constructClassInstance","mountClassInstance","resumeMountClassInstance","updateClassInstance","resolveDefaultProps","resolveLazyComponentTag","createFiberFromTypeAndProps","createFiberFromFragment","createFiberFromOffscreen","createWorkInProgress","createOffscreenHostContainerFiber","isSimpleFunctionComponent","retryDehydratedSuspenseBoundary","scheduleUpdateOnFiber","renderDidSuspendDelayIfPossible","markSkippedUpdateLanes","getWorkInProgressRoot","pushRenderLanes","setWorkInProgressVersion","pushCacheProvider","CacheContext","createCapturedValue","createClassErrorUpdate","completeSuspendedOffscreenHostContainer","is","getForksAtLevel","isForkedChild","pushTreeId","pushMaterializedTreeId","requestCacheFromPool","pushRootTransition","getSuspendedCache","pushTransition","getOffscreenDeferredCache","getSuspendedTransitions","ReactCurrentOwner","didReceiveUpdate","didWarnAboutBadClass","didWarnAboutModulePatternComponent","didWarnAboutContextTypeOnFunctionComponent","didWarnAboutGetDerivedStateOnFunctionComponent","didWarnAboutFunctionRefs","didWarnAboutReassigningProps","didWarnAboutRevealOrder","didWarnAboutTailOptions","didWarnAboutDefaultPropsOnFunctionComponent","__DEV__","reconcileChildren","current","workInProgress","nextChildren","renderLanes","child","forceUnmountCurrentAndReconcile","updateForwardRef","Component","nextProps","type","elementType","innerPropTypes","propTypes","render","ref","hasId","mode","bailoutOnAlreadyFinishedWork","flags","updateMemoComponent","compare","defaultProps","undefined","resolvedType","tag","validateFunctionComponentInDev","updateSimpleMemoComponent","return","currentChild","hasScheduledUpdateOrContext","checkScheduledUpdateOrContext","prevProps","memoizedProps","newChild","outerMemoType","$$typeof","lazyComponent","payload","_payload","init","_init","x","outerPropTypes","pendingProps","lanes","updateFunctionComponent","updateOffscreenComponent","children","prevState","memoizedState","nextState","baseLanes","cachePool","transitions","spawnedCachePool","nextBaseLanes","prevBaseLanes","childLanes","updateQueue","subtreeRenderLanes","prevCachePool","isHidden","offscreenContainer","reconcileOffscreenHostContainer","currentOffscreen","offscreen","containerProps","hostContainer","currentHostContainer","updateLegacyHiddenComponent","updateCacheComponent","parentCache","freshCache","initialState","parent","cache","derivedState","baseState","nextCache","updateTracingMarkerComponent","updateFragment","updateMode","updateProfiler","stateNode","effectDuration","passiveEffectDuration","markRef","context","unmaskedContext","updateClassComponent","instance","ctor","tempInstance","state","updater","enqueueSetState","error","Error","lane","update","hasContext","shouldUpdate","alternate","nextUnitOfWork","finishClassComponent","inst","props","console","didCaptureError","getDerivedStateFromError","pushHostRootContext","root","pendingContext","containerInfo","updateHostRoot","prevChildren","element","isDehydrated","overrideState","pendingSuspenseBoundaries","recoverableError","mountHostRootWithoutHydrating","mutableSourceEagerHydrationData","i","length","mutableSource","version","node","sibling","updateHostComponent","isDirectTextChild","updateHostText","mountLazyComponent","_current","resolvedTag","resolvedProps","hint","mountIncompleteClassComponent","mountIndeterminateComponent","value","prototype","componentName","recordLegacyContextWarning","contextTypes","childContextTypes","displayName","name","info","ownerName","warningKey","debugSource","_debugSource","fileName","lineNumber","getDerivedStateFromProps","contextType","SUSPENDED_MARKER","dehydrated","treeContext","retryLane","mountSuspenseOffscreenState","updateSuspenseOffscreenState","prevOffscreenState","_currentValue","_currentValue2","pool","shouldRemainOnFallback","suspenseContext","suspenseState","getRemainingWorkInPrimaryTree","updateSuspenseComponent","showFallback","didSuspend","unstable_avoidThisFallback","mountDehydratedSuspenseComponent","nextPrimaryChildren","nextFallbackChildren","fallback","fallbackFragment","mountSuspenseFallbackChildren","primaryChildFragment","currentTransitions","primaryChildUpdateQueue","unstable_expectedLoadTime","mountSuspensePrimaryChildren","updateDehydratedSuspenseComponent","retrySuspenseComponentWithoutHydrating","fallbackChildFragment","mountSuspenseFallbackAfterRetryWithoutHydrating","updateSuspenseFallbackChildren","updateSuspensePrimaryChildren","primaryChildren","primaryChildProps","mountWorkInProgressOffscreenFiber","fallbackChildren","progressedPrimaryFragment","actualDuration","actualStartTime","selfBaseDuration","treeBaseDuration","offscreenProps","updateWorkInProgressOffscreenFiber","currentPrimaryChildFragment","currentFallbackChildFragment","deletions","push","currentOffscreenContainer","subtreeFlags","fiberMode","suspenseInstance","attemptHydrationAtLane","eventTime","retry","bind","scheduleSuspenseWorkOnFiber","fiber","propagationRoot","propagateSuspenseContextChange","firstChild","findLastContentRow","row","lastContentRow","currentRow","validateRevealOrder","revealOrder","toLowerCase","validateTailOptions","tailMode","validateSuspenseListNestedChild","childSlot","index","isAnArray","isIterable","validateSuspenseListChildren","iteratorFn","childrenIterator","call","step","next","done","initSuspenseListRenderState","isBackwards","tail","renderState","rendering","renderingStartTime","last","updateSuspenseListComponent","newChildren","shouldForceFallback","didSuspendBefore","nextRow","updatePortalComponent","hasWarnedAboutUsingNoValuePropOnContextProvider","updateContextProvider","providerType","_context","newProps","oldProps","newValue","providerPropTypes","oldValue","hasWarnedAboutUsingContextAsConsumer","updateContextConsumer","Consumer","updateScopeComponent","markWorkInProgressReceivedUpdate","checkIfWorkInProgressReceivedUpdate","dependencies","remountFiber","oldWorkInProgress","newWorkInProgress","returnFiber","prevSibling","updateLanes","attemptEarlyBailoutIfNoScheduledUpdate","hasChildWork","primaryChildLanes","lastEffect","beginWork","_debugNeedsRemount","key","_debugOwner","slotIndex","numberOfForks","unresolvedProps"],"sources":["D:/project/font-end/debug-anything/react-test/src/react/packages/react-reconciler/src/ReactFiberBeginWork.old.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {\r\n  ReactProviderType,\r\n  ReactContext,\r\n  ReactNodeList,\r\n} from 'shared/ReactTypes';\r\nimport type { LazyComponent as LazyComponentType } from 'react/src/ReactLazy';\r\nimport type { Fiber, FiberRoot } from './ReactInternalTypes';\r\nimport type { TypeOfMode } from './ReactTypeOfMode';\r\nimport type { Lanes, Lane } from './ReactFiberLane.old';\r\nimport type { MutableSource } from 'shared/ReactTypes';\r\nimport type {\r\n  SuspenseState,\r\n  SuspenseListRenderState,\r\n  SuspenseListTailMode,\r\n} from './ReactFiberSuspenseComponent.old';\r\nimport type { SuspenseContext } from './ReactFiberSuspenseContext.old';\r\nimport type {\r\n  OffscreenProps,\r\n  OffscreenState,\r\n  OffscreenQueue,\r\n} from './ReactFiberOffscreenComponent';\r\nimport type {\r\n  Cache,\r\n  CacheComponentState,\r\n  SpawnedCachePool,\r\n} from './ReactFiberCacheComponent.old';\r\nimport type { UpdateQueue } from './ReactUpdateQueue.old';\r\nimport type { RootState } from './ReactFiberRoot.old';\r\nimport {\r\n  enableSuspenseAvoidThisFallback,\r\n  enableCPUSuspense,\r\n  enableUseMutableSource,\r\n} from 'shared/ReactFeatureFlags';\r\n\r\nimport checkPropTypes from 'shared/checkPropTypes';\r\nimport {\r\n  markComponentRenderStarted,\r\n  markComponentRenderStopped,\r\n  setIsStrictModeForDevtools,\r\n} from './ReactFiberDevToolsHook.old';\r\nimport {\r\n  IndeterminateComponent,\r\n  FunctionComponent,\r\n  ClassComponent,\r\n  HostRoot,\r\n  HostComponent,\r\n  HostText,\r\n  HostPortal,\r\n  ForwardRef,\r\n  Fragment,\r\n  Mode,\r\n  ContextProvider,\r\n  ContextConsumer,\r\n  Profiler,\r\n  SuspenseComponent,\r\n  SuspenseListComponent,\r\n  MemoComponent,\r\n  SimpleMemoComponent,\r\n  LazyComponent,\r\n  IncompleteClassComponent,\r\n  ScopeComponent,\r\n  OffscreenComponent,\r\n  LegacyHiddenComponent,\r\n  CacheComponent,\r\n  TracingMarkerComponent,\r\n} from './ReactWorkTags';\r\nimport {\r\n  NoFlags,\r\n  PerformedWork,\r\n  Placement,\r\n  Hydrating,\r\n  ContentReset,\r\n  DidCapture,\r\n  Update,\r\n  Ref,\r\n  RefStatic,\r\n  ChildDeletion,\r\n  ForceUpdateForLegacySuspense,\r\n  StaticMask,\r\n  ShouldCapture,\r\n  ForceClientRender,\r\n} from './ReactFiberFlags';\r\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\r\nimport {\r\n  debugRenderPhaseSideEffectsForStrictMode,\r\n  disableLegacyContext,\r\n  disableModulePatternComponents,\r\n  enableProfilerCommitHooks,\r\n  enableProfilerTimer,\r\n  warnAboutDefaultPropsOnFunctionComponents,\r\n  enableScopeAPI,\r\n  enableCache,\r\n  enableLazyContextPropagation,\r\n  enableSuspenseLayoutEffectSemantics,\r\n  enableSchedulingProfiler,\r\n  enablePersistentOffscreenHostContainer,\r\n  enableTransitionTracing,\r\n  enableLegacyHidden,\r\n} from 'shared/ReactFeatureFlags';\r\nimport isArray from 'shared/isArray';\r\nimport shallowEqual from 'shared/shallowEqual';\r\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\r\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\r\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\r\nimport { REACT_LAZY_TYPE, getIteratorFn } from 'shared/ReactSymbols';\r\nimport {\r\n  getCurrentFiberOwnerNameInDevOrNull,\r\n  setIsRendering,\r\n} from './ReactCurrentFiber';\r\nimport {\r\n  resolveFunctionForHotReloading,\r\n  resolveForwardRefForHotReloading,\r\n  resolveClassForHotReloading,\r\n} from './ReactFiberHotReloading.old';\r\n\r\nimport {\r\n  mountChildFibers,\r\n  reconcileChildFibers,\r\n  cloneChildFibers,\r\n} from './ReactChildFiber.old';\r\nimport {\r\n  processUpdateQueue,\r\n  cloneUpdateQueue,\r\n  initializeUpdateQueue,\r\n  enqueueCapturedUpdate,\r\n} from './ReactUpdateQueue.old';\r\nimport {\r\n  NoLane,\r\n  NoLanes,\r\n  SyncLane,\r\n  OffscreenLane,\r\n  DefaultHydrationLane,\r\n  SomeRetryLane,\r\n  NoTimestamp,\r\n  includesSomeLane,\r\n  laneToLanes,\r\n  removeLanes,\r\n  mergeLanes,\r\n  getBumpedLaneForHydration,\r\n  pickArbitraryLane,\r\n} from './ReactFiberLane.old';\r\nimport {\r\n  ConcurrentMode,\r\n  NoMode,\r\n  ProfileMode,\r\n  StrictLegacyMode,\r\n} from './ReactTypeOfMode';\r\nimport {\r\n  shouldSetTextContent,\r\n  isSuspenseInstancePending,\r\n  isSuspenseInstanceFallback,\r\n  registerSuspenseInstanceRetry,\r\n  supportsHydration,\r\n  isPrimaryRenderer,\r\n  supportsPersistence,\r\n  getOffscreenContainerProps,\r\n} from './ReactFiberHostConfig';\r\nimport type { SuspenseInstance } from './ReactFiberHostConfig';\r\nimport { shouldError, shouldSuspend } from './ReactFiberReconciler';\r\nimport { pushHostContext, pushHostContainer } from './ReactFiberHostContext.old';\r\nimport {\r\n  suspenseStackCursor,\r\n  pushSuspenseContext,\r\n  InvisibleParentSuspenseContext,\r\n  ForceSuspenseFallback,\r\n  hasSuspenseContext,\r\n  setDefaultShallowSuspenseContext,\r\n  addSubtreeSuspenseContext,\r\n  setShallowSuspenseContext,\r\n} from './ReactFiberSuspenseContext.old';\r\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent.old';\r\nimport {\r\n  pushProvider,\r\n  propagateContextChange,\r\n  lazilyPropagateParentContextChanges,\r\n  propagateParentContextChangesToDeferredTree,\r\n  checkIfContextChanged,\r\n  readContext,\r\n  prepareToReadContext,\r\n  scheduleContextWorkOnParentPath,\r\n} from './ReactFiberNewContext.old';\r\nimport {\r\n  renderWithHooks,\r\n  checkDidRenderIdHook,\r\n  bailoutHooks,\r\n} from './ReactFiberHooks.old';\r\nimport { stopProfilerTimerIfRunning } from './ReactProfilerTimer.old';\r\nimport {\r\n  getMaskedContext,\r\n  getUnmaskedContext,\r\n  hasContextChanged as hasLegacyContextChanged,\r\n  pushContextProvider as pushLegacyContextProvider,\r\n  isContextProvider as isLegacyContextProvider,\r\n  pushTopLevelContextObject,\r\n  invalidateContextProvider,\r\n} from './ReactFiberContext.old';\r\nimport {\r\n  getIsHydrating,\r\n  enterHydrationState,\r\n  reenterHydrationStateFromDehydratedSuspenseInstance,\r\n  resetHydrationState,\r\n  tryToClaimNextHydratableInstance,\r\n  warnIfHydrating,\r\n  queueHydrationError,\r\n} from './ReactFiberHydrationContext.old';\r\nimport {\r\n  adoptClassInstance,\r\n  constructClassInstance,\r\n  mountClassInstance,\r\n  resumeMountClassInstance,\r\n  updateClassInstance,\r\n} from './ReactFiberClassComponent.old';\r\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.old';\r\nimport {\r\n  resolveLazyComponentTag,\r\n  createFiberFromTypeAndProps,\r\n  createFiberFromFragment,\r\n  createFiberFromOffscreen,\r\n  createWorkInProgress,\r\n  createOffscreenHostContainerFiber,\r\n  isSimpleFunctionComponent,\r\n} from './ReactFiber.old';\r\nimport {\r\n  retryDehydratedSuspenseBoundary,\r\n  scheduleUpdateOnFiber,\r\n  renderDidSuspendDelayIfPossible,\r\n  markSkippedUpdateLanes,\r\n  getWorkInProgressRoot,\r\n  pushRenderLanes,\r\n} from './ReactFiberWorkLoop.old';\r\nimport { setWorkInProgressVersion } from './ReactMutableSource.old';\r\nimport { pushCacheProvider, CacheContext } from './ReactFiberCacheComponent.old';\r\nimport { createCapturedValue } from './ReactCapturedValue';\r\nimport { createClassErrorUpdate } from './ReactFiberThrow.old';\r\nimport { completeSuspendedOffscreenHostContainer } from './ReactFiberCompleteWork.old';\r\nimport is from 'shared/objectIs';\r\nimport {\r\n  getForksAtLevel,\r\n  isForkedChild,\r\n  pushTreeId,\r\n  pushMaterializedTreeId,\r\n} from './ReactFiberTreeContext.old';\r\nimport {\r\n  requestCacheFromPool,\r\n  pushRootTransition,\r\n  getSuspendedCache,\r\n  pushTransition,\r\n  getOffscreenDeferredCache,\r\n  getSuspendedTransitions,\r\n} from './ReactFiberTransition.old';\r\n\r\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\n\r\nlet didReceiveUpdate: boolean = false;\r\n\r\nlet didWarnAboutBadClass;\r\nlet didWarnAboutModulePatternComponent;\r\nlet didWarnAboutContextTypeOnFunctionComponent;\r\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\r\nlet didWarnAboutFunctionRefs;\r\nexport let didWarnAboutReassigningProps;\r\nlet didWarnAboutRevealOrder;\r\nlet didWarnAboutTailOptions;\r\nlet didWarnAboutDefaultPropsOnFunctionComponent;\r\n\r\nif (__DEV__) {\r\n  didWarnAboutBadClass = {};\r\n  didWarnAboutModulePatternComponent = {};\r\n  didWarnAboutContextTypeOnFunctionComponent = {};\r\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\r\n  didWarnAboutFunctionRefs = {};\r\n  didWarnAboutReassigningProps = false;\r\n  didWarnAboutRevealOrder = {};\r\n  didWarnAboutTailOptions = {};\r\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\r\n}\r\n\r\n// 创建子fiber的过程会进入reconcileChildren，该函数的作用是为workInProgress fiber节点生成它的child fiber即 workInProgress.child。然后继续深度优先遍历它的子节点执行相同的操作。\r\nexport function reconcileChildren (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  nextChildren: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (current === null) {\r\n    // If this is a fresh new component that hasn't been rendered yet, we\r\n    // won't update its child set by applying minimal side-effects. Instead,\r\n    // we will add them all to the child before it gets rendered. That means\r\n    // we can optimize this reconciliation pass by not tracking side-effects.\r\n    // mount阶段\r\n    workInProgress.child = mountChildFibers(\r\n      workInProgress,\r\n      null,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    // If the current child is the same as the work in progress, it means that\r\n    // we haven't yet started any work on these children. Therefore, we use\r\n    // the clone algorithm to create a copy of all the current children.\r\n\r\n    // If we had any progressed work already, that is invalid at this point so\r\n    // let's throw it out.\r\n    // update阶段\r\n    workInProgress.child = reconcileChildFibers(\r\n      workInProgress,\r\n      current.child,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n  }\r\n}\r\n\r\nfunction forceUnmountCurrentAndReconcile (\r\n  current: Fiber,\r\n  workInProgress: Fiber,\r\n  nextChildren: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  // This function is fork of reconcileChildren. It's used in cases where we\r\n  // want to reconcile without matching against the existing set. This has the\r\n  // effect of all current children being unmounted; even if the type and key\r\n  // are the same, the old child is unmounted and a new child is created.\r\n  //\r\n  // To do this, we're going to go through the reconcile algorithm twice. In\r\n  // the first pass, we schedule a deletion for all the current children by\r\n  // passing null.\r\n  workInProgress.child = reconcileChildFibers(\r\n    workInProgress,\r\n    current.child,\r\n    null,\r\n    renderLanes,\r\n  );\r\n  // In the second pass, we mount the new children. The trick here is that we\r\n  // pass null in place of where we usually pass the current child set. This has\r\n  // the effect of remounting all children regardless of whether their\r\n  // identities match.\r\n  workInProgress.child = reconcileChildFibers(\r\n    workInProgress,\r\n    null,\r\n    nextChildren,\r\n    renderLanes,\r\n  );\r\n}\r\n\r\nfunction updateForwardRef (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  // TODO: current can be non-null here even if the component\r\n  // hasn't yet mounted. This happens after the first render suspends.\r\n  // We'll need to figure out if this is fine or can cause issues.\r\n\r\n  if (__DEV__) {\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      const innerPropTypes = Component.propTypes;\r\n      if (innerPropTypes) {\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentNameFromType(Component),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  const render = Component.render;\r\n  const ref = workInProgress.ref;\r\n\r\n  // The rest is a fork of updateFunctionComponent\r\n  let nextChildren;\r\n  let hasId;\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  if (enableSchedulingProfiler) {\r\n    markComponentRenderStarted(workInProgress);\r\n  }\r\n  if (__DEV__) {\r\n    ReactCurrentOwner.current = workInProgress;\r\n    setIsRendering(true);\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      render,\r\n      nextProps,\r\n      ref,\r\n      renderLanes,\r\n    );\r\n    hasId = checkDidRenderIdHook();\r\n    if (\r\n      debugRenderPhaseSideEffectsForStrictMode &&\r\n      workInProgress.mode & StrictLegacyMode\r\n    ) {\r\n      setIsStrictModeForDevtools(true);\r\n      try {\r\n        nextChildren = renderWithHooks(\r\n          current,\r\n          workInProgress,\r\n          render,\r\n          nextProps,\r\n          ref,\r\n          renderLanes,\r\n        );\r\n        hasId = checkDidRenderIdHook();\r\n      } finally {\r\n        setIsStrictModeForDevtools(false);\r\n      }\r\n    }\r\n    setIsRendering(false);\r\n  } else {\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      render,\r\n      nextProps,\r\n      ref,\r\n      renderLanes,\r\n    );\r\n    hasId = checkDidRenderIdHook();\r\n  }\r\n  if (enableSchedulingProfiler) {\r\n    markComponentRenderStopped();\r\n  }\r\n\r\n  if (current !== null && !didReceiveUpdate) {\r\n    bailoutHooks(current, workInProgress, renderLanes);\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n\r\n  if (getIsHydrating() && hasId) {\r\n    pushMaterializedTreeId(workInProgress);\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateMemoComponent (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  renderLanes: Lanes,\r\n): null | Fiber {\r\n  if (current === null) {\r\n    const type = Component.type;\r\n    if (\r\n      isSimpleFunctionComponent(type) &&\r\n      Component.compare === null &&\r\n      // SimpleMemoComponent codepath doesn't resolve outer props either.\r\n      Component.defaultProps === undefined\r\n    ) {\r\n      let resolvedType = type;\r\n      if (__DEV__) {\r\n        resolvedType = resolveFunctionForHotReloading(type);\r\n      }\r\n      // If this is a plain function component without default props,\r\n      // and with only the default shallow comparison, we upgrade it\r\n      // to a SimpleMemoComponent to allow fast path updates.\r\n      workInProgress.tag = SimpleMemoComponent;\r\n      workInProgress.type = resolvedType;\r\n      if (__DEV__) {\r\n        validateFunctionComponentInDev(workInProgress, type);\r\n      }\r\n      return updateSimpleMemoComponent(\r\n        current,\r\n        workInProgress,\r\n        resolvedType,\r\n        nextProps,\r\n        renderLanes,\r\n      );\r\n    }\r\n    if (__DEV__) {\r\n      const innerPropTypes = type.propTypes;\r\n      if (innerPropTypes) {\r\n        // Inner memo component props aren't currently validated in createElement.\r\n        // We could move it there, but we'd still need this for lazy code path.\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentNameFromType(type),\r\n        );\r\n      }\r\n    }\r\n    const child = createFiberFromTypeAndProps(\r\n      Component.type,\r\n      null,\r\n      nextProps,\r\n      workInProgress,\r\n      workInProgress.mode,\r\n      renderLanes,\r\n    );\r\n    child.ref = workInProgress.ref;\r\n    child.return = workInProgress;\r\n    workInProgress.child = child;\r\n    return child;\r\n  }\r\n  if (__DEV__) {\r\n    const type = Component.type;\r\n    const innerPropTypes = type.propTypes;\r\n    if (innerPropTypes) {\r\n      // Inner memo component props aren't currently validated in createElement.\r\n      // We could move it there, but we'd still need this for lazy code path.\r\n      checkPropTypes(\r\n        innerPropTypes,\r\n        nextProps, // Resolved props\r\n        'prop',\r\n        getComponentNameFromType(type),\r\n      );\r\n    }\r\n  }\r\n  const currentChild = ((current.child: any): Fiber); // This is always exactly one child\r\n  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\r\n    current,\r\n    renderLanes,\r\n  );\r\n  if (!hasScheduledUpdateOrContext) {\r\n    // This will be the props with resolved defaultProps,\r\n    // unlike current.memoizedProps which will be the unresolved ones.\r\n    const prevProps = currentChild.memoizedProps;\r\n    // Default to shallow comparison\r\n    let compare = Component.compare;\r\n    compare = compare !== null ? compare : shallowEqual;\r\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\r\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n    }\r\n  }\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  const newChild = createWorkInProgress(currentChild, nextProps);\r\n  newChild.ref = workInProgress.ref;\r\n  newChild.return = workInProgress;\r\n  workInProgress.child = newChild;\r\n  return newChild;\r\n}\r\n\r\nfunction updateSimpleMemoComponent (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  renderLanes: Lanes,\r\n): null | Fiber {\r\n  // TODO: current can be non-null here even if the component\r\n  // hasn't yet mounted. This happens when the inner render suspends.\r\n  // We'll need to figure out if this is fine or can cause issues.\r\n\r\n  if (__DEV__) {\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      let outerMemoType = workInProgress.elementType;\r\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\r\n        // We warn when you define propTypes on lazy()\r\n        // so let's just skip over it to find memo() outer wrapper.\r\n        // Inner props for memo are validated later.\r\n        const lazyComponent: LazyComponentType<any, any> = outerMemoType;\r\n        const payload = lazyComponent._payload;\r\n        const init = lazyComponent._init;\r\n        try {\r\n          outerMemoType = init(payload);\r\n        } catch (x) {\r\n          outerMemoType = null;\r\n        }\r\n        // Inner propTypes will be validated in the function component path.\r\n        const outerPropTypes = outerMemoType && (outerMemoType: any).propTypes;\r\n        if (outerPropTypes) {\r\n          checkPropTypes(\r\n            outerPropTypes,\r\n            nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\r\n            'prop',\r\n            getComponentNameFromType(outerMemoType),\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (current !== null) {\r\n    const prevProps = current.memoizedProps;\r\n    if (\r\n      shallowEqual(prevProps, nextProps) &&\r\n      current.ref === workInProgress.ref &&\r\n      // Prevent bailout if the implementation changed due to hot reload.\r\n      (__DEV__ ? workInProgress.type === current.type : true)\r\n    ) {\r\n      didReceiveUpdate = false;\r\n\r\n      // The props are shallowly equal. Reuse the previous props object, like we\r\n      // would during a normal fiber bailout.\r\n      //\r\n      // We don't have strong guarantees that the props object is referentially\r\n      // equal during updates where we can't bail out anyway — like if the props\r\n      // are shallowly equal, but there's a local state or context update in the\r\n      // same batch.\r\n      //\r\n      // However, as a principle, we should aim to make the behavior consistent\r\n      // across different ways of memoizing a component. For example, React.memo\r\n      // has a different internal Fiber layout if you pass a normal function\r\n      // component (SimpleMemoComponent) versus if you pass a different type\r\n      // like forwardRef (MemoComponent). But this is an implementation detail.\r\n      // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\r\n      // affect whether the props object is reused during a bailout.\r\n      workInProgress.pendingProps = nextProps = prevProps;\r\n\r\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\r\n        // The pending lanes were cleared at the beginning of beginWork. We're\r\n        // about to bail out, but there might be other lanes that weren't\r\n        // included in the current render. Usually, the priority level of the\r\n        // remaining updates is accumulated during the evaluation of the\r\n        // component (i.e. when processing the update queue). But since since\r\n        // we're bailing out early *without* evaluating the component, we need\r\n        // to account for it here, too. Reset to the value of the current fiber.\r\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\r\n        // because a MemoComponent fiber does not have hooks or an update queue;\r\n        // rather, it wraps around an inner component, which may or may not\r\n        // contains hooks.\r\n        // TODO: Move the reset at in beginWork out of the common path so that\r\n        // this is no longer necessary.\r\n        workInProgress.lanes = current.lanes;\r\n        return bailoutOnAlreadyFinishedWork(\r\n          current,\r\n          workInProgress,\r\n          renderLanes,\r\n        );\r\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\r\n        // This is a special case that only exists for legacy mode.\r\n        // See https://github.com/facebook/react/pull/19216.\r\n        didReceiveUpdate = true;\r\n      }\r\n    }\r\n  }\r\n  return updateFunctionComponent(\r\n    current,\r\n    workInProgress,\r\n    Component,\r\n    nextProps,\r\n    renderLanes,\r\n  );\r\n}\r\n\r\nfunction updateOffscreenComponent (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const nextProps: OffscreenProps = workInProgress.pendingProps;\r\n  const nextChildren = nextProps.children;\r\n\r\n  const prevState: OffscreenState | null =\r\n    current !== null ? current.memoizedState : null;\r\n\r\n  if (\r\n    nextProps.mode === 'hidden' ||\r\n    (enableLegacyHidden && nextProps.mode === 'unstable-defer-without-hiding')\r\n  ) {\r\n    // Rendering a hidden tree.\r\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\r\n      // In legacy sync mode, don't defer the subtree. Render it now.\r\n      // TODO: Consider how Offscreen should work with transitions in the future\r\n      const nextState: OffscreenState = {\r\n        baseLanes: NoLanes,\r\n        cachePool: null,\r\n        transitions: null,\r\n      };\r\n      workInProgress.memoizedState = nextState;\r\n      if (enableCache) {\r\n        // push the cache pool even though we're going to bail out\r\n        // because otherwise there'd be a context mismatch\r\n        if (current !== null) {\r\n          pushTransition(workInProgress, null, null);\r\n        }\r\n      }\r\n      pushRenderLanes(workInProgress, renderLanes);\r\n    } else if (!includesSomeLane(renderLanes, (OffscreenLane: Lane))) {\r\n      let spawnedCachePool: SpawnedCachePool | null = null;\r\n      // We're hidden, and we're not rendering at Offscreen. We will bail out\r\n      // and resume this tree later.\r\n      let nextBaseLanes;\r\n      if (prevState !== null) {\r\n        const prevBaseLanes = prevState.baseLanes;\r\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\r\n        if (enableCache) {\r\n          // Save the cache pool so we can resume later.\r\n          spawnedCachePool = getOffscreenDeferredCache();\r\n        }\r\n      } else {\r\n        nextBaseLanes = renderLanes;\r\n      }\r\n\r\n      // Schedule this fiber to re-render at offscreen priority. Then bailout.\r\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(\r\n        OffscreenLane,\r\n      );\r\n      const nextState: OffscreenState = {\r\n        baseLanes: nextBaseLanes,\r\n        cachePool: spawnedCachePool,\r\n        transitions: null,\r\n      };\r\n      workInProgress.memoizedState = nextState;\r\n      workInProgress.updateQueue = null;\r\n      if (enableCache) {\r\n        // push the cache pool even though we're going to bail out\r\n        // because otherwise there'd be a context mismatch\r\n        if (current !== null) {\r\n          pushTransition(workInProgress, null, null);\r\n        }\r\n      }\r\n\r\n      // We're about to bail out, but we need to push this to the stack anyway\r\n      // to avoid a push/pop misalignment.\r\n      pushRenderLanes(workInProgress, nextBaseLanes);\r\n\r\n      if (enableLazyContextPropagation && current !== null) {\r\n        // Since this tree will resume rendering in a separate render, we need\r\n        // to propagate parent contexts now so we don't lose track of which\r\n        // ones changed.\r\n        propagateParentContextChangesToDeferredTree(\r\n          current,\r\n          workInProgress,\r\n          renderLanes,\r\n        );\r\n      }\r\n\r\n      return null;\r\n    } else {\r\n      // This is the second render. The surrounding visible content has already\r\n      // committed. Now we resume rendering the hidden tree.\r\n\r\n      // Rendering at offscreen, so we can clear the base lanes.\r\n      const nextState: OffscreenState = {\r\n        baseLanes: NoLanes,\r\n        cachePool: null,\r\n        transitions: null,\r\n      };\r\n      workInProgress.memoizedState = nextState;\r\n      // Push the lanes that were skipped when we bailed out.\r\n      const subtreeRenderLanes =\r\n        prevState !== null ? prevState.baseLanes : renderLanes;\r\n      if (enableCache && current !== null) {\r\n        // If the render that spawned this one accessed the cache pool, resume\r\n        // using the same cache. Unless the parent changed, since that means\r\n        // there was a refresh.\r\n        const prevCachePool = prevState !== null ? prevState.cachePool : null;\r\n        // TODO: Consider if and how Offscreen pre-rendering should\r\n        // be attributed to the transition that spawned it\r\n        pushTransition(workInProgress, prevCachePool, null);\r\n      }\r\n\r\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\r\n    }\r\n  } else {\r\n    // Rendering a visible tree.\r\n    let subtreeRenderLanes;\r\n    if (prevState !== null) {\r\n      // We're going from hidden -> visible.\r\n\r\n      subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\r\n\r\n      let prevCachePool = null;\r\n      if (enableCache) {\r\n        // If the render that spawned this one accessed the cache pool, resume\r\n        // using the same cache. Unless the parent changed, since that means\r\n        // there was a refresh.\r\n        prevCachePool = prevState.cachePool;\r\n      }\r\n\r\n      pushTransition(workInProgress, prevCachePool, null);\r\n\r\n      // Since we're not hidden anymore, reset the state\r\n      workInProgress.memoizedState = null;\r\n    } else {\r\n      // We weren't previously hidden, and we still aren't, so there's nothing\r\n      // special to do. Need to push to the stack regardless, though, to avoid\r\n      // a push/pop misalignment.\r\n      subtreeRenderLanes = renderLanes;\r\n\r\n      if (enableCache) {\r\n        // If the render that spawned this one accessed the cache pool, resume\r\n        // using the same cache. Unless the parent changed, since that means\r\n        // there was a refresh.\r\n        if (current !== null) {\r\n          pushTransition(workInProgress, null, null);\r\n        }\r\n      }\r\n    }\r\n    pushRenderLanes(workInProgress, subtreeRenderLanes);\r\n  }\r\n\r\n  if (enablePersistentOffscreenHostContainer && supportsPersistence) {\r\n    // In persistent mode, the offscreen children are wrapped in a host node.\r\n    // TODO: Optimize this to use the OffscreenComponent fiber instead of\r\n    // an extra HostComponent fiber. Need to make sure this doesn't break Fabric\r\n    // or some other infra that expects a HostComponent.\r\n    const isHidden =\r\n      nextProps.mode === 'hidden' &&\r\n      (!enableLegacyHidden || workInProgress.tag !== LegacyHiddenComponent);\r\n    const offscreenContainer = reconcileOffscreenHostContainer(\r\n      current,\r\n      workInProgress,\r\n      isHidden,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n    return offscreenContainer;\r\n  } else {\r\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n    return workInProgress.child;\r\n  }\r\n}\r\n\r\nfunction reconcileOffscreenHostContainer (\r\n  currentOffscreen: Fiber | null,\r\n  offscreen: Fiber,\r\n  isHidden: boolean,\r\n  children: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  const containerProps = getOffscreenContainerProps(\r\n    isHidden ? 'hidden' : 'visible',\r\n    children,\r\n  );\r\n  let hostContainer;\r\n  if (currentOffscreen === null) {\r\n    hostContainer = createOffscreenHostContainerFiber(\r\n      containerProps,\r\n      offscreen.mode,\r\n      renderLanes,\r\n      null,\r\n    );\r\n  } else {\r\n    const currentHostContainer = currentOffscreen.child;\r\n    if (currentHostContainer === null) {\r\n      hostContainer = createOffscreenHostContainerFiber(\r\n        containerProps,\r\n        offscreen.mode,\r\n        renderLanes,\r\n        null,\r\n      );\r\n      hostContainer.flags |= Placement;\r\n    } else {\r\n      hostContainer = createWorkInProgress(\r\n        currentHostContainer,\r\n        containerProps,\r\n      );\r\n    }\r\n  }\r\n  hostContainer.return = offscreen;\r\n  offscreen.child = hostContainer;\r\n  return hostContainer;\r\n}\r\n\r\n// Note: These happen to have identical begin phases, for now. We shouldn't hold\r\n// ourselves to this constraint, though. If the behavior diverges, we should\r\n// fork the function.\r\nconst updateLegacyHiddenComponent = updateOffscreenComponent;\r\n\r\nfunction updateCacheComponent (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (!enableCache) {\r\n    return null;\r\n  }\r\n\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  const parentCache = readContext(CacheContext);\r\n\r\n  if (current === null) {\r\n    // Initial mount. Request a fresh cache from the pool.\r\n    const freshCache = requestCacheFromPool(renderLanes);\r\n    const initialState: CacheComponentState = {\r\n      parent: parentCache,\r\n      cache: freshCache,\r\n    };\r\n    workInProgress.memoizedState = initialState;\r\n    initializeUpdateQueue(workInProgress);\r\n    pushCacheProvider(workInProgress, freshCache);\r\n  } else {\r\n    // Check for updates\r\n    if (includesSomeLane(current.lanes, renderLanes)) {\r\n      cloneUpdateQueue(current, workInProgress);\r\n      processUpdateQueue(workInProgress, null, null, renderLanes);\r\n    }\r\n    const prevState: CacheComponentState = current.memoizedState;\r\n    const nextState: CacheComponentState = workInProgress.memoizedState;\r\n\r\n    // Compare the new parent cache to the previous to see detect there was\r\n    // a refresh.\r\n    if (prevState.parent !== parentCache) {\r\n      // Refresh in parent. Update the parent.\r\n      const derivedState: CacheComponentState = {\r\n        parent: parentCache,\r\n        cache: parentCache,\r\n      };\r\n\r\n      // Copied from getDerivedStateFromProps implementation. Once the update\r\n      // queue is empty, persist the derived state onto the base state.\r\n      workInProgress.memoizedState = derivedState;\r\n      if (workInProgress.lanes === NoLanes) {\r\n        const updateQueue: UpdateQueue<any> = (workInProgress.updateQueue: any);\r\n        workInProgress.memoizedState = updateQueue.baseState = derivedState;\r\n      }\r\n\r\n      pushCacheProvider(workInProgress, parentCache);\r\n      // No need to propagate a context change because the refreshed parent\r\n      // already did.\r\n    } else {\r\n      // The parent didn't refresh. Now check if this cache did.\r\n      const nextCache = nextState.cache;\r\n      pushCacheProvider(workInProgress, nextCache);\r\n      if (nextCache !== prevState.cache) {\r\n        // This cache refreshed. Propagate a context change.\r\n        propagateContextChange(workInProgress, CacheContext, renderLanes);\r\n      }\r\n    }\r\n  }\r\n\r\n  const nextChildren = workInProgress.pendingProps.children;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\n// This should only be called if the name changes\r\nfunction updateTracingMarkerComponent (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (!enableTransitionTracing) {\r\n    return null;\r\n  }\r\n\r\n  const nextChildren = workInProgress.pendingProps.children;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateFragment (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const nextChildren = workInProgress.pendingProps;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateMode (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  const nextChildren = workInProgress.pendingProps.children;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateProfiler (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (enableProfilerTimer) {\r\n    workInProgress.flags |= Update;\r\n\r\n    if (enableProfilerCommitHooks) {\r\n      // Reset effect durations for the next eventual effect phase.\r\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\r\n      const stateNode = workInProgress.stateNode;\r\n      stateNode.effectDuration = 0;\r\n      stateNode.passiveEffectDuration = 0;\r\n    }\r\n  }\r\n  const nextProps = workInProgress.pendingProps;\r\n  const nextChildren = nextProps.children;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction markRef (current: Fiber | null, workInProgress: Fiber) {\r\n  const ref = workInProgress.ref;\r\n  if (\r\n    (current === null && ref !== null) ||\r\n    (current !== null && current.ref !== ref)\r\n  ) {\r\n    // Schedule a Ref effect\r\n    workInProgress.flags |= Ref;\r\n    if (enableSuspenseLayoutEffectSemantics) {\r\n      workInProgress.flags |= RefStatic;\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateFunctionComponent (\r\n  current,\r\n  workInProgress,\r\n  Component,\r\n  nextProps: any,\r\n  renderLanes,\r\n) {\r\n  if (__DEV__) {\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      const innerPropTypes = Component.propTypes;\r\n      if (innerPropTypes) {\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentNameFromType(Component),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  let context;\r\n  if (!disableLegacyContext) {\r\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\r\n    context = getMaskedContext(workInProgress, unmaskedContext);\r\n  }\r\n\r\n  let nextChildren;\r\n  let hasId;\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n  if (enableSchedulingProfiler) {\r\n    markComponentRenderStarted(workInProgress);\r\n  }\r\n  if (__DEV__) {\r\n    ReactCurrentOwner.current = workInProgress;\r\n    setIsRendering(true);\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      context,\r\n      renderLanes,\r\n    );\r\n    hasId = checkDidRenderIdHook();\r\n    if (\r\n      debugRenderPhaseSideEffectsForStrictMode &&\r\n      workInProgress.mode & StrictLegacyMode\r\n    ) {\r\n      setIsStrictModeForDevtools(true);\r\n      try {\r\n        nextChildren = renderWithHooks(\r\n          current,\r\n          workInProgress,\r\n          Component,\r\n          nextProps,\r\n          context,\r\n          renderLanes,\r\n        );\r\n        hasId = checkDidRenderIdHook();\r\n      } finally {\r\n        setIsStrictModeForDevtools(false);\r\n      }\r\n    }\r\n    setIsRendering(false);\r\n  } else {\r\n    nextChildren = renderWithHooks(\r\n      current,\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      context,\r\n      renderLanes,\r\n    );\r\n    hasId = checkDidRenderIdHook();\r\n  }\r\n  if (enableSchedulingProfiler) {\r\n    markComponentRenderStopped();\r\n  }\r\n\r\n  if (current !== null && !didReceiveUpdate) {\r\n    bailoutHooks(current, workInProgress, renderLanes);\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n\r\n  if (getIsHydrating() && hasId) {\r\n    pushMaterializedTreeId(workInProgress);\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction updateClassComponent (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  nextProps: any,\r\n  renderLanes: Lanes,\r\n) {\r\n  if (__DEV__) {\r\n    // This is used by DevTools to force a boundary to error.\r\n    switch (shouldError(workInProgress)) {\r\n      case false: {\r\n        const instance = workInProgress.stateNode;\r\n        const ctor = workInProgress.type;\r\n        // TODO This way of resetting the error boundary state is a hack.\r\n        // Is there a better way to do this?\r\n        const tempInstance = new ctor(\r\n          workInProgress.memoizedProps,\r\n          instance.context,\r\n        );\r\n        const state = tempInstance.state;\r\n        instance.updater.enqueueSetState(instance, state, null);\r\n        break;\r\n      }\r\n      case true: {\r\n        workInProgress.flags |= DidCapture;\r\n        workInProgress.flags |= ShouldCapture;\r\n        // eslint-disable-next-line react-internal/prod-error-codes\r\n        const error = new Error('Simulated error coming from DevTools');\r\n        const lane = pickArbitraryLane(renderLanes);\r\n        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\r\n        // Schedule the error boundary to re-render using updated state\r\n        const update = createClassErrorUpdate(\r\n          workInProgress,\r\n          createCapturedValue(error, workInProgress),\r\n          lane,\r\n        );\r\n        enqueueCapturedUpdate(workInProgress, update);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (workInProgress.type !== workInProgress.elementType) {\r\n      // Lazy component props can't be validated in createElement\r\n      // because they're only guaranteed to be resolved here.\r\n      const innerPropTypes = Component.propTypes;\r\n      if (innerPropTypes) {\r\n        checkPropTypes(\r\n          innerPropTypes,\r\n          nextProps, // Resolved props\r\n          'prop',\r\n          getComponentNameFromType(Component),\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Push context providers early to prevent context stack mismatches.\r\n  // During mounting we don't know the child context yet as the instance doesn't exist.\r\n  // We will invalidate the child context in finishClassComponent() right after rendering.\r\n  let hasContext;\r\n  if (isLegacyContextProvider(Component)) {\r\n    hasContext = true;\r\n    pushLegacyContextProvider(workInProgress);\r\n  } else {\r\n    hasContext = false;\r\n  }\r\n  prepareToReadContext(workInProgress, renderLanes);\r\n\r\n  const instance = workInProgress.stateNode;\r\n  let shouldUpdate;\r\n  if (instance === null) {\r\n    if (current !== null) {\r\n      // A class component without an instance only mounts if it suspended\r\n      // inside a non-concurrent tree, in an inconsistent state. We want to\r\n      // treat it like a new mount, even though an empty version of it already\r\n      // committed. Disconnect the alternate pointers.\r\n      current.alternate = null;\r\n      workInProgress.alternate = null;\r\n      // Since this is conceptually a new fiber, schedule a Placement effect\r\n      workInProgress.flags |= Placement;\r\n    }\r\n    // In the initial pass we might need to construct the instance.\r\n    constructClassInstance(workInProgress, Component, nextProps);\r\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\r\n    shouldUpdate = true;\r\n  } else if (current === null) {\r\n    // In a resume, we'll already have an instance we can reuse.\r\n    shouldUpdate = resumeMountClassInstance(\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    shouldUpdate = updateClassInstance(\r\n      current,\r\n      workInProgress,\r\n      Component,\r\n      nextProps,\r\n      renderLanes,\r\n    );\r\n  }\r\n  const nextUnitOfWork = finishClassComponent(\r\n    current,\r\n    workInProgress,\r\n    Component,\r\n    shouldUpdate,\r\n    hasContext,\r\n    renderLanes,\r\n  );\r\n  if (__DEV__) {\r\n    const inst = workInProgress.stateNode;\r\n    if (shouldUpdate && inst.props !== nextProps) {\r\n      if (!didWarnAboutReassigningProps) {\r\n        console.error(\r\n          'It looks like %s is reassigning its own `this.props` while rendering. ' +\r\n          'This is not supported and can lead to confusing bugs.',\r\n          getComponentNameFromFiber(workInProgress) || 'a component',\r\n        );\r\n      }\r\n      didWarnAboutReassigningProps = true;\r\n    }\r\n  }\r\n  return nextUnitOfWork;\r\n}\r\n\r\nfunction finishClassComponent (\r\n  current: Fiber | null,\r\n  workInProgress: Fiber,\r\n  Component: any,\r\n  shouldUpdate: boolean,\r\n  hasContext: boolean,\r\n  renderLanes: Lanes,\r\n) {\r\n  // Refs should update even if shouldComponentUpdate returns false\r\n  markRef(current, workInProgress);\r\n\r\n  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\r\n\r\n  if (!shouldUpdate && !didCaptureError) {\r\n    // Context providers should defer to sCU for rendering\r\n    if (hasContext) {\r\n      invalidateContextProvider(workInProgress, Component, false);\r\n    }\r\n\r\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n  }\r\n\r\n  const instance = workInProgress.stateNode;\r\n\r\n  // Rerender\r\n  ReactCurrentOwner.current = workInProgress;\r\n  let nextChildren;\r\n  if (\r\n    didCaptureError &&\r\n    typeof Component.getDerivedStateFromError !== 'function'\r\n  ) {\r\n    // If we captured an error, but getDerivedStateFromError is not defined,\r\n    // unmount all the children. componentDidCatch will schedule an update to\r\n    // re-render a fallback. This is temporary until we migrate everyone to\r\n    // the new API.\r\n    // TODO: Warn in a future release.\r\n    nextChildren = null;\r\n\r\n    if (enableProfilerTimer) {\r\n      stopProfilerTimerIfRunning(workInProgress);\r\n    }\r\n  } else {\r\n    if (enableSchedulingProfiler) {\r\n      markComponentRenderStarted(workInProgress);\r\n    }\r\n    if (__DEV__) {\r\n      setIsRendering(true);\r\n      nextChildren = instance.render();\r\n      if (\r\n        debugRenderPhaseSideEffectsForStrictMode &&\r\n        workInProgress.mode & StrictLegacyMode\r\n      ) {\r\n        setIsStrictModeForDevtools(true);\r\n        try {\r\n          instance.render();\r\n        } finally {\r\n          setIsStrictModeForDevtools(false);\r\n        }\r\n      }\r\n      setIsRendering(false);\r\n    } else {\r\n      nextChildren = instance.render();\r\n    }\r\n    if (enableSchedulingProfiler) {\r\n      markComponentRenderStopped();\r\n    }\r\n  }\r\n\r\n  // React DevTools reads this flag.\r\n  workInProgress.flags |= PerformedWork;\r\n  if (current !== null && didCaptureError) {\r\n    // If we're recovering from an error, reconcile without reusing any of\r\n    // the existing children. Conceptually, the normal children and the children\r\n    // that are shown on error are two different sets, so we shouldn't reuse\r\n    // normal children even if their identities match.\r\n    forceUnmountCurrentAndReconcile(\r\n      current,\r\n      workInProgress,\r\n      nextChildren,\r\n      renderLanes,\r\n    );\r\n  } else {\r\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  }\r\n\r\n  // Memoize state using the values we just used to render.\r\n  // TODO: Restructure so we never read values from the instance.\r\n  workInProgress.memoizedState = instance.state;\r\n\r\n  // The context might have changed so we need to recalculate it.\r\n  if (hasContext) {\r\n    invalidateContextProvider(workInProgress, Component, true);\r\n  }\r\n\r\n  return workInProgress.child;\r\n}\r\n\r\nfunction pushHostRootContext (workInProgress) {\r\n  const root = (workInProgress.stateNode: FiberRoot);\r\n  if (root.pendingContext) {\r\n    pushTopLevelContextObject(\r\n      workInProgress,\r\n      root.pendingContext,\r\n      root.pendingContext !== root.context,\r\n    );\r\n  } else if (root.context) {\r\n    // Should always be set\r\n    pushTopLevelContextObject(workInProgress, root.context, false);\r\n  }\r\n  pushHostContainer(workInProgress, root.containerInfo);\r\n}\r\n\r\nfunction updateHostRoot (current, workInProgress, renderLanes) {\r\n  pushHostRootContext(workInProgress);\r\n\r\n  if (current === null) {\r\n    throw new Error('Should have a current fiber. This is a bug in React.');\r\n  }\r\n\r\n  const nextProps = workInProgress.pendingProps;\r\n  const prevState = workInProgress.memoizedState;\r\n  const prevChildren = prevState.element;\r\n  cloneUpdateQueue(current, workInProgress);\r\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\r\n\r\n  const nextState: RootState = workInProgress.memoizedState;\r\n  const root: FiberRoot = workInProgress.stateNode;\r\n  pushRootTransition(workInProgress, root, renderLanes);\r\n\r\n  if (enableCache) {\r\n    const nextCache: Cache = nextState.cache;\r\n    pushCacheProvider(workInProgress, nextCache);\r\n    if (nextCache !== prevState.cache) {\r\n      // The root cache refreshed.\r\n      propagateContextChange(workInProgress, CacheContext, renderLanes);\r\n    }\r\n  }\r\n\r\n  // Caution: React DevTools currently depends on this property\r\n  // being called \"element\".\r\n  const nextChildren = nextState.element;\r\n  if (supportsHydration && prevState.isDehydrated) {\r\n    // This is a hydration root whose shell has not yet hydrated. We should\r\n    // attempt to hydrate.\r\n\r\n    // Flip isDehydrated to false to indicate that when this render\r\n    // finishes, the root will no longer be dehydrated.\r\n    const overrideState: RootState = {\r\n      element: nextChildren,\r\n      isDehydrated: false,\r\n      cache: nextState.cache,\r\n      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\r\n      transitions: nextState.transitions,\r\n    };\r\n    const updateQueue: UpdateQueue<RootState> = (workInProgress.updateQueue: any);\r\n    // `baseState` can always be the last state because the root doesn't\r\n    // have reducer functions so it doesn't need rebasing.\r\n    updateQueue.baseState = overrideState;\r\n    workInProgress.memoizedState = overrideState;\r\n\r\n    if (workInProgress.flags & ForceClientRender) {\r\n      // Something errored during a previous attempt to hydrate the shell, so we\r\n      // forced a client render.\r\n      const recoverableError = new Error(\r\n        'There was an error while hydrating. Because the error happened outside ' +\r\n        'of a Suspense boundary, the entire root will switch to ' +\r\n        'client rendering.',\r\n      );\r\n      return mountHostRootWithoutHydrating(\r\n        current,\r\n        workInProgress,\r\n        nextChildren,\r\n        renderLanes,\r\n        recoverableError,\r\n      );\r\n    } else if (nextChildren !== prevChildren) {\r\n      const recoverableError = new Error(\r\n        'This root received an early update, before anything was able ' +\r\n        'hydrate. Switched the entire root to client rendering.',\r\n      );\r\n      return mountHostRootWithoutHydrating(\r\n        current,\r\n        workInProgress,\r\n        nextChildren,\r\n        renderLanes,\r\n        recoverableError,\r\n      );\r\n    } else {\r\n      // The outermost shell has not hydrated yet. Start hydrating.\r\n      enterHydrationState(workInProgress);\r\n      if (enableUseMutableSource) {\r\n        const mutableSourceEagerHydrationData =\r\n          root.mutableSourceEagerHydrationData;\r\n        if (mutableSourceEagerHydrationData != null) {\r\n          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\r\n            const mutableSource = ((mutableSourceEagerHydrationData[\r\n              i\r\n            ]: any): MutableSource<any>);\r\n              const version = mutableSourceEagerHydrationData[i + 1];\r\n              setWorkInProgressVersion(mutableSource, version);\r\n          }\r\n        }\r\n      }\r\n\r\n              const child = mountChildFibers(\r\n              workInProgress,\r\n              null,\r\n              nextChildren,\r\n              renderLanes,\r\n              );\r\n              workInProgress.child = child;\r\n\r\n              let node = child;\r\n              while (node) {\r\n                // Mark each child as hydrating. This is a fast path to know whether this\r\n                // tree is part of a hydrating tree. This is used to determine if a child\r\n                // node has fully mounted yet, and for scheduling event replaying.\r\n                // Conceptually this is similar to Placement in that a new subtree is\r\n                // inserted into the React tree here. It just happens to not need DOM\r\n                // mutations because it already exists.\r\n                node.flags = (node.flags & ~Placement) | Hydrating;\r\n              node = node.sibling;\r\n      }\r\n    }\r\n  } else {\r\n                // Root is not dehydrated. Either this is a client-only root, or it\r\n                // already hydrated.\r\n                resetHydrationState();\r\n              if (nextChildren === prevChildren) {\r\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n    }\r\n              reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n  }\r\n              return workInProgress.child;\r\n}\r\n\r\n              function mountHostRootWithoutHydrating(\r\n              current: Fiber,\r\n              workInProgress: Fiber,\r\n              nextChildren: ReactNodeList,\r\n              renderLanes: Lanes,\r\n              recoverableError: Error,\r\n              ) {\r\n                // Revert to client rendering.\r\n                resetHydrationState();\r\n\r\n              queueHydrationError(recoverableError);\r\n\r\n              workInProgress.flags |= ForceClientRender;\r\n\r\n              reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n              return workInProgress.child;\r\n}\r\n\r\n              function updateHostComponent(\r\n              current: Fiber | null,\r\n              workInProgress: Fiber,\r\n              renderLanes: Lanes,\r\n              ) {\r\n                pushHostContext(workInProgress);\r\n\r\n              if (current === null) {\r\n                tryToClaimNextHydratableInstance(workInProgress);\r\n  }\r\n\r\n              const type = workInProgress.type;\r\n              const nextProps = workInProgress.pendingProps;\r\n              const prevProps = current !== null ? current.memoizedProps : null;\r\n\r\n              let nextChildren = nextProps.children;\r\n              const isDirectTextChild = shouldSetTextContent(type, nextProps);\r\n\r\n              if (isDirectTextChild) {\r\n                // We special case a direct text child of a host node. This is a common\r\n                // case. We won't handle it as a reified child. We will instead handle\r\n                // this in the host environment that also has access to this prop. That\r\n                // avoids allocating another HostText fiber and traversing it.\r\n                nextChildren = null;\r\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\r\n                // If we're switching from a direct text child to a normal child, or to\r\n                // empty, we need to schedule the text content to be reset.\r\n                workInProgress.flags |= ContentReset;\r\n  }\r\n\r\n              markRef(current, workInProgress);\r\n              reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n              return workInProgress.child;\r\n}\r\n\r\n              function updateHostText(current, workInProgress) {\r\n  if (current === null) {\r\n                tryToClaimNextHydratableInstance(workInProgress);\r\n  }\r\n              // Nothing to do here. This is terminal. We'll do the completion step\r\n              // immediately after.\r\n              return null;\r\n}\r\n\r\n              function mountLazyComponent(\r\n              _current,\r\n              workInProgress,\r\n              elementType,\r\n              renderLanes,\r\n              ) {\r\n  if (_current !== null) {\r\n                // A lazy component only mounts if it suspended inside a non-\r\n                // concurrent tree, in an inconsistent state. We want to treat it like\r\n                // a new mount, even though an empty version of it already committed.\r\n                // Disconnect the alternate pointers.\r\n                _current.alternate = null;\r\n              workInProgress.alternate = null;\r\n              // Since this is conceptually a new fiber, schedule a Placement effect\r\n              workInProgress.flags |= Placement;\r\n  }\r\n\r\n              const props = workInProgress.pendingProps;\r\n              const lazyComponent: LazyComponentType<any, any> = elementType;\r\n              const payload = lazyComponent._payload;\r\n              const init = lazyComponent._init;\r\n              let Component = init(payload);\r\n              // Store the unwrapped component in the type.\r\n              workInProgress.type = Component;\r\n              const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));\r\n              const resolvedProps = resolveDefaultProps(Component, props);\r\n              let child;\r\n              switch (resolvedTag) {\r\n    case FunctionComponent: {\r\n      if (__DEV__) {\r\n                validateFunctionComponentInDev(workInProgress, Component);\r\n              workInProgress.type = Component = resolveFunctionForHotReloading(\r\n              Component,\r\n              );\r\n      }\r\n              child = updateFunctionComponent(\r\n              null,\r\n              workInProgress,\r\n              Component,\r\n              resolvedProps,\r\n              renderLanes,\r\n              );\r\n              return child;\r\n    }\r\n              case ClassComponent: {\r\n      if (__DEV__) {\r\n                workInProgress.type = Component = resolveClassForHotReloading(\r\n                  Component,\r\n                );\r\n      }\r\n              child = updateClassComponent(\r\n              null,\r\n              workInProgress,\r\n              Component,\r\n              resolvedProps,\r\n              renderLanes,\r\n              );\r\n              return child;\r\n    }\r\n              case ForwardRef: {\r\n      if (__DEV__) {\r\n                workInProgress.type = Component = resolveForwardRefForHotReloading(\r\n                  Component,\r\n                );\r\n      }\r\n              child = updateForwardRef(\r\n              null,\r\n              workInProgress,\r\n              Component,\r\n              resolvedProps,\r\n              renderLanes,\r\n              );\r\n              return child;\r\n    }\r\n              case MemoComponent: {\r\n      if (__DEV__) {\r\n        if (workInProgress.type !== workInProgress.elementType) {\r\n          const outerPropTypes = Component.propTypes;\r\n              if (outerPropTypes) {\r\n                checkPropTypes(\r\n                  outerPropTypes,\r\n                  resolvedProps, // Resolved for outer only\r\n                  'prop',\r\n                  getComponentNameFromType(Component),\r\n                );\r\n          }\r\n        }\r\n      }\r\n              child = updateMemoComponent(\r\n              null,\r\n              workInProgress,\r\n              Component,\r\n              resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\r\n              renderLanes,\r\n              );\r\n              return child;\r\n    }\r\n  }\r\n              let hint = '';\r\n              if (__DEV__) {\r\n    if (\r\n              Component !== null &&\r\n              typeof Component === 'object' &&\r\n              Component.$$typeof === REACT_LAZY_TYPE\r\n              ) {\r\n                hint = ' Did you wrap a component in React.lazy() more than once?';\r\n    }\r\n  }\r\n\r\n              // This message intentionally doesn't mention ForwardRef or MemoComponent\r\n              // because the fact that it's a separate type of work is an\r\n              // implementation detail.\r\n              throw new Error(\r\n              `Element type is invalid. Received a promise that resolves to: ${Component}. ` +\r\n              `Lazy element type must resolve to a class or function.${hint}`,\r\n              );\r\n}\r\n\r\n              function mountIncompleteClassComponent(\r\n              _current,\r\n              workInProgress,\r\n              Component,\r\n              nextProps,\r\n              renderLanes,\r\n              ) {\r\n  if (_current !== null) {\r\n                // An incomplete component only mounts if it suspended inside a non-\r\n                // concurrent tree, in an inconsistent state. We want to treat it like\r\n                // a new mount, even though an empty version of it already committed.\r\n                // Disconnect the alternate pointers.\r\n                _current.alternate = null;\r\n              workInProgress.alternate = null;\r\n              // Since this is conceptually a new fiber, schedule a Placement effect\r\n              workInProgress.flags |= Placement;\r\n  }\r\n\r\n              // Promote the fiber to a class and try rendering again.\r\n              workInProgress.tag = ClassComponent;\r\n\r\n              // The rest of this function is a fork of `updateClassComponent`\r\n\r\n              // Push context providers early to prevent context stack mismatches.\r\n              // During mounting we don't know the child context yet as the instance doesn't exist.\r\n              // We will invalidate the child context in finishClassComponent() right after rendering.\r\n              let hasContext;\r\n              if (isLegacyContextProvider(Component)) {\r\n                hasContext = true;\r\n              pushLegacyContextProvider(workInProgress);\r\n  } else {\r\n                hasContext = false;\r\n  }\r\n              prepareToReadContext(workInProgress, renderLanes);\r\n\r\n              constructClassInstance(workInProgress, Component, nextProps);\r\n              mountClassInstance(workInProgress, Component, nextProps, renderLanes);\r\n\r\n              return finishClassComponent(\r\n              null,\r\n              workInProgress,\r\n              Component,\r\n              true,\r\n              hasContext,\r\n              renderLanes,\r\n              );\r\n}\r\n\r\n              function mountIndeterminateComponent(\r\n              _current,\r\n              workInProgress,\r\n              Component,\r\n              renderLanes,\r\n              ) {\r\n  if (_current !== null) {\r\n                // An indeterminate component only mounts if it suspended inside a non-\r\n                // concurrent tree, in an inconsistent state. We want to treat it like\r\n                // a new mount, even though an empty version of it already committed.\r\n                // Disconnect the alternate pointers.\r\n                _current.alternate = null;\r\n              workInProgress.alternate = null;\r\n              // Since this is conceptually a new fiber, schedule a Placement effect\r\n              workInProgress.flags |= Placement;\r\n  }\r\n\r\n              const props = workInProgress.pendingProps;\r\n              let context;\r\n              if (!disableLegacyContext) {\r\n    const unmaskedContext = getUnmaskedContext(\r\n              workInProgress,\r\n              Component,\r\n              false,\r\n              );\r\n              context = getMaskedContext(workInProgress, unmaskedContext);\r\n  }\r\n\r\n              prepareToReadContext(workInProgress, renderLanes);\r\n              let value;\r\n              let hasId;\r\n\r\n              if (enableSchedulingProfiler) {\r\n                markComponentRenderStarted(workInProgress);\r\n  }\r\n              if (__DEV__) {\r\n    if (\r\n              Component.prototype &&\r\n              typeof Component.prototype.render === 'function'\r\n              ) {\r\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\r\n\r\n              if (!didWarnAboutBadClass[componentName]) {\r\n                console.error(\r\n                  \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\r\n                  'This is likely to cause errors. Change %s to extend React.Component instead.',\r\n                  componentName,\r\n                  componentName,\r\n                );\r\n              didWarnAboutBadClass[componentName] = true;\r\n      }\r\n    }\r\n\r\n              if (workInProgress.mode & StrictLegacyMode) {\r\n                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\r\n    }\r\n\r\n              setIsRendering(true);\r\n              ReactCurrentOwner.current = workInProgress;\r\n              value = renderWithHooks(\r\n              null,\r\n              workInProgress,\r\n              Component,\r\n              props,\r\n              context,\r\n              renderLanes,\r\n              );\r\n              hasId = checkDidRenderIdHook();\r\n              setIsRendering(false);\r\n  } else {\r\n                value = renderWithHooks(\r\n                  null,\r\n                  workInProgress,\r\n                  Component,\r\n                  props,\r\n                  context,\r\n                  renderLanes,\r\n                );\r\n              hasId = checkDidRenderIdHook();\r\n  }\r\n              if (enableSchedulingProfiler) {\r\n                markComponentRenderStopped();\r\n  }\r\n\r\n              // React DevTools reads this flag.\r\n              workInProgress.flags |= PerformedWork;\r\n\r\n              if (__DEV__) {\r\n    // Support for module components is deprecated and is removed behind a flag.\r\n    // Whether or not it would crash later, we want to show a good message in DEV first.\r\n    if (\r\n              typeof value === 'object' &&\r\n              value !== null &&\r\n              typeof value.render === 'function' &&\r\n              value.$$typeof === undefined\r\n              ) {\r\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\r\n              if (!didWarnAboutModulePatternComponent[componentName]) {\r\n                console.error(\r\n                  'The <%s /> component appears to be a function component that returns a class instance. ' +\r\n                  'Change %s to a class that extends React.Component instead. ' +\r\n                  \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\r\n                  \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\r\n                  'cannot be called with `new` by React.',\r\n                  componentName,\r\n                  componentName,\r\n                  componentName,\r\n                );\r\n              didWarnAboutModulePatternComponent[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n              if (\r\n              // Run these checks in production only if the flag is off.\r\n              // Eventually we'll delete this branch altogether.\r\n              !disableModulePatternComponents &&\r\n              typeof value === 'object' &&\r\n              value !== null &&\r\n              typeof value.render === 'function' &&\r\n              value.$$typeof === undefined\r\n              ) {\r\n    if (__DEV__) {\r\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\r\n              if (!didWarnAboutModulePatternComponent[componentName]) {\r\n                console.error(\r\n                  'The <%s /> component appears to be a function component that returns a class instance. ' +\r\n                  'Change %s to a class that extends React.Component instead. ' +\r\n                  \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\r\n                  \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\r\n                  'cannot be called with `new` by React.',\r\n                  componentName,\r\n                  componentName,\r\n                  componentName,\r\n                );\r\n              didWarnAboutModulePatternComponent[componentName] = true;\r\n      }\r\n    }\r\n\r\n              // Proceed under the assumption that this is a class instance\r\n              workInProgress.tag = ClassComponent;\r\n\r\n              // Throw out any hooks that were used.\r\n              workInProgress.memoizedState = null;\r\n              workInProgress.updateQueue = null;\r\n\r\n              // Push context providers early to prevent context stack mismatches.\r\n              // During mounting we don't know the child context yet as the instance doesn't exist.\r\n              // We will invalidate the child context in finishClassComponent() right after rendering.\r\n              let hasContext = false;\r\n              if (isLegacyContextProvider(Component)) {\r\n                hasContext = true;\r\n              pushLegacyContextProvider(workInProgress);\r\n    } else {\r\n                hasContext = false;\r\n    }\r\n\r\n              workInProgress.memoizedState =\r\n              value.state !== null && value.state !== undefined ? value.state : null;\r\n\r\n              initializeUpdateQueue(workInProgress);\r\n\r\n              adoptClassInstance(workInProgress, value);\r\n              mountClassInstance(workInProgress, Component, props, renderLanes);\r\n              return finishClassComponent(\r\n              null,\r\n              workInProgress,\r\n              Component,\r\n              true,\r\n              hasContext,\r\n              renderLanes,\r\n              );\r\n  } else {\r\n                // Proceed under the assumption that this is a function component\r\n                workInProgress.tag = FunctionComponent;\r\n              if (__DEV__) {\r\n      if (disableLegacyContext && Component.contextTypes) {\r\n                console.error(\r\n                  '%s uses the legacy contextTypes API which is no longer supported. ' +\r\n                  'Use React.createContext() with React.useContext() instead.',\r\n                  getComponentNameFromType(Component) || 'Unknown',\r\n                );\r\n      }\r\n\r\n              if (\r\n              debugRenderPhaseSideEffectsForStrictMode &&\r\n              workInProgress.mode & StrictLegacyMode\r\n              ) {\r\n                setIsStrictModeForDevtools(true);\r\n              try {\r\n                value = renderWithHooks(\r\n                  null,\r\n                  workInProgress,\r\n                  Component,\r\n                  props,\r\n                  context,\r\n                  renderLanes,\r\n                );\r\n              hasId = checkDidRenderIdHook();\r\n        } finally {\r\n                setIsStrictModeForDevtools(false);\r\n        }\r\n      }\r\n    }\r\n\r\n              if (getIsHydrating() && hasId) {\r\n                pushMaterializedTreeId(workInProgress);\r\n    }\r\n\r\n              reconcileChildren(null, workInProgress, value, renderLanes);\r\n              if (__DEV__) {\r\n                validateFunctionComponentInDev(workInProgress, Component);\r\n    }\r\n              return workInProgress.child;\r\n  }\r\n}\r\n\r\n              function validateFunctionComponentInDev(workInProgress: Fiber, Component: any) {\r\n  if (__DEV__) {\r\n    if (Component) {\r\n      if (Component.childContextTypes) {\r\n                console.error(\r\n                  '%s(...): childContextTypes cannot be defined on a function component.',\r\n                  Component.displayName || Component.name || 'Component',\r\n                );\r\n      }\r\n    }\r\n              if (workInProgress.ref !== null) {\r\n                let info = '';\r\n              const ownerName = getCurrentFiberOwnerNameInDevOrNull();\r\n              if (ownerName) {\r\n                info += '\\n\\nCheck the render method of `' + ownerName + '`.';\r\n      }\r\n\r\n              let warningKey = ownerName || '';\r\n              const debugSource = workInProgress._debugSource;\r\n              if (debugSource) {\r\n                warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\r\n      }\r\n              if (!didWarnAboutFunctionRefs[warningKey]) {\r\n                didWarnAboutFunctionRefs[warningKey] = true;\r\n              console.error(\r\n              'Function components cannot be given refs. ' +\r\n              'Attempts to access this ref will fail. ' +\r\n              'Did you mean to use React.forwardRef()?%s',\r\n              info,\r\n              );\r\n      }\r\n    }\r\n\r\n              if (\r\n              warnAboutDefaultPropsOnFunctionComponents &&\r\n              Component.defaultProps !== undefined\r\n              ) {\r\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\r\n\r\n              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\r\n                console.error(\r\n                  '%s: Support for defaultProps will be removed from function components ' +\r\n                  'in a future major release. Use JavaScript default parameters instead.',\r\n                  componentName,\r\n                );\r\n              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\r\n      }\r\n    }\r\n\r\n              if (typeof Component.getDerivedStateFromProps === 'function') {\r\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\r\n\r\n              if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\r\n                console.error(\r\n                  '%s: Function components do not support getDerivedStateFromProps.',\r\n                  componentName,\r\n                );\r\n              didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\r\n      }\r\n    }\r\n\r\n              if (\r\n              typeof Component.contextType === 'object' &&\r\n              Component.contextType !== null\r\n              ) {\r\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\r\n\r\n              if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\r\n                console.error(\r\n                  '%s: Function components do not support contextType.',\r\n                  componentName,\r\n                );\r\n              didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n              const SUSPENDED_MARKER: SuspenseState = {\r\n                dehydrated: null,\r\n              treeContext: null,\r\n              retryLane: NoLane,\r\n};\r\n\r\n              function mountSuspenseOffscreenState(renderLanes: Lanes): OffscreenState {\r\n  return {\r\n                baseLanes: renderLanes,\r\n              cachePool: getSuspendedCache(),\r\n              transitions: null,\r\n  };\r\n}\r\n\r\n              function updateSuspenseOffscreenState(\r\n              prevOffscreenState: OffscreenState,\r\n              renderLanes: Lanes,\r\n              ): OffscreenState {\r\n                let cachePool: SpawnedCachePool | null = null;\r\n              if (enableCache) {\r\n    const prevCachePool: SpawnedCachePool | null = prevOffscreenState.cachePool;\r\n              if (prevCachePool !== null) {\r\n      const parentCache = isPrimaryRenderer\r\n              ? CacheContext._currentValue\r\n              : CacheContext._currentValue2;\r\n              if (prevCachePool.parent !== parentCache) {\r\n                // Detected a refresh in the parent. This overrides any previously\r\n                // suspended cache.\r\n                cachePool = {\r\n                  parent: parentCache,\r\n                  pool: parentCache,\r\n                };\r\n      } else {\r\n                // We can reuse the cache from last time. The only thing that would have\r\n                // overridden it is a parent refresh, which we checked for above.\r\n                cachePool = prevCachePool;\r\n      }\r\n    } else {\r\n                // If there's no previous cache pool, grab the current one.\r\n                cachePool = getSuspendedCache();\r\n    }\r\n  }\r\n              return {\r\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\r\n              cachePool,\r\n              transitions: prevOffscreenState.transitions,\r\n  };\r\n}\r\n\r\n              // TODO: Probably should inline this back\r\n              function shouldRemainOnFallback(\r\n              suspenseContext: SuspenseContext,\r\n              current: null | Fiber,\r\n              workInProgress: Fiber,\r\n              renderLanes: Lanes,\r\n              ) {\r\n  // If we're already showing a fallback, there are cases where we need to\r\n  // remain on that fallback regardless of whether the content has resolved.\r\n  // For example, SuspenseList coordinates when nested content appears.\r\n  if (current !== null) {\r\n    const suspenseState: SuspenseState = current.memoizedState;\r\n              if (suspenseState === null) {\r\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\r\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\r\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\r\n      // no fallback to remain on.\r\n      return false;\r\n    }\r\n  }\r\n\r\n              // Not currently showing content. Consult the Suspense context.\r\n              return hasSuspenseContext(\r\n              suspenseContext,\r\n              (ForceSuspenseFallback: SuspenseContext),\r\n              );\r\n}\r\n\r\n              function getRemainingWorkInPrimaryTree(current: Fiber, renderLanes) {\r\n  // TODO: Should not remove render lanes that were pinged during this render\r\n  return removeLanes(current.childLanes, renderLanes);\r\n}\r\n\r\n              function updateSuspenseComponent(current, workInProgress, renderLanes) {\r\n  const nextProps = workInProgress.pendingProps;\r\n\r\n              // This is used by DevTools to force a boundary to suspend.\r\n              if (__DEV__) {\r\n    if (shouldSuspend(workInProgress)) {\r\n                workInProgress.flags |= DidCapture;\r\n    }\r\n  }\r\n\r\n              let suspenseContext: SuspenseContext = suspenseStackCursor.current;\r\n\r\n              let showFallback = false;\r\n              const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\r\n\r\n              if (\r\n              didSuspend ||\r\n              shouldRemainOnFallback(\r\n              suspenseContext,\r\n              current,\r\n              workInProgress,\r\n              renderLanes,\r\n              )\r\n              ) {\r\n                // Something in this boundary's subtree already suspended. Switch to\r\n                // rendering the fallback children.\r\n                showFallback = true;\r\n              workInProgress.flags &= ~DidCapture;\r\n  } else {\r\n    // Attempting the main content\r\n    if (\r\n              current === null ||\r\n              (current.memoizedState: null | SuspenseState) !== null\r\n              ) {\r\n      // This is a new mount or this boundary is already showing a fallback state.\r\n      // Mark this subtree context as having at least one invisible parent that could\r\n      // handle the fallback state.\r\n      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\r\n      if (\r\n              !enableSuspenseAvoidThisFallback ||\r\n              nextProps.unstable_avoidThisFallback !== true\r\n              ) {\r\n                suspenseContext = addSubtreeSuspenseContext(\r\n                  suspenseContext,\r\n                  InvisibleParentSuspenseContext,\r\n                );\r\n      }\r\n    }\r\n  }\r\n\r\n              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n\r\n              pushSuspenseContext(workInProgress, suspenseContext);\r\n\r\n              // OK, the next part is confusing. We're about to reconcile the Suspense\r\n              // boundary's children. This involves some custom reconciliation logic. Two\r\n              // main reasons this is so complicated.\r\n              //\r\n              // First, Legacy Mode has different semantics for backwards compatibility. The\r\n              // primary tree will commit in an inconsistent state, so when we do the\r\n              // second pass to render the fallback, we do some exceedingly, uh, clever\r\n              // hacks to make that not totally break. Like transferring effects and\r\n              // deletions from hidden tree. In Concurrent Mode, it's much simpler,\r\n              // because we bailout on the primary tree completely and leave it in its old\r\n              // state, no effects. Same as what we do for Offscreen (except that\r\n              // Offscreen doesn't have the first render pass).\r\n              //\r\n              // Second is hydration. During hydration, the Suspense fiber has a slightly\r\n              // different layout, where the child points to a dehydrated fragment, which\r\n              // contains the DOM rendered by the server.\r\n              //\r\n              // Third, even if you set all that aside, Suspense is like error boundaries in\r\n              // that we first we try to render one tree, and if that fails, we render again\r\n              // and switch to a different tree. Like a try/catch block. So we have to track\r\n              // which branch we're currently rendering. Ideally we would model this using\r\n              // a stack.\r\n              if (current === null) {\r\n                // Initial mount\r\n                // If we're currently hydrating, try to hydrate this boundary.\r\n                tryToClaimNextHydratableInstance(workInProgress);\r\n              // This could've been a dehydrated suspense component.\r\n              const suspenseState: null | SuspenseState = workInProgress.memoizedState;\r\n              if (suspenseState !== null) {\r\n      const dehydrated = suspenseState.dehydrated;\r\n              if (dehydrated !== null) {\r\n        return mountDehydratedSuspenseComponent(\r\n              workInProgress,\r\n              dehydrated,\r\n              renderLanes,\r\n              );\r\n      }\r\n    }\r\n\r\n              const nextPrimaryChildren = nextProps.children;\r\n              const nextFallbackChildren = nextProps.fallback;\r\n\r\n              if (showFallback) {\r\n      const fallbackFragment = mountSuspenseFallbackChildren(\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              nextFallbackChildren,\r\n              renderLanes,\r\n              );\r\n              const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\r\n              renderLanes,\r\n              );\r\n              workInProgress.memoizedState = SUSPENDED_MARKER;\r\n              if (enableTransitionTracing) {\r\n        const currentTransitions = getSuspendedTransitions();\r\n              if (currentTransitions !== null) {\r\n          const primaryChildUpdateQueue: OffscreenQueue = {\r\n                transitions: currentTransitions,\r\n          };\r\n              primaryChildFragment.updateQueue = primaryChildUpdateQueue;\r\n        }\r\n      }\r\n\r\n              return fallbackFragment;\r\n    } else if (\r\n              enableCPUSuspense &&\r\n              typeof nextProps.unstable_expectedLoadTime === 'number'\r\n              ) {\r\n      // This is a CPU-bound tree. Skip this tree and show a placeholder to\r\n      // unblock the surrounding content. Then immediately retry after the\r\n      // initial commit.\r\n      const fallbackFragment = mountSuspenseFallbackChildren(\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              nextFallbackChildren,\r\n              renderLanes,\r\n              );\r\n              const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\r\n              renderLanes,\r\n              );\r\n              workInProgress.memoizedState = SUSPENDED_MARKER;\r\n\r\n              // Since nothing actually suspended, there will nothing to ping this to\r\n              // get it started back up to attempt the next item. While in terms of\r\n              // priority this work has the same priority as this current render, it's\r\n              // not part of the same transition once the transition has committed. If\r\n              // it's sync, we still want to yield so that it can be painted.\r\n              // Conceptually, this is really the same as pinging. We can use any\r\n              // RetryLane even if it's the one currently rendering since we're leaving\r\n              // it behind on this node.\r\n              workInProgress.lanes = SomeRetryLane;\r\n              return fallbackFragment;\r\n    } else {\r\n      return mountSuspensePrimaryChildren(\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              renderLanes,\r\n              );\r\n    }\r\n  } else {\r\n    // This is an update.\r\n\r\n    // If the current fiber has a SuspenseState, that means it's already showing\r\n    // a fallback.\r\n    const prevState: null | SuspenseState = current.memoizedState;\r\n              if (prevState !== null) {\r\n      // The current tree is already showing a fallback\r\n\r\n      // Special path for hydration\r\n      const dehydrated = prevState.dehydrated;\r\n              if (dehydrated !== null) {\r\n        if (!didSuspend) {\r\n          return updateDehydratedSuspenseComponent(\r\n              current,\r\n              workInProgress,\r\n              dehydrated,\r\n              prevState,\r\n              renderLanes,\r\n              );\r\n        } else if (workInProgress.flags & ForceClientRender) {\r\n                // Something errored during hydration. Try again without hydrating.\r\n                workInProgress.flags &= ~ForceClientRender;\r\n              return retrySuspenseComponentWithoutHydrating(\r\n              current,\r\n              workInProgress,\r\n              renderLanes,\r\n              new Error(\r\n              'There was an error while hydrating this Suspense boundary. ' +\r\n              'Switched to client rendering.',\r\n              ),\r\n              );\r\n        } else if (\r\n              (workInProgress.memoizedState: null | SuspenseState) !== null\r\n              ) {\r\n                // Something suspended and we should still be in dehydrated mode.\r\n                // Leave the existing child in place.\r\n                workInProgress.child = current.child;\r\n              // The dehydrated completion pass expects this flag to be there\r\n              // but the normal suspense pass doesn't.\r\n              workInProgress.flags |= DidCapture;\r\n              return null;\r\n        } else {\r\n          // Suspended but we should no longer be in dehydrated mode.\r\n          // Therefore we now have to render the fallback.\r\n          const nextPrimaryChildren = nextProps.children;\r\n              const nextFallbackChildren = nextProps.fallback;\r\n              const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(\r\n              current,\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              nextFallbackChildren,\r\n              renderLanes,\r\n              );\r\n              const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\r\n              renderLanes,\r\n              );\r\n              workInProgress.memoizedState = SUSPENDED_MARKER;\r\n              return fallbackChildFragment;\r\n        }\r\n      }\r\n\r\n              if (showFallback) {\r\n        const nextFallbackChildren = nextProps.fallback;\r\n              const nextPrimaryChildren = nextProps.children;\r\n              const fallbackChildFragment = updateSuspenseFallbackChildren(\r\n              current,\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              nextFallbackChildren,\r\n              renderLanes,\r\n              );\r\n              const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n              const prevOffscreenState: OffscreenState | null = (current.child: any)\r\n              .memoizedState;\r\n              primaryChildFragment.memoizedState =\r\n              prevOffscreenState === null\r\n              ? mountSuspenseOffscreenState(renderLanes)\r\n              : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\r\n              if (enableTransitionTracing) {\r\n          const currentTransitions = getSuspendedTransitions();\r\n              if (currentTransitions !== null) {\r\n            const primaryChildUpdateQueue: OffscreenQueue = {\r\n                transitions: currentTransitions,\r\n            };\r\n              primaryChildFragment.updateQueue = primaryChildUpdateQueue;\r\n          }\r\n        }\r\n              primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(\r\n              current,\r\n              renderLanes,\r\n              );\r\n              workInProgress.memoizedState = SUSPENDED_MARKER;\r\n              return fallbackChildFragment;\r\n      } else {\r\n        const nextPrimaryChildren = nextProps.children;\r\n              const primaryChildFragment = updateSuspensePrimaryChildren(\r\n              current,\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              renderLanes,\r\n              );\r\n              workInProgress.memoizedState = null;\r\n              return primaryChildFragment;\r\n      }\r\n    } else {\r\n      // The current tree is not already showing a fallback.\r\n      if (showFallback) {\r\n        // Timed out.\r\n        const nextFallbackChildren = nextProps.fallback;\r\n              const nextPrimaryChildren = nextProps.children;\r\n              const fallbackChildFragment = updateSuspenseFallbackChildren(\r\n              current,\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              nextFallbackChildren,\r\n              renderLanes,\r\n              );\r\n              const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n              const prevOffscreenState: OffscreenState | null = (current.child: any)\r\n              .memoizedState;\r\n              primaryChildFragment.memoizedState =\r\n              prevOffscreenState === null\r\n              ? mountSuspenseOffscreenState(renderLanes)\r\n              : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\r\n              primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(\r\n              current,\r\n              renderLanes,\r\n              );\r\n\r\n              if (enableTransitionTracing) {\r\n          const currentTransitions = getSuspendedTransitions();\r\n              if (currentTransitions !== null) {\r\n            const primaryChildUpdateQueue: OffscreenQueue = {\r\n                transitions: currentTransitions,\r\n            };\r\n              primaryChildFragment.updateQueue = primaryChildUpdateQueue;\r\n          }\r\n        }\r\n\r\n              // Skip the primary children, and continue working on the\r\n              // fallback children.\r\n              workInProgress.memoizedState = SUSPENDED_MARKER;\r\n              return fallbackChildFragment;\r\n      } else {\r\n        // Still haven't timed out. Continue rendering the children, like we\r\n        // normally do.\r\n        const nextPrimaryChildren = nextProps.children;\r\n              const primaryChildFragment = updateSuspensePrimaryChildren(\r\n              current,\r\n              workInProgress,\r\n              nextPrimaryChildren,\r\n              renderLanes,\r\n              );\r\n              workInProgress.memoizedState = null;\r\n              return primaryChildFragment;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n              function mountSuspensePrimaryChildren(\r\n              workInProgress,\r\n              primaryChildren,\r\n              renderLanes,\r\n              ) {\r\n  const mode = workInProgress.mode;\r\n              const primaryChildProps: OffscreenProps = {\r\n                mode: 'visible',\r\n              children: primaryChildren,\r\n  };\r\n              const primaryChildFragment = mountWorkInProgressOffscreenFiber(\r\n              primaryChildProps,\r\n              mode,\r\n              renderLanes,\r\n              );\r\n              primaryChildFragment.return = workInProgress;\r\n              workInProgress.child = primaryChildFragment;\r\n              return primaryChildFragment;\r\n}\r\n\r\n              function mountSuspenseFallbackChildren(\r\n              workInProgress,\r\n              primaryChildren,\r\n              fallbackChildren,\r\n              renderLanes,\r\n              ) {\r\n  const mode = workInProgress.mode;\r\n              const progressedPrimaryFragment: Fiber | null = workInProgress.child;\r\n\r\n              const primaryChildProps: OffscreenProps = {\r\n                mode: 'hidden',\r\n              children: primaryChildren,\r\n  };\r\n\r\n              let primaryChildFragment;\r\n              let fallbackChildFragment;\r\n              if (\r\n              (mode & ConcurrentMode) === NoMode &&\r\n              progressedPrimaryFragment !== null\r\n              ) {\r\n                // In legacy mode, we commit the primary tree as if it successfully\r\n                // completed, even though it's in an inconsistent state.\r\n                primaryChildFragment = progressedPrimaryFragment;\r\n              primaryChildFragment.childLanes = NoLanes;\r\n              primaryChildFragment.pendingProps = primaryChildProps;\r\n\r\n              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\r\n                // Reset the durations from the first pass so they aren't included in the\r\n                // final amounts. This seems counterintuitive, since we're intentionally\r\n                // not measuring part of the render phase, but this makes it match what we\r\n                // do in Concurrent Mode.\r\n                primaryChildFragment.actualDuration = 0;\r\n              primaryChildFragment.actualStartTime = -1;\r\n              primaryChildFragment.selfBaseDuration = 0;\r\n              primaryChildFragment.treeBaseDuration = 0;\r\n    }\r\n\r\n              fallbackChildFragment = createFiberFromFragment(\r\n              fallbackChildren,\r\n              mode,\r\n              renderLanes,\r\n              null,\r\n              );\r\n  } else {\r\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(\r\n                  primaryChildProps,\r\n                  mode,\r\n                  NoLanes,\r\n                );\r\n              fallbackChildFragment = createFiberFromFragment(\r\n              fallbackChildren,\r\n              mode,\r\n              renderLanes,\r\n              null,\r\n              );\r\n  }\r\n\r\n              primaryChildFragment.return = workInProgress;\r\n              fallbackChildFragment.return = workInProgress;\r\n              primaryChildFragment.sibling = fallbackChildFragment;\r\n              workInProgress.child = primaryChildFragment;\r\n              return fallbackChildFragment;\r\n}\r\n\r\n              function mountWorkInProgressOffscreenFiber(\r\n              offscreenProps: OffscreenProps,\r\n              mode: TypeOfMode,\r\n              renderLanes: Lanes,\r\n              ) {\r\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\r\n  // this wrapper function to constrain it.\r\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\r\n}\r\n\r\n              function updateWorkInProgressOffscreenFiber(\r\n              current: Fiber,\r\n              offscreenProps: OffscreenProps,\r\n              ) {\r\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\r\n  // wrapper function to constrain it.\r\n  return createWorkInProgress(current, offscreenProps);\r\n}\r\n\r\n              function updateSuspensePrimaryChildren(\r\n              current,\r\n              workInProgress,\r\n              primaryChildren,\r\n              renderLanes,\r\n              ) {\r\n  const currentPrimaryChildFragment: Fiber = (current.child: any);\r\n              const currentFallbackChildFragment: Fiber | null =\r\n              currentPrimaryChildFragment.sibling;\r\n\r\n              const primaryChildFragment = updateWorkInProgressOffscreenFiber(\r\n              currentPrimaryChildFragment,\r\n              {\r\n                mode: 'visible',\r\n              children: primaryChildren,\r\n    },\r\n              );\r\n              if ((workInProgress.mode & ConcurrentMode) === NoMode) {\r\n                primaryChildFragment.lanes = renderLanes;\r\n  }\r\n              primaryChildFragment.return = workInProgress;\r\n              primaryChildFragment.sibling = null;\r\n              if (currentFallbackChildFragment !== null) {\r\n    // Delete the fallback child fragment\r\n    const deletions = workInProgress.deletions;\r\n              if (deletions === null) {\r\n                workInProgress.deletions = [currentFallbackChildFragment];\r\n              workInProgress.flags |= ChildDeletion;\r\n    } else {\r\n                deletions.push(currentFallbackChildFragment);\r\n    }\r\n  }\r\n\r\n              workInProgress.child = primaryChildFragment;\r\n              return primaryChildFragment;\r\n}\r\n\r\n              function updateSuspenseFallbackChildren(\r\n              current,\r\n              workInProgress,\r\n              primaryChildren,\r\n              fallbackChildren,\r\n              renderLanes,\r\n              ) {\r\n  const mode = workInProgress.mode;\r\n              const currentPrimaryChildFragment: Fiber = (current.child: any);\r\n              const currentFallbackChildFragment: Fiber | null =\r\n              currentPrimaryChildFragment.sibling;\r\n\r\n              const primaryChildProps: OffscreenProps = {\r\n                mode: 'hidden',\r\n              children: primaryChildren,\r\n  };\r\n\r\n              let primaryChildFragment;\r\n              if (\r\n              // In legacy mode, we commit the primary tree as if it successfully\r\n              // completed, even though it's in an inconsistent state.\r\n              (mode & ConcurrentMode) === NoMode &&\r\n              // Make sure we're on the second pass, i.e. the primary child fragment was\r\n              // already cloned. In legacy mode, the only case where this isn't true is\r\n              // when DevTools forces us to display a fallback; we skip the first render\r\n              // pass entirely and go straight to rendering the fallback. (In Concurrent\r\n              // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\r\n              // only codepath.)\r\n              workInProgress.child !== currentPrimaryChildFragment\r\n              ) {\r\n    const progressedPrimaryFragment: Fiber = (workInProgress.child: any);\r\n              primaryChildFragment = progressedPrimaryFragment;\r\n              primaryChildFragment.childLanes = NoLanes;\r\n              primaryChildFragment.pendingProps = primaryChildProps;\r\n\r\n              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\r\n                // Reset the durations from the first pass so they aren't included in the\r\n                // final amounts. This seems counterintuitive, since we're intentionally\r\n                // not measuring part of the render phase, but this makes it match what we\r\n                // do in Concurrent Mode.\r\n                primaryChildFragment.actualDuration = 0;\r\n              primaryChildFragment.actualStartTime = -1;\r\n              primaryChildFragment.selfBaseDuration =\r\n              currentPrimaryChildFragment.selfBaseDuration;\r\n              primaryChildFragment.treeBaseDuration =\r\n              currentPrimaryChildFragment.treeBaseDuration;\r\n    }\r\n\r\n              if (enablePersistentOffscreenHostContainer && supportsPersistence) {\r\n      // In persistent mode, the offscreen children are wrapped in a host node.\r\n      // We need to complete it now, because we're going to skip over its normal\r\n      // complete phase and go straight to rendering the fallback.\r\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\r\n              const offscreenContainer: Fiber = (primaryChildFragment.child: any);\r\n              const containerProps = getOffscreenContainerProps(\r\n              'hidden',\r\n              primaryChildren,\r\n              );\r\n              offscreenContainer.pendingProps = containerProps;\r\n              offscreenContainer.memoizedProps = containerProps;\r\n              completeSuspendedOffscreenHostContainer(\r\n              currentOffscreenContainer,\r\n              offscreenContainer,\r\n              );\r\n    }\r\n\r\n              // The fallback fiber was added as a deletion during the first pass.\r\n              // However, since we're going to remain on the fallback, we no longer want\r\n              // to delete it.\r\n              workInProgress.deletions = null;\r\n  } else {\r\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(\r\n                  currentPrimaryChildFragment,\r\n                  primaryChildProps,\r\n                );\r\n\r\n              if (enablePersistentOffscreenHostContainer && supportsPersistence) {\r\n      // In persistent mode, the offscreen children are wrapped in a host node.\r\n      // We need to complete it now, because we're going to skip over its normal\r\n      // complete phase and go straight to rendering the fallback.\r\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\r\n              if (currentOffscreenContainer !== null) {\r\n        const isHidden = true;\r\n              const offscreenContainer = reconcileOffscreenHostContainer(\r\n              currentPrimaryChildFragment,\r\n              primaryChildFragment,\r\n              isHidden,\r\n              primaryChildren,\r\n              renderLanes,\r\n              );\r\n              offscreenContainer.memoizedProps = offscreenContainer.pendingProps;\r\n              completeSuspendedOffscreenHostContainer(\r\n              currentOffscreenContainer,\r\n              offscreenContainer,\r\n              );\r\n      }\r\n    }\r\n\r\n              // Since we're reusing a current tree, we need to reuse the flags, too.\r\n              // (We don't do this in legacy mode, because in legacy mode we don't re-use\r\n              // the current tree; see previous branch.)\r\n              primaryChildFragment.subtreeFlags =\r\n              currentPrimaryChildFragment.subtreeFlags & StaticMask;\r\n  }\r\n              let fallbackChildFragment;\r\n              if (currentFallbackChildFragment !== null) {\r\n                fallbackChildFragment = createWorkInProgress(\r\n                  currentFallbackChildFragment,\r\n                  fallbackChildren,\r\n                );\r\n  } else {\r\n                fallbackChildFragment = createFiberFromFragment(\r\n                  fallbackChildren,\r\n                  mode,\r\n                  renderLanes,\r\n                  null,\r\n                );\r\n              // Needs a placement effect because the parent (the Suspense boundary) already\r\n              // mounted but this is a new fiber.\r\n              fallbackChildFragment.flags |= Placement;\r\n  }\r\n\r\n              fallbackChildFragment.return = workInProgress;\r\n              primaryChildFragment.return = workInProgress;\r\n              primaryChildFragment.sibling = fallbackChildFragment;\r\n              workInProgress.child = primaryChildFragment;\r\n\r\n              return fallbackChildFragment;\r\n}\r\n\r\n              function retrySuspenseComponentWithoutHydrating(\r\n              current: Fiber,\r\n              workInProgress: Fiber,\r\n              renderLanes: Lanes,\r\n              recoverableError: Error | null,\r\n              ) {\r\n  // Falling back to client rendering. Because this has performance\r\n  // implications, it's considered a recoverable error, even though the user\r\n  // likely won't observe anything wrong with the UI.\r\n  //\r\n  // The error is passed in as an argument to enforce that every caller provide\r\n  // a custom message, or explicitly opt out (currently the only path that opts\r\n  // out is legacy mode; every concurrent path provides an error).\r\n  if (recoverableError !== null) {\r\n                queueHydrationError(recoverableError);\r\n  }\r\n\r\n              // This will add the old fiber to the deletion list\r\n              reconcileChildFibers(workInProgress, current.child, null, renderLanes);\r\n\r\n              // We're now not suspended nor dehydrated.\r\n              const nextProps = workInProgress.pendingProps;\r\n              const primaryChildren = nextProps.children;\r\n              const primaryChildFragment = mountSuspensePrimaryChildren(\r\n              workInProgress,\r\n              primaryChildren,\r\n              renderLanes,\r\n              );\r\n              // Needs a placement effect because the parent (the Suspense boundary) already\r\n              // mounted but this is a new fiber.\r\n              primaryChildFragment.flags |= Placement;\r\n              workInProgress.memoizedState = null;\r\n\r\n              return primaryChildFragment;\r\n}\r\n\r\n              function mountSuspenseFallbackAfterRetryWithoutHydrating(\r\n              current,\r\n              workInProgress,\r\n              primaryChildren,\r\n              fallbackChildren,\r\n              renderLanes,\r\n              ) {\r\n  const fiberMode = workInProgress.mode;\r\n              const primaryChildProps: OffscreenProps = {\r\n                mode: 'visible',\r\n              children: primaryChildren,\r\n  };\r\n              const primaryChildFragment = mountWorkInProgressOffscreenFiber(\r\n              primaryChildProps,\r\n              fiberMode,\r\n              NoLanes,\r\n              );\r\n              const fallbackChildFragment = createFiberFromFragment(\r\n              fallbackChildren,\r\n              fiberMode,\r\n              renderLanes,\r\n              null,\r\n              );\r\n              // Needs a placement effect because the parent (the Suspense\r\n              // boundary) already mounted but this is a new fiber.\r\n              fallbackChildFragment.flags |= Placement;\r\n\r\n              primaryChildFragment.return = workInProgress;\r\n              fallbackChildFragment.return = workInProgress;\r\n              primaryChildFragment.sibling = fallbackChildFragment;\r\n              workInProgress.child = primaryChildFragment;\r\n\r\n              if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\r\n                // We will have dropped the effect list which contains the\r\n                // deletion. We need to reconcile to delete the current child.\r\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\r\n  }\r\n\r\n              return fallbackChildFragment;\r\n}\r\n\r\n              function mountDehydratedSuspenseComponent(\r\n              workInProgress: Fiber,\r\n              suspenseInstance: SuspenseInstance,\r\n              renderLanes: Lanes,\r\n              ): null | Fiber {\r\n  // During the first pass, we'll bail out and not drill into the children.\r\n  // Instead, we'll leave the content in place and try to hydrate it later.\r\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\r\n    if (__DEV__) {\r\n                console.error(\r\n                  'Cannot hydrate Suspense in legacy mode. Switch from ' +\r\n                  'ReactDOM.hydrate(element, container) to ' +\r\n                  'ReactDOMClient.hydrateRoot(container, <App />)' +\r\n                  '.render(element) or remove the Suspense components from ' +\r\n                  'the server rendered components.',\r\n                );\r\n    }\r\n              workInProgress.lanes = laneToLanes(SyncLane);\r\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\r\n                // This is a client-only boundary. Since we won't get any content from the server\r\n                // for this, we need to schedule that at a higher priority based on when it would\r\n                // have timed out. In theory we could render it in this pass but it would have the\r\n                // wrong priority associated with it and will prevent hydration of parent path.\r\n                // Instead, we'll leave work left on it to render it in a separate commit.\r\n\r\n                // TODO This time should be the time at which the server rendered response that is\r\n                // a parent to this boundary was displayed. However, since we currently don't have\r\n                // a protocol to transfer that time, we'll just estimate it by using the current\r\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\r\n                // they should be.\r\n                // Schedule a normal pri update to render this content.\r\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\r\n  } else {\r\n                // We'll continue hydrating the rest at offscreen priority since we'll already\r\n                // be showing the right content coming from the server, it is no rush.\r\n                workInProgress.lanes = laneToLanes(OffscreenLane);\r\n  }\r\n              return null;\r\n}\r\n\r\n              function updateDehydratedSuspenseComponent(\r\n              current: Fiber,\r\n              workInProgress: Fiber,\r\n              suspenseInstance: SuspenseInstance,\r\n              suspenseState: SuspenseState,\r\n              renderLanes: Lanes,\r\n              ): null | Fiber {\r\n                // We should never be hydrating at this point because it is the first pass,\r\n                // but after we've already committed once.\r\n                warnIfHydrating();\r\n\r\n              if ((workInProgress.mode & ConcurrentMode) === NoMode) {\r\n    return retrySuspenseComponentWithoutHydrating(\r\n              current,\r\n              workInProgress,\r\n              renderLanes,\r\n              // TODO: When we delete legacy mode, we should make this error argument\r\n              // required — every concurrent mode path that causes hydration to\r\n              // de-opt to client rendering should have an error message.\r\n              null,\r\n              );\r\n  }\r\n\r\n              if (isSuspenseInstanceFallback(suspenseInstance)) {\r\n    // This boundary is in a permanent fallback state. In this case, we'll never\r\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\r\n    // client side render instead.\r\n    return retrySuspenseComponentWithoutHydrating(\r\n              current,\r\n              workInProgress,\r\n              renderLanes,\r\n              // TODO: The server should serialize the error message so we can log it\r\n              // here on the client. Or, in production, a hash/id that corresponds to\r\n              // the error.\r\n              new Error(\r\n              'The server could not finish this Suspense boundary, likely ' +\r\n              'due to an error during server rendering. Switched to ' +\r\n              'client rendering.',\r\n              ),\r\n              );\r\n  }\r\n\r\n              if (\r\n              enableLazyContextPropagation &&\r\n              // TODO: Factoring is a little weird, since we check this right below, too.\r\n              // But don't want to re-arrange the if-else chain until/unless this\r\n              // feature lands.\r\n              !didReceiveUpdate\r\n              ) {\r\n                // We need to check if any children have context before we decide to bail\r\n                // out, so propagate the changes now.\r\n                lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\r\n  }\r\n\r\n              // We use lanes to indicate that a child might depend on context, so if\r\n              // any context has changed, we need to treat is as if the input might have changed.\r\n              const hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\r\n              if (didReceiveUpdate || hasContextChanged) {\r\n    // This boundary has changed since the first render. This means that we are now unable to\r\n    // hydrate it. We might still be able to hydrate it using a higher priority lane.\r\n    const root = getWorkInProgressRoot();\r\n              if (root !== null) {\r\n      const attemptHydrationAtLane = getBumpedLaneForHydration(\r\n              root,\r\n              renderLanes,\r\n              );\r\n              if (\r\n              attemptHydrationAtLane !== NoLane &&\r\n              attemptHydrationAtLane !== suspenseState.retryLane\r\n              ) {\r\n                // Intentionally mutating since this render will get interrupted. This\r\n                // is one of the very rare times where we mutate the current tree\r\n                // during the render phase.\r\n                suspenseState.retryLane = attemptHydrationAtLane;\r\n              // TODO: Ideally this would inherit the event time of the current render\r\n              const eventTime = NoTimestamp;\r\n              scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\r\n      } else {\r\n                // We have already tried to ping at a higher priority than we're rendering with\r\n                // so if we got here, we must have failed to hydrate at those levels. We must\r\n                // now give up. Instead, we're going to delete the whole subtree and instead inject\r\n                // a new real Suspense boundary to take its place, which may render content\r\n                // or fallback. This might suspend for a while and if it does we might still have\r\n                // an opportunity to hydrate before this pass commits.\r\n              }\r\n    }\r\n\r\n              // If we have scheduled higher pri work above, this will probably just abort the render\r\n              // since we now have higher priority work, but in case it doesn't, we need to prepare to\r\n              // render something, if we time out. Even if that requires us to delete everything and\r\n              // skip hydration.\r\n              // Delay having to do this as long as the suspense timeout allows us.\r\n              renderDidSuspendDelayIfPossible();\r\n              return retrySuspenseComponentWithoutHydrating(\r\n              current,\r\n              workInProgress,\r\n              renderLanes,\r\n              new Error(\r\n              'This Suspense boundary received an update before it finished ' +\r\n              'hydrating. This caused the boundary to switch to client rendering. ' +\r\n              'The usual way to fix this is to wrap the original update ' +\r\n              'in startTransition.',\r\n              ),\r\n              );\r\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\r\n                // This component is still pending more data from the server, so we can't hydrate its\r\n                // content. We treat it as if this component suspended itself. It might seem as if\r\n                // we could just try to render it client-side instead. However, this will perform a\r\n                // lot of unnecessary work and is unlikely to complete since it often will suspend\r\n                // on missing data anyway. Additionally, the server might be able to render more\r\n                // than we can on the client yet. In that case we'd end up with more fallback states\r\n                // on the client than if we just leave it alone. If the server times out or errors\r\n                // these should update this boundary to the permanent Fallback state instead.\r\n                // Mark it as having captured (i.e. suspended).\r\n                workInProgress.flags |= DidCapture;\r\n              // Leave the child in place. I.e. the dehydrated fragment.\r\n              workInProgress.child = current.child;\r\n              // Register a callback to retry this boundary once the server has sent the result.\r\n              const retry = retryDehydratedSuspenseBoundary.bind(null, current);\r\n              registerSuspenseInstanceRetry(suspenseInstance, retry);\r\n              return null;\r\n  } else {\r\n                // This is the first attempt.\r\n                reenterHydrationStateFromDehydratedSuspenseInstance(\r\n                  workInProgress,\r\n                  suspenseInstance,\r\n                  suspenseState.treeContext,\r\n                );\r\n              const nextProps = workInProgress.pendingProps;\r\n              const primaryChildren = nextProps.children;\r\n              const primaryChildFragment = mountSuspensePrimaryChildren(\r\n              workInProgress,\r\n              primaryChildren,\r\n              renderLanes,\r\n              );\r\n              // Mark the children as hydrating. This is a fast path to know whether this\r\n              // tree is part of a hydrating tree. This is used to determine if a child\r\n              // node has fully mounted yet, and for scheduling event replaying.\r\n              // Conceptually this is similar to Placement in that a new subtree is\r\n              // inserted into the React tree here. It just happens to not need DOM\r\n              // mutations because it already exists.\r\n              primaryChildFragment.flags |= Hydrating;\r\n              return primaryChildFragment;\r\n  }\r\n}\r\n\r\n              function scheduleSuspenseWorkOnFiber(\r\n              fiber: Fiber,\r\n              renderLanes: Lanes,\r\n              propagationRoot: Fiber,\r\n              ) {\r\n                fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\r\n              const alternate = fiber.alternate;\r\n              if (alternate !== null) {\r\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\r\n  }\r\n              scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\r\n}\r\n\r\n              function propagateSuspenseContextChange(\r\n              workInProgress: Fiber,\r\n              firstChild: null | Fiber,\r\n              renderLanes: Lanes,\r\n              ): void {\r\n                // Mark any Suspense boundaries with fallbacks as having work to do.\r\n                // If they were previously forced into fallbacks, they may now be able\r\n                // to unblock.\r\n                let node = firstChild;\r\n              while (node !== null) {\r\n    if (node.tag === SuspenseComponent) {\r\n      const state: SuspenseState | null = node.memoizedState;\r\n              if (state !== null) {\r\n                scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\r\n      }\r\n    } else if (node.tag === SuspenseListComponent) {\r\n                // If the tail is hidden there might not be an Suspense boundaries\r\n                // to schedule work on. In this case we have to schedule it on the\r\n                // list itself.\r\n                // We don't have to traverse to the children of the list since\r\n                // the list will propagate the change when it rerenders.\r\n                scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\r\n    } else if (node.child !== null) {\r\n                node.child.return = node;\r\n              node = node.child;\r\n              continue;\r\n    }\r\n              if (node === workInProgress) {\r\n      return;\r\n    }\r\n              while (node.sibling === null) {\r\n      if (node.return === null || node.return === workInProgress) {\r\n        return;\r\n      }\r\n              node = node.return;\r\n    }\r\n              node.sibling.return = node.return;\r\n              node = node.sibling;\r\n  }\r\n}\r\n\r\n              function findLastContentRow(firstChild: null | Fiber): null | Fiber {\r\n                // This is going to find the last row among these children that is already\r\n                // showing content on the screen, as opposed to being in fallback state or\r\n                // new. If a row has multiple Suspense boundaries, any of them being in the\r\n                // fallback state, counts as the whole row being in a fallback state.\r\n                // Note that the \"rows\" will be workInProgress, but any nested children\r\n                // will still be current since we haven't rendered them yet. The mounted\r\n                // order may not be the same as the new order. We use the new order.\r\n                let row = firstChild;\r\n              let lastContentRow: null | Fiber = null;\r\n              while (row !== null) {\r\n    const currentRow = row.alternate;\r\n              // New rows can't be content rows.\r\n              if (currentRow !== null && findFirstSuspended(currentRow) === null) {\r\n                lastContentRow = row;\r\n    }\r\n              row = row.sibling;\r\n  }\r\n              return lastContentRow;\r\n}\r\n\r\n              type SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void;\r\n\r\n              function validateRevealOrder(revealOrder: SuspenseListRevealOrder) {\r\n  if (__DEV__) {\r\n    if (\r\n              revealOrder !== undefined &&\r\n              revealOrder !== 'forwards' &&\r\n              revealOrder !== 'backwards' &&\r\n              revealOrder !== 'together' &&\r\n              !didWarnAboutRevealOrder[revealOrder]\r\n              ) {\r\n                didWarnAboutRevealOrder[revealOrder] = true;\r\n              if (typeof revealOrder === 'string') {\r\n        switch (revealOrder.toLowerCase()) {\r\n          case 'together':\r\n              case 'forwards':\r\n              case 'backwards': {\r\n                console.error(\r\n                  '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\r\n                  'Use lowercase \"%s\" instead.',\r\n                  revealOrder,\r\n                  revealOrder.toLowerCase(),\r\n                );\r\n              break;\r\n          }\r\n              case 'forward':\r\n              case 'backward': {\r\n                console.error(\r\n                  '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\r\n                  'React uses the -s suffix in the spelling. Use \"%ss\" instead.',\r\n                  revealOrder,\r\n                  revealOrder.toLowerCase(),\r\n                );\r\n              break;\r\n          }\r\n              default:\r\n              console.error(\r\n              '\"%s\" is not a supported revealOrder on <SuspenseList />. ' +\r\n              'Did you mean \"together\", \"forwards\" or \"backwards\"?',\r\n              revealOrder,\r\n              );\r\n              break;\r\n        }\r\n      } else {\r\n                console.error(\r\n                  '%s is not a supported value for revealOrder on <SuspenseList />. ' +\r\n                  'Did you mean \"together\", \"forwards\" or \"backwards\"?',\r\n                  revealOrder,\r\n                );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n              function validateTailOptions(\r\n              tailMode: SuspenseListTailMode,\r\n              revealOrder: SuspenseListRevealOrder,\r\n              ) {\r\n  if (__DEV__) {\r\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\r\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\r\n                didWarnAboutTailOptions[tailMode] = true;\r\n              console.error(\r\n              '\"%s\" is not a supported value for tail on <SuspenseList />. ' +\r\n              'Did you mean \"collapsed\" or \"hidden\"?',\r\n              tailMode,\r\n              );\r\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\r\n                didWarnAboutTailOptions[tailMode] = true;\r\n              console.error(\r\n              '<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' +\r\n              '\"forwards\" or \"backwards\". ' +\r\n              'Did you mean to specify revealOrder=\"forwards\"?',\r\n              tailMode,\r\n              );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n              function validateSuspenseListNestedChild(childSlot: mixed, index: number) {\r\n  if (__DEV__) {\r\n    const isAnArray = isArray(childSlot);\r\n              const isIterable =\r\n              !isAnArray && typeof getIteratorFn(childSlot) === 'function';\r\n              if (isAnArray || isIterable) {\r\n      const type = isAnArray ? 'array' : 'iterable';\r\n              console.error(\r\n              'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +\r\n              'an additional SuspenseList to configure its revealOrder: ' +\r\n              '<SuspenseList revealOrder=...> ... ' +\r\n              '<SuspenseList revealOrder=...>{% s}</SuspenseList> ... ' +\r\n            '</SuspenseList>',\r\n              type,\r\n              index,\r\n              type,\r\n      );\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n\r\n      function validateSuspenseListChildren (\r\n        children: mixed,\r\n        revealOrder: SuspenseListRevealOrder,\r\n      ) {\r\n        if (__DEV__) {\r\n          if (\r\n            (revealOrder === 'forwards' || revealOrder === 'backwards') &&\r\n            children !== undefined &&\r\n            children !== null &&\r\n            children !== false\r\n          ) {\r\n            if (isArray(children)) {\r\n              for (let i = 0; i < children.length; i++) {\r\n                if (!validateSuspenseListNestedChild(children[i], i)) {\r\n                  return;\r\n                }\r\n              }\r\n            } else {\r\n              const iteratorFn = getIteratorFn(children);\r\n              if (typeof iteratorFn === 'function') {\r\n                const childrenIterator = iteratorFn.call(children);\r\n                if (childrenIterator) {\r\n                  let step = childrenIterator.next();\r\n                  let i = 0;\r\n                  for (; !step.done; step = childrenIterator.next()) {\r\n                    if (!validateSuspenseListNestedChild(step.value, i)) {\r\n                      return;\r\n                    }\r\n                    i++;\r\n                  }\r\n                }\r\n              } else {\r\n                console.error(\r\n                  'A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' +\r\n                  'This is not useful since it needs multiple rows. ' +\r\n                  'Did you mean to pass multiple children or an array?',\r\n                  revealOrder,\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      function initSuspenseListRenderState (\r\n        workInProgress: Fiber,\r\n        isBackwards: boolean,\r\n        tail: null | Fiber,\r\n        lastContentRow: null | Fiber,\r\n        tailMode: SuspenseListTailMode,\r\n      ): void {\r\n        const renderState: null | SuspenseListRenderState =\r\n          workInProgress.memoizedState;\r\n        if (renderState === null) {\r\n          workInProgress.memoizedState = ({\r\n            isBackwards: isBackwards,\r\n            rendering: null,\r\n            renderingStartTime: 0,\r\n            last: lastContentRow,\r\n            tail: tail,\r\n            tailMode: tailMode,\r\n          }: SuspenseListRenderState);\r\n        } else {\r\n          // We can reuse the existing object from previous renders.\r\n          renderState.isBackwards = isBackwards;\r\n          renderState.rendering = null;\r\n          renderState.renderingStartTime = 0;\r\n          renderState.last = lastContentRow;\r\n          renderState.tail = tail;\r\n          renderState.tailMode = tailMode;\r\n        }\r\n      }\r\n\r\n      // This can end up rendering this component multiple passes.\r\n      // The first pass splits the children fibers into two sets. A head and tail.\r\n      // We first render the head. If anything is in fallback state, we do another\r\n      // pass through beginWork to rerender all children (including the tail) with\r\n      // the force suspend context. If the first render didn't have anything in\r\n      // in fallback state. Then we render each row in the tail one-by-one.\r\n      // That happens in the completeWork phase without going back to beginWork.\r\n      function updateSuspenseListComponent (\r\n        current: Fiber | null,\r\n        workInProgress: Fiber,\r\n        renderLanes: Lanes,\r\n      ) {\r\n        const nextProps = workInProgress.pendingProps;\r\n        const revealOrder: SuspenseListRevealOrder = nextProps.revealOrder;\r\n        const tailMode: SuspenseListTailMode = nextProps.tail;\r\n        const newChildren = nextProps.children;\r\n\r\n        validateRevealOrder(revealOrder);\r\n        validateTailOptions(tailMode, revealOrder);\r\n        validateSuspenseListChildren(newChildren, revealOrder);\r\n\r\n        reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n\r\n        let suspenseContext: SuspenseContext = suspenseStackCursor.current;\r\n\r\n        const shouldForceFallback = hasSuspenseContext(\r\n          suspenseContext,\r\n          (ForceSuspenseFallback: SuspenseContext),\r\n        );\r\n        if (shouldForceFallback) {\r\n          suspenseContext = setShallowSuspenseContext(\r\n            suspenseContext,\r\n            ForceSuspenseFallback,\r\n          );\r\n          workInProgress.flags |= DidCapture;\r\n        } else {\r\n          const didSuspendBefore =\r\n            current !== null && (current.flags & DidCapture) !== NoFlags;\r\n          if (didSuspendBefore) {\r\n            // If we previously forced a fallback, we need to schedule work\r\n            // on any nested boundaries to let them know to try to render\r\n            // again. This is the same as context updating.\r\n            propagateSuspenseContextChange(\r\n              workInProgress,\r\n              workInProgress.child,\r\n              renderLanes,\r\n            );\r\n          }\r\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n        }\r\n        pushSuspenseContext(workInProgress, suspenseContext);\r\n\r\n        if ((workInProgress.mode & ConcurrentMode) === NoMode) {\r\n          // In legacy mode, SuspenseList doesn't work so we just\r\n          // use make it a noop by treating it as the default revealOrder.\r\n          workInProgress.memoizedState = null;\r\n        } else {\r\n          switch (revealOrder) {\r\n            case 'forwards': {\r\n              const lastContentRow = findLastContentRow(workInProgress.child);\r\n              let tail;\r\n              if (lastContentRow === null) {\r\n                // The whole list is part of the tail.\r\n                // TODO: We could fast path by just rendering the tail now.\r\n                tail = workInProgress.child;\r\n                workInProgress.child = null;\r\n              } else {\r\n                // Disconnect the tail rows after the content row.\r\n                // We're going to render them separately later.\r\n                tail = lastContentRow.sibling;\r\n                lastContentRow.sibling = null;\r\n              }\r\n              initSuspenseListRenderState(\r\n                workInProgress,\r\n                false, // isBackwards\r\n                tail,\r\n                lastContentRow,\r\n                tailMode,\r\n              );\r\n              break;\r\n            }\r\n            case 'backwards': {\r\n              // We're going to find the first row that has existing content.\r\n              // At the same time we're going to reverse the list of everything\r\n              // we pass in the meantime. That's going to be our tail in reverse\r\n              // order.\r\n              let tail = null;\r\n              let row = workInProgress.child;\r\n              workInProgress.child = null;\r\n              while (row !== null) {\r\n                const currentRow = row.alternate;\r\n                // New rows can't be content rows.\r\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\r\n                  // This is the beginning of the main content.\r\n                  workInProgress.child = row;\r\n                  break;\r\n                }\r\n                const nextRow = row.sibling;\r\n                row.sibling = tail;\r\n                tail = row;\r\n                row = nextRow;\r\n              }\r\n              // TODO: If workInProgress.child is null, we can continue on the tail immediately.\r\n              initSuspenseListRenderState(\r\n                workInProgress,\r\n                true, // isBackwards\r\n                tail,\r\n                null, // last\r\n                tailMode,\r\n              );\r\n              break;\r\n            }\r\n            case 'together': {\r\n              initSuspenseListRenderState(\r\n                workInProgress,\r\n                false, // isBackwards\r\n                null, // tail\r\n                null, // last\r\n                undefined,\r\n              );\r\n              break;\r\n            }\r\n            default: {\r\n              // The default reveal order is the same as not having\r\n              // a boundary.\r\n              workInProgress.memoizedState = null;\r\n            }\r\n          }\r\n        }\r\n        return workInProgress.child;\r\n      }\r\n\r\n      function updatePortalComponent (\r\n        current: Fiber | null,\r\n        workInProgress: Fiber,\r\n        renderLanes: Lanes,\r\n      ) {\r\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\r\n        const nextChildren = workInProgress.pendingProps;\r\n        if (current === null) {\r\n          // Portals are special because we don't append the children during mount\r\n          // but at commit. Therefore we need to track insertions which the normal\r\n          // flow doesn't do during mount. This doesn't happen at the root because\r\n          // the root always starts with a \"current\" with a null child.\r\n          // TODO: Consider unifying this with how the root works.\r\n          workInProgress.child = reconcileChildFibers(\r\n            workInProgress,\r\n            null,\r\n            nextChildren,\r\n            renderLanes,\r\n          );\r\n        } else {\r\n          reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n        }\r\n        return workInProgress.child;\r\n      }\r\n\r\n      let hasWarnedAboutUsingNoValuePropOnContextProvider = false;\r\n\r\n      function updateContextProvider (\r\n        current: Fiber | null,\r\n        workInProgress: Fiber,\r\n        renderLanes: Lanes,\r\n      ) {\r\n        const providerType: ReactProviderType<any> = workInProgress.type;\r\n        const context: ReactContext<any> = providerType._context;\r\n\r\n        const newProps = workInProgress.pendingProps;\r\n        const oldProps = workInProgress.memoizedProps;\r\n\r\n        const newValue = newProps.value;\r\n\r\n        if (__DEV__) {\r\n          if (!('value' in newProps)) {\r\n            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\r\n              hasWarnedAboutUsingNoValuePropOnContextProvider = true;\r\n              console.error(\r\n                'The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?',\r\n              );\r\n            }\r\n          }\r\n          const providerPropTypes = workInProgress.type.propTypes;\r\n\r\n          if (providerPropTypes) {\r\n            checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\r\n          }\r\n        }\r\n\r\n        pushProvider(workInProgress, context, newValue);\r\n\r\n        if (enableLazyContextPropagation) {\r\n          // In the lazy propagation implementation, we don't scan for matching\r\n          // consumers until something bails out, because until something bails out\r\n          // we're going to visit those nodes, anyway. The trade-off is that it shifts\r\n          // responsibility to the consumer to track whether something has changed.\r\n        } else {\r\n          if (oldProps !== null) {\r\n            const oldValue = oldProps.value;\r\n            if (is(oldValue, newValue)) {\r\n              // No change. Bailout early if children are the same.\r\n              if (\r\n                oldProps.children === newProps.children &&\r\n                !hasLegacyContextChanged()\r\n              ) {\r\n                return bailoutOnAlreadyFinishedWork(\r\n                  current,\r\n                  workInProgress,\r\n                  renderLanes,\r\n                );\r\n              }\r\n            } else {\r\n              // The context value changed. Search for matching consumers and schedule\r\n              // them to update.\r\n              propagateContextChange(workInProgress, context, renderLanes);\r\n            }\r\n          }\r\n        }\r\n\r\n        const newChildren = newProps.children;\r\n        reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n        return workInProgress.child;\r\n      }\r\n\r\n      let hasWarnedAboutUsingContextAsConsumer = false;\r\n\r\n      function updateContextConsumer (\r\n        current: Fiber | null,\r\n        workInProgress: Fiber,\r\n        renderLanes: Lanes,\r\n      ) {\r\n        let context: ReactContext<any> = workInProgress.type;\r\n        // The logic below for Context differs depending on PROD or DEV mode. In\r\n        // DEV mode, we create a separate object for Context.Consumer that acts\r\n        // like a proxy to Context. This proxy object adds unnecessary code in PROD\r\n        // so we use the old behaviour (Context.Consumer references Context) to\r\n        // reduce size and overhead. The separate object references context via\r\n        // a property called \"_context\", which also gives us the ability to check\r\n        // in DEV mode if this property exists or not and warn if it does not.\r\n        if (__DEV__) {\r\n          if ((context: any)._context === undefined) {\r\n            // This may be because it's a Context (rather than a Consumer).\r\n            // Or it may be because it's older React where they're the same thing.\r\n            // We only want to warn if we're sure it's a new React.\r\n            if (context !== context.Consumer) {\r\n              if (!hasWarnedAboutUsingContextAsConsumer) {\r\n                hasWarnedAboutUsingContextAsConsumer = true;\r\n                console.error(\r\n                  'Rendering <Context> directly is not supported and will be removed in ' +\r\n                  'a future major release. Did you mean to render <Context.Consumer> instead?',\r\n                );\r\n              }\r\n            }\r\n          } else {\r\n            context = (context: any)._context;\r\n          }\r\n        }\r\n        const newProps = workInProgress.pendingProps;\r\n        const render = newProps.children;\r\n\r\n        if (__DEV__) {\r\n          if (typeof render !== 'function') {\r\n            console.error(\r\n              'A context consumer was rendered with multiple children, or a child ' +\r\n              \"that isn't a function. A context consumer expects a single child \" +\r\n              'that is a function. If you did pass a function, make sure there ' +\r\n              'is no trailing or leading whitespace around it.',\r\n            );\r\n          }\r\n        }\r\n\r\n        prepareToReadContext(workInProgress, renderLanes);\r\n        const newValue = readContext(context);\r\n        if (enableSchedulingProfiler) {\r\n          markComponentRenderStarted(workInProgress);\r\n        }\r\n        let newChildren;\r\n        if (__DEV__) {\r\n          ReactCurrentOwner.current = workInProgress;\r\n          setIsRendering(true);\r\n          newChildren = render(newValue);\r\n          setIsRendering(false);\r\n        } else {\r\n          newChildren = render(newValue);\r\n        }\r\n        if (enableSchedulingProfiler) {\r\n          markComponentRenderStopped();\r\n        }\r\n\r\n        // React DevTools reads this flag.\r\n        workInProgress.flags |= PerformedWork;\r\n        reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n        return workInProgress.child;\r\n      }\r\n\r\n      function updateScopeComponent (current, workInProgress, renderLanes) {\r\n        const nextProps = workInProgress.pendingProps;\r\n        const nextChildren = nextProps.children;\r\n\r\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n        return workInProgress.child;\r\n      }\r\n\r\n      export function markWorkInProgressReceivedUpdate () {\r\n        didReceiveUpdate = true;\r\n      }\r\n\r\n      export function checkIfWorkInProgressReceivedUpdate () {\r\n        return didReceiveUpdate;\r\n      }\r\n\r\n      function bailoutOnAlreadyFinishedWork (\r\n        current: Fiber | null,\r\n        workInProgress: Fiber,\r\n        renderLanes: Lanes,\r\n      ): Fiber | null {\r\n        if (current !== null) {\r\n          // Reuse previous dependencies\r\n          workInProgress.dependencies = current.dependencies;\r\n        }\r\n\r\n        if (enableProfilerTimer) {\r\n          // Don't update \"base\" render times for bailouts.\r\n          stopProfilerTimerIfRunning(workInProgress);\r\n        }\r\n\r\n        markSkippedUpdateLanes(workInProgress.lanes);\r\n\r\n        // 判断优先级\r\n        // Check if the children have any pending work.\r\n        if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\r\n          // The children don't have any work either. We can skip them.\r\n          // TODO: Once we add back resuming, we should check if the children are\r\n          // a work-in-progress set. If so, we need to transfer their effects.\r\n\r\n          if (enableLazyContextPropagation && current !== null) {\r\n            // Before bailing out, check if there are any context changes in\r\n            // the children.\r\n            lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\r\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\r\n              return null;\r\n            }\r\n          } else {\r\n            return null;\r\n          }\r\n        }\r\n\r\n        // This fiber doesn't have work, but its subtree does. Clone the child\r\n        // fibers and continue.\r\n        cloneChildFibers(current, workInProgress);\r\n        return workInProgress.child;\r\n      }\r\n\r\n      function remountFiber (\r\n        current: Fiber,\r\n        oldWorkInProgress: Fiber,\r\n        newWorkInProgress: Fiber,\r\n      ): Fiber | null {\r\n        if (__DEV__) {\r\n          const returnFiber = oldWorkInProgress.return;\r\n          if (returnFiber === null) {\r\n            // eslint-disable-next-line react-internal/prod-error-codes\r\n            throw new Error('Cannot swap the root fiber.');\r\n          }\r\n\r\n          // Disconnect from the old current.\r\n          // It will get deleted.\r\n          current.alternate = null;\r\n          oldWorkInProgress.alternate = null;\r\n\r\n          // Connect to the new tree.\r\n          newWorkInProgress.index = oldWorkInProgress.index;\r\n          newWorkInProgress.sibling = oldWorkInProgress.sibling;\r\n          newWorkInProgress.return = oldWorkInProgress.return;\r\n          newWorkInProgress.ref = oldWorkInProgress.ref;\r\n\r\n          // Replace the child/sibling pointers above it.\r\n          if (oldWorkInProgress === returnFiber.child) {\r\n            returnFiber.child = newWorkInProgress;\r\n          } else {\r\n            let prevSibling = returnFiber.child;\r\n            if (prevSibling === null) {\r\n              // eslint-disable-next-line react-internal/prod-error-codes\r\n              throw new Error('Expected parent to have a child.');\r\n            }\r\n            while (prevSibling.sibling !== oldWorkInProgress) {\r\n              prevSibling = prevSibling.sibling;\r\n              if (prevSibling === null) {\r\n                // eslint-disable-next-line react-internal/prod-error-codes\r\n                throw new Error('Expected to find the previous sibling.');\r\n              }\r\n            }\r\n            prevSibling.sibling = newWorkInProgress;\r\n          }\r\n\r\n          // Delete the old fiber and place the new one.\r\n          // Since the old fiber is disconnected, we have to schedule it manually.\r\n          const deletions = returnFiber.deletions;\r\n          if (deletions === null) {\r\n            returnFiber.deletions = [current];\r\n            returnFiber.flags |= ChildDeletion;\r\n          } else {\r\n            deletions.push(current);\r\n          }\r\n\r\n          newWorkInProgress.flags |= Placement;\r\n\r\n          // Restart work from the new fiber.\r\n          return newWorkInProgress;\r\n        } else {\r\n          throw new Error(\r\n            'Did not expect this call in production. ' +\r\n            'This is a bug in React. Please file an issue.',\r\n          );\r\n        }\r\n      }\r\n\r\n      function checkScheduledUpdateOrContext (\r\n        current: Fiber,\r\n        renderLanes: Lanes,\r\n      ): boolean {\r\n        // Before performing an early bailout, we must check if there are pending\r\n        // updates or context.\r\n        const updateLanes = current.lanes;\r\n        if (includesSomeLane(updateLanes, renderLanes)) {\r\n          return true;\r\n        }\r\n        // No pending update, but because context is propagated lazily, we need\r\n        // to check for a context change before we bail out.\r\n        if (enableLazyContextPropagation) {\r\n          const dependencies = current.dependencies;\r\n          if (dependencies !== null && checkIfContextChanged(dependencies)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n\r\n      function attemptEarlyBailoutIfNoScheduledUpdate (\r\n        current: Fiber,\r\n        workInProgress: Fiber,\r\n        renderLanes: Lanes,\r\n      ) {\r\n        // This fiber does not have any pending work. Bailout without entering\r\n        // the begin phase. There's still some bookkeeping we that needs to be done\r\n        // in this optimized path, mostly pushing stuff onto the stack.\r\n        switch (workInProgress.tag) {\r\n          case HostRoot:\r\n            pushHostRootContext(workInProgress);\r\n            const root: FiberRoot = workInProgress.stateNode;\r\n            pushRootTransition(workInProgress, root, renderLanes);\r\n\r\n            if (enableCache) {\r\n              const cache: Cache = current.memoizedState.cache;\r\n              pushCacheProvider(workInProgress, cache);\r\n            }\r\n            resetHydrationState();\r\n            break;\r\n          case HostComponent:\r\n            pushHostContext(workInProgress);\r\n            break;\r\n          case ClassComponent: {\r\n            const Component = workInProgress.type;\r\n            if (isLegacyContextProvider(Component)) {\r\n              pushLegacyContextProvider(workInProgress);\r\n            }\r\n            break;\r\n          }\r\n          case HostPortal:\r\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\r\n            break;\r\n          case ContextProvider: {\r\n            const newValue = workInProgress.memoizedProps.value;\r\n            const context: ReactContext<any> = workInProgress.type._context;\r\n            pushProvider(workInProgress, context, newValue);\r\n            break;\r\n          }\r\n          case Profiler:\r\n            if (enableProfilerTimer) {\r\n              // Profiler should only call onRender when one of its descendants actually rendered.\r\n              const hasChildWork = includesSomeLane(\r\n                renderLanes,\r\n                workInProgress.childLanes,\r\n              );\r\n              if (hasChildWork) {\r\n                workInProgress.flags |= Update;\r\n              }\r\n\r\n              if (enableProfilerCommitHooks) {\r\n                // Reset effect durations for the next eventual effect phase.\r\n                // These are reset during render to allow the DevTools commit hook a chance to read them,\r\n                const stateNode = workInProgress.stateNode;\r\n                stateNode.effectDuration = 0;\r\n                stateNode.passiveEffectDuration = 0;\r\n              }\r\n            }\r\n            break;\r\n          case SuspenseComponent: {\r\n            const state: SuspenseState | null = workInProgress.memoizedState;\r\n            if (state !== null) {\r\n              if (state.dehydrated !== null) {\r\n                pushSuspenseContext(\r\n                  workInProgress,\r\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\r\n                );\r\n                // We know that this component will suspend again because if it has\r\n                // been unsuspended it has committed as a resolved Suspense component.\r\n                // If it needs to be retried, it should have work scheduled on it.\r\n                workInProgress.flags |= DidCapture;\r\n                // We should never render the children of a dehydrated boundary until we\r\n                // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\r\n                return null;\r\n              }\r\n\r\n              // If this boundary is currently timed out, we need to decide\r\n              // whether to retry the primary children, or to skip over it and\r\n              // go straight to the fallback. Check the priority of the primary\r\n              // child fragment.\r\n              const primaryChildFragment: Fiber = (workInProgress.child: any);\r\n              const primaryChildLanes = primaryChildFragment.childLanes;\r\n              if (includesSomeLane(renderLanes, primaryChildLanes)) {\r\n                // The primary children have pending work. Use the normal path\r\n                // to attempt to render the primary children again.\r\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\r\n              } else {\r\n                // The primary child fragment does not have pending work marked\r\n                // on it\r\n                pushSuspenseContext(\r\n                  workInProgress,\r\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\r\n                );\r\n                // The primary children do not have pending work with sufficient\r\n                // priority. Bailout.\r\n                const child = bailoutOnAlreadyFinishedWork(\r\n                  current,\r\n                  workInProgress,\r\n                  renderLanes,\r\n                );\r\n                if (child !== null) {\r\n                  // The fallback children have pending work. Skip over the\r\n                  // primary children and work on the fallback.\r\n                  return child.sibling;\r\n                } else {\r\n                  // Note: We can return `null` here because we already checked\r\n                  // whether there were nested context consumers, via the call to\r\n                  // `bailoutOnAlreadyFinishedWork` above.\r\n                  return null;\r\n                }\r\n              }\r\n            } else {\r\n              pushSuspenseContext(\r\n                workInProgress,\r\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\r\n              );\r\n            }\r\n            break;\r\n          }\r\n          case SuspenseListComponent: {\r\n            const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\r\n\r\n            let hasChildWork = includesSomeLane(\r\n              renderLanes,\r\n              workInProgress.childLanes,\r\n            );\r\n\r\n            if (enableLazyContextPropagation && !hasChildWork) {\r\n              // Context changes may not have been propagated yet. We need to do\r\n              // that now, before we can decide whether to bail out.\r\n              // TODO: We use `childLanes` as a heuristic for whether there is\r\n              // remaining work in a few places, including\r\n              // `bailoutOnAlreadyFinishedWork` and\r\n              // `updateDehydratedSuspenseComponent`. We should maybe extract this\r\n              // into a dedicated function.\r\n              lazilyPropagateParentContextChanges(\r\n                current,\r\n                workInProgress,\r\n                renderLanes,\r\n              );\r\n              hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\r\n            }\r\n\r\n            if (didSuspendBefore) {\r\n              if (hasChildWork) {\r\n                // If something was in fallback state last time, and we have all the\r\n                // same children then we're still in progressive loading state.\r\n                // Something might get unblocked by state updates or retries in the\r\n                // tree which will affect the tail. So we need to use the normal\r\n                // path to compute the correct tail.\r\n                return updateSuspenseListComponent(\r\n                  current,\r\n                  workInProgress,\r\n                  renderLanes,\r\n                );\r\n              }\r\n              // If none of the children had any work, that means that none of\r\n              // them got retried so they'll still be blocked in the same way\r\n              // as before. We can fast bail out.\r\n              workInProgress.flags |= DidCapture;\r\n            }\r\n\r\n            // If nothing suspended before and we're rendering the same children,\r\n            // then the tail doesn't matter. Anything new that suspends will work\r\n            // in the \"together\" mode, so we can continue from the state we had.\r\n            const renderState = workInProgress.memoizedState;\r\n            if (renderState !== null) {\r\n              // Reset to the \"together\" mode in case we've started a different\r\n              // update in the past but didn't complete it.\r\n              renderState.rendering = null;\r\n              renderState.tail = null;\r\n              renderState.lastEffect = null;\r\n            }\r\n            pushSuspenseContext(workInProgress, suspenseStackCursor.current);\r\n\r\n            if (hasChildWork) {\r\n              break;\r\n            } else {\r\n              // If none of the children had any work, that means that none of\r\n              // them got retried so they'll still be blocked in the same way\r\n              // as before. We can fast bail out.\r\n              return null;\r\n            }\r\n          }\r\n          case OffscreenComponent:\r\n          case LegacyHiddenComponent: {\r\n            // Need to check if the tree still needs to be deferred. This is\r\n            // almost identical to the logic used in the normal update path,\r\n            // so we'll just enter that. The only difference is we'll bail out\r\n            // at the next level instead of this one, because the child props\r\n            // have not changed. Which is fine.\r\n            // TODO: Probably should refactor `beginWork` to split the bailout\r\n            // path from the normal path. I'm tempted to do a labeled break here\r\n            // but I won't :)\r\n            workInProgress.lanes = NoLanes;\r\n            return updateOffscreenComponent(current, workInProgress, renderLanes);\r\n          }\r\n          case CacheComponent: {\r\n            if (enableCache) {\r\n              const cache: Cache = current.memoizedState.cache;\r\n              pushCacheProvider(workInProgress, cache);\r\n            }\r\n            break;\r\n          }\r\n        }\r\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n      }\r\n\r\n      function beginWork (\r\n        current: Fiber | null,\r\n        workInProgress: Fiber,\r\n        renderLanes: Lanes,\r\n      ): Fiber | null {\r\n        if (__DEV__) {\r\n          if (workInProgress._debugNeedsRemount && current !== null) {\r\n            // This will restart the begin phase with a new fiber.\r\n            return remountFiber(\r\n              current,\r\n              workInProgress,\r\n              createFiberFromTypeAndProps(\r\n                workInProgress.type,\r\n                workInProgress.key,\r\n                workInProgress.pendingProps,\r\n                workInProgress._debugOwner || null,\r\n                workInProgress.mode,\r\n                workInProgress.lanes,\r\n              ),\r\n            );\r\n          }\r\n        }\r\n        // 1.update时满足条件即可复用current fiber进入bailoutOnAlreadyFinishedWork函数\r\n        // 首次渲染时current为null， update时current不为null\r\n        // update时\r\n        if (current !== null) {\r\n          const oldProps = current.memoizedProps;\r\n          const newProps = workInProgress.pendingProps;\r\n\r\n          if (\r\n            oldProps !== newProps ||\r\n            hasLegacyContextChanged() ||\r\n            // Force a re-render if the implementation changed due to hot reload:\r\n            (__DEV__ ? workInProgress.type !== current.type : false)\r\n          ) {\r\n            // If props or context changed, mark the fiber as having performed work.\r\n            // This may be unset if the props are determined to be equal later (memo).\r\n            didReceiveUpdate = true;\r\n          } else {\r\n            // Neither props nor legacy context changes. Check if there's a pending\r\n            // update or context change.\r\n            const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\r\n              current,\r\n              renderLanes,\r\n            );\r\n            if (\r\n              !hasScheduledUpdateOrContext &&\r\n              // If this is the second pass of an error or suspense boundary, there\r\n              // may not be work scheduled on `current`, so we check for this flag.\r\n              (workInProgress.flags & DidCapture) === NoFlags\r\n            ) {\r\n              // No pending updates or context. Bail out now.\r\n              didReceiveUpdate = false;\r\n              return attemptEarlyBailoutIfNoScheduledUpdate(\r\n                current,\r\n                workInProgress,\r\n                renderLanes,\r\n              );\r\n            }\r\n            if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\r\n              // This is a special case that only exists for legacy mode.\r\n              // See https://github.com/facebook/react/pull/19216.\r\n              didReceiveUpdate = true;\r\n            } else {\r\n              // An update was scheduled on this fiber, but there are no new props\r\n              // nor legacy context. Set this to false. If an update queue or context\r\n              // consumer produces a changed value, it will set this to true. Otherwise,\r\n              // the component will assume the children have not changed and bail out.\r\n              didReceiveUpdate = false;\r\n            }\r\n          }\r\n        } else {\r\n          \r\n          didReceiveUpdate = false;\r\n\r\n          if (getIsHydrating() && isForkedChild(workInProgress)) {\r\n            // Check if this child belongs to a list of muliple children in\r\n            // its parent.\r\n            //\r\n            // In a true multi-threaded implementation, we would render children on\r\n            // parallel threads. This would represent the beginning of a new render\r\n            // thread for this subtree.\r\n            //\r\n            // We only use this for id generation during hydration, which is why the\r\n            // logic is located in this special branch.\r\n            const slotIndex = workInProgress.index;\r\n            const numberOfForks = getForksAtLevel(workInProgress);\r\n            pushTreeId(workInProgress, numberOfForks, slotIndex);\r\n          }\r\n        }\r\n\r\n        // Before entering the begin phase, clear pending update priority.\r\n        // TODO: This assumes that we're about to evaluate the component and process\r\n        // the update queue. However, there's an exception: SimpleMemoComponent\r\n        // sometimes bails out later in the begin phase. This indicates that we should\r\n        // move this assignment out of the common path and into each branch.\r\n        workInProgress.lanes = NoLanes;\r\n\r\n        //2.根据tag来创建不同的fiber 最后进入reconcileChildren函数\r\n        switch (workInProgress.tag) {\r\n          case IndeterminateComponent: {\r\n            return mountIndeterminateComponent(\r\n              current,\r\n              workInProgress,\r\n              workInProgress.type,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case LazyComponent: {\r\n            const elementType = workInProgress.elementType;\r\n            return mountLazyComponent(\r\n              current,\r\n              workInProgress,\r\n              elementType,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case FunctionComponent: {\r\n            const Component = workInProgress.type;\r\n            const unresolvedProps = workInProgress.pendingProps;\r\n            const resolvedProps =\r\n              workInProgress.elementType === Component\r\n                ? unresolvedProps\r\n                : resolveDefaultProps(Component, unresolvedProps);\r\n            return updateFunctionComponent(\r\n              current,\r\n              workInProgress,\r\n              Component,\r\n              resolvedProps,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case ClassComponent: {\r\n            const Component = workInProgress.type;\r\n            const unresolvedProps = workInProgress.pendingProps;\r\n            const resolvedProps =\r\n              workInProgress.elementType === Component\r\n                ? unresolvedProps\r\n                : resolveDefaultProps(Component, unresolvedProps);\r\n            return updateClassComponent(\r\n              current,\r\n              workInProgress,\r\n              Component,\r\n              resolvedProps,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case HostRoot:\r\n            return updateHostRoot(current, workInProgress, renderLanes);\r\n          case HostComponent:\r\n            return updateHostComponent(current, workInProgress, renderLanes);\r\n          case HostText:\r\n            return updateHostText(current, workInProgress);\r\n          case SuspenseComponent:\r\n            return updateSuspenseComponent(current, workInProgress, renderLanes);\r\n          case HostPortal:\r\n            return updatePortalComponent(current, workInProgress, renderLanes);\r\n          case ForwardRef: {\r\n            const type = workInProgress.type;\r\n            const unresolvedProps = workInProgress.pendingProps;\r\n            const resolvedProps =\r\n              workInProgress.elementType === type\r\n                ? unresolvedProps\r\n                : resolveDefaultProps(type, unresolvedProps);\r\n            return updateForwardRef(\r\n              current,\r\n              workInProgress,\r\n              type,\r\n              resolvedProps,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case Fragment:\r\n            return updateFragment(current, workInProgress, renderLanes);\r\n          case Mode:\r\n            return updateMode(current, workInProgress, renderLanes);\r\n          case Profiler:\r\n            return updateProfiler(current, workInProgress, renderLanes);\r\n          case ContextProvider:\r\n            return updateContextProvider(current, workInProgress, renderLanes);\r\n          case ContextConsumer:\r\n            return updateContextConsumer(current, workInProgress, renderLanes);\r\n          case MemoComponent: {\r\n            const type = workInProgress.type;\r\n            const unresolvedProps = workInProgress.pendingProps;\r\n            // Resolve outer props first, then resolve inner props.\r\n            let resolvedProps = resolveDefaultProps(type, unresolvedProps);\r\n            if (__DEV__) {\r\n              if (workInProgress.type !== workInProgress.elementType) {\r\n                const outerPropTypes = type.propTypes;\r\n                if (outerPropTypes) {\r\n                  checkPropTypes(\r\n                    outerPropTypes,\r\n                    resolvedProps, // Resolved for outer only\r\n                    'prop',\r\n                    getComponentNameFromType(type),\r\n                  );\r\n                }\r\n              }\r\n            }\r\n            resolvedProps = resolveDefaultProps(type.type, resolvedProps);\r\n            return updateMemoComponent(\r\n              current,\r\n              workInProgress,\r\n              type,\r\n              resolvedProps,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case SimpleMemoComponent: {\r\n            return updateSimpleMemoComponent(\r\n              current,\r\n              workInProgress,\r\n              workInProgress.type,\r\n              workInProgress.pendingProps,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case IncompleteClassComponent: {\r\n            const Component = workInProgress.type;\r\n            const unresolvedProps = workInProgress.pendingProps;\r\n            const resolvedProps =\r\n              workInProgress.elementType === Component\r\n                ? unresolvedProps\r\n                : resolveDefaultProps(Component, unresolvedProps);\r\n            return mountIncompleteClassComponent(\r\n              current,\r\n              workInProgress,\r\n              Component,\r\n              resolvedProps,\r\n              renderLanes,\r\n            );\r\n          }\r\n          case SuspenseListComponent: {\r\n            return updateSuspenseListComponent(current, workInProgress, renderLanes);\r\n          }\r\n          case ScopeComponent: {\r\n            if (enableScopeAPI) {\r\n              return updateScopeComponent(current, workInProgress, renderLanes);\r\n            }\r\n            break;\r\n          }\r\n          case OffscreenComponent: {\r\n            return updateOffscreenComponent(current, workInProgress, renderLanes);\r\n          }\r\n          case LegacyHiddenComponent: {\r\n            if (enableLegacyHidden) {\r\n              return updateLegacyHiddenComponent(\r\n                current,\r\n                workInProgress,\r\n                renderLanes,\r\n              );\r\n            }\r\n            break;\r\n          }\r\n          case CacheComponent: {\r\n            if (enableCache) {\r\n              return updateCacheComponent(current, workInProgress, renderLanes);\r\n            }\r\n            break;\r\n          }\r\n          case TracingMarkerComponent: {\r\n            if (enableTransitionTracing) {\r\n              return updateTracingMarkerComponent(\r\n                current,\r\n                workInProgress,\r\n                renderLanes,\r\n              );\r\n            }\r\n            break;\r\n          }\r\n        }\r\n\r\n        throw new Error(\r\n          `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\r\n          'React. Please file an issue.',\r\n        );\r\n      }\r\n\r\n      export { beginWork };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}